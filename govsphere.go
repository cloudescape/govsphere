package govsphere

//Generated by https://github.com/c4milo/gowsdl
//Do not modify
//Copyright (c) 2014, Cloudescape. All rights reserved.
import (
	"bytes"
	"crypto/tls"
	"encoding/xml"
	gowsdl "github.com/c4milo/gowsdl/generator"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"time"
)

type AddAuthorizationRoleResponse struct {
	returnval int32 `xml:"returnval,omitempty"`
}

type RemoveAuthorizationRoleResponse struct {
}

type UpdateAuthorizationRoleResponse struct {
}

type MergePermissionsResponse struct {
}

type RetrieveRolePermissionsResponse struct {
	returnval []*Permission `xml:"returnval,omitempty"`
}

type RetrieveEntityPermissionsResponse struct {
	returnval []*Permission `xml:"returnval,omitempty"`
}

type RetrieveAllPermissionsResponse struct {
	returnval []*Permission `xml:"returnval,omitempty"`
}

type SetEntityPermissionsResponse struct {
}

type ResetEntityPermissionsResponse struct {
}

type RemoveEntityPermissionResponse struct {
}

type HasPrivilegeOnEntityResponse struct {
	returnval []bool `xml:"returnval,omitempty"`
}

type HasPrivilegeOnEntitiesResponse struct {
	returnval []*EntityPrivilege `xml:"returnval,omitempty"`
}

type ReconfigureCluster_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ApplyRecommendationResponse struct {
}

type CancelRecommendationResponse struct {
}

type RecommendHostsForVmResponse struct {
	returnval []*ClusterHostRecommendation `xml:"returnval,omitempty"`
}

type AddHost_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MoveInto_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MoveHostInto_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RefreshRecommendationResponse struct {
}

type RetrieveDasAdvancedRuntimeInfoResponse struct {
	returnval *ClusterDasAdvancedRuntimeInfo `xml:"returnval,omitempty"`
}

type ClusterEnterMaintenanceModeResponse struct {
	returnval *ClusterEnterMaintenanceResult `xml:"returnval,omitempty"`
}

type ReconfigureComputeResource_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type AddCustomFieldDefResponse struct {
	returnval *CustomFieldDef `xml:"returnval,omitempty"`
}

type RemoveCustomFieldDefResponse struct {
}

type RenameCustomFieldDefResponse struct {
}

type SetFieldResponse struct {
}

type DoesCustomizationSpecExistResponse struct {
	returnval bool `xml:"returnval,omitempty"`
}

type GetCustomizationSpecResponse struct {
	returnval *CustomizationSpecItem `xml:"returnval,omitempty"`
}

type CreateCustomizationSpecResponse struct {
}

type OverwriteCustomizationSpecResponse struct {
}

type DeleteCustomizationSpecResponse struct {
}

type DuplicateCustomizationSpecResponse struct {
}

type RenameCustomizationSpecResponse struct {
}

type CustomizationSpecItemToXmlResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type XmlToCustomizationSpecItemResponse struct {
	returnval *CustomizationSpecItem `xml:"returnval,omitempty"`
}

type CheckCustomizationResourcesResponse struct {
}

type QueryConnectionInfoResponse struct {
	returnval *HostConnectInfo `xml:"returnval,omitempty"`
}

type PowerOnMultiVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type queryDatacenterConfigOptionDescriptorResponse struct {
	returnval []*VirtualMachineConfigOptionDescriptor `xml:"returnval,omitempty"`
}

type ReconfigureDatacenter_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RefreshDatastoreResponse struct {
}

type RefreshDatastoreStorageInfoResponse struct {
}

type UpdateVirtualMachineFiles_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RenameDatastoreResponse struct {
}

type DestroyDatastoreResponse struct {
}

type DatastoreEnterMaintenanceModeResponse struct {
	returnval *StoragePlacementResult `xml:"returnval,omitempty"`
}

type DatastoreExitMaintenanceMode_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateDirectoryResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type DeleteDirectoryResponse struct {
}

type QueryDescriptionsResponse struct {
	returnval []*DiagnosticManagerLogDescriptor `xml:"returnval,omitempty"`
}

type BrowseDiagnosticLogResponse struct {
	returnval *DiagnosticManagerLogHeader `xml:"returnval,omitempty"`
}

type GenerateLogBundles_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type FetchDVPortKeysResponse struct {
	returnval []string `xml:"returnval,omitempty"`
}

type FetchDVPortsResponse struct {
	returnval []*DistributedVirtualPort `xml:"returnval,omitempty"`
}

type QueryUsedVlanIdInDvsResponse struct {
	returnval []int32 `xml:"returnval,omitempty"`
}

type ReconfigureDvs_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type PerformDvsProductSpecOperation_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MergeDvs_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type AddDVPortgroup_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MoveDVPort_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpdateDvsCapabilityResponse struct {
}

type ReconfigureDVPort_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RefreshDVPortStateResponse struct {
}

type RectifyDvsHost_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpdateNetworkResourcePoolResponse struct {
}

type AddNetworkResourcePoolResponse struct {
}

type RemoveNetworkResourcePoolResponse struct {
}

type EnableNetworkResourceManagementResponse struct {
}

type DVSRollback_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateDVPortgroup_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpdateDVSHealthCheckConfig_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type LookupDvPortGroupResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryConfigOptionDescriptorResponse struct {
	returnval []*VirtualMachineConfigOptionDescriptor `xml:"returnval,omitempty"`
}

type QueryConfigOptionResponse struct {
	returnval *VirtualMachineConfigOption `xml:"returnval,omitempty"`
}

type QueryConfigTargetResponse struct {
	returnval *ConfigTarget `xml:"returnval,omitempty"`
}

type QueryTargetCapabilitiesResponse struct {
	returnval *HostCapability `xml:"returnval,omitempty"`
}

type setCustomValueResponse struct {
}

type UnregisterExtensionResponse struct {
}

type FindExtensionResponse struct {
	returnval *Extension `xml:"returnval,omitempty"`
}

type RegisterExtensionResponse struct {
}

type UpdateExtensionResponse struct {
}

type GetPublicKeyResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type SetPublicKeyResponse struct {
}

type SetExtensionCertificateResponse struct {
}

type QueryManagedByResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryExtensionIpAllocationUsageResponse struct {
	returnval []*ExtensionManagerIpAllocationUsage `xml:"returnval,omitempty"`
}

type MoveDatastoreFile_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CopyDatastoreFile_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DeleteDatastoreFile_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MakeDirectoryResponse struct {
}

type ChangeOwnerResponse struct {
}

type CreateFolderResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MoveIntoFolder_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RegisterVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateClusterResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateClusterExResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type AddStandaloneHost_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateDatacenterResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UnregisterAndDestroy_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateDVS_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateStoragePodResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type SetCollectorPageSizeResponse struct {
}

type RewindCollectorResponse struct {
}

type ResetCollectorResponse struct {
}

type DestroyCollectorResponse struct {
}

type QueryTpmAttestationReportResponse struct {
	returnval *HostTpmAttestationReport `xml:"returnval,omitempty"`
}

type QueryHostConnectionInfoResponse struct {
	returnval *HostConnectInfo `xml:"returnval,omitempty"`
}

type UpdateSystemResourcesResponse struct {
}

type UpdateSystemSwapConfigurationResponse struct {
}

type ReconnectHost_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DisconnectHost_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type EnterMaintenanceMode_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ExitMaintenanceMode_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RebootHost_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ShutdownHost_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type PowerDownHostToStandBy_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type PowerUpHostFromStandBy_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryMemoryOverheadResponse struct {
	returnval int64 `xml:"returnval,omitempty"`
}

type QueryMemoryOverheadExResponse struct {
	returnval int64 `xml:"returnval,omitempty"`
}

type ReconfigureHostForDAS_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpdateFlagsResponse struct {
}

type EnterLockdownModeResponse struct {
}

type ExitLockdownModeResponse struct {
}

type AcquireCimServicesTicketResponse struct {
	returnval *HostServiceTicket `xml:"returnval,omitempty"`
}

type UpdateIpmiResponse struct {
}

type RetrieveHardwareUptimeResponse struct {
	returnval int64 `xml:"returnval,omitempty"`
}

type HttpNfcLeaseGetManifestResponse struct {
	returnval []*HttpNfcLeaseManifestEntry `xml:"returnval,omitempty"`
}

type HttpNfcLeaseCompleteResponse struct {
}

type HttpNfcLeaseAbortResponse struct {
}

type HttpNfcLeaseProgressResponse struct {
}

type QueryIpPoolsResponse struct {
	returnval []*IpPool `xml:"returnval,omitempty"`
}

type CreateIpPoolResponse struct {
	returnval int32 `xml:"returnval,omitempty"`
}

type UpdateIpPoolResponse struct {
}

type DestroyIpPoolResponse struct {
}

type AllocateIpv4AddressResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type AllocateIpv6AddressResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type ReleaseIpAllocationResponse struct {
}

type QueryIPAllocationsResponse struct {
	returnval []*IpPoolManagerIpAllocation `xml:"returnval,omitempty"`
}

type UpdateAssignedLicenseResponse struct {
	returnval *LicenseManagerLicenseInfo `xml:"returnval,omitempty"`
}

type RemoveAssignedLicenseResponse struct {
}

type QueryAssignedLicensesResponse struct {
	returnval []*LicenseAssignmentManagerLicenseAssignment `xml:"returnval,omitempty"`
}

type QuerySupportedFeaturesResponse struct {
	returnval []*LicenseFeatureInfo `xml:"returnval,omitempty"`
}

type QueryLicenseSourceAvailabilityResponse struct {
	returnval []*LicenseAvailabilityInfo `xml:"returnval,omitempty"`
}

type QueryLicenseUsageResponse struct {
	returnval *LicenseUsageInfo `xml:"returnval,omitempty"`
}

type SetLicenseEditionResponse struct {
}

type CheckLicenseFeatureResponse struct {
	returnval bool `xml:"returnval,omitempty"`
}

type EnableFeatureResponse struct {
	returnval bool `xml:"returnval,omitempty"`
}

type DisableFeatureResponse struct {
	returnval bool `xml:"returnval,omitempty"`
}

type ConfigureLicenseSourceResponse struct {
}

type UpdateLicenseResponse struct {
	returnval *LicenseManagerLicenseInfo `xml:"returnval,omitempty"`
}

type AddLicenseResponse struct {
	returnval *LicenseManagerLicenseInfo `xml:"returnval,omitempty"`
}

type RemoveLicenseResponse struct {
}

type DecodeLicenseResponse struct {
	returnval *LicenseManagerLicenseInfo `xml:"returnval,omitempty"`
}

type UpdateLicenseLabelResponse struct {
}

type RemoveLicenseLabelResponse struct {
}

type ReloadResponse struct {
}

type Rename_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type Destroy_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DestroyNetworkResponse struct {
}

type ValidateHostResponse struct {
	returnval *OvfValidateHostResult `xml:"returnval,omitempty"`
}

type ParseDescriptorResponse struct {
	returnval *OvfParseDescriptorResult `xml:"returnval,omitempty"`
}

type CreateImportSpecResponse struct {
	returnval *OvfCreateImportSpecResult `xml:"returnval,omitempty"`
}

type CreateDescriptorResponse struct {
	returnval *OvfCreateDescriptorResult `xml:"returnval,omitempty"`
}

type QueryPerfProviderSummaryResponse struct {
	returnval *PerfProviderSummary `xml:"returnval,omitempty"`
}

type QueryAvailablePerfMetricResponse struct {
	returnval []*PerfMetricId `xml:"returnval,omitempty"`
}

type QueryPerfCounterResponse struct {
	returnval []*PerfCounterInfo `xml:"returnval,omitempty"`
}

type QueryPerfCounterByLevelResponse struct {
	returnval []*PerfCounterInfo `xml:"returnval,omitempty"`
}

type QueryPerfResponse struct {
	returnval []*PerfEntityMetricBase `xml:"returnval,omitempty"`
}

type QueryPerfCompositeResponse struct {
	returnval *PerfCompositeMetric `xml:"returnval,omitempty"`
}

type CreatePerfIntervalResponse struct {
}

type RemovePerfIntervalResponse struct {
}

type UpdatePerfIntervalResponse struct {
}

type UpdateCounterLevelMappingResponse struct {
}

type ResetCounterLevelMappingResponse struct {
}

type EstimateDatabaseSizeResponse struct {
	returnval *DatabaseSizeEstimate `xml:"returnval,omitempty"`
}

type UpdateConfigResponse struct {
}

type MoveIntoResourcePoolResponse struct {
}

type UpdateChildResourceConfigurationResponse struct {
}

type CreateResourcePoolResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DestroyChildrenResponse struct {
}

type CreateVAppResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateChildVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RegisterChildVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ImportVAppResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryResourceConfigOptionResponse struct {
	returnval *ResourceConfigOption `xml:"returnval,omitempty"`
}

type RefreshRuntimeResponse struct {
}

type FindByUuidResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type FindByDatastorePathResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type FindByDnsNameResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type FindByIpResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type FindByInventoryPathResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type FindChildResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type FindAllByUuidResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type FindAllByDnsNameResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type FindAllByIpResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type CurrentTimeResponse struct {
	returnval time.Time `xml:"returnval,omitempty"`
}

type RetrieveServiceContentResponse struct {
	returnval *ServiceContent `xml:"returnval,omitempty"`
}

type ValidateMigrationResponse struct {
	returnval []*Event `xml:"returnval,omitempty"`
}

type QueryVMotionCompatibilityResponse struct {
	returnval []*HostVMotionCompatibility `xml:"returnval,omitempty"`
}

type RetrieveProductComponentsResponse struct {
	returnval []*ProductComponentInfo `xml:"returnval,omitempty"`
}

type QueryServiceListResponse struct {
	returnval []*ServiceManagerServiceInfo `xml:"returnval,omitempty"`
}

type UpdateServiceMessageResponse struct {
}

type LoginByTokenResponse struct {
	returnval *UserSession `xml:"returnval,omitempty"`
}

type LoginResponse struct {
	returnval *UserSession `xml:"returnval,omitempty"`
}

type LoginBySSPIResponse struct {
	returnval *UserSession `xml:"returnval,omitempty"`
}

type LogoutResponse struct {
}

type AcquireLocalTicketResponse struct {
	returnval *SessionManagerLocalTicket `xml:"returnval,omitempty"`
}

type AcquireGenericServiceTicketResponse struct {
	returnval *SessionManagerGenericServiceTicket `xml:"returnval,omitempty"`
}

type TerminateSessionResponse struct {
}

type SetLocaleResponse struct {
}

type LoginExtensionBySubjectNameResponse struct {
	returnval *UserSession `xml:"returnval,omitempty"`
}

type LoginExtensionByCertificateResponse struct {
	returnval *UserSession `xml:"returnval,omitempty"`
}

type ImpersonateUserResponse struct {
	returnval *UserSession `xml:"returnval,omitempty"`
}

type SessionIsActiveResponse struct {
	returnval bool `xml:"returnval,omitempty"`
}

type AcquireCloneTicketResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type CloneSessionResponse struct {
	returnval *UserSession `xml:"returnval,omitempty"`
}

type ExecuteSimpleCommandResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type ConfigureDatastoreIORM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryIORMConfigOptionResponse struct {
	returnval *StorageIORMConfigOption `xml:"returnval,omitempty"`
}

type QueryDatastorePerformanceSummaryResponse struct {
	returnval []*StoragePerformanceSummary `xml:"returnval,omitempty"`
}

type ApplyStorageDrsRecommendationToPod_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ApplyStorageDrsRecommendation_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CancelStorageDrsRecommendationResponse struct {
}

type RefreshStorageDrsRecommendationResponse struct {
}

type ConfigureStorageDrsForPod_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RecommendDatastoresResponse struct {
	returnval *StoragePlacementResult `xml:"returnval,omitempty"`
}

type CancelTaskResponse struct {
}

type UpdateProgressResponse struct {
}

type SetTaskStateResponse struct {
}

type SetTaskDescriptionResponse struct {
}

type ReadNextTasksResponse struct {
	returnval []*TaskInfo `xml:"returnval,omitempty"`
}

type ReadPreviousTasksResponse struct {
	returnval []*TaskInfo `xml:"returnval,omitempty"`
}

type CreateCollectorForTasksResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateTaskResponse struct {
	returnval *TaskInfo `xml:"returnval,omitempty"`
}

type RetrieveUserGroupsResponse struct {
	returnval []*UserSearchResult `xml:"returnval,omitempty"`
}

type UpdateVAppConfigResponse struct {
}

type UpdateLinkedChildrenResponse struct {
}

type CloneVApp_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ExportVAppResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type PowerOnVApp_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type PowerOffVApp_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type SuspendVApp_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type unregisterVApp_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DeleteVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MoveVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CopyVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ExtendVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryVirtualDiskFragmentationResponse struct {
	returnval int32 `xml:"returnval,omitempty"`
}

type DefragmentVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ShrinkVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type InflateVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type EagerZeroVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ZeroFillVirtualDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type SetVirtualDiskUuidResponse struct {
}

type QueryVirtualDiskUuidResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type QueryVirtualDiskGeometryResponse struct {
	returnval *HostDiskDimensionsChs `xml:"returnval,omitempty"`
}

type RefreshStorageInfoResponse struct {
}

type CreateSnapshot_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RevertToCurrentSnapshot_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RemoveAllSnapshots_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ConsolidateVMDisks_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type EstimateStorageForConsolidateSnapshots_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ReconfigVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpgradeVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ExtractOvfEnvironmentResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type PowerOnVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type PowerOffVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type SuspendVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ResetVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ShutdownGuestResponse struct {
}

type RebootGuestResponse struct {
}

type StandbyGuestResponse struct {
}

type AnswerVMResponse struct {
}

type CustomizeVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CheckCustomizationSpecResponse struct {
}

type MigrateVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RelocateVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CloneVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ExportVmResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MarkAsTemplateResponse struct {
}

type MarkAsVirtualMachineResponse struct {
}

type UnregisterVMResponse struct {
}

type ResetGuestInformationResponse struct {
}

type MountToolsInstallerResponse struct {
}

type UnmountToolsInstallerResponse struct {
}

type UpgradeTools_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type AcquireMksTicketResponse struct {
	returnval *VirtualMachineMksTicket `xml:"returnval,omitempty"`
}

type AcquireTicketResponse struct {
	returnval *VirtualMachineTicket `xml:"returnval,omitempty"`
}

type SetScreenResolutionResponse struct {
}

type DefragmentAllDisksResponse struct {
}

type CreateSecondaryVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type TurnOffFaultToleranceForVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type MakePrimaryVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type TerminateFaultTolerantVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DisableSecondaryVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type EnableSecondaryVM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type SetDisplayTopologyResponse struct {
}

type StartRecording_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type StopRecording_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type StartReplaying_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type StopReplaying_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type PromoteDisks_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateScreenshot_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryChangedDiskAreasResponse struct {
	returnval *DiskChangeInfo `xml:"returnval,omitempty"`
}

type QueryUnownedFilesResponse struct {
	returnval []string `xml:"returnval,omitempty"`
}

type reloadVirtualMachineFromPath_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryFaultToleranceCompatibilityResponse struct {
	returnval []*LocalizedMethodFault `xml:"returnval,omitempty"`
}

type TerminateVMResponse struct {
}

type RemoveAlarmResponse struct {
}

type ReconfigureAlarmResponse struct {
}

type CreateAlarmResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type GetAlarmResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type AreAlarmActionsEnabledResponse struct {
	returnval bool `xml:"returnval,omitempty"`
}

type EnableAlarmActionsResponse struct {
}

type GetAlarmStateResponse struct {
	returnval []*AlarmState `xml:"returnval,omitempty"`
}

type AcknowledgeAlarmResponse struct {
}

type ReconfigureDVPortgroup_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DVPortgroupRollback_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryAvailableDvsSpecResponse struct {
	returnval []*DistributedVirtualSwitchProductSpec `xml:"returnval,omitempty"`
}

type QueryCompatibleHostForNewDvsResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryCompatibleHostForExistingDvsResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryDvsCompatibleHostSpecResponse struct {
	returnval []*DistributedVirtualSwitchHostProductSpec `xml:"returnval,omitempty"`
}

type QueryDvsFeatureCapabilityResponse struct {
	returnval *DVSFeatureCapability `xml:"returnval,omitempty"`
}

type QueryDvsByUuidResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryDvsConfigTargetResponse struct {
	returnval *DVSManagerDvsConfigTarget `xml:"returnval,omitempty"`
}

type QueryDvsCheckCompatibilityResponse struct {
	returnval []*DistributedVirtualSwitchManagerCompatibilityResult `xml:"returnval,omitempty"`
}

type RectifyDvsOnHost_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DVSManagerExportEntity_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DVSManagerImportEntity_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DVSManagerLookupDvPortGroupResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpdateDVSLacpGroupConfig_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ReadNextEventsResponse struct {
	returnval []*Event `xml:"returnval,omitempty"`
}

type ReadPreviousEventsResponse struct {
	returnval []*Event `xml:"returnval,omitempty"`
}

type RetrieveArgumentDescriptionResponse struct {
	returnval []*EventArgDesc `xml:"returnval,omitempty"`
}

type CreateCollectorForEventsResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type LogUserEventResponse struct {
}

type QueryEventsResponse struct {
	returnval []*Event `xml:"returnval,omitempty"`
}

type PostEventResponse struct {
}

type JoinDomain_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type JoinDomainWithCAM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ImportCertificateForCAM_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type LeaveCurrentDomain_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ReconfigureAutostartResponse struct {
}

type AutoStartPowerOnResponse struct {
}

type AutoStartPowerOffResponse struct {
}

type QueryBootDevicesResponse struct {
	returnval *HostBootDeviceInfo `xml:"returnval,omitempty"`
}

type UpdateBootDeviceResponse struct {
}

type ConfigureHostCache_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type EnableHyperThreadingResponse struct {
}

type DisableHyperThreadingResponse struct {
}

type SearchDatastore_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type SearchDatastoreSubFolders_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DeleteFileResponse struct {
}

type UpdateLocalSwapDatastoreResponse struct {
}

type QueryAvailableDisksForVmfsResponse struct {
	returnval []*HostScsiDisk `xml:"returnval,omitempty"`
}

type QueryVmfsDatastoreCreateOptionsResponse struct {
	returnval []*VmfsDatastoreOption `xml:"returnval,omitempty"`
}

type CreateVmfsDatastoreResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryVmfsDatastoreExtendOptionsResponse struct {
	returnval []*VmfsDatastoreOption `xml:"returnval,omitempty"`
}

type QueryVmfsDatastoreExpandOptionsResponse struct {
	returnval []*VmfsDatastoreOption `xml:"returnval,omitempty"`
}

type ExtendVmfsDatastoreResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ExpandVmfsDatastoreResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateNasDatastoreResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateLocalDatastoreResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RemoveDatastoreResponse struct {
}

type ConfigureDatastorePrincipalResponse struct {
}

type QueryUnresolvedVmfsVolumesResponse struct {
	returnval []*HostUnresolvedVmfsVolume `xml:"returnval,omitempty"`
}

type ResignatureUnresolvedVmfsVolume_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpdateDateTimeConfigResponse struct {
}

type QueryAvailableTimeZonesResponse struct {
	returnval []*HostDateTimeSystemTimeZone `xml:"returnval,omitempty"`
}

type QueryDateTimeResponse struct {
	returnval time.Time `xml:"returnval,omitempty"`
}

type UpdateDateTimeResponse struct {
}

type RefreshDateTimeSystemResponse struct {
}

type QueryAvailablePartitionResponse struct {
	returnval []*HostDiagnosticPartition `xml:"returnval,omitempty"`
}

type SelectActivePartitionResponse struct {
}

type QueryPartitionCreateOptionsResponse struct {
	returnval []*HostDiagnosticPartitionCreateOption `xml:"returnval,omitempty"`
}

type QueryPartitionCreateDescResponse struct {
	returnval *HostDiagnosticPartitionCreateDescription `xml:"returnval,omitempty"`
}

type CreateDiagnosticPartitionResponse struct {
}

type EsxAgentHostManagerUpdateConfigResponse struct {
}

type UpdateDefaultPolicyResponse struct {
}

type EnableRulesetResponse struct {
}

type DisableRulesetResponse struct {
}

type UpdateRulesetResponse struct {
}

type RefreshFirewallResponse struct {
}

type ResetFirmwareToFactoryDefaultsResponse struct {
}

type BackupFirmwareConfigurationResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type QueryFirmwareConfigUploadURLResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type RestoreFirmwareConfigurationResponse struct {
}

type RefreshGraphicsManagerResponse struct {
}

type IsSharedGraphicsActiveResponse struct {
	returnval bool `xml:"returnval,omitempty"`
}

type RefreshHealthStatusSystemResponse struct {
}

type ResetSystemHealthInfoResponse struct {
}

type HostImageConfigGetAcceptanceResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type HostImageConfigGetProfileResponse struct {
	returnval *HostImageProfileSummary `xml:"returnval,omitempty"`
}

type UpdateHostImageAcceptanceLevelResponse struct {
}

type QueryVnicStatusResponse struct {
	returnval *IscsiStatus `xml:"returnval,omitempty"`
}

type QueryPnicStatusResponse struct {
	returnval *IscsiStatus `xml:"returnval,omitempty"`
}

type QueryBoundVnicsResponse struct {
	returnval []*IscsiPortInfo `xml:"returnval,omitempty"`
}

type QueryCandidateNicsResponse struct {
	returnval []*IscsiPortInfo `xml:"returnval,omitempty"`
}

type BindVnicResponse struct {
}

type UnbindVnicResponse struct {
}

type QueryMigrationDependenciesResponse struct {
	returnval *IscsiMigrationDependency `xml:"returnval,omitempty"`
}

type QueryModulesResponse struct {
	returnval []*KernelModuleInfo `xml:"returnval,omitempty"`
}

type UpdateModuleOptionStringResponse struct {
}

type QueryConfiguredModuleOptionStringResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type CreateUserResponse struct {
}

type UpdateUserResponse struct {
}

type CreateGroupResponse struct {
}

type RemoveUserResponse struct {
}

type RemoveGroupResponse struct {
}

type AssignUserToGroupResponse struct {
}

type UnassignUserFromGroupResponse struct {
}

type ReconfigureServiceConsoleReservationResponse struct {
}

type ReconfigureVirtualMachineReservationResponse struct {
}

type UpdateNetworkConfigResponse struct {
	returnval *HostNetworkConfigResult `xml:"returnval,omitempty"`
}

type UpdateDnsConfigResponse struct {
}

type UpdateIpRouteConfigResponse struct {
}

type UpdateConsoleIpRouteConfigResponse struct {
}

type UpdateIpRouteTableConfigResponse struct {
}

type AddVirtualSwitchResponse struct {
}

type RemoveVirtualSwitchResponse struct {
}

type UpdateVirtualSwitchResponse struct {
}

type AddPortGroupResponse struct {
}

type RemovePortGroupResponse struct {
}

type UpdatePortGroupResponse struct {
}

type UpdatePhysicalNicLinkSpeedResponse struct {
}

type QueryNetworkHintResponse struct {
	returnval []*PhysicalNicHintInfo `xml:"returnval,omitempty"`
}

type AddVirtualNicResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type RemoveVirtualNicResponse struct {
}

type UpdateVirtualNicResponse struct {
}

type AddServiceConsoleVirtualNicResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type RemoveServiceConsoleVirtualNicResponse struct {
}

type UpdateServiceConsoleVirtualNicResponse struct {
}

type RestartServiceConsoleVirtualNicResponse struct {
}

type RefreshNetworkSystemResponse struct {
}

type CheckHostPatch_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ScanHostPatch_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ScanHostPatchV2_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type StageHostPatch_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type InstallHostPatch_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type InstallHostPatchV2_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UninstallHostPatch_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryHostPatch_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RefreshResponse struct {
}

type UpdatePassthruConfigResponse struct {
}

type ConfigurePowerPolicyResponse struct {
}

type UpdateServicePolicyResponse struct {
}

type StartServiceResponse struct {
}

type StopServiceResponse struct {
}

type RestartServiceResponse struct {
}

type UninstallServiceResponse struct {
}

type RefreshServicesResponse struct {
}

type ReconfigureSnmpAgentResponse struct {
}

type SendTestNotificationResponse struct {
}

type RetrieveDiskPartitionInfoResponse struct {
	returnval []*HostDiskPartitionInfo `xml:"returnval,omitempty"`
}

type ComputeDiskPartitionInfoResponse struct {
	returnval *HostDiskPartitionInfo `xml:"returnval,omitempty"`
}

type ComputeDiskPartitionInfoForResizeResponse struct {
	returnval *HostDiskPartitionInfo `xml:"returnval,omitempty"`
}

type UpdateDiskPartitionsResponse struct {
}

type FormatVmfsResponse struct {
	returnval *HostVmfsVolume `xml:"returnval,omitempty"`
}

type MountVmfsVolumeResponse struct {
}

type UnmountVmfsVolumeResponse struct {
}

type DeleteVmfsVolumeStateResponse struct {
}

type RescanVmfsResponse struct {
}

type AttachVmfsExtentResponse struct {
}

type ExpandVmfsExtentResponse struct {
}

type UpgradeVmfsResponse struct {
}

type UpgradeVmLayoutResponse struct {
}

type QueryUnresolvedVmfsVolumeResponse struct {
	returnval []*HostUnresolvedVmfsVolume `xml:"returnval,omitempty"`
}

type ResolveMultipleUnresolvedVmfsVolumesResponse struct {
	returnval []*HostUnresolvedVmfsResolutionResult `xml:"returnval,omitempty"`
}

type ResolveMultipleUnresolvedVmfsVolumesEx_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UnmountForceMountedVmfsVolumeResponse struct {
}

type RescanHbaResponse struct {
}

type RescanAllHbaResponse struct {
}

type UpdateSoftwareInternetScsiEnabledResponse struct {
}

type UpdateInternetScsiDiscoveryPropertiesResponse struct {
}

type UpdateInternetScsiAuthenticationPropertiesResponse struct {
}

type UpdateInternetScsiDigestPropertiesResponse struct {
}

type UpdateInternetScsiAdvancedOptionsResponse struct {
}

type UpdateInternetScsiIPPropertiesResponse struct {
}

type UpdateInternetScsiNameResponse struct {
}

type UpdateInternetScsiAliasResponse struct {
}

type AddInternetScsiSendTargetsResponse struct {
}

type RemoveInternetScsiSendTargetsResponse struct {
}

type AddInternetScsiStaticTargetsResponse struct {
}

type RemoveInternetScsiStaticTargetsResponse struct {
}

type EnableMultipathPathResponse struct {
}

type DisableMultipathPathResponse struct {
}

type SetMultipathLunPolicyResponse struct {
}

type QueryPathSelectionPolicyOptionsResponse struct {
	returnval []*HostPathSelectionPolicyOption `xml:"returnval,omitempty"`
}

type QueryStorageArrayTypePolicyOptionsResponse struct {
	returnval []*HostStorageArrayTypePolicyOption `xml:"returnval,omitempty"`
}

type UpdateScsiLunDisplayNameResponse struct {
}

type DetachScsiLunResponse struct {
}

type DeleteScsiLunStateResponse struct {
}

type AttachScsiLunResponse struct {
}

type RefreshStorageSystemResponse struct {
}

type DiscoverFcoeHbasResponse struct {
}

type MarkForRemovalResponse struct {
}

type FormatVffsResponse struct {
	returnval *HostVffsVolume `xml:"returnval,omitempty"`
}

type ExtendVffsResponse struct {
}

type DestroyVffsResponse struct {
}

type MountVffsVolumeResponse struct {
}

type UnmountVffsVolumeResponse struct {
}

type DeleteVffsVolumeStateResponse struct {
}

type RescanVffsResponse struct {
}

type QueryAvailableSsdsResponse struct {
	returnval []*HostScsiDisk `xml:"returnval,omitempty"`
}

type ConfigureVFlashResourceEx_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type HostConfigureVFlashResourceResponse struct {
}

type HostRemoveVFlashResourceResponse struct {
}

type HostConfigVFlashCacheResponse struct {
}

type HostGetVFlashModuleDefaultConfigResponse struct {
	returnval *VirtualDiskVFlashCacheConfigInfo `xml:"returnval,omitempty"`
}

type UpdateIpConfigResponse struct {
}

type SelectVnicResponse struct {
}

type DeselectVnicResponse struct {
}

type QueryNetConfigResponse struct {
	returnval *VirtualNicManagerNetConfig `xml:"returnval,omitempty"`
}

type SelectVnicForNicTypeResponse struct {
}

type DeselectVnicForNicTypeResponse struct {
}

type QueryCmmdsResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type QueryPhysicalVsanDisksResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type QueryVsanObjectsResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type QueryObjectsOnPhysicalVsanDiskResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type QueryDisksForVsanResponse struct {
	returnval []*VsanHostDiskResult `xml:"returnval,omitempty"`
}

type AddDisks_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type InitializeDisks_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RemoveDisk_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RemoveDiskMapping_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpdateVsan_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryHostStatusResponse struct {
	returnval *VsanHostClusterStatus `xml:"returnval,omitempty"`
}

type QueryOptionsResponse struct {
	returnval []*OptionValue `xml:"returnval,omitempty"`
}

type UpdateOptionsResponse struct {
}

type CheckCompliance_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryComplianceStatusResponse struct {
	returnval []*ComplianceResult `xml:"returnval,omitempty"`
}

type ClearComplianceStatusResponse struct {
}

type QueryExpressionMetadataResponse struct {
	returnval []*ProfileExpressionMetadata `xml:"returnval,omitempty"`
}

type RetrieveDescriptionResponse struct {
	returnval *ProfileDescription `xml:"returnval,omitempty"`
}

type DestroyProfileResponse struct {
}

type AssociateProfileResponse struct {
}

type DissociateProfileResponse struct {
}

type CheckProfileCompliance_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ExportProfileResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type CreateProfileResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryPolicyMetadataResponse struct {
	returnval []*ProfilePolicyMetadata `xml:"returnval,omitempty"`
}

type FindAssociatedProfileResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type UpdateClusterProfileResponse struct {
}

type UpdateReferenceHostResponse struct {
}

type UpdateHostProfileResponse struct {
}

type ExecuteHostProfileResponse struct {
	returnval *ProfileExecuteResult `xml:"returnval,omitempty"`
}

type ApplyHostConfig_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type GenerateConfigTaskListResponse struct {
	returnval *HostProfileManagerConfigTaskList `xml:"returnval,omitempty"`
}

type GenerateHostProfileTaskList_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryHostProfileMetadataResponse struct {
	returnval []*ProfileMetadata `xml:"returnval,omitempty"`
}

type QueryProfileStructureResponse struct {
	returnval *ProfileProfileStructure `xml:"returnval,omitempty"`
}

type CreateDefaultProfileResponse struct {
	returnval *ApplyProfile `xml:"returnval,omitempty"`
}

type UpdateAnswerFile_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RetrieveAnswerFileResponse struct {
	returnval *AnswerFile `xml:"returnval,omitempty"`
}

type RetrieveAnswerFileForProfileResponse struct {
	returnval *AnswerFile `xml:"returnval,omitempty"`
}

type ExportAnswerFile_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CheckAnswerFileStatus_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryAnswerFileStatusResponse struct {
	returnval []*AnswerFileStatusResult `xml:"returnval,omitempty"`
}

type RemoveScheduledTaskResponse struct {
}

type ReconfigureScheduledTaskResponse struct {
}

type RunScheduledTaskResponse struct {
}

type CreateScheduledTaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RetrieveEntityScheduledTaskResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateObjectScheduledTaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RetrieveObjectScheduledTaskResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type OpenInventoryViewFolderResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type CloseInventoryViewFolderResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type ModifyListViewResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type ResetListViewResponse struct {
	returnval []*ManagedObjectReference `xml:"returnval,omitempty"`
}

type ResetListViewFromViewResponse struct {
}

type DestroyViewResponse struct {
}

type CreateInventoryViewResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateContainerViewResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateListViewResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CreateListViewFromViewResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RevertToSnapshot_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RemoveSnapshot_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RenameSnapshotResponse struct {
}

type ExportSnapshotResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CheckCompatibility_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type QueryVMotionCompatibilityEx_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CheckMigrate_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type CheckRelocate_TaskResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type ValidateCredentialsInGuestResponse struct {
}

type AcquireCredentialsInGuestResponse struct {
	returnval *GuestAuthentication `xml:"returnval,omitempty"`
}

type ReleaseCredentialsInGuestResponse struct {
}

type MakeDirectoryInGuestResponse struct {
}

type DeleteFileInGuestResponse struct {
}

type DeleteDirectoryInGuestResponse struct {
}

type MoveDirectoryInGuestResponse struct {
}

type MoveFileInGuestResponse struct {
}

type CreateTemporaryFileInGuestResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type CreateTemporaryDirectoryInGuestResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type ListFilesInGuestResponse struct {
	returnval *GuestListFileInfo `xml:"returnval,omitempty"`
}

type ChangeFileAttributesInGuestResponse struct {
}

type InitiateFileTransferFromGuestResponse struct {
	returnval *FileTransferInformation `xml:"returnval,omitempty"`
}

type InitiateFileTransferToGuestResponse struct {
	returnval string `xml:"returnval,omitempty"`
}

type StartProgramInGuestResponse struct {
	returnval int64 `xml:"returnval,omitempty"`
}

type ListProcessesInGuestResponse struct {
	returnval []*GuestProcessInfo `xml:"returnval,omitempty"`
}

type TerminateProcessInGuestResponse struct {
}

type ReadEnvironmentVariableInGuestResponse struct {
	returnval []string `xml:"returnval,omitempty"`
}

type DestroyPropertyFilterResponse struct {
}

type CreateFilterResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type RetrievePropertiesResponse struct {
	returnval []*ObjectContent `xml:"returnval,omitempty"`
}

type CheckForUpdatesResponse struct {
	returnval *UpdateSet `xml:"returnval,omitempty"`
}

type WaitForUpdatesResponse struct {
	returnval *UpdateSet `xml:"returnval,omitempty"`
}

type CancelWaitForUpdatesResponse struct {
}

type WaitForUpdatesExResponse struct {
	returnval *UpdateSet `xml:"returnval,omitempty"`
}

type RetrievePropertiesExResponse struct {
	returnval *RetrieveResult `xml:"returnval,omitempty"`
}

type ContinueRetrievePropertiesExResponse struct {
	returnval *RetrieveResult `xml:"returnval,omitempty"`
}

type CancelRetrievePropertiesExResponse struct {
}

type CreatePropertyCollectorResponse struct {
	returnval *ManagedObjectReference `xml:"returnval,omitempty"`
}

type DestroyPropertyCollectorResponse struct {
}

type DynamicArray struct {
	dynamicType string        `xml:"dynamicType,omitempty"`
	val         []interface{} `xml:"val,omitempty"`
}

type DynamicData struct {
	dynamicType     string             `xml:"dynamicType,omitempty"`
	dynamicProperty []*DynamicProperty `xml:"dynamicProperty,omitempty"`
}

type DynamicProperty struct {
	name string      `xml:"name,omitempty"`
	val  interface{} `xml:"val,omitempty"`
}

type ArrayOfDynamicProperty struct {
	DynamicProperty []*DynamicProperty `xml:"DynamicProperty,omitempty"`
}

type KeyAnyValue struct {
	*DynamicData

	key   string      `xml:"key,omitempty"`
	value interface{} `xml:"value,omitempty"`
}

type ArrayOfKeyAnyValue struct {
	KeyAnyValue []*KeyAnyValue `xml:"KeyAnyValue,omitempty"`
}

type LocalizableMessage struct {
	*DynamicData

	key     string         `xml:"key,omitempty"`
	arg     []*KeyAnyValue `xml:"arg,omitempty"`
	message string         `xml:"message,omitempty"`
}

type ArrayOfLocalizableMessage struct {
	LocalizableMessage []*LocalizableMessage `xml:"LocalizableMessage,omitempty"`
}

type LocalizedMethodFault struct {
	*DynamicData

	fault            *MethodFault `xml:"fault,omitempty"`
	localizedMessage string       `xml:"localizedMessage,omitempty"`
}

type MethodFault struct {
	dynamicType     string                `xml:"dynamicType,omitempty"`
	dynamicProperty []*DynamicProperty    `xml:"dynamicProperty,omitempty"`
	faultCause      *LocalizedMethodFault `xml:"faultCause,omitempty"`
	faultMessage    []*LocalizableMessage `xml:"faultMessage,omitempty"`
}

type ArrayOfMethodFault struct {
	MethodFault []*MethodFault `xml:"MethodFault,omitempty"`
}

type RuntimeFault struct {
	*MethodFault
}

type HostCommunication struct {
	*RuntimeFault
}

type HostNotConnected struct {
	*HostCommunication
}

type HostNotReachable struct {
	*HostCommunication
}

type InvalidArgument struct {
	*RuntimeFault

	invalidProperty string `xml:"invalidProperty,omitempty"`
}

type InvalidRequest struct {
	*RuntimeFault
}

type InvalidType struct {
	*InvalidRequest

	argument string `xml:"argument,omitempty"`
}

type ManagedObjectNotFound struct {
	*RuntimeFault

	obj *ManagedObjectReference `xml:"obj,omitempty"`
}

type MethodNotFound struct {
	*InvalidRequest

	receiver *ManagedObjectReference `xml:"receiver,omitempty"`
	method   string                  `xml:"method,omitempty"`
}

type NotEnoughLicenses struct {
	*RuntimeFault
}

type NotImplemented struct {
	*RuntimeFault
}

type NotSupported struct {
	*RuntimeFault
}

type RequestCanceled struct {
	*RuntimeFault
}

type SecurityError struct {
	*RuntimeFault
}

type SystemError struct {
	*RuntimeFault

	reason string `xml:"reason,omitempty"`
}

type UnexpectedFault struct {
	*RuntimeFault

	faultName string                `xml:"faultName,omitempty"`
	fault     *LocalizedMethodFault `xml:"fault,omitempty"`
}

type ManagedObjectReference struct {
}

type ArrayOfString struct {
	string []string `xml:"string,omitempty"`
}

type ArrayOfAnyType struct {
	anyType []interface{} `xml:"anyType,omitempty"`
}

type ArrayOfManagedObjectReference struct {
	ManagedObjectReference []*ManagedObjectReference `xml:"ManagedObjectReference,omitempty"`
}

type ArrayOfBoolean struct {
	boolean []bool `xml:"boolean,omitempty"`
}

type ArrayOfByte struct {
	byte []int8 `xml:"byte,omitempty"`
}

type ArrayOfDouble struct {
	double []float64 `xml:"double,omitempty"`
}

type ArrayOfInt struct {
	int []int32 `xml:"int,omitempty"`
}

type ArrayOfLong struct {
	long []int64 `xml:"long,omitempty"`
}

type ArrayOfShort struct {
	short []int16 `xml:"short,omitempty"`
}

type ObjectUpdateKind string

const (
	ObjectUpdateKind_Modify ObjectUpdateKind = "modify"
	ObjectUpdateKind_Enter  ObjectUpdateKind = "enter"
	ObjectUpdateKind_Leave  ObjectUpdateKind = "leave"
)

type PropertyChangeOp string

const (
	PropertyChangeOp_Add            PropertyChangeOp = "add"
	PropertyChangeOp_Remove         PropertyChangeOp = "remove"
	PropertyChangeOp_Assign         PropertyChangeOp = "assign"
	PropertyChangeOp_IndirectRemove PropertyChangeOp = "indirectRemove"
)

type InvalidCollectorVersion struct {
	*MethodFault
}

type InvalidProperty struct {
	*MethodFault

	name string `xml:"name,omitempty"`
}

type PropertyFilterSpec struct {
	*DynamicData

	propSet                       []*PropertySpec `xml:"propSet,omitempty"`
	objectSet                     []*ObjectSpec   `xml:"objectSet,omitempty"`
	reportMissingObjectsInResults bool            `xml:"reportMissingObjectsInResults,omitempty"`
}

type ArrayOfPropertyFilterSpec struct {
	PropertyFilterSpec []*PropertyFilterSpec `xml:"PropertyFilterSpec,omitempty"`
}

type PropertySpec struct {
	*DynamicData

	type_   string   `xml:"type,omitempty"`
	all     bool     `xml:"all,omitempty"`
	pathSet []string `xml:"pathSet,omitempty"`
}

type ArrayOfPropertySpec struct {
	PropertySpec []*PropertySpec `xml:"PropertySpec,omitempty"`
}

type ObjectSpec struct {
	*DynamicData

	obj       *ManagedObjectReference `xml:"obj,omitempty"`
	skip      bool                    `xml:"skip,omitempty"`
	selectSet []*SelectionSpec        `xml:"selectSet,omitempty"`
}

type ArrayOfObjectSpec struct {
	ObjectSpec []*ObjectSpec `xml:"ObjectSpec,omitempty"`
}

type SelectionSpec struct {
	*DynamicData

	name string `xml:"name,omitempty"`
}

type ArrayOfSelectionSpec struct {
	SelectionSpec []*SelectionSpec `xml:"SelectionSpec,omitempty"`
}

type TraversalSpec struct {
	*SelectionSpec

	type_     string           `xml:"type,omitempty"`
	path      string           `xml:"path,omitempty"`
	skip      bool             `xml:"skip,omitempty"`
	selectSet []*SelectionSpec `xml:"selectSet,omitempty"`
}

type ObjectContent struct {
	*DynamicData

	obj        *ManagedObjectReference `xml:"obj,omitempty"`
	propSet    []*DynamicProperty      `xml:"propSet,omitempty"`
	missingSet []*MissingProperty      `xml:"missingSet,omitempty"`
}

type ArrayOfObjectContent struct {
	ObjectContent []*ObjectContent `xml:"ObjectContent,omitempty"`
}

type UpdateSet struct {
	*DynamicData

	version   string                  `xml:"version,omitempty"`
	filterSet []*PropertyFilterUpdate `xml:"filterSet,omitempty"`
	truncated bool                    `xml:"truncated,omitempty"`
}

type PropertyFilterUpdate struct {
	*DynamicData

	filter     *ManagedObjectReference `xml:"filter,omitempty"`
	objectSet  []*ObjectUpdate         `xml:"objectSet,omitempty"`
	missingSet []*MissingObject        `xml:"missingSet,omitempty"`
}

type ArrayOfPropertyFilterUpdate struct {
	PropertyFilterUpdate []*PropertyFilterUpdate `xml:"PropertyFilterUpdate,omitempty"`
}

type ObjectUpdate struct {
	*DynamicData

	kind       *ObjectUpdateKind       `xml:"kind,omitempty"`
	obj        *ManagedObjectReference `xml:"obj,omitempty"`
	changeSet  []*PropertyChange       `xml:"changeSet,omitempty"`
	missingSet []*MissingProperty      `xml:"missingSet,omitempty"`
}

type ArrayOfObjectUpdate struct {
	ObjectUpdate []*ObjectUpdate `xml:"ObjectUpdate,omitempty"`
}

type PropertyChange struct {
	*DynamicData

	name string            `xml:"name,omitempty"`
	op   *PropertyChangeOp `xml:"op,omitempty"`
	val  interface{}       `xml:"val,omitempty"`
}

type ArrayOfPropertyChange struct {
	PropertyChange []*PropertyChange `xml:"PropertyChange,omitempty"`
}

type MissingProperty struct {
	*DynamicData

	path  string                `xml:"path,omitempty"`
	fault *LocalizedMethodFault `xml:"fault,omitempty"`
}

type ArrayOfMissingProperty struct {
	MissingProperty []*MissingProperty `xml:"MissingProperty,omitempty"`
}

type MissingObject struct {
	*DynamicData

	obj   *ManagedObjectReference `xml:"obj,omitempty"`
	fault *LocalizedMethodFault   `xml:"fault,omitempty"`
}

type ArrayOfMissingObject struct {
	MissingObject []*MissingObject `xml:"MissingObject,omitempty"`
}

type WaitOptions struct {
	*DynamicData

	maxWaitSeconds   int32 `xml:"maxWaitSeconds,omitempty"`
	maxObjectUpdates int32 `xml:"maxObjectUpdates,omitempty"`
}

type RetrieveOptions struct {
	*DynamicData

	maxObjects int32 `xml:"maxObjects,omitempty"`
}

type RetrieveResult struct {
	*DynamicData

	token   string           `xml:"token,omitempty"`
	objects []*ObjectContent `xml:"objects,omitempty"`
}

type DestroyPropertyFilterRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateFilterRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	spec           *PropertyFilterSpec     `xml:"spec,omitempty"`
	partialUpdates bool                    `xml:"partialUpdates,omitempty"`
}

type RetrievePropertiesRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	specSet []*PropertyFilterSpec   `xml:"specSet,omitempty"`
}

type CheckForUpdatesRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	version string                  `xml:"version,omitempty"`
}

type WaitForUpdatesRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	version string                  `xml:"version,omitempty"`
}

type CancelWaitForUpdatesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type WaitForUpdatesExRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	version string                  `xml:"version,omitempty"`
	options *WaitOptions            `xml:"options,omitempty"`
}

type RetrievePropertiesExRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	specSet []*PropertyFilterSpec   `xml:"specSet,omitempty"`
	options *RetrieveOptions        `xml:"options,omitempty"`
}

type ContinueRetrievePropertiesExRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	token string                  `xml:"token,omitempty"`
}

type CancelRetrievePropertiesExRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	token string                  `xml:"token,omitempty"`
}

type CreatePropertyCollectorRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type DestroyPropertyCollectorRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState string

const (
	ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState_Licensed   ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState = "licensed"
	ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState_Unlicensed ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState = "unlicensed"
	ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState_Unknown    ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState = "unknown"
)

type ConfigSpecOperation string

const (
	ConfigSpecOperation_Add    ConfigSpecOperation = "add"
	ConfigSpecOperation_Edit   ConfigSpecOperation = "edit"
	ConfigSpecOperation_Remove ConfigSpecOperation = "remove"
)

type DatastoreAccessible string

const (
	DatastoreAccessible_True  DatastoreAccessible = "True"
	DatastoreAccessible_False DatastoreAccessible = "False"
)

type DatastoreSummaryMaintenanceModeState string

const (
	DatastoreSummaryMaintenanceModeState_Normal              DatastoreSummaryMaintenanceModeState = "normal"
	DatastoreSummaryMaintenanceModeState_EnteringMaintenance DatastoreSummaryMaintenanceModeState = "enteringMaintenance"
	DatastoreSummaryMaintenanceModeState_InMaintenance       DatastoreSummaryMaintenanceModeState = "inMaintenance"
)

type DiagnosticManagerLogCreator string

const (
	DiagnosticManagerLogCreator_Vpxd      DiagnosticManagerLogCreator = "vpxd"
	DiagnosticManagerLogCreator_Vpxa      DiagnosticManagerLogCreator = "vpxa"
	DiagnosticManagerLogCreator_Hostd     DiagnosticManagerLogCreator = "hostd"
	DiagnosticManagerLogCreator_Serverd   DiagnosticManagerLogCreator = "serverd"
	DiagnosticManagerLogCreator_Install   DiagnosticManagerLogCreator = "install"
	DiagnosticManagerLogCreator_VpxClient DiagnosticManagerLogCreator = "vpxClient"
	DiagnosticManagerLogCreator_RecordLog DiagnosticManagerLogCreator = "recordLog"
)

type DiagnosticManagerLogFormat string

const (
	DiagnosticManagerLogFormat_Plain DiagnosticManagerLogFormat = "plain"
)

type DistributedVirtualSwitchProductSpecOperationType string

const (
	DistributedVirtualSwitchProductSpecOperationType_PreInstall             DistributedVirtualSwitchProductSpecOperationType = "preInstall"
	DistributedVirtualSwitchProductSpecOperationType_Upgrade                DistributedVirtualSwitchProductSpecOperationType = "upgrade"
	DistributedVirtualSwitchProductSpecOperationType_NotifyAvailableUpgrade DistributedVirtualSwitchProductSpecOperationType = "notifyAvailableUpgrade"
	DistributedVirtualSwitchProductSpecOperationType_ProceedWithUpgrade     DistributedVirtualSwitchProductSpecOperationType = "proceedWithUpgrade"
	DistributedVirtualSwitchProductSpecOperationType_UpdateBundleInfo       DistributedVirtualSwitchProductSpecOperationType = "updateBundleInfo"
)

type DistributedVirtualSwitchNicTeamingPolicyMode string

const (
	DistributedVirtualSwitchNicTeamingPolicyMode_Loadbalance_ip        DistributedVirtualSwitchNicTeamingPolicyMode = "loadbalance_ip"
	DistributedVirtualSwitchNicTeamingPolicyMode_Loadbalance_srcmac    DistributedVirtualSwitchNicTeamingPolicyMode = "loadbalance_srcmac"
	DistributedVirtualSwitchNicTeamingPolicyMode_Loadbalance_srcid     DistributedVirtualSwitchNicTeamingPolicyMode = "loadbalance_srcid"
	DistributedVirtualSwitchNicTeamingPolicyMode_Failover_explicit     DistributedVirtualSwitchNicTeamingPolicyMode = "failover_explicit"
	DistributedVirtualSwitchNicTeamingPolicyMode_Loadbalance_loadbased DistributedVirtualSwitchNicTeamingPolicyMode = "loadbalance_loadbased"
)

type DistributedVirtualSwitchHostInfrastructureTrafficClass string

const (
	DistributedVirtualSwitchHostInfrastructureTrafficClass_Management     DistributedVirtualSwitchHostInfrastructureTrafficClass = "management"
	DistributedVirtualSwitchHostInfrastructureTrafficClass_FaultTolerance DistributedVirtualSwitchHostInfrastructureTrafficClass = "faultTolerance"
	DistributedVirtualSwitchHostInfrastructureTrafficClass_Vmotion        DistributedVirtualSwitchHostInfrastructureTrafficClass = "vmotion"
	DistributedVirtualSwitchHostInfrastructureTrafficClass_VirtualMachine DistributedVirtualSwitchHostInfrastructureTrafficClass = "virtualMachine"
	DistributedVirtualSwitchHostInfrastructureTrafficClass_ISCSI          DistributedVirtualSwitchHostInfrastructureTrafficClass = "iSCSI"
	DistributedVirtualSwitchHostInfrastructureTrafficClass_Nfs            DistributedVirtualSwitchHostInfrastructureTrafficClass = "nfs"
	DistributedVirtualSwitchHostInfrastructureTrafficClass_Hbr            DistributedVirtualSwitchHostInfrastructureTrafficClass = "hbr"
	DistributedVirtualSwitchHostInfrastructureTrafficClass_Vsan           DistributedVirtualSwitchHostInfrastructureTrafficClass = "vsan"
)

type DrsInjectorWorkloadCorrelationState string

const (
	DrsInjectorWorkloadCorrelationState_Correlated   DrsInjectorWorkloadCorrelationState = "Correlated"
	DrsInjectorWorkloadCorrelationState_Uncorrelated DrsInjectorWorkloadCorrelationState = "Uncorrelated"
)

type ReplicationVmState string

const (
	ReplicationVmState_None    ReplicationVmState = "none"
	ReplicationVmState_Paused  ReplicationVmState = "paused"
	ReplicationVmState_Syncing ReplicationVmState = "syncing"
	ReplicationVmState_Idle    ReplicationVmState = "idle"
	ReplicationVmState_Active  ReplicationVmState = "active"
	ReplicationVmState_Error   ReplicationVmState = "error"
)

type HostSystemConnectionState string

const (
	HostSystemConnectionState_Connected     HostSystemConnectionState = "connected"
	HostSystemConnectionState_NotResponding HostSystemConnectionState = "notResponding"
	HostSystemConnectionState_Disconnected  HostSystemConnectionState = "disconnected"
)

type HostSystemPowerState string

const (
	HostSystemPowerState_PoweredOn  HostSystemPowerState = "poweredOn"
	HostSystemPowerState_PoweredOff HostSystemPowerState = "poweredOff"
	HostSystemPowerState_StandBy    HostSystemPowerState = "standBy"
	HostSystemPowerState_Unknown    HostSystemPowerState = "unknown"
)

type HostStandbyMode string

const (
	HostStandbyMode_Entering HostStandbyMode = "entering"
	HostStandbyMode_Exiting  HostStandbyMode = "exiting"
	HostStandbyMode_In       HostStandbyMode = "in"
	HostStandbyMode_None     HostStandbyMode = "none"
)

type HttpNfcLeaseState string

const (
	HttpNfcLeaseState_Initializing HttpNfcLeaseState = "initializing"
	HttpNfcLeaseState_Ready        HttpNfcLeaseState = "ready"
	HttpNfcLeaseState_Done         HttpNfcLeaseState = "done"
	HttpNfcLeaseState_Error        HttpNfcLeaseState = "error"
)

type LatencySensitivitySensitivityLevel string

const (
	LatencySensitivitySensitivityLevel_Low    LatencySensitivitySensitivityLevel = "low"
	LatencySensitivitySensitivityLevel_Normal LatencySensitivitySensitivityLevel = "normal"
	LatencySensitivitySensitivityLevel_Medium LatencySensitivitySensitivityLevel = "medium"
	LatencySensitivitySensitivityLevel_High   LatencySensitivitySensitivityLevel = "high"
	LatencySensitivitySensitivityLevel_Custom LatencySensitivitySensitivityLevel = "custom"
)

type LicenseManagerState string

const (
	LicenseManagerState_Initializing LicenseManagerState = "initializing"
	LicenseManagerState_Normal       LicenseManagerState = "normal"
	LicenseManagerState_Marginal     LicenseManagerState = "marginal"
	LicenseManagerState_Fault        LicenseManagerState = "fault"
)

type LicenseManagerLicenseKey string

const (
	LicenseManagerLicenseKey_EsxFull    LicenseManagerLicenseKey = "esxFull"
	LicenseManagerLicenseKey_EsxVmtn    LicenseManagerLicenseKey = "esxVmtn"
	LicenseManagerLicenseKey_EsxExpress LicenseManagerLicenseKey = "esxExpress"
	LicenseManagerLicenseKey_San        LicenseManagerLicenseKey = "san"
	LicenseManagerLicenseKey_Iscsi      LicenseManagerLicenseKey = "iscsi"
	LicenseManagerLicenseKey_Nas        LicenseManagerLicenseKey = "nas"
	LicenseManagerLicenseKey_Vsmp       LicenseManagerLicenseKey = "vsmp"
	LicenseManagerLicenseKey_Backup     LicenseManagerLicenseKey = "backup"
	LicenseManagerLicenseKey_Vc         LicenseManagerLicenseKey = "vc"
	LicenseManagerLicenseKey_VcExpress  LicenseManagerLicenseKey = "vcExpress"
	LicenseManagerLicenseKey_EsxHost    LicenseManagerLicenseKey = "esxHost"
	LicenseManagerLicenseKey_GsxHost    LicenseManagerLicenseKey = "gsxHost"
	LicenseManagerLicenseKey_ServerHost LicenseManagerLicenseKey = "serverHost"
	LicenseManagerLicenseKey_DrsPower   LicenseManagerLicenseKey = "drsPower"
	LicenseManagerLicenseKey_Vmotion    LicenseManagerLicenseKey = "vmotion"
	LicenseManagerLicenseKey_Drs        LicenseManagerLicenseKey = "drs"
	LicenseManagerLicenseKey_Das        LicenseManagerLicenseKey = "das"
)

type LicenseFeatureInfoUnit string

const (
	LicenseFeatureInfoUnit_Host       LicenseFeatureInfoUnit = "host"
	LicenseFeatureInfoUnit_CpuCore    LicenseFeatureInfoUnit = "cpuCore"
	LicenseFeatureInfoUnit_CpuPackage LicenseFeatureInfoUnit = "cpuPackage"
	LicenseFeatureInfoUnit_Server     LicenseFeatureInfoUnit = "server"
	LicenseFeatureInfoUnit_Vm         LicenseFeatureInfoUnit = "vm"
)

type LicenseFeatureInfoState string

const (
	LicenseFeatureInfoState_Enabled  LicenseFeatureInfoState = "enabled"
	LicenseFeatureInfoState_Disabled LicenseFeatureInfoState = "disabled"
	LicenseFeatureInfoState_Optional LicenseFeatureInfoState = "optional"
)

type LicenseFeatureInfoSourceRestriction string

const (
	LicenseFeatureInfoSourceRestriction_Unrestricted LicenseFeatureInfoSourceRestriction = "unrestricted"
	LicenseFeatureInfoSourceRestriction_Served       LicenseFeatureInfoSourceRestriction = "served"
	LicenseFeatureInfoSourceRestriction_File         LicenseFeatureInfoSourceRestriction = "file"
)

type LicenseReservationInfoState string

const (
	LicenseReservationInfoState_NotUsed       LicenseReservationInfoState = "notUsed"
	LicenseReservationInfoState_NoLicense     LicenseReservationInfoState = "noLicense"
	LicenseReservationInfoState_UnlicensedUse LicenseReservationInfoState = "unlicensedUse"
	LicenseReservationInfoState_Licensed      LicenseReservationInfoState = "licensed"
)

type HostLicensableResourceKey string

const (
	HostLicensableResourceKey_NumCpuPackages HostLicensableResourceKey = "numCpuPackages"
	HostLicensableResourceKey_NumCpuCores    HostLicensableResourceKey = "numCpuCores"
	HostLicensableResourceKey_MemorySize     HostLicensableResourceKey = "memorySize"
	HostLicensableResourceKey_MemoryForVms   HostLicensableResourceKey = "memoryForVms"
	HostLicensableResourceKey_NumVmsStarted  HostLicensableResourceKey = "numVmsStarted"
	HostLicensableResourceKey_NumVmsStarting HostLicensableResourceKey = "numVmsStarting"
)

type ManagedEntityStatus string

const (
	ManagedEntityStatus_Gray   ManagedEntityStatus = "gray"
	ManagedEntityStatus_Green  ManagedEntityStatus = "green"
	ManagedEntityStatus_Yellow ManagedEntityStatus = "yellow"
	ManagedEntityStatus_Red    ManagedEntityStatus = "red"
)

type OvfConsumerOstNodeType string

const (
	OvfConsumerOstNodeType_Envelope                OvfConsumerOstNodeType = "envelope"
	OvfConsumerOstNodeType_VirtualSystem           OvfConsumerOstNodeType = "virtualSystem"
	OvfConsumerOstNodeType_VirtualSystemCollection OvfConsumerOstNodeType = "virtualSystemCollection"
)

type OvfCreateImportSpecParamsDiskProvisioningType string

const (
	OvfCreateImportSpecParamsDiskProvisioningType_MonolithicSparse     OvfCreateImportSpecParamsDiskProvisioningType = "monolithicSparse"
	OvfCreateImportSpecParamsDiskProvisioningType_MonolithicFlat       OvfCreateImportSpecParamsDiskProvisioningType = "monolithicFlat"
	OvfCreateImportSpecParamsDiskProvisioningType_TwoGbMaxExtentSparse OvfCreateImportSpecParamsDiskProvisioningType = "twoGbMaxExtentSparse"
	OvfCreateImportSpecParamsDiskProvisioningType_TwoGbMaxExtentFlat   OvfCreateImportSpecParamsDiskProvisioningType = "twoGbMaxExtentFlat"
	OvfCreateImportSpecParamsDiskProvisioningType_Thin                 OvfCreateImportSpecParamsDiskProvisioningType = "thin"
	OvfCreateImportSpecParamsDiskProvisioningType_Thick                OvfCreateImportSpecParamsDiskProvisioningType = "thick"
	OvfCreateImportSpecParamsDiskProvisioningType_SeSparse             OvfCreateImportSpecParamsDiskProvisioningType = "seSparse"
	OvfCreateImportSpecParamsDiskProvisioningType_EagerZeroedThick     OvfCreateImportSpecParamsDiskProvisioningType = "eagerZeroedThick"
	OvfCreateImportSpecParamsDiskProvisioningType_Sparse               OvfCreateImportSpecParamsDiskProvisioningType = "sparse"
	OvfCreateImportSpecParamsDiskProvisioningType_Flat                 OvfCreateImportSpecParamsDiskProvisioningType = "flat"
)

type PerfFormat string

const (
	PerfFormat_Normal PerfFormat = "normal"
	PerfFormat_Csv    PerfFormat = "csv"
)

type PerfSummaryType string

const (
	PerfSummaryType_Average   PerfSummaryType = "average"
	PerfSummaryType_Maximum   PerfSummaryType = "maximum"
	PerfSummaryType_Minimum   PerfSummaryType = "minimum"
	PerfSummaryType_Latest    PerfSummaryType = "latest"
	PerfSummaryType_Summation PerfSummaryType = "summation"
	PerfSummaryType_None      PerfSummaryType = "none"
)

type PerfStatsType string

const (
	PerfStatsType_Absolute PerfStatsType = "absolute"
	PerfStatsType_Delta    PerfStatsType = "delta"
	PerfStatsType_Rate     PerfStatsType = "rate"
)

type PerformanceManagerUnit string

const (
	PerformanceManagerUnit_Percent            PerformanceManagerUnit = "percent"
	PerformanceManagerUnit_KiloBytes          PerformanceManagerUnit = "kiloBytes"
	PerformanceManagerUnit_MegaBytes          PerformanceManagerUnit = "megaBytes"
	PerformanceManagerUnit_MegaHertz          PerformanceManagerUnit = "megaHertz"
	PerformanceManagerUnit_Number             PerformanceManagerUnit = "number"
	PerformanceManagerUnit_Microsecond        PerformanceManagerUnit = "microsecond"
	PerformanceManagerUnit_Millisecond        PerformanceManagerUnit = "millisecond"
	PerformanceManagerUnit_Second             PerformanceManagerUnit = "second"
	PerformanceManagerUnit_KiloBytesPerSecond PerformanceManagerUnit = "kiloBytesPerSecond"
	PerformanceManagerUnit_MegaBytesPerSecond PerformanceManagerUnit = "megaBytesPerSecond"
	PerformanceManagerUnit_Watt               PerformanceManagerUnit = "watt"
	PerformanceManagerUnit_Joule              PerformanceManagerUnit = "joule"
)

type ValidateMigrationTestType string

const (
	ValidateMigrationTestType_SourceTests            ValidateMigrationTestType = "sourceTests"
	ValidateMigrationTestType_CompatibilityTests     ValidateMigrationTestType = "compatibilityTests"
	ValidateMigrationTestType_DiskAccessibilityTests ValidateMigrationTestType = "diskAccessibilityTests"
	ValidateMigrationTestType_ResourceTests          ValidateMigrationTestType = "resourceTests"
)

type VMotionCompatibilityType string

const (
	VMotionCompatibilityType_Cpu      VMotionCompatibilityType = "cpu"
	VMotionCompatibilityType_Software VMotionCompatibilityType = "software"
)

type SessionManagerHttpServiceRequestSpecMethod string

const (
	SessionManagerHttpServiceRequestSpecMethod_HttpOptions SessionManagerHttpServiceRequestSpecMethod = "httpOptions"
	SessionManagerHttpServiceRequestSpecMethod_HttpGet     SessionManagerHttpServiceRequestSpecMethod = "httpGet"
	SessionManagerHttpServiceRequestSpecMethod_HttpHead    SessionManagerHttpServiceRequestSpecMethod = "httpHead"
	SessionManagerHttpServiceRequestSpecMethod_HttpPost    SessionManagerHttpServiceRequestSpecMethod = "httpPost"
	SessionManagerHttpServiceRequestSpecMethod_HttpPut     SessionManagerHttpServiceRequestSpecMethod = "httpPut"
	SessionManagerHttpServiceRequestSpecMethod_HttpDelete  SessionManagerHttpServiceRequestSpecMethod = "httpDelete"
	SessionManagerHttpServiceRequestSpecMethod_HttpTrace   SessionManagerHttpServiceRequestSpecMethod = "httpTrace"
	SessionManagerHttpServiceRequestSpecMethod_HttpConnect SessionManagerHttpServiceRequestSpecMethod = "httpConnect"
)

type SharesLevel string

const (
	SharesLevel_Low    SharesLevel = "low"
	SharesLevel_Normal SharesLevel = "normal"
	SharesLevel_High   SharesLevel = "high"
	SharesLevel_Custom SharesLevel = "custom"
)

type SimpleCommandEncoding string

const (
	SimpleCommandEncoding_CSV    SimpleCommandEncoding = "CSV"
	SimpleCommandEncoding_HEX    SimpleCommandEncoding = "HEX"
	SimpleCommandEncoding_STRING SimpleCommandEncoding = "STRING"
)

type StorageIORMThresholdMode string

const (
	StorageIORMThresholdMode_Automatic StorageIORMThresholdMode = "automatic"
	StorageIORMThresholdMode_Manual    StorageIORMThresholdMode = "manual"
)

type TaskFilterSpecRecursionOption string

const (
	TaskFilterSpecRecursionOption_Self     TaskFilterSpecRecursionOption = "self"
	TaskFilterSpecRecursionOption_Children TaskFilterSpecRecursionOption = "children"
	TaskFilterSpecRecursionOption_All      TaskFilterSpecRecursionOption = "all"
)

type TaskFilterSpecTimeOption string

const (
	TaskFilterSpecTimeOption_QueuedTime    TaskFilterSpecTimeOption = "queuedTime"
	TaskFilterSpecTimeOption_StartedTime   TaskFilterSpecTimeOption = "startedTime"
	TaskFilterSpecTimeOption_CompletedTime TaskFilterSpecTimeOption = "completedTime"
)

type TaskInfoState string

const (
	TaskInfoState_Queued  TaskInfoState = "queued"
	TaskInfoState_Running TaskInfoState = "running"
	TaskInfoState_Success TaskInfoState = "success"
	TaskInfoState_Error   TaskInfoState = "error"
)

type VirtualAppVAppState string

const (
	VirtualAppVAppState_Started  VirtualAppVAppState = "started"
	VirtualAppVAppState_Stopped  VirtualAppVAppState = "stopped"
	VirtualAppVAppState_Starting VirtualAppVAppState = "starting"
	VirtualAppVAppState_Stopping VirtualAppVAppState = "stopping"
)

type VirtualDiskType string

const (
	VirtualDiskType_Preallocated     VirtualDiskType = "preallocated"
	VirtualDiskType_Thin             VirtualDiskType = "thin"
	VirtualDiskType_SeSparse         VirtualDiskType = "seSparse"
	VirtualDiskType_Rdm              VirtualDiskType = "rdm"
	VirtualDiskType_Rdmp             VirtualDiskType = "rdmp"
	VirtualDiskType_Raw              VirtualDiskType = "raw"
	VirtualDiskType_Delta            VirtualDiskType = "delta"
	VirtualDiskType_Sparse2Gb        VirtualDiskType = "sparse2Gb"
	VirtualDiskType_Thick2Gb         VirtualDiskType = "thick2Gb"
	VirtualDiskType_EagerZeroedThick VirtualDiskType = "eagerZeroedThick"
	VirtualDiskType_SparseMonolithic VirtualDiskType = "sparseMonolithic"
	VirtualDiskType_FlatMonolithic   VirtualDiskType = "flatMonolithic"
	VirtualDiskType_Thick            VirtualDiskType = "thick"
)

type VirtualDiskAdapterType string

const (
	VirtualDiskAdapterType_Ide      VirtualDiskAdapterType = "ide"
	VirtualDiskAdapterType_BusLogic VirtualDiskAdapterType = "busLogic"
	VirtualDiskAdapterType_LsiLogic VirtualDiskAdapterType = "lsiLogic"
)

type VirtualMachinePowerState string

const (
	VirtualMachinePowerState_PoweredOff VirtualMachinePowerState = "poweredOff"
	VirtualMachinePowerState_PoweredOn  VirtualMachinePowerState = "poweredOn"
	VirtualMachinePowerState_Suspended  VirtualMachinePowerState = "suspended"
)

type VirtualMachineAppHeartbeatStatusType string

const (
	VirtualMachineAppHeartbeatStatusType_AppStatusGray  VirtualMachineAppHeartbeatStatusType = "appStatusGray"
	VirtualMachineAppHeartbeatStatusType_AppStatusGreen VirtualMachineAppHeartbeatStatusType = "appStatusGreen"
	VirtualMachineAppHeartbeatStatusType_AppStatusRed   VirtualMachineAppHeartbeatStatusType = "appStatusRed"
)

type VirtualMachineConnectionState string

const (
	VirtualMachineConnectionState_Connected    VirtualMachineConnectionState = "connected"
	VirtualMachineConnectionState_Disconnected VirtualMachineConnectionState = "disconnected"
	VirtualMachineConnectionState_Orphaned     VirtualMachineConnectionState = "orphaned"
	VirtualMachineConnectionState_Inaccessible VirtualMachineConnectionState = "inaccessible"
	VirtualMachineConnectionState_Invalid      VirtualMachineConnectionState = "invalid"
)

type VirtualMachineMovePriority string

const (
	VirtualMachineMovePriority_LowPriority     VirtualMachineMovePriority = "lowPriority"
	VirtualMachineMovePriority_HighPriority    VirtualMachineMovePriority = "highPriority"
	VirtualMachineMovePriority_DefaultPriority VirtualMachineMovePriority = "defaultPriority"
)

type VirtualMachineFaultToleranceState string

const (
	VirtualMachineFaultToleranceState_NotConfigured VirtualMachineFaultToleranceState = "notConfigured"
	VirtualMachineFaultToleranceState_Disabled      VirtualMachineFaultToleranceState = "disabled"
	VirtualMachineFaultToleranceState_Enabled       VirtualMachineFaultToleranceState = "enabled"
	VirtualMachineFaultToleranceState_NeedSecondary VirtualMachineFaultToleranceState = "needSecondary"
	VirtualMachineFaultToleranceState_Starting      VirtualMachineFaultToleranceState = "starting"
	VirtualMachineFaultToleranceState_Running       VirtualMachineFaultToleranceState = "running"
)

type VirtualMachineRecordReplayState string

const (
	VirtualMachineRecordReplayState_Recording VirtualMachineRecordReplayState = "recording"
	VirtualMachineRecordReplayState_Replaying VirtualMachineRecordReplayState = "replaying"
	VirtualMachineRecordReplayState_Inactive  VirtualMachineRecordReplayState = "inactive"
)

type VirtualMachineNeedSecondaryReason string

const (
	VirtualMachineNeedSecondaryReason_Initializing           VirtualMachineNeedSecondaryReason = "initializing"
	VirtualMachineNeedSecondaryReason_Divergence             VirtualMachineNeedSecondaryReason = "divergence"
	VirtualMachineNeedSecondaryReason_LostConnection         VirtualMachineNeedSecondaryReason = "lostConnection"
	VirtualMachineNeedSecondaryReason_PartialHardwareFailure VirtualMachineNeedSecondaryReason = "partialHardwareFailure"
	VirtualMachineNeedSecondaryReason_UserAction             VirtualMachineNeedSecondaryReason = "userAction"
	VirtualMachineNeedSecondaryReason_Other                  VirtualMachineNeedSecondaryReason = "other"
)

type VirtualMachineTicketType string

const (
	VirtualMachineTicketType_Mks          VirtualMachineTicketType = "mks"
	VirtualMachineTicketType_Device       VirtualMachineTicketType = "device"
	VirtualMachineTicketType_GuestControl VirtualMachineTicketType = "guestControl"
)

type ActionParameter string

const (
	ActionParameter_TargetName        ActionParameter = "targetName"
	ActionParameter_AlarmName         ActionParameter = "alarmName"
	ActionParameter_OldStatus         ActionParameter = "oldStatus"
	ActionParameter_NewStatus         ActionParameter = "newStatus"
	ActionParameter_TriggeringSummary ActionParameter = "triggeringSummary"
	ActionParameter_DeclaringSummary  ActionParameter = "declaringSummary"
	ActionParameter_EventDescription  ActionParameter = "eventDescription"
	ActionParameter_Target            ActionParameter = "target"
	ActionParameter_Alarm             ActionParameter = "alarm"
)

type StateAlarmOperator string

const (
	StateAlarmOperator_IsEqual   StateAlarmOperator = "isEqual"
	StateAlarmOperator_IsUnequal StateAlarmOperator = "isUnequal"
)

type EventAlarmExpressionComparisonOperator string

const (
	EventAlarmExpressionComparisonOperator_Equals           EventAlarmExpressionComparisonOperator = "equals"
	EventAlarmExpressionComparisonOperator_NotEqualTo       EventAlarmExpressionComparisonOperator = "notEqualTo"
	EventAlarmExpressionComparisonOperator_StartsWith       EventAlarmExpressionComparisonOperator = "startsWith"
	EventAlarmExpressionComparisonOperator_DoesNotStartWith EventAlarmExpressionComparisonOperator = "doesNotStartWith"
	EventAlarmExpressionComparisonOperator_EndsWith         EventAlarmExpressionComparisonOperator = "endsWith"
	EventAlarmExpressionComparisonOperator_DoesNotEndWith   EventAlarmExpressionComparisonOperator = "doesNotEndWith"
)

type MetricAlarmOperator string

const (
	MetricAlarmOperator_IsAbove MetricAlarmOperator = "isAbove"
	MetricAlarmOperator_IsBelow MetricAlarmOperator = "isBelow"
)

type ActionType string

const (
	ActionType_MigrationV1        ActionType = "MigrationV1"
	ActionType_VmPowerV1          ActionType = "VmPowerV1"
	ActionType_HostPowerV1        ActionType = "HostPowerV1"
	ActionType_HostMaintenanceV1  ActionType = "HostMaintenanceV1"
	ActionType_StorageMigrationV1 ActionType = "StorageMigrationV1"
	ActionType_StoragePlacementV1 ActionType = "StoragePlacementV1"
)

type DrsBehavior string

const (
	DrsBehavior_Manual             DrsBehavior = "manual"
	DrsBehavior_PartiallyAutomated DrsBehavior = "partiallyAutomated"
	DrsBehavior_FullyAutomated     DrsBehavior = "fullyAutomated"
)

type DpmBehavior string

const (
	DpmBehavior_Manual    DpmBehavior = "manual"
	DpmBehavior_Automated DpmBehavior = "automated"
)

type ClusterDasAamNodeStateDasState string

const (
	ClusterDasAamNodeStateDasState_Uninitialized ClusterDasAamNodeStateDasState = "uninitialized"
	ClusterDasAamNodeStateDasState_Initialized   ClusterDasAamNodeStateDasState = "initialized"
	ClusterDasAamNodeStateDasState_Configuring   ClusterDasAamNodeStateDasState = "configuring"
	ClusterDasAamNodeStateDasState_Unconfiguring ClusterDasAamNodeStateDasState = "unconfiguring"
	ClusterDasAamNodeStateDasState_Running       ClusterDasAamNodeStateDasState = "running"
	ClusterDasAamNodeStateDasState_Error         ClusterDasAamNodeStateDasState = "error"
	ClusterDasAamNodeStateDasState_AgentShutdown ClusterDasAamNodeStateDasState = "agentShutdown"
	ClusterDasAamNodeStateDasState_NodeFailed    ClusterDasAamNodeStateDasState = "nodeFailed"
)

type ClusterDasConfigInfoServiceState string

const (
	ClusterDasConfigInfoServiceState_Disabled ClusterDasConfigInfoServiceState = "disabled"
	ClusterDasConfigInfoServiceState_Enabled  ClusterDasConfigInfoServiceState = "enabled"
)

type ClusterDasConfigInfoVmMonitoringState string

const (
	ClusterDasConfigInfoVmMonitoringState_VmMonitoringDisabled ClusterDasConfigInfoVmMonitoringState = "vmMonitoringDisabled"
	ClusterDasConfigInfoVmMonitoringState_VmMonitoringOnly     ClusterDasConfigInfoVmMonitoringState = "vmMonitoringOnly"
	ClusterDasConfigInfoVmMonitoringState_VmAndAppMonitoring   ClusterDasConfigInfoVmMonitoringState = "vmAndAppMonitoring"
)

type ClusterDasConfigInfoHBDatastoreCandidate string

const (
	ClusterDasConfigInfoHBDatastoreCandidate_UserSelectedDs                  ClusterDasConfigInfoHBDatastoreCandidate = "userSelectedDs"
	ClusterDasConfigInfoHBDatastoreCandidate_AllFeasibleDs                   ClusterDasConfigInfoHBDatastoreCandidate = "allFeasibleDs"
	ClusterDasConfigInfoHBDatastoreCandidate_AllFeasibleDsWithUserPreference ClusterDasConfigInfoHBDatastoreCandidate = "allFeasibleDsWithUserPreference"
)

type ClusterDasFdmAvailabilityState string

const (
	ClusterDasFdmAvailabilityState_Uninitialized                ClusterDasFdmAvailabilityState = "uninitialized"
	ClusterDasFdmAvailabilityState_Election                     ClusterDasFdmAvailabilityState = "election"
	ClusterDasFdmAvailabilityState_Master                       ClusterDasFdmAvailabilityState = "master"
	ClusterDasFdmAvailabilityState_ConnectedToMaster            ClusterDasFdmAvailabilityState = "connectedToMaster"
	ClusterDasFdmAvailabilityState_NetworkPartitionedFromMaster ClusterDasFdmAvailabilityState = "networkPartitionedFromMaster"
	ClusterDasFdmAvailabilityState_NetworkIsolated              ClusterDasFdmAvailabilityState = "networkIsolated"
	ClusterDasFdmAvailabilityState_HostDown                     ClusterDasFdmAvailabilityState = "hostDown"
	ClusterDasFdmAvailabilityState_InitializationError          ClusterDasFdmAvailabilityState = "initializationError"
	ClusterDasFdmAvailabilityState_UninitializationError        ClusterDasFdmAvailabilityState = "uninitializationError"
	ClusterDasFdmAvailabilityState_FdmUnreachable               ClusterDasFdmAvailabilityState = "fdmUnreachable"
)

type DasVmPriority string

const (
	DasVmPriority_Disabled DasVmPriority = "disabled"
	DasVmPriority_Low      DasVmPriority = "low"
	DasVmPriority_Medium   DasVmPriority = "medium"
	DasVmPriority_High     DasVmPriority = "high"
)

type ClusterDasVmSettingsRestartPriority string

const (
	ClusterDasVmSettingsRestartPriority_Disabled               ClusterDasVmSettingsRestartPriority = "disabled"
	ClusterDasVmSettingsRestartPriority_Low                    ClusterDasVmSettingsRestartPriority = "low"
	ClusterDasVmSettingsRestartPriority_Medium                 ClusterDasVmSettingsRestartPriority = "medium"
	ClusterDasVmSettingsRestartPriority_High                   ClusterDasVmSettingsRestartPriority = "high"
	ClusterDasVmSettingsRestartPriority_ClusterRestartPriority ClusterDasVmSettingsRestartPriority = "clusterRestartPriority"
)

type ClusterDasVmSettingsIsolationResponse string

const (
	ClusterDasVmSettingsIsolationResponse_None                     ClusterDasVmSettingsIsolationResponse = "none"
	ClusterDasVmSettingsIsolationResponse_PowerOff                 ClusterDasVmSettingsIsolationResponse = "powerOff"
	ClusterDasVmSettingsIsolationResponse_Shutdown                 ClusterDasVmSettingsIsolationResponse = "shutdown"
	ClusterDasVmSettingsIsolationResponse_ClusterIsolationResponse ClusterDasVmSettingsIsolationResponse = "clusterIsolationResponse"
)

type DrsRecommendationReasonCode string

const (
	DrsRecommendationReasonCode_FairnessCpuAvg DrsRecommendationReasonCode = "fairnessCpuAvg"
	DrsRecommendationReasonCode_FairnessMemAvg DrsRecommendationReasonCode = "fairnessMemAvg"
	DrsRecommendationReasonCode_JointAffin     DrsRecommendationReasonCode = "jointAffin"
	DrsRecommendationReasonCode_AntiAffin      DrsRecommendationReasonCode = "antiAffin"
	DrsRecommendationReasonCode_HostMaint      DrsRecommendationReasonCode = "hostMaint"
)

type HostPowerOperationType string

const (
	HostPowerOperationType_PowerOn  HostPowerOperationType = "powerOn"
	HostPowerOperationType_PowerOff HostPowerOperationType = "powerOff"
)

type ClusterPowerOnVmOption string

const (
	ClusterPowerOnVmOption_OverrideAutomationLevel ClusterPowerOnVmOption = "OverrideAutomationLevel"
	ClusterPowerOnVmOption_ReserveResources        ClusterPowerOnVmOption = "ReserveResources"
)

type RecommendationType string

const (
	RecommendationType_V1 RecommendationType = "V1"
)

type RecommendationReasonCode string

const (
	RecommendationReasonCode_FairnessCpuAvg             RecommendationReasonCode = "fairnessCpuAvg"
	RecommendationReasonCode_FairnessMemAvg             RecommendationReasonCode = "fairnessMemAvg"
	RecommendationReasonCode_JointAffin                 RecommendationReasonCode = "jointAffin"
	RecommendationReasonCode_AntiAffin                  RecommendationReasonCode = "antiAffin"
	RecommendationReasonCode_HostMaint                  RecommendationReasonCode = "hostMaint"
	RecommendationReasonCode_EnterStandby               RecommendationReasonCode = "enterStandby"
	RecommendationReasonCode_ReservationCpu             RecommendationReasonCode = "reservationCpu"
	RecommendationReasonCode_ReservationMem             RecommendationReasonCode = "reservationMem"
	RecommendationReasonCode_PowerOnVm                  RecommendationReasonCode = "powerOnVm"
	RecommendationReasonCode_PowerSaving                RecommendationReasonCode = "powerSaving"
	RecommendationReasonCode_IncreaseCapacity           RecommendationReasonCode = "increaseCapacity"
	RecommendationReasonCode_CheckResource              RecommendationReasonCode = "checkResource"
	RecommendationReasonCode_UnreservedCapacity         RecommendationReasonCode = "unreservedCapacity"
	RecommendationReasonCode_VmHostHardAffinity         RecommendationReasonCode = "vmHostHardAffinity"
	RecommendationReasonCode_VmHostSoftAffinity         RecommendationReasonCode = "vmHostSoftAffinity"
	RecommendationReasonCode_BalanceDatastoreSpaceUsage RecommendationReasonCode = "balanceDatastoreSpaceUsage"
	RecommendationReasonCode_BalanceDatastoreIOLoad     RecommendationReasonCode = "balanceDatastoreIOLoad"
	RecommendationReasonCode_DatastoreMaint             RecommendationReasonCode = "datastoreMaint"
	RecommendationReasonCode_VirtualDiskJointAffin      RecommendationReasonCode = "virtualDiskJointAffin"
	RecommendationReasonCode_VirtualDiskAntiAffin       RecommendationReasonCode = "virtualDiskAntiAffin"
	RecommendationReasonCode_DatastoreSpaceOutage       RecommendationReasonCode = "datastoreSpaceOutage"
	RecommendationReasonCode_StoragePlacement           RecommendationReasonCode = "storagePlacement"
	RecommendationReasonCode_IolbDisabledInternal       RecommendationReasonCode = "iolbDisabledInternal"
)

type DvsFilterOnFailure string

const (
	DvsFilterOnFailure_FailOpen   DvsFilterOnFailure = "failOpen"
	DvsFilterOnFailure_FailClosed DvsFilterOnFailure = "failClosed"
)

type DVPortStatusVmDirectPathGen2InactiveReasonNetwork string

const (
	DVPortStatusVmDirectPathGen2InactiveReasonNetwork_PortNptIncompatibleDvs             DVPortStatusVmDirectPathGen2InactiveReasonNetwork = "portNptIncompatibleDvs"
	DVPortStatusVmDirectPathGen2InactiveReasonNetwork_PortNptNoCompatibleNics            DVPortStatusVmDirectPathGen2InactiveReasonNetwork = "portNptNoCompatibleNics"
	DVPortStatusVmDirectPathGen2InactiveReasonNetwork_PortNptNoVirtualFunctionsAvailable DVPortStatusVmDirectPathGen2InactiveReasonNetwork = "portNptNoVirtualFunctionsAvailable"
	DVPortStatusVmDirectPathGen2InactiveReasonNetwork_PortNptDisabledForPort             DVPortStatusVmDirectPathGen2InactiveReasonNetwork = "portNptDisabledForPort"
)

type DVPortStatusVmDirectPathGen2InactiveReasonOther string

const (
	DVPortStatusVmDirectPathGen2InactiveReasonOther_PortNptIncompatibleHost      DVPortStatusVmDirectPathGen2InactiveReasonOther = "portNptIncompatibleHost"
	DVPortStatusVmDirectPathGen2InactiveReasonOther_PortNptIncompatibleConnectee DVPortStatusVmDirectPathGen2InactiveReasonOther = "portNptIncompatibleConnectee"
)

type DistributedVirtualPortgroupPortgroupType string

const (
	DistributedVirtualPortgroupPortgroupType_EarlyBinding DistributedVirtualPortgroupPortgroupType = "earlyBinding"
	DistributedVirtualPortgroupPortgroupType_LateBinding  DistributedVirtualPortgroupPortgroupType = "lateBinding"
	DistributedVirtualPortgroupPortgroupType_Ephemeral    DistributedVirtualPortgroupPortgroupType = "ephemeral"
)

type DistributedVirtualPortgroupMetaTagName string

const (
	DistributedVirtualPortgroupMetaTagName_DvsName       DistributedVirtualPortgroupMetaTagName = "dvsName"
	DistributedVirtualPortgroupMetaTagName_PortgroupName DistributedVirtualPortgroupMetaTagName = "portgroupName"
	DistributedVirtualPortgroupMetaTagName_PortIndex     DistributedVirtualPortgroupMetaTagName = "portIndex"
)

type EntityType string

const (
	EntityType_DistributedVirtualSwitch    EntityType = "distributedVirtualSwitch"
	EntityType_DistributedVirtualPortgroup EntityType = "distributedVirtualPortgroup"
)

type EntityImportType string

const (
	EntityImportType_CreateEntityWithNewIdentifier      EntityImportType = "createEntityWithNewIdentifier"
	EntityImportType_CreateEntityWithOriginalIdentifier EntityImportType = "createEntityWithOriginalIdentifier"
	EntityImportType_ApplyToEntitySpecified             EntityImportType = "applyToEntitySpecified"
)

type DistributedVirtualSwitchHostMemberHostComponentState string

const (
	DistributedVirtualSwitchHostMemberHostComponentState_Up           DistributedVirtualSwitchHostMemberHostComponentState = "up"
	DistributedVirtualSwitchHostMemberHostComponentState_Pending      DistributedVirtualSwitchHostMemberHostComponentState = "pending"
	DistributedVirtualSwitchHostMemberHostComponentState_OutOfSync    DistributedVirtualSwitchHostMemberHostComponentState = "outOfSync"
	DistributedVirtualSwitchHostMemberHostComponentState_Warning      DistributedVirtualSwitchHostMemberHostComponentState = "warning"
	DistributedVirtualSwitchHostMemberHostComponentState_Disconnected DistributedVirtualSwitchHostMemberHostComponentState = "disconnected"
	DistributedVirtualSwitchHostMemberHostComponentState_Down         DistributedVirtualSwitchHostMemberHostComponentState = "down"
)

type DistributedVirtualSwitchPortConnecteeConnecteeType string

const (
	DistributedVirtualSwitchPortConnecteeConnecteeType_Pnic            DistributedVirtualSwitchPortConnecteeConnecteeType = "pnic"
	DistributedVirtualSwitchPortConnecteeConnecteeType_VmVnic          DistributedVirtualSwitchPortConnecteeConnecteeType = "vmVnic"
	DistributedVirtualSwitchPortConnecteeConnecteeType_HostConsoleVnic DistributedVirtualSwitchPortConnecteeConnecteeType = "hostConsoleVnic"
	DistributedVirtualSwitchPortConnecteeConnecteeType_HostVmkVnic     DistributedVirtualSwitchPortConnecteeConnecteeType = "hostVmkVnic"
)

type DvsNetworkRuleDirectionType string

const (
	DvsNetworkRuleDirectionType_IncomingPackets DvsNetworkRuleDirectionType = "incomingPackets"
	DvsNetworkRuleDirectionType_OutgoingPackets DvsNetworkRuleDirectionType = "outgoingPackets"
	DvsNetworkRuleDirectionType_Both            DvsNetworkRuleDirectionType = "both"
)

type VmwareDistributedVirtualSwitchPvlanPortType string

const (
	VmwareDistributedVirtualSwitchPvlanPortType_Promiscuous VmwareDistributedVirtualSwitchPvlanPortType = "promiscuous"
	VmwareDistributedVirtualSwitchPvlanPortType_Isolated    VmwareDistributedVirtualSwitchPvlanPortType = "isolated"
	VmwareDistributedVirtualSwitchPvlanPortType_Community   VmwareDistributedVirtualSwitchPvlanPortType = "community"
)

type VMwareDVSVspanSessionType string

const (
	VMwareDVSVspanSessionType_MixedDestMirror                VMwareDVSVspanSessionType = "mixedDestMirror"
	VMwareDVSVspanSessionType_DvPortMirror                   VMwareDVSVspanSessionType = "dvPortMirror"
	VMwareDVSVspanSessionType_RemoteMirrorSource             VMwareDVSVspanSessionType = "remoteMirrorSource"
	VMwareDVSVspanSessionType_RemoteMirrorDest               VMwareDVSVspanSessionType = "remoteMirrorDest"
	VMwareDVSVspanSessionType_EncapsulatedRemoteMirrorSource VMwareDVSVspanSessionType = "encapsulatedRemoteMirrorSource"
)

type VMwareDVSTeamingMatchStatus string

const (
	VMwareDVSTeamingMatchStatus_IphashMatch       VMwareDVSTeamingMatchStatus = "iphashMatch"
	VMwareDVSTeamingMatchStatus_NonIphashMatch    VMwareDVSTeamingMatchStatus = "nonIphashMatch"
	VMwareDVSTeamingMatchStatus_IphashMismatch    VMwareDVSTeamingMatchStatus = "iphashMismatch"
	VMwareDVSTeamingMatchStatus_NonIphashMismatch VMwareDVSTeamingMatchStatus = "nonIphashMismatch"
)

type VMwareUplinkLacpMode string

const (
	VMwareUplinkLacpMode_Active  VMwareUplinkLacpMode = "active"
	VMwareUplinkLacpMode_Passive VMwareUplinkLacpMode = "passive"
)

type VMwareDvsLacpLoadBalanceAlgorithm string

const (
	VMwareDvsLacpLoadBalanceAlgorithm_SrcMac                  VMwareDvsLacpLoadBalanceAlgorithm = "srcMac"
	VMwareDvsLacpLoadBalanceAlgorithm_DestMac                 VMwareDvsLacpLoadBalanceAlgorithm = "destMac"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcDestMac              VMwareDvsLacpLoadBalanceAlgorithm = "srcDestMac"
	VMwareDvsLacpLoadBalanceAlgorithm_DestIpVlan              VMwareDvsLacpLoadBalanceAlgorithm = "destIpVlan"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcIpVlan               VMwareDvsLacpLoadBalanceAlgorithm = "srcIpVlan"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcDestIpVlan           VMwareDvsLacpLoadBalanceAlgorithm = "srcDestIpVlan"
	VMwareDvsLacpLoadBalanceAlgorithm_DestTcpUdpPort          VMwareDvsLacpLoadBalanceAlgorithm = "destTcpUdpPort"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcTcpUdpPort           VMwareDvsLacpLoadBalanceAlgorithm = "srcTcpUdpPort"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcDestTcpUdpPort       VMwareDvsLacpLoadBalanceAlgorithm = "srcDestTcpUdpPort"
	VMwareDvsLacpLoadBalanceAlgorithm_DestIpTcpUdpPort        VMwareDvsLacpLoadBalanceAlgorithm = "destIpTcpUdpPort"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcIpTcpUdpPort         VMwareDvsLacpLoadBalanceAlgorithm = "srcIpTcpUdpPort"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcDestIpTcpUdpPort     VMwareDvsLacpLoadBalanceAlgorithm = "srcDestIpTcpUdpPort"
	VMwareDvsLacpLoadBalanceAlgorithm_DestIpTcpUdpPortVlan    VMwareDvsLacpLoadBalanceAlgorithm = "destIpTcpUdpPortVlan"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcIpTcpUdpPortVlan     VMwareDvsLacpLoadBalanceAlgorithm = "srcIpTcpUdpPortVlan"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcDestIpTcpUdpPortVlan VMwareDvsLacpLoadBalanceAlgorithm = "srcDestIpTcpUdpPortVlan"
	VMwareDvsLacpLoadBalanceAlgorithm_DestIp                  VMwareDvsLacpLoadBalanceAlgorithm = "destIp"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcIp                   VMwareDvsLacpLoadBalanceAlgorithm = "srcIp"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcDestIp               VMwareDvsLacpLoadBalanceAlgorithm = "srcDestIp"
	VMwareDvsLacpLoadBalanceAlgorithm_Vlan                    VMwareDvsLacpLoadBalanceAlgorithm = "vlan"
	VMwareDvsLacpLoadBalanceAlgorithm_SrcPortId               VMwareDvsLacpLoadBalanceAlgorithm = "srcPortId"
)

type VMwareDvsLacpApiVersion string

const (
	VMwareDvsLacpApiVersion_SingleLag   VMwareDvsLacpApiVersion = "singleLag"
	VMwareDvsLacpApiVersion_MultipleLag VMwareDvsLacpApiVersion = "multipleLag"
)

type EventEventSeverity string

const (
	EventEventSeverity_Error   EventEventSeverity = "error"
	EventEventSeverity_Warning EventEventSeverity = "warning"
	EventEventSeverity_Info    EventEventSeverity = "info"
	EventEventSeverity_User    EventEventSeverity = "user"
)

type HostDisconnectedEventReasonCode string

const (
	HostDisconnectedEventReasonCode_SslThumbprintVerifyFailed HostDisconnectedEventReasonCode = "sslThumbprintVerifyFailed"
	HostDisconnectedEventReasonCode_LicenseExpired            HostDisconnectedEventReasonCode = "licenseExpired"
	HostDisconnectedEventReasonCode_AgentUpgrade              HostDisconnectedEventReasonCode = "agentUpgrade"
	HostDisconnectedEventReasonCode_UserRequest               HostDisconnectedEventReasonCode = "userRequest"
	HostDisconnectedEventReasonCode_InsufficientLicenses      HostDisconnectedEventReasonCode = "insufficientLicenses"
	HostDisconnectedEventReasonCode_AgentOutOfDate            HostDisconnectedEventReasonCode = "agentOutOfDate"
	HostDisconnectedEventReasonCode_PasswordDecryptFailure    HostDisconnectedEventReasonCode = "passwordDecryptFailure"
	HostDisconnectedEventReasonCode_Unknown                   HostDisconnectedEventReasonCode = "unknown"
	HostDisconnectedEventReasonCode_VcVRAMCapacityExceeded    HostDisconnectedEventReasonCode = "vcVRAMCapacityExceeded"
)

type HostDasErrorEventHostDasErrorReason string

const (
	HostDasErrorEventHostDasErrorReason_ConfigFailed               HostDasErrorEventHostDasErrorReason = "configFailed"
	HostDasErrorEventHostDasErrorReason_Timeout                    HostDasErrorEventHostDasErrorReason = "timeout"
	HostDasErrorEventHostDasErrorReason_CommunicationInitFailed    HostDasErrorEventHostDasErrorReason = "communicationInitFailed"
	HostDasErrorEventHostDasErrorReason_HealthCheckScriptFailed    HostDasErrorEventHostDasErrorReason = "healthCheckScriptFailed"
	HostDasErrorEventHostDasErrorReason_AgentFailed                HostDasErrorEventHostDasErrorReason = "agentFailed"
	HostDasErrorEventHostDasErrorReason_AgentShutdown              HostDasErrorEventHostDasErrorReason = "agentShutdown"
	HostDasErrorEventHostDasErrorReason_IsolationAddressUnpingable HostDasErrorEventHostDasErrorReason = "isolationAddressUnpingable"
	HostDasErrorEventHostDasErrorReason_Other                      HostDasErrorEventHostDasErrorReason = "other"
)

type VmShutdownOnIsolationEventOperation string

const (
	VmShutdownOnIsolationEventOperation_Shutdown   VmShutdownOnIsolationEventOperation = "shutdown"
	VmShutdownOnIsolationEventOperation_PoweredOff VmShutdownOnIsolationEventOperation = "poweredOff"
)

type VmDasBeingResetEventReasonCode string

const (
	VmDasBeingResetEventReasonCode_VmtoolsHeartbeatFailure  VmDasBeingResetEventReasonCode = "vmtoolsHeartbeatFailure"
	VmDasBeingResetEventReasonCode_AppHeartbeatFailure      VmDasBeingResetEventReasonCode = "appHeartbeatFailure"
	VmDasBeingResetEventReasonCode_AppImmediateResetRequest VmDasBeingResetEventReasonCode = "appImmediateResetRequest"
)

type VmFailedStartingSecondaryEventFailureReason string

const (
	VmFailedStartingSecondaryEventFailureReason_IncompatibleHost VmFailedStartingSecondaryEventFailureReason = "incompatibleHost"
	VmFailedStartingSecondaryEventFailureReason_LoginFailed      VmFailedStartingSecondaryEventFailureReason = "loginFailed"
	VmFailedStartingSecondaryEventFailureReason_RegisterVmFailed VmFailedStartingSecondaryEventFailureReason = "registerVmFailed"
	VmFailedStartingSecondaryEventFailureReason_MigrateFailed    VmFailedStartingSecondaryEventFailureReason = "migrateFailed"
)

type EventCategory string

const (
	EventCategory_Info    EventCategory = "info"
	EventCategory_Warning EventCategory = "warning"
	EventCategory_Error   EventCategory = "error"
	EventCategory_User    EventCategory = "user"
)

type EventFilterSpecRecursionOption string

const (
	EventFilterSpecRecursionOption_Self     EventFilterSpecRecursionOption = "self"
	EventFilterSpecRecursionOption_Children EventFilterSpecRecursionOption = "children"
	EventFilterSpecRecursionOption_All      EventFilterSpecRecursionOption = "all"
)

type AffinityType string

const (
	AffinityType_Memory AffinityType = "memory"
	AffinityType_Cpu    AffinityType = "cpu"
)

type AgentInstallFailedReason string

const (
	AgentInstallFailedReason_NotEnoughSpaceOnDevice      AgentInstallFailedReason = "NotEnoughSpaceOnDevice"
	AgentInstallFailedReason_PrepareToUpgradeFailed      AgentInstallFailedReason = "PrepareToUpgradeFailed"
	AgentInstallFailedReason_AgentNotRunning             AgentInstallFailedReason = "AgentNotRunning"
	AgentInstallFailedReason_AgentNotReachable           AgentInstallFailedReason = "AgentNotReachable"
	AgentInstallFailedReason_InstallTimedout             AgentInstallFailedReason = "InstallTimedout"
	AgentInstallFailedReason_SignatureVerificationFailed AgentInstallFailedReason = "SignatureVerificationFailed"
	AgentInstallFailedReason_AgentUploadFailed           AgentInstallFailedReason = "AgentUploadFailed"
	AgentInstallFailedReason_AgentUploadTimedout         AgentInstallFailedReason = "AgentUploadTimedout"
	AgentInstallFailedReason_UnknownInstallerError       AgentInstallFailedReason = "UnknownInstallerError"
)

type CannotMoveFaultToleranceVmMoveType string

const (
	CannotMoveFaultToleranceVmMoveType_ResourcePool CannotMoveFaultToleranceVmMoveType = "resourcePool"
	CannotMoveFaultToleranceVmMoveType_Cluster      CannotMoveFaultToleranceVmMoveType = "cluster"
)

type CannotPowerOffVmInClusterOperation string

const (
	CannotPowerOffVmInClusterOperation_Suspend       CannotPowerOffVmInClusterOperation = "suspend"
	CannotPowerOffVmInClusterOperation_PowerOff      CannotPowerOffVmInClusterOperation = "powerOff"
	CannotPowerOffVmInClusterOperation_GuestShutdown CannotPowerOffVmInClusterOperation = "guestShutdown"
	CannotPowerOffVmInClusterOperation_GuestSuspend  CannotPowerOffVmInClusterOperation = "guestSuspend"
)

type CannotUseNetworkReason string

const (
	CannotUseNetworkReason_NetworkReservationNotSupported  CannotUseNetworkReason = "NetworkReservationNotSupported"
	CannotUseNetworkReason_MismatchedNetworkPolicies       CannotUseNetworkReason = "MismatchedNetworkPolicies"
	CannotUseNetworkReason_MismatchedDvsVersionOrVendor    CannotUseNetworkReason = "MismatchedDvsVersionOrVendor"
	CannotUseNetworkReason_VMotionToUnsupportedNetworkType CannotUseNetworkReason = "VMotionToUnsupportedNetworkType"
)

type DasConfigFaultDasConfigFaultReason string

const (
	DasConfigFaultDasConfigFaultReason_HostNetworkMisconfiguration DasConfigFaultDasConfigFaultReason = "HostNetworkMisconfiguration"
	DasConfigFaultDasConfigFaultReason_HostMisconfiguration        DasConfigFaultDasConfigFaultReason = "HostMisconfiguration"
	DasConfigFaultDasConfigFaultReason_InsufficientPrivileges      DasConfigFaultDasConfigFaultReason = "InsufficientPrivileges"
	DasConfigFaultDasConfigFaultReason_NoPrimaryAgentAvailable     DasConfigFaultDasConfigFaultReason = "NoPrimaryAgentAvailable"
	DasConfigFaultDasConfigFaultReason_Other                       DasConfigFaultDasConfigFaultReason = "Other"
	DasConfigFaultDasConfigFaultReason_NoDatastoresConfigured      DasConfigFaultDasConfigFaultReason = "NoDatastoresConfigured"
	DasConfigFaultDasConfigFaultReason_VSanNotSupportedOnHost      DasConfigFaultDasConfigFaultReason = "VSanNotSupportedOnHost"
)

type DeviceNotSupportedReason string

const (
	DeviceNotSupportedReason_Host  DeviceNotSupportedReason = "host"
	DeviceNotSupportedReason_Guest DeviceNotSupportedReason = "guest"
)

type DisallowedChangeByServiceDisallowedChange string

const (
	DisallowedChangeByServiceDisallowedChange_HotExtendDisk DisallowedChangeByServiceDisallowedChange = "hotExtendDisk"
)

type FtIssuesOnHostHostSelectionType string

const (
	FtIssuesOnHostHostSelectionType_User FtIssuesOnHostHostSelectionType = "user"
	FtIssuesOnHostHostSelectionType_Vc   FtIssuesOnHostHostSelectionType = "vc"
	FtIssuesOnHostHostSelectionType_Drs  FtIssuesOnHostHostSelectionType = "drs"
)

type HostIncompatibleForFaultToleranceReason string

const (
	HostIncompatibleForFaultToleranceReason_Product   HostIncompatibleForFaultToleranceReason = "product"
	HostIncompatibleForFaultToleranceReason_Processor HostIncompatibleForFaultToleranceReason = "processor"
)

type HostIncompatibleForRecordReplayReason string

const (
	HostIncompatibleForRecordReplayReason_Product   HostIncompatibleForRecordReplayReason = "product"
	HostIncompatibleForRecordReplayReason_Processor HostIncompatibleForRecordReplayReason = "processor"
)

type InvalidDasConfigArgumentEntryForInvalidArgument string

const (
	InvalidDasConfigArgumentEntryForInvalidArgument_AdmissionControl InvalidDasConfigArgumentEntryForInvalidArgument = "admissionControl"
	InvalidDasConfigArgumentEntryForInvalidArgument_UserHeartbeatDs  InvalidDasConfigArgumentEntryForInvalidArgument = "userHeartbeatDs"
	InvalidDasConfigArgumentEntryForInvalidArgument_VmConfig         InvalidDasConfigArgumentEntryForInvalidArgument = "vmConfig"
)

type InvalidProfileReferenceHostReason string

const (
	InvalidProfileReferenceHostReason_IncompatibleVersion  InvalidProfileReferenceHostReason = "incompatibleVersion"
	InvalidProfileReferenceHostReason_MissingReferenceHost InvalidProfileReferenceHostReason = "missingReferenceHost"
)

type LicenseAssignmentFailedReason string

const (
	LicenseAssignmentFailedReason_KeyEntityMismatch                                    LicenseAssignmentFailedReason = "keyEntityMismatch"
	LicenseAssignmentFailedReason_DowngradeDisallowed                                  LicenseAssignmentFailedReason = "downgradeDisallowed"
	LicenseAssignmentFailedReason_InventoryNotManageableByVirtualCenter                LicenseAssignmentFailedReason = "inventoryNotManageableByVirtualCenter"
	LicenseAssignmentFailedReason_HostsUnmanageableByVirtualCenterWithoutLicenseServer LicenseAssignmentFailedReason = "hostsUnmanageableByVirtualCenterWithoutLicenseServer"
)

type NotSupportedDeviceForFTDeviceType string

const (
	NotSupportedDeviceForFTDeviceType_VirtualVmxnet3            NotSupportedDeviceForFTDeviceType = "virtualVmxnet3"
	NotSupportedDeviceForFTDeviceType_ParaVirtualSCSIController NotSupportedDeviceForFTDeviceType = "paraVirtualSCSIController"
)

type NumVirtualCpusIncompatibleReason string

const (
	NumVirtualCpusIncompatibleReason_RecordReplay   NumVirtualCpusIncompatibleReason = "recordReplay"
	NumVirtualCpusIncompatibleReason_FaultTolerance NumVirtualCpusIncompatibleReason = "faultTolerance"
)

type ReplicationDiskConfigFaultReasonForFault string

const (
	ReplicationDiskConfigFaultReasonForFault_DiskNotFound                           ReplicationDiskConfigFaultReasonForFault = "diskNotFound"
	ReplicationDiskConfigFaultReasonForFault_DiskTypeNotSupported                   ReplicationDiskConfigFaultReasonForFault = "diskTypeNotSupported"
	ReplicationDiskConfigFaultReasonForFault_InvalidDiskKey                         ReplicationDiskConfigFaultReasonForFault = "invalidDiskKey"
	ReplicationDiskConfigFaultReasonForFault_InvalidDiskReplicationId               ReplicationDiskConfigFaultReasonForFault = "invalidDiskReplicationId"
	ReplicationDiskConfigFaultReasonForFault_DuplicateDiskReplicationId             ReplicationDiskConfigFaultReasonForFault = "duplicateDiskReplicationId"
	ReplicationDiskConfigFaultReasonForFault_InvalidPersistentFilePath              ReplicationDiskConfigFaultReasonForFault = "invalidPersistentFilePath"
	ReplicationDiskConfigFaultReasonForFault_ReconfigureDiskReplicationIdNotAllowed ReplicationDiskConfigFaultReasonForFault = "reconfigureDiskReplicationIdNotAllowed"
)

type ReplicationVmConfigFaultReasonForFault string

const (
	ReplicationVmConfigFaultReasonForFault_IncompatibleHwVersion                    ReplicationVmConfigFaultReasonForFault = "incompatibleHwVersion"
	ReplicationVmConfigFaultReasonForFault_InvalidVmReplicationId                   ReplicationVmConfigFaultReasonForFault = "invalidVmReplicationId"
	ReplicationVmConfigFaultReasonForFault_InvalidGenerationNumber                  ReplicationVmConfigFaultReasonForFault = "invalidGenerationNumber"
	ReplicationVmConfigFaultReasonForFault_OutOfBoundsRpoValue                      ReplicationVmConfigFaultReasonForFault = "outOfBoundsRpoValue"
	ReplicationVmConfigFaultReasonForFault_InvalidDestinationIpAddress              ReplicationVmConfigFaultReasonForFault = "invalidDestinationIpAddress"
	ReplicationVmConfigFaultReasonForFault_InvalidDestinationPort                   ReplicationVmConfigFaultReasonForFault = "invalidDestinationPort"
	ReplicationVmConfigFaultReasonForFault_InvalidExtraVmOptions                    ReplicationVmConfigFaultReasonForFault = "invalidExtraVmOptions"
	ReplicationVmConfigFaultReasonForFault_StaleGenerationNumber                    ReplicationVmConfigFaultReasonForFault = "staleGenerationNumber"
	ReplicationVmConfigFaultReasonForFault_ReconfigureVmReplicationIdNotAllowed     ReplicationVmConfigFaultReasonForFault = "reconfigureVmReplicationIdNotAllowed"
	ReplicationVmConfigFaultReasonForFault_CannotRetrieveVmReplicationConfiguration ReplicationVmConfigFaultReasonForFault = "cannotRetrieveVmReplicationConfiguration"
	ReplicationVmConfigFaultReasonForFault_ReplicationAlreadyEnabled                ReplicationVmConfigFaultReasonForFault = "replicationAlreadyEnabled"
	ReplicationVmConfigFaultReasonForFault_InvalidPriorConfiguration                ReplicationVmConfigFaultReasonForFault = "invalidPriorConfiguration"
	ReplicationVmConfigFaultReasonForFault_ReplicationNotEnabled                    ReplicationVmConfigFaultReasonForFault = "replicationNotEnabled"
	ReplicationVmConfigFaultReasonForFault_ReplicationConfigurationFailed           ReplicationVmConfigFaultReasonForFault = "replicationConfigurationFailed"
)

type ReplicationVmFaultReasonForFault string

const (
	ReplicationVmFaultReasonForFault_NotConfigured      ReplicationVmFaultReasonForFault = "notConfigured"
	ReplicationVmFaultReasonForFault_PoweredOff         ReplicationVmFaultReasonForFault = "poweredOff"
	ReplicationVmFaultReasonForFault_Suspended          ReplicationVmFaultReasonForFault = "suspended"
	ReplicationVmFaultReasonForFault_PoweredOn          ReplicationVmFaultReasonForFault = "poweredOn"
	ReplicationVmFaultReasonForFault_OfflineReplicating ReplicationVmFaultReasonForFault = "offlineReplicating"
	ReplicationVmFaultReasonForFault_InvalidState       ReplicationVmFaultReasonForFault = "invalidState"
	ReplicationVmFaultReasonForFault_InvalidInstanceId  ReplicationVmFaultReasonForFault = "invalidInstanceId"
)

type ThirdPartyLicenseAssignmentFailedReason string

const (
	ThirdPartyLicenseAssignmentFailedReason_LicenseAssignmentFailed ThirdPartyLicenseAssignmentFailedReason = "licenseAssignmentFailed"
	ThirdPartyLicenseAssignmentFailedReason_ModuleNotInstalled      ThirdPartyLicenseAssignmentFailedReason = "moduleNotInstalled"
)

type VFlashModuleNotSupportedReason string

const (
	VFlashModuleNotSupportedReason_CacheModeNotSupported            VFlashModuleNotSupportedReason = "CacheModeNotSupported"
	VFlashModuleNotSupportedReason_CacheConsistencyTypeNotSupported VFlashModuleNotSupportedReason = "CacheConsistencyTypeNotSupported"
	VFlashModuleNotSupportedReason_CacheBlockSizeNotSupported       VFlashModuleNotSupportedReason = "CacheBlockSizeNotSupported"
	VFlashModuleNotSupportedReason_CacheReservationNotSupported     VFlashModuleNotSupportedReason = "CacheReservationNotSupported"
	VFlashModuleNotSupportedReason_DiskSizeNotSupported             VFlashModuleNotSupportedReason = "DiskSizeNotSupported"
)

type VmFaultToleranceConfigIssueReasonForIssue string

const (
	VmFaultToleranceConfigIssueReasonForIssue_HaNotEnabled                   VmFaultToleranceConfigIssueReasonForIssue = "haNotEnabled"
	VmFaultToleranceConfigIssueReasonForIssue_MoreThanOneSecondary           VmFaultToleranceConfigIssueReasonForIssue = "moreThanOneSecondary"
	VmFaultToleranceConfigIssueReasonForIssue_RecordReplayNotSupported       VmFaultToleranceConfigIssueReasonForIssue = "recordReplayNotSupported"
	VmFaultToleranceConfigIssueReasonForIssue_ReplayNotSupported             VmFaultToleranceConfigIssueReasonForIssue = "replayNotSupported"
	VmFaultToleranceConfigIssueReasonForIssue_TemplateVm                     VmFaultToleranceConfigIssueReasonForIssue = "templateVm"
	VmFaultToleranceConfigIssueReasonForIssue_MultipleVCPU                   VmFaultToleranceConfigIssueReasonForIssue = "multipleVCPU"
	VmFaultToleranceConfigIssueReasonForIssue_HostInactive                   VmFaultToleranceConfigIssueReasonForIssue = "hostInactive"
	VmFaultToleranceConfigIssueReasonForIssue_FtUnsupportedHardware          VmFaultToleranceConfigIssueReasonForIssue = "ftUnsupportedHardware"
	VmFaultToleranceConfigIssueReasonForIssue_FtUnsupportedProduct           VmFaultToleranceConfigIssueReasonForIssue = "ftUnsupportedProduct"
	VmFaultToleranceConfigIssueReasonForIssue_MissingVMotionNic              VmFaultToleranceConfigIssueReasonForIssue = "missingVMotionNic"
	VmFaultToleranceConfigIssueReasonForIssue_MissingFTLoggingNic            VmFaultToleranceConfigIssueReasonForIssue = "missingFTLoggingNic"
	VmFaultToleranceConfigIssueReasonForIssue_ThinDisk                       VmFaultToleranceConfigIssueReasonForIssue = "thinDisk"
	VmFaultToleranceConfigIssueReasonForIssue_VerifySSLCertificateFlagNotSet VmFaultToleranceConfigIssueReasonForIssue = "verifySSLCertificateFlagNotSet"
	VmFaultToleranceConfigIssueReasonForIssue_HasSnapshots                   VmFaultToleranceConfigIssueReasonForIssue = "hasSnapshots"
	VmFaultToleranceConfigIssueReasonForIssue_NoConfig                       VmFaultToleranceConfigIssueReasonForIssue = "noConfig"
	VmFaultToleranceConfigIssueReasonForIssue_FtSecondaryVm                  VmFaultToleranceConfigIssueReasonForIssue = "ftSecondaryVm"
	VmFaultToleranceConfigIssueReasonForIssue_HasLocalDisk                   VmFaultToleranceConfigIssueReasonForIssue = "hasLocalDisk"
	VmFaultToleranceConfigIssueReasonForIssue_EsxAgentVm                     VmFaultToleranceConfigIssueReasonForIssue = "esxAgentVm"
	VmFaultToleranceConfigIssueReasonForIssue_Video3dEnabled                 VmFaultToleranceConfigIssueReasonForIssue = "video3dEnabled"
	VmFaultToleranceConfigIssueReasonForIssue_HasUnsupportedDisk             VmFaultToleranceConfigIssueReasonForIssue = "hasUnsupportedDisk"
	VmFaultToleranceConfigIssueReasonForIssue_HasNestedHVConfiguration       VmFaultToleranceConfigIssueReasonForIssue = "hasNestedHVConfiguration"
	VmFaultToleranceConfigIssueReasonForIssue_HasVFlashConfiguration         VmFaultToleranceConfigIssueReasonForIssue = "hasVFlashConfiguration"
)

type VmFaultToleranceInvalidFileBackingDeviceType string

const (
	VmFaultToleranceInvalidFileBackingDeviceType_VirtualFloppy       VmFaultToleranceInvalidFileBackingDeviceType = "virtualFloppy"
	VmFaultToleranceInvalidFileBackingDeviceType_VirtualCdrom        VmFaultToleranceInvalidFileBackingDeviceType = "virtualCdrom"
	VmFaultToleranceInvalidFileBackingDeviceType_VirtualSerialPort   VmFaultToleranceInvalidFileBackingDeviceType = "virtualSerialPort"
	VmFaultToleranceInvalidFileBackingDeviceType_VirtualParallelPort VmFaultToleranceInvalidFileBackingDeviceType = "virtualParallelPort"
	VmFaultToleranceInvalidFileBackingDeviceType_VirtualDisk         VmFaultToleranceInvalidFileBackingDeviceType = "virtualDisk"
)

type WillLoseHAProtectionResolution string

const (
	WillLoseHAProtectionResolution_Svmotion WillLoseHAProtectionResolution = "svmotion"
	WillLoseHAProtectionResolution_Relocate WillLoseHAProtectionResolution = "relocate"
)

type HostActiveDirectoryInfoDomainMembershipStatus string

const (
	HostActiveDirectoryInfoDomainMembershipStatus_Unknown           HostActiveDirectoryInfoDomainMembershipStatus = "unknown"
	HostActiveDirectoryInfoDomainMembershipStatus_Ok                HostActiveDirectoryInfoDomainMembershipStatus = "ok"
	HostActiveDirectoryInfoDomainMembershipStatus_NoServers         HostActiveDirectoryInfoDomainMembershipStatus = "noServers"
	HostActiveDirectoryInfoDomainMembershipStatus_ClientTrustBroken HostActiveDirectoryInfoDomainMembershipStatus = "clientTrustBroken"
	HostActiveDirectoryInfoDomainMembershipStatus_ServerTrustBroken HostActiveDirectoryInfoDomainMembershipStatus = "serverTrustBroken"
	HostActiveDirectoryInfoDomainMembershipStatus_InconsistentTrust HostActiveDirectoryInfoDomainMembershipStatus = "inconsistentTrust"
	HostActiveDirectoryInfoDomainMembershipStatus_OtherProblem      HostActiveDirectoryInfoDomainMembershipStatus = "otherProblem"
)

type AutoStartAction string

const (
	AutoStartAction_None          AutoStartAction = "none"
	AutoStartAction_SystemDefault AutoStartAction = "systemDefault"
	AutoStartAction_PowerOn       AutoStartAction = "powerOn"
	AutoStartAction_PowerOff      AutoStartAction = "powerOff"
	AutoStartAction_GuestShutdown AutoStartAction = "guestShutdown"
	AutoStartAction_Suspend       AutoStartAction = "suspend"
)

type AutoStartWaitHeartbeatSetting string

const (
	AutoStartWaitHeartbeatSetting_Yes           AutoStartWaitHeartbeatSetting = "yes"
	AutoStartWaitHeartbeatSetting_No            AutoStartWaitHeartbeatSetting = "no"
	AutoStartWaitHeartbeatSetting_SystemDefault AutoStartWaitHeartbeatSetting = "systemDefault"
)

type HostReplayUnsupportedReason string

const (
	HostReplayUnsupportedReason_IncompatibleProduct HostReplayUnsupportedReason = "incompatibleProduct"
	HostReplayUnsupportedReason_IncompatibleCpu     HostReplayUnsupportedReason = "incompatibleCpu"
	HostReplayUnsupportedReason_HvDisabled          HostReplayUnsupportedReason = "hvDisabled"
	HostReplayUnsupportedReason_CpuidLimitSet       HostReplayUnsupportedReason = "cpuidLimitSet"
	HostReplayUnsupportedReason_OldBIOS             HostReplayUnsupportedReason = "oldBIOS"
	HostReplayUnsupportedReason_Unknown             HostReplayUnsupportedReason = "unknown"
)

type HostCapabilityFtUnsupportedReason string

const (
	HostCapabilityFtUnsupportedReason_VMotionNotLicensed  HostCapabilityFtUnsupportedReason = "vMotionNotLicensed"
	HostCapabilityFtUnsupportedReason_MissingVMotionNic   HostCapabilityFtUnsupportedReason = "missingVMotionNic"
	HostCapabilityFtUnsupportedReason_MissingFTLoggingNic HostCapabilityFtUnsupportedReason = "missingFTLoggingNic"
	HostCapabilityFtUnsupportedReason_FtNotLicensed       HostCapabilityFtUnsupportedReason = "ftNotLicensed"
	HostCapabilityFtUnsupportedReason_HaAgentIssue        HostCapabilityFtUnsupportedReason = "haAgentIssue"
)

type HostCapabilityVmDirectPathGen2UnsupportedReason string

const (
	HostCapabilityVmDirectPathGen2UnsupportedReason_HostNptIncompatibleProduct  HostCapabilityVmDirectPathGen2UnsupportedReason = "hostNptIncompatibleProduct"
	HostCapabilityVmDirectPathGen2UnsupportedReason_HostNptIncompatibleHardware HostCapabilityVmDirectPathGen2UnsupportedReason = "hostNptIncompatibleHardware"
	HostCapabilityVmDirectPathGen2UnsupportedReason_HostNptDisabled             HostCapabilityVmDirectPathGen2UnsupportedReason = "hostNptDisabled"
)

type HostConfigChangeMode string

const (
	HostConfigChangeMode_Modify  HostConfigChangeMode = "modify"
	HostConfigChangeMode_Replace HostConfigChangeMode = "replace"
)

type HostConfigChangeOperation string

const (
	HostConfigChangeOperation_Add    HostConfigChangeOperation = "add"
	HostConfigChangeOperation_Remove HostConfigChangeOperation = "remove"
	HostConfigChangeOperation_Edit   HostConfigChangeOperation = "edit"
)

type DiagnosticPartitionStorageType string

const (
	DiagnosticPartitionStorageType_DirectAttached  DiagnosticPartitionStorageType = "directAttached"
	DiagnosticPartitionStorageType_NetworkAttached DiagnosticPartitionStorageType = "networkAttached"
)

type DiagnosticPartitionType string

const (
	DiagnosticPartitionType_SingleHost DiagnosticPartitionType = "singleHost"
	DiagnosticPartitionType_MultiHost  DiagnosticPartitionType = "multiHost"
)

type HostDiskPartitionInfoPartitionFormat string

const (
	HostDiskPartitionInfoPartitionFormat_Gpt     HostDiskPartitionInfoPartitionFormat = "gpt"
	HostDiskPartitionInfoPartitionFormat_Mbr     HostDiskPartitionInfoPartitionFormat = "mbr"
	HostDiskPartitionInfoPartitionFormat_Unknown HostDiskPartitionInfoPartitionFormat = "unknown"
)

type HostDiskPartitionInfoType string

const (
	HostDiskPartitionInfoType_None          HostDiskPartitionInfoType = "none"
	HostDiskPartitionInfoType_Vmfs          HostDiskPartitionInfoType = "vmfs"
	HostDiskPartitionInfoType_LinuxNative   HostDiskPartitionInfoType = "linuxNative"
	HostDiskPartitionInfoType_LinuxSwap     HostDiskPartitionInfoType = "linuxSwap"
	HostDiskPartitionInfoType_Extended      HostDiskPartitionInfoType = "extended"
	HostDiskPartitionInfoType_Ntfs          HostDiskPartitionInfoType = "ntfs"
	HostDiskPartitionInfoType_VmkDiagnostic HostDiskPartitionInfoType = "vmkDiagnostic"
	HostDiskPartitionInfoType_Vffs          HostDiskPartitionInfoType = "vffs"
)

type HostFeatureVersionKey string

const (
	HostFeatureVersionKey_FaultTolerance HostFeatureVersionKey = "faultTolerance"
)

type FileSystemMountInfoVStorageSupportStatus string

const (
	FileSystemMountInfoVStorageSupportStatus_VStorageSupported   FileSystemMountInfoVStorageSupportStatus = "vStorageSupported"
	FileSystemMountInfoVStorageSupportStatus_VStorageUnsupported FileSystemMountInfoVStorageSupportStatus = "vStorageUnsupported"
	FileSystemMountInfoVStorageSupportStatus_VStorageUnknown     FileSystemMountInfoVStorageSupportStatus = "vStorageUnknown"
)

type HostGraphicsInfoGraphicsType string

const (
	HostGraphicsInfoGraphicsType_Basic  HostGraphicsInfoGraphicsType = "basic"
	HostGraphicsInfoGraphicsType_Shared HostGraphicsInfoGraphicsType = "shared"
	HostGraphicsInfoGraphicsType_Direct HostGraphicsInfoGraphicsType = "direct"
)

type HostCpuPowerManagementInfoPolicyType string

const (
	HostCpuPowerManagementInfoPolicyType_Off           HostCpuPowerManagementInfoPolicyType = "off"
	HostCpuPowerManagementInfoPolicyType_StaticPolicy  HostCpuPowerManagementInfoPolicyType = "staticPolicy"
	HostCpuPowerManagementInfoPolicyType_DynamicPolicy HostCpuPowerManagementInfoPolicyType = "dynamicPolicy"
)

type HostCpuPackageVendor string

const (
	HostCpuPackageVendor_Unknown HostCpuPackageVendor = "unknown"
	HostCpuPackageVendor_Intel   HostCpuPackageVendor = "intel"
	HostCpuPackageVendor_Amd     HostCpuPackageVendor = "amd"
)

type HostHardwareElementStatus string

const (
	HostHardwareElementStatus_Unknown HostHardwareElementStatus = "Unknown"
	HostHardwareElementStatus_Green   HostHardwareElementStatus = "Green"
	HostHardwareElementStatus_Yellow  HostHardwareElementStatus = "Yellow"
	HostHardwareElementStatus_Red     HostHardwareElementStatus = "Red"
)

type FibreChannelPortType string

const (
	FibreChannelPortType_Fabric       FibreChannelPortType = "fabric"
	FibreChannelPortType_Loop         FibreChannelPortType = "loop"
	FibreChannelPortType_PointToPoint FibreChannelPortType = "pointToPoint"
	FibreChannelPortType_Unknown      FibreChannelPortType = "unknown"
)

type InternetScsiSnsDiscoveryMethod string

const (
	InternetScsiSnsDiscoveryMethod_IsnsStatic InternetScsiSnsDiscoveryMethod = "isnsStatic"
	InternetScsiSnsDiscoveryMethod_IsnsDhcp   InternetScsiSnsDiscoveryMethod = "isnsDhcp"
	InternetScsiSnsDiscoveryMethod_IsnsSlp    InternetScsiSnsDiscoveryMethod = "isnsSlp"
)

type SlpDiscoveryMethod string

const (
	SlpDiscoveryMethod_SlpDhcp          SlpDiscoveryMethod = "slpDhcp"
	SlpDiscoveryMethod_SlpAutoUnicast   SlpDiscoveryMethod = "slpAutoUnicast"
	SlpDiscoveryMethod_SlpAutoMulticast SlpDiscoveryMethod = "slpAutoMulticast"
	SlpDiscoveryMethod_SlpManual        SlpDiscoveryMethod = "slpManual"
)

type HostInternetScsiHbaChapAuthenticationType string

const (
	HostInternetScsiHbaChapAuthenticationType_ChapProhibited  HostInternetScsiHbaChapAuthenticationType = "chapProhibited"
	HostInternetScsiHbaChapAuthenticationType_ChapDiscouraged HostInternetScsiHbaChapAuthenticationType = "chapDiscouraged"
	HostInternetScsiHbaChapAuthenticationType_ChapPreferred   HostInternetScsiHbaChapAuthenticationType = "chapPreferred"
	HostInternetScsiHbaChapAuthenticationType_ChapRequired    HostInternetScsiHbaChapAuthenticationType = "chapRequired"
)

type HostInternetScsiHbaDigestType string

const (
	HostInternetScsiHbaDigestType_DigestProhibited  HostInternetScsiHbaDigestType = "digestProhibited"
	HostInternetScsiHbaDigestType_DigestDiscouraged HostInternetScsiHbaDigestType = "digestDiscouraged"
	HostInternetScsiHbaDigestType_DigestPreferred   HostInternetScsiHbaDigestType = "digestPreferred"
	HostInternetScsiHbaDigestType_DigestRequired    HostInternetScsiHbaDigestType = "digestRequired"
)

type HostInternetScsiHbaStaticTargetTargetDiscoveryMethod string

const (
	HostInternetScsiHbaStaticTargetTargetDiscoveryMethod_StaticMethod     HostInternetScsiHbaStaticTargetTargetDiscoveryMethod = "staticMethod"
	HostInternetScsiHbaStaticTargetTargetDiscoveryMethod_SendTargetMethod HostInternetScsiHbaStaticTargetTargetDiscoveryMethod = "sendTargetMethod"
	HostInternetScsiHbaStaticTargetTargetDiscoveryMethod_SlpMethod        HostInternetScsiHbaStaticTargetTargetDiscoveryMethod = "slpMethod"
	HostInternetScsiHbaStaticTargetTargetDiscoveryMethod_IsnsMethod       HostInternetScsiHbaStaticTargetTargetDiscoveryMethod = "isnsMethod"
	HostInternetScsiHbaStaticTargetTargetDiscoveryMethod_UnknownMethod    HostInternetScsiHbaStaticTargetTargetDiscoveryMethod = "unknownMethod"
)

type HostInternetScsiHbaNetworkBindingSupportType string

const (
	HostInternetScsiHbaNetworkBindingSupportType_Notsupported HostInternetScsiHbaNetworkBindingSupportType = "notsupported"
	HostInternetScsiHbaNetworkBindingSupportType_Optional     HostInternetScsiHbaNetworkBindingSupportType = "optional"
	HostInternetScsiHbaNetworkBindingSupportType_Required     HostInternetScsiHbaNetworkBindingSupportType = "required"
)

type HostImageAcceptanceLevel string

const (
	HostImageAcceptanceLevel_Vmware_certified HostImageAcceptanceLevel = "vmware_certified"
	HostImageAcceptanceLevel_Vmware_accepted  HostImageAcceptanceLevel = "vmware_accepted"
	HostImageAcceptanceLevel_Partner          HostImageAcceptanceLevel = "partner"
	HostImageAcceptanceLevel_Community        HostImageAcceptanceLevel = "community"
)

type HostIpConfigIpV6AddressConfigType string

const (
	HostIpConfigIpV6AddressConfigType_Other     HostIpConfigIpV6AddressConfigType = "other"
	HostIpConfigIpV6AddressConfigType_Manual    HostIpConfigIpV6AddressConfigType = "manual"
	HostIpConfigIpV6AddressConfigType_Dhcp      HostIpConfigIpV6AddressConfigType = "dhcp"
	HostIpConfigIpV6AddressConfigType_Linklayer HostIpConfigIpV6AddressConfigType = "linklayer"
	HostIpConfigIpV6AddressConfigType_Random    HostIpConfigIpV6AddressConfigType = "random"
)

type HostIpConfigIpV6AddressStatus string

const (
	HostIpConfigIpV6AddressStatus_Preferred    HostIpConfigIpV6AddressStatus = "preferred"
	HostIpConfigIpV6AddressStatus_Deprecated   HostIpConfigIpV6AddressStatus = "deprecated"
	HostIpConfigIpV6AddressStatus_Invalid      HostIpConfigIpV6AddressStatus = "invalid"
	HostIpConfigIpV6AddressStatus_Inaccessible HostIpConfigIpV6AddressStatus = "inaccessible"
	HostIpConfigIpV6AddressStatus_Unknown      HostIpConfigIpV6AddressStatus = "unknown"
	HostIpConfigIpV6AddressStatus_Tentative    HostIpConfigIpV6AddressStatus = "tentative"
	HostIpConfigIpV6AddressStatus_Duplicate    HostIpConfigIpV6AddressStatus = "duplicate"
)

type IscsiPortInfoPathStatus string

const (
	IscsiPortInfoPathStatus_NotUsed    IscsiPortInfoPathStatus = "notUsed"
	IscsiPortInfoPathStatus_Active     IscsiPortInfoPathStatus = "active"
	IscsiPortInfoPathStatus_StandBy    IscsiPortInfoPathStatus = "standBy"
	IscsiPortInfoPathStatus_LastActive IscsiPortInfoPathStatus = "lastActive"
)

type LinkDiscoveryProtocolConfigProtocolType string

const (
	LinkDiscoveryProtocolConfigProtocolType_Cdp  LinkDiscoveryProtocolConfigProtocolType = "cdp"
	LinkDiscoveryProtocolConfigProtocolType_Lldp LinkDiscoveryProtocolConfigProtocolType = "lldp"
)

type LinkDiscoveryProtocolConfigOperationType string

const (
	LinkDiscoveryProtocolConfigOperationType_None      LinkDiscoveryProtocolConfigOperationType = "none"
	LinkDiscoveryProtocolConfigOperationType_Listen    LinkDiscoveryProtocolConfigOperationType = "listen"
	LinkDiscoveryProtocolConfigOperationType_Advertise LinkDiscoveryProtocolConfigOperationType = "advertise"
	LinkDiscoveryProtocolConfigOperationType_Both      LinkDiscoveryProtocolConfigOperationType = "both"
)

type HostLowLevelProvisioningManagerReloadTarget string

const (
	HostLowLevelProvisioningManagerReloadTarget_CurrentConfig  HostLowLevelProvisioningManagerReloadTarget = "currentConfig"
	HostLowLevelProvisioningManagerReloadTarget_SnapshotConfig HostLowLevelProvisioningManagerReloadTarget = "snapshotConfig"
)

type VirtualMachineMemoryAllocationPolicy string

const (
	VirtualMachineMemoryAllocationPolicy_SwapNone VirtualMachineMemoryAllocationPolicy = "swapNone"
	VirtualMachineMemoryAllocationPolicy_SwapSome VirtualMachineMemoryAllocationPolicy = "swapSome"
	VirtualMachineMemoryAllocationPolicy_SwapMost VirtualMachineMemoryAllocationPolicy = "swapMost"
)

type HostMountMode string

const (
	HostMountMode_ReadWrite HostMountMode = "readWrite"
	HostMountMode_ReadOnly  HostMountMode = "readOnly"
)

type HostMountInfoInaccessibleReason string

const (
	HostMountInfoInaccessibleReason_AllPathsDown_Start   HostMountInfoInaccessibleReason = "AllPathsDown_Start"
	HostMountInfoInaccessibleReason_AllPathsDown_Timeout HostMountInfoInaccessibleReason = "AllPathsDown_Timeout"
	HostMountInfoInaccessibleReason_PermanentDeviceLoss  HostMountInfoInaccessibleReason = "PermanentDeviceLoss"
)

type MultipathState string

const (
	MultipathState_Standby  MultipathState = "standby"
	MultipathState_Active   MultipathState = "active"
	MultipathState_Disabled MultipathState = "disabled"
	MultipathState_Dead     MultipathState = "dead"
	MultipathState_Unknown  MultipathState = "unknown"
)

type HostNetStackInstanceSystemStackKey string

const (
	HostNetStackInstanceSystemStackKey_DefaultTcpipStack HostNetStackInstanceSystemStackKey = "defaultTcpipStack"
)

type HostNetStackInstanceCongestionControlAlgorithmType string

const (
	HostNetStackInstanceCongestionControlAlgorithmType_Newreno HostNetStackInstanceCongestionControlAlgorithmType = "newreno"
	HostNetStackInstanceCongestionControlAlgorithmType_Cubic   HostNetStackInstanceCongestionControlAlgorithmType = "cubic"
)

type HostNumericSensorHealthState string

const (
	HostNumericSensorHealthState_Unknown HostNumericSensorHealthState = "unknown"
	HostNumericSensorHealthState_Green   HostNumericSensorHealthState = "green"
	HostNumericSensorHealthState_Yellow  HostNumericSensorHealthState = "yellow"
	HostNumericSensorHealthState_Red     HostNumericSensorHealthState = "red"
)

type HostNumericSensorType string

const (
	HostNumericSensorType_Fan         HostNumericSensorType = "fan"
	HostNumericSensorType_Power       HostNumericSensorType = "power"
	HostNumericSensorType_Temperature HostNumericSensorType = "temperature"
	HostNumericSensorType_Voltage     HostNumericSensorType = "voltage"
	HostNumericSensorType_Other       HostNumericSensorType = "other"
)

type HostPatchManagerReason string

const (
	HostPatchManagerReason_Obsoleted         HostPatchManagerReason = "obsoleted"
	HostPatchManagerReason_MissingPatch      HostPatchManagerReason = "missingPatch"
	HostPatchManagerReason_MissingLib        HostPatchManagerReason = "missingLib"
	HostPatchManagerReason_HasDependentPatch HostPatchManagerReason = "hasDependentPatch"
	HostPatchManagerReason_ConflictPatch     HostPatchManagerReason = "conflictPatch"
	HostPatchManagerReason_ConflictLib       HostPatchManagerReason = "conflictLib"
)

type HostPatchManagerIntegrityStatus string

const (
	HostPatchManagerIntegrityStatus_Validated           HostPatchManagerIntegrityStatus = "validated"
	HostPatchManagerIntegrityStatus_KeyNotFound         HostPatchManagerIntegrityStatus = "keyNotFound"
	HostPatchManagerIntegrityStatus_KeyRevoked          HostPatchManagerIntegrityStatus = "keyRevoked"
	HostPatchManagerIntegrityStatus_KeyExpired          HostPatchManagerIntegrityStatus = "keyExpired"
	HostPatchManagerIntegrityStatus_DigestMismatch      HostPatchManagerIntegrityStatus = "digestMismatch"
	HostPatchManagerIntegrityStatus_NotEnoughSignatures HostPatchManagerIntegrityStatus = "notEnoughSignatures"
	HostPatchManagerIntegrityStatus_ValidationError     HostPatchManagerIntegrityStatus = "validationError"
)

type HostPatchManagerInstallState string

const (
	HostPatchManagerInstallState_HostRestarted HostPatchManagerInstallState = "hostRestarted"
	HostPatchManagerInstallState_ImageActive   HostPatchManagerInstallState = "imageActive"
)

type PhysicalNicVmDirectPathGen2SupportedMode string

const (
	PhysicalNicVmDirectPathGen2SupportedMode_Upt PhysicalNicVmDirectPathGen2SupportedMode = "upt"
)

type PhysicalNicResourcePoolSchedulerDisallowedReason string

const (
	PhysicalNicResourcePoolSchedulerDisallowedReason_UserOptOut          PhysicalNicResourcePoolSchedulerDisallowedReason = "userOptOut"
	PhysicalNicResourcePoolSchedulerDisallowedReason_HardwareUnsupported PhysicalNicResourcePoolSchedulerDisallowedReason = "hardwareUnsupported"
)

type PortGroupConnecteeType string

const (
	PortGroupConnecteeType_VirtualMachine   PortGroupConnecteeType = "virtualMachine"
	PortGroupConnecteeType_SystemManagement PortGroupConnecteeType = "systemManagement"
	PortGroupConnecteeType_Host             PortGroupConnecteeType = "host"
	PortGroupConnecteeType_Unknown          PortGroupConnecteeType = "unknown"
)

type HostFirewallRuleDirection string

const (
	HostFirewallRuleDirection_Inbound  HostFirewallRuleDirection = "inbound"
	HostFirewallRuleDirection_Outbound HostFirewallRuleDirection = "outbound"
)

type HostFirewallRulePortType string

const (
	HostFirewallRulePortType_Src HostFirewallRulePortType = "src"
	HostFirewallRulePortType_Dst HostFirewallRulePortType = "dst"
)

type HostFirewallRuleProtocol string

const (
	HostFirewallRuleProtocol_Tcp HostFirewallRuleProtocol = "tcp"
	HostFirewallRuleProtocol_Udp HostFirewallRuleProtocol = "udp"
)

type HostRuntimeInfoNetStackInstanceRuntimeInfoState string

const (
	HostRuntimeInfoNetStackInstanceRuntimeInfoState_Inactive     HostRuntimeInfoNetStackInstanceRuntimeInfoState = "inactive"
	HostRuntimeInfoNetStackInstanceRuntimeInfoState_Active       HostRuntimeInfoNetStackInstanceRuntimeInfoState = "active"
	HostRuntimeInfoNetStackInstanceRuntimeInfoState_Deactivating HostRuntimeInfoNetStackInstanceRuntimeInfoState = "deactivating"
	HostRuntimeInfoNetStackInstanceRuntimeInfoState_Activating   HostRuntimeInfoNetStackInstanceRuntimeInfoState = "activating"
)

type ScsiLunType string

const (
	ScsiLunType_Disk                   ScsiLunType = "disk"
	ScsiLunType_Tape                   ScsiLunType = "tape"
	ScsiLunType_Printer                ScsiLunType = "printer"
	ScsiLunType_Processor              ScsiLunType = "processor"
	ScsiLunType_Worm                   ScsiLunType = "worm"
	ScsiLunType_Cdrom                  ScsiLunType = "cdrom"
	ScsiLunType_Scanner                ScsiLunType = "scanner"
	ScsiLunType_OpticalDevice          ScsiLunType = "opticalDevice"
	ScsiLunType_MediaChanger           ScsiLunType = "mediaChanger"
	ScsiLunType_Communications         ScsiLunType = "communications"
	ScsiLunType_StorageArrayController ScsiLunType = "storageArrayController"
	ScsiLunType_Enclosure              ScsiLunType = "enclosure"
	ScsiLunType_Unknown                ScsiLunType = "unknown"
)

type ScsiLunState string

const (
	ScsiLunState_UnknownState      ScsiLunState = "unknownState"
	ScsiLunState_Ok                ScsiLunState = "ok"
	ScsiLunState_Error             ScsiLunState = "error"
	ScsiLunState_Off               ScsiLunState = "off"
	ScsiLunState_Quiesced          ScsiLunState = "quiesced"
	ScsiLunState_Degraded          ScsiLunState = "degraded"
	ScsiLunState_LostCommunication ScsiLunState = "lostCommunication"
	ScsiLunState_Timeout           ScsiLunState = "timeout"
)

type ScsiLunDescriptorQuality string

const (
	ScsiLunDescriptorQuality_HighQuality    ScsiLunDescriptorQuality = "highQuality"
	ScsiLunDescriptorQuality_MediumQuality  ScsiLunDescriptorQuality = "mediumQuality"
	ScsiLunDescriptorQuality_LowQuality     ScsiLunDescriptorQuality = "lowQuality"
	ScsiLunDescriptorQuality_UnknownQuality ScsiLunDescriptorQuality = "unknownQuality"
)

type ScsiLunVStorageSupportStatus string

const (
	ScsiLunVStorageSupportStatus_VStorageSupported   ScsiLunVStorageSupportStatus = "vStorageSupported"
	ScsiLunVStorageSupportStatus_VStorageUnsupported ScsiLunVStorageSupportStatus = "vStorageUnsupported"
	ScsiLunVStorageSupportStatus_VStorageUnknown     ScsiLunVStorageSupportStatus = "vStorageUnknown"
)

type HostServicePolicy string

const (
	HostServicePolicy_On        HostServicePolicy = "on"
	HostServicePolicy_Automatic HostServicePolicy = "automatic"
	HostServicePolicy_Off       HostServicePolicy = "off"
)

type HostSnmpAgentCapability string

const (
	HostSnmpAgentCapability_COMPLETE      HostSnmpAgentCapability = "COMPLETE"
	HostSnmpAgentCapability_DIAGNOSTICS   HostSnmpAgentCapability = "DIAGNOSTICS"
	HostSnmpAgentCapability_CONFIGURATION HostSnmpAgentCapability = "CONFIGURATION"
)

type HostSystemIdentificationInfoIdentifier string

const (
	HostSystemIdentificationInfoIdentifier_AssetTag          HostSystemIdentificationInfoIdentifier = "AssetTag"
	HostSystemIdentificationInfoIdentifier_ServiceTag        HostSystemIdentificationInfoIdentifier = "ServiceTag"
	HostSystemIdentificationInfoIdentifier_OemSpecificString HostSystemIdentificationInfoIdentifier = "OemSpecificString"
)

type HostDigestInfoDigestMethodType string

const (
	HostDigestInfoDigestMethodType_SHA1 HostDigestInfoDigestMethodType = "SHA1"
	HostDigestInfoDigestMethodType_MD5  HostDigestInfoDigestMethodType = "MD5"
)

type HostUnresolvedVmfsExtentUnresolvedReason string

const (
	HostUnresolvedVmfsExtentUnresolvedReason_DiskIdMismatch HostUnresolvedVmfsExtentUnresolvedReason = "diskIdMismatch"
	HostUnresolvedVmfsExtentUnresolvedReason_UuidConflict   HostUnresolvedVmfsExtentUnresolvedReason = "uuidConflict"
)

type HostUnresolvedVmfsResolutionSpecVmfsUuidResolution string

const (
	HostUnresolvedVmfsResolutionSpecVmfsUuidResolution_Resignature HostUnresolvedVmfsResolutionSpecVmfsUuidResolution = "resignature"
	HostUnresolvedVmfsResolutionSpecVmfsUuidResolution_ForceMount  HostUnresolvedVmfsResolutionSpecVmfsUuidResolution = "forceMount"
)

type HostVirtualNicManagerNicType string

const (
	HostVirtualNicManagerNicType_Vmotion               HostVirtualNicManagerNicType = "vmotion"
	HostVirtualNicManagerNicType_FaultToleranceLogging HostVirtualNicManagerNicType = "faultToleranceLogging"
	HostVirtualNicManagerNicType_VSphereReplication    HostVirtualNicManagerNicType = "vSphereReplication"
	HostVirtualNicManagerNicType_Management            HostVirtualNicManagerNicType = "management"
	HostVirtualNicManagerNicType_Vsan                  HostVirtualNicManagerNicType = "vsan"
)

type HostVmciAccessManagerMode string

const (
	HostVmciAccessManagerMode_Grant   HostVmciAccessManagerMode = "grant"
	HostVmciAccessManagerMode_Replace HostVmciAccessManagerMode = "replace"
	HostVmciAccessManagerMode_Revoke  HostVmciAccessManagerMode = "revoke"
)

type NetIpConfigInfoIpAddressOrigin string

const (
	NetIpConfigInfoIpAddressOrigin_Other     NetIpConfigInfoIpAddressOrigin = "other"
	NetIpConfigInfoIpAddressOrigin_Manual    NetIpConfigInfoIpAddressOrigin = "manual"
	NetIpConfigInfoIpAddressOrigin_Dhcp      NetIpConfigInfoIpAddressOrigin = "dhcp"
	NetIpConfigInfoIpAddressOrigin_Linklayer NetIpConfigInfoIpAddressOrigin = "linklayer"
	NetIpConfigInfoIpAddressOrigin_Random    NetIpConfigInfoIpAddressOrigin = "random"
)

type NetIpConfigInfoIpAddressStatus string

const (
	NetIpConfigInfoIpAddressStatus_Preferred    NetIpConfigInfoIpAddressStatus = "preferred"
	NetIpConfigInfoIpAddressStatus_Deprecated   NetIpConfigInfoIpAddressStatus = "deprecated"
	NetIpConfigInfoIpAddressStatus_Invalid      NetIpConfigInfoIpAddressStatus = "invalid"
	NetIpConfigInfoIpAddressStatus_Inaccessible NetIpConfigInfoIpAddressStatus = "inaccessible"
	NetIpConfigInfoIpAddressStatus_Unknown      NetIpConfigInfoIpAddressStatus = "unknown"
	NetIpConfigInfoIpAddressStatus_Tentative    NetIpConfigInfoIpAddressStatus = "tentative"
	NetIpConfigInfoIpAddressStatus_Duplicate    NetIpConfigInfoIpAddressStatus = "duplicate"
)

type NetIpStackInfoEntryType string

const (
	NetIpStackInfoEntryType_Other   NetIpStackInfoEntryType = "other"
	NetIpStackInfoEntryType_Invalid NetIpStackInfoEntryType = "invalid"
	NetIpStackInfoEntryType_Dynamic NetIpStackInfoEntryType = "dynamic"
	NetIpStackInfoEntryType_Manual  NetIpStackInfoEntryType = "manual"
)

type NetIpStackInfoPreference string

const (
	NetIpStackInfoPreference_Reserved NetIpStackInfoPreference = "reserved"
	NetIpStackInfoPreference_Low      NetIpStackInfoPreference = "low"
	NetIpStackInfoPreference_Medium   NetIpStackInfoPreference = "medium"
	NetIpStackInfoPreference_High     NetIpStackInfoPreference = "high"
)

type NetBIOSConfigInfoMode string

const (
	NetBIOSConfigInfoMode_Unknown        NetBIOSConfigInfoMode = "unknown"
	NetBIOSConfigInfoMode_Enabled        NetBIOSConfigInfoMode = "enabled"
	NetBIOSConfigInfoMode_Disabled       NetBIOSConfigInfoMode = "disabled"
	NetBIOSConfigInfoMode_EnabledViaDHCP NetBIOSConfigInfoMode = "enabledViaDHCP"
)

type ArrayUpdateOperation string

const (
	ArrayUpdateOperation_Add    ArrayUpdateOperation = "add"
	ArrayUpdateOperation_Remove ArrayUpdateOperation = "remove"
	ArrayUpdateOperation_Edit   ArrayUpdateOperation = "edit"
)

type ComplianceResultStatus string

const (
	ComplianceResultStatus_Compliant    ComplianceResultStatus = "compliant"
	ComplianceResultStatus_NonCompliant ComplianceResultStatus = "nonCompliant"
	ComplianceResultStatus_Unknown      ComplianceResultStatus = "unknown"
)

type ProfileNumericComparator string

const (
	ProfileNumericComparator_LessThan         ProfileNumericComparator = "lessThan"
	ProfileNumericComparator_LessThanEqual    ProfileNumericComparator = "lessThanEqual"
	ProfileNumericComparator_Equal            ProfileNumericComparator = "equal"
	ProfileNumericComparator_NotEqual         ProfileNumericComparator = "notEqual"
	ProfileNumericComparator_GreaterThanEqual ProfileNumericComparator = "greaterThanEqual"
	ProfileNumericComparator_GreaterThan      ProfileNumericComparator = "greaterThan"
)

type ClusterProfileServiceType string

const (
	ClusterProfileServiceType_DRS ClusterProfileServiceType = "DRS"
	ClusterProfileServiceType_HA  ClusterProfileServiceType = "HA"
	ClusterProfileServiceType_DPM ClusterProfileServiceType = "DPM"
	ClusterProfileServiceType_FT  ClusterProfileServiceType = "FT"
)

type ProfileExecuteResultStatus string

const (
	ProfileExecuteResultStatus_Success   ProfileExecuteResultStatus = "success"
	ProfileExecuteResultStatus_NeedInput ProfileExecuteResultStatus = "needInput"
	ProfileExecuteResultStatus_Error     ProfileExecuteResultStatus = "error"
)

type HostProfileManagerAnswerFileStatus string

const (
	HostProfileManagerAnswerFileStatus_Valid   HostProfileManagerAnswerFileStatus = "valid"
	HostProfileManagerAnswerFileStatus_Invalid HostProfileManagerAnswerFileStatus = "invalid"
	HostProfileManagerAnswerFileStatus_Unknown HostProfileManagerAnswerFileStatus = "unknown"
)

type DayOfWeek string

const (
	DayOfWeek_Sunday    DayOfWeek = "sunday"
	DayOfWeek_Monday    DayOfWeek = "monday"
	DayOfWeek_Tuesday   DayOfWeek = "tuesday"
	DayOfWeek_Wednesday DayOfWeek = "wednesday"
	DayOfWeek_Thursday  DayOfWeek = "thursday"
	DayOfWeek_Friday    DayOfWeek = "friday"
	DayOfWeek_Saturday  DayOfWeek = "saturday"
)

type WeekOfMonth string

const (
	WeekOfMonth_First  WeekOfMonth = "first"
	WeekOfMonth_Second WeekOfMonth = "second"
	WeekOfMonth_Third  WeekOfMonth = "third"
	WeekOfMonth_Fourth WeekOfMonth = "fourth"
	WeekOfMonth_Last   WeekOfMonth = "last"
)

type StorageDrsPodConfigInfoBehavior string

const (
	StorageDrsPodConfigInfoBehavior_Manual    StorageDrsPodConfigInfoBehavior = "manual"
	StorageDrsPodConfigInfoBehavior_Automated StorageDrsPodConfigInfoBehavior = "automated"
)

type StoragePlacementSpecPlacementType string

const (
	StoragePlacementSpecPlacementType_Create      StoragePlacementSpecPlacementType = "create"
	StoragePlacementSpecPlacementType_Reconfigure StoragePlacementSpecPlacementType = "reconfigure"
	StoragePlacementSpecPlacementType_Relocate    StoragePlacementSpecPlacementType = "relocate"
	StoragePlacementSpecPlacementType_Clone       StoragePlacementSpecPlacementType = "clone"
)

type VAppCloneSpecProvisioningType string

const (
	VAppCloneSpecProvisioningType_SameAsSource VAppCloneSpecProvisioningType = "sameAsSource"
	VAppCloneSpecProvisioningType_Thin         VAppCloneSpecProvisioningType = "thin"
	VAppCloneSpecProvisioningType_Thick        VAppCloneSpecProvisioningType = "thick"
)

type VAppAutoStartAction string

const (
	VAppAutoStartAction_None          VAppAutoStartAction = "none"
	VAppAutoStartAction_PowerOn       VAppAutoStartAction = "powerOn"
	VAppAutoStartAction_PowerOff      VAppAutoStartAction = "powerOff"
	VAppAutoStartAction_GuestShutdown VAppAutoStartAction = "guestShutdown"
	VAppAutoStartAction_Suspend       VAppAutoStartAction = "suspend"
)

type VAppIPAssignmentInfoIpAllocationPolicy string

const (
	VAppIPAssignmentInfoIpAllocationPolicy_DhcpPolicy           VAppIPAssignmentInfoIpAllocationPolicy = "dhcpPolicy"
	VAppIPAssignmentInfoIpAllocationPolicy_TransientPolicy      VAppIPAssignmentInfoIpAllocationPolicy = "transientPolicy"
	VAppIPAssignmentInfoIpAllocationPolicy_FixedPolicy          VAppIPAssignmentInfoIpAllocationPolicy = "fixedPolicy"
	VAppIPAssignmentInfoIpAllocationPolicy_FixedAllocatedPolicy VAppIPAssignmentInfoIpAllocationPolicy = "fixedAllocatedPolicy"
)

type VAppIPAssignmentInfoAllocationSchemes string

const (
	VAppIPAssignmentInfoAllocationSchemes_Dhcp   VAppIPAssignmentInfoAllocationSchemes = "dhcp"
	VAppIPAssignmentInfoAllocationSchemes_Ovfenv VAppIPAssignmentInfoAllocationSchemes = "ovfenv"
)

type VAppIPAssignmentInfoProtocols string

const (
	VAppIPAssignmentInfoProtocols_IPv4 VAppIPAssignmentInfoProtocols = "IPv4"
	VAppIPAssignmentInfoProtocols_IPv6 VAppIPAssignmentInfoProtocols = "IPv6"
)

type VirtualMachineConfigInfoNpivWwnType string

const (
	VirtualMachineConfigInfoNpivWwnType_Vc       VirtualMachineConfigInfoNpivWwnType = "vc"
	VirtualMachineConfigInfoNpivWwnType_Host     VirtualMachineConfigInfoNpivWwnType = "host"
	VirtualMachineConfigInfoNpivWwnType_External VirtualMachineConfigInfoNpivWwnType = "external"
)

type VirtualMachineConfigInfoSwapPlacementType string

const (
	VirtualMachineConfigInfoSwapPlacementType_Inherit     VirtualMachineConfigInfoSwapPlacementType = "inherit"
	VirtualMachineConfigInfoSwapPlacementType_VmDirectory VirtualMachineConfigInfoSwapPlacementType = "vmDirectory"
	VirtualMachineConfigInfoSwapPlacementType_HostLocal   VirtualMachineConfigInfoSwapPlacementType = "hostLocal"
)

type VirtualMachineConfigSpecNpivWwnOp string

const (
	VirtualMachineConfigSpecNpivWwnOp_Generate VirtualMachineConfigSpecNpivWwnOp = "generate"
	VirtualMachineConfigSpecNpivWwnOp_Set      VirtualMachineConfigSpecNpivWwnOp = "set"
	VirtualMachineConfigSpecNpivWwnOp_Remove   VirtualMachineConfigSpecNpivWwnOp = "remove"
	VirtualMachineConfigSpecNpivWwnOp_Extend   VirtualMachineConfigSpecNpivWwnOp = "extend"
)

type VirtualMachinePowerOpType string

const (
	VirtualMachinePowerOpType_Soft   VirtualMachinePowerOpType = "soft"
	VirtualMachinePowerOpType_Hard   VirtualMachinePowerOpType = "hard"
	VirtualMachinePowerOpType_Preset VirtualMachinePowerOpType = "preset"
)

type VirtualMachineStandbyActionType string

const (
	VirtualMachineStandbyActionType_Checkpoint     VirtualMachineStandbyActionType = "checkpoint"
	VirtualMachineStandbyActionType_PowerOnSuspend VirtualMachineStandbyActionType = "powerOnSuspend"
)

type VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm string

const (
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptIncompatibleGuest                      VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptIncompatibleGuest"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptIncompatibleGuestDriver                VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptIncompatibleGuestDriver"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptIncompatibleAdapterType                VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptIncompatibleAdapterType"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptDisabledOrDisconnectedAdapter          VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptDisabledOrDisconnectedAdapter"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptIncompatibleAdapterFeatures            VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptIncompatibleAdapterFeatures"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptIncompatibleBackingType                VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptIncompatibleBackingType"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptInsufficientMemoryReservation          VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptInsufficientMemoryReservation"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptFaultToleranceOrRecordReplayConfigured VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptFaultToleranceOrRecordReplayConfigured"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptConflictingIOChainConfigured           VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptConflictingIOChainConfigured"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptMonitorBlocks                          VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptMonitorBlocks"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptConflictingOperationInProgress         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptConflictingOperationInProgress"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptRuntimeError                           VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptRuntimeError"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptOutOfIntrVector                        VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptOutOfIntrVector"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_VmNptVMCIActive                             VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm = "vmNptVMCIActive"
)

type VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther string

const (
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther_VmNptIncompatibleHost    VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther = "vmNptIncompatibleHost"
	VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther_VmNptIncompatibleNetwork VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther = "vmNptIncompatibleNetwork"
)

type VirtualMachineFileLayoutExFileType string

const (
	VirtualMachineFileLayoutExFileType_Config               VirtualMachineFileLayoutExFileType = "config"
	VirtualMachineFileLayoutExFileType_ExtendedConfig       VirtualMachineFileLayoutExFileType = "extendedConfig"
	VirtualMachineFileLayoutExFileType_DiskDescriptor       VirtualMachineFileLayoutExFileType = "diskDescriptor"
	VirtualMachineFileLayoutExFileType_DiskExtent           VirtualMachineFileLayoutExFileType = "diskExtent"
	VirtualMachineFileLayoutExFileType_DigestDescriptor     VirtualMachineFileLayoutExFileType = "digestDescriptor"
	VirtualMachineFileLayoutExFileType_DigestExtent         VirtualMachineFileLayoutExFileType = "digestExtent"
	VirtualMachineFileLayoutExFileType_DiskReplicationState VirtualMachineFileLayoutExFileType = "diskReplicationState"
	VirtualMachineFileLayoutExFileType_Log                  VirtualMachineFileLayoutExFileType = "log"
	VirtualMachineFileLayoutExFileType_Stat                 VirtualMachineFileLayoutExFileType = "stat"
	VirtualMachineFileLayoutExFileType_NamespaceData        VirtualMachineFileLayoutExFileType = "namespaceData"
	VirtualMachineFileLayoutExFileType_Nvram                VirtualMachineFileLayoutExFileType = "nvram"
	VirtualMachineFileLayoutExFileType_SnapshotData         VirtualMachineFileLayoutExFileType = "snapshotData"
	VirtualMachineFileLayoutExFileType_SnapshotList         VirtualMachineFileLayoutExFileType = "snapshotList"
	VirtualMachineFileLayoutExFileType_SnapshotManifestList VirtualMachineFileLayoutExFileType = "snapshotManifestList"
	VirtualMachineFileLayoutExFileType_Suspend              VirtualMachineFileLayoutExFileType = "suspend"
	VirtualMachineFileLayoutExFileType_Swap                 VirtualMachineFileLayoutExFileType = "swap"
	VirtualMachineFileLayoutExFileType_Uwswap               VirtualMachineFileLayoutExFileType = "uwswap"
	VirtualMachineFileLayoutExFileType_Core                 VirtualMachineFileLayoutExFileType = "core"
	VirtualMachineFileLayoutExFileType_Screenshot           VirtualMachineFileLayoutExFileType = "screenshot"
)

type VirtualMachineHtSharing string

const (
	VirtualMachineHtSharing_Any      VirtualMachineHtSharing = "any"
	VirtualMachineHtSharing_None     VirtualMachineHtSharing = "none"
	VirtualMachineHtSharing_Internal VirtualMachineHtSharing = "internal"
)

type VirtualMachinePowerOffBehavior string

const (
	VirtualMachinePowerOffBehavior_PowerOff VirtualMachinePowerOffBehavior = "powerOff"
	VirtualMachinePowerOffBehavior_Revert   VirtualMachinePowerOffBehavior = "revert"
	VirtualMachinePowerOffBehavior_Prompt   VirtualMachinePowerOffBehavior = "prompt"
)

type VirtualMachineFlagInfoMonitorType string

const (
	VirtualMachineFlagInfoMonitorType_Release VirtualMachineFlagInfoMonitorType = "release"
	VirtualMachineFlagInfoMonitorType_Debug   VirtualMachineFlagInfoMonitorType = "debug"
	VirtualMachineFlagInfoMonitorType_Stats   VirtualMachineFlagInfoMonitorType = "stats"
)

type VirtualMachineFlagInfoVirtualMmuUsage string

const (
	VirtualMachineFlagInfoVirtualMmuUsage_Automatic VirtualMachineFlagInfoVirtualMmuUsage = "automatic"
	VirtualMachineFlagInfoVirtualMmuUsage_On        VirtualMachineFlagInfoVirtualMmuUsage = "on"
	VirtualMachineFlagInfoVirtualMmuUsage_Off       VirtualMachineFlagInfoVirtualMmuUsage = "off"
)

type VirtualMachineFlagInfoVirtualExecUsage string

const (
	VirtualMachineFlagInfoVirtualExecUsage_HvAuto VirtualMachineFlagInfoVirtualExecUsage = "hvAuto"
	VirtualMachineFlagInfoVirtualExecUsage_HvOn   VirtualMachineFlagInfoVirtualExecUsage = "hvOn"
	VirtualMachineFlagInfoVirtualExecUsage_HvOff  VirtualMachineFlagInfoVirtualExecUsage = "hvOff"
)

type VirtualMachineToolsStatus string

const (
	VirtualMachineToolsStatus_ToolsNotInstalled VirtualMachineToolsStatus = "toolsNotInstalled"
	VirtualMachineToolsStatus_ToolsNotRunning   VirtualMachineToolsStatus = "toolsNotRunning"
	VirtualMachineToolsStatus_ToolsOld          VirtualMachineToolsStatus = "toolsOld"
	VirtualMachineToolsStatus_ToolsOk           VirtualMachineToolsStatus = "toolsOk"
)

type VirtualMachineToolsVersionStatus string

const (
	VirtualMachineToolsVersionStatus_GuestToolsNotInstalled VirtualMachineToolsVersionStatus = "guestToolsNotInstalled"
	VirtualMachineToolsVersionStatus_GuestToolsNeedUpgrade  VirtualMachineToolsVersionStatus = "guestToolsNeedUpgrade"
	VirtualMachineToolsVersionStatus_GuestToolsCurrent      VirtualMachineToolsVersionStatus = "guestToolsCurrent"
	VirtualMachineToolsVersionStatus_GuestToolsUnmanaged    VirtualMachineToolsVersionStatus = "guestToolsUnmanaged"
	VirtualMachineToolsVersionStatus_GuestToolsTooOld       VirtualMachineToolsVersionStatus = "guestToolsTooOld"
	VirtualMachineToolsVersionStatus_GuestToolsSupportedOld VirtualMachineToolsVersionStatus = "guestToolsSupportedOld"
	VirtualMachineToolsVersionStatus_GuestToolsSupportedNew VirtualMachineToolsVersionStatus = "guestToolsSupportedNew"
	VirtualMachineToolsVersionStatus_GuestToolsTooNew       VirtualMachineToolsVersionStatus = "guestToolsTooNew"
	VirtualMachineToolsVersionStatus_GuestToolsBlacklisted  VirtualMachineToolsVersionStatus = "guestToolsBlacklisted"
)

type VirtualMachineToolsRunningStatus string

const (
	VirtualMachineToolsRunningStatus_GuestToolsNotRunning       VirtualMachineToolsRunningStatus = "guestToolsNotRunning"
	VirtualMachineToolsRunningStatus_GuestToolsRunning          VirtualMachineToolsRunningStatus = "guestToolsRunning"
	VirtualMachineToolsRunningStatus_GuestToolsExecutingScripts VirtualMachineToolsRunningStatus = "guestToolsExecutingScripts"
)

type VirtualMachineGuestState string

const (
	VirtualMachineGuestState_Running      VirtualMachineGuestState = "running"
	VirtualMachineGuestState_ShuttingDown VirtualMachineGuestState = "shuttingDown"
	VirtualMachineGuestState_Resetting    VirtualMachineGuestState = "resetting"
	VirtualMachineGuestState_Standby      VirtualMachineGuestState = "standby"
	VirtualMachineGuestState_NotRunning   VirtualMachineGuestState = "notRunning"
	VirtualMachineGuestState_Unknown      VirtualMachineGuestState = "unknown"
)

type GuestInfoAppStateType string

const (
	GuestInfoAppStateType_None              GuestInfoAppStateType = "none"
	GuestInfoAppStateType_AppStateOk        GuestInfoAppStateType = "appStateOk"
	GuestInfoAppStateType_AppStateNeedReset GuestInfoAppStateType = "appStateNeedReset"
)

type VirtualMachineGuestOsFamily string

const (
	VirtualMachineGuestOsFamily_WindowsGuest      VirtualMachineGuestOsFamily = "windowsGuest"
	VirtualMachineGuestOsFamily_LinuxGuest        VirtualMachineGuestOsFamily = "linuxGuest"
	VirtualMachineGuestOsFamily_NetwareGuest      VirtualMachineGuestOsFamily = "netwareGuest"
	VirtualMachineGuestOsFamily_SolarisGuest      VirtualMachineGuestOsFamily = "solarisGuest"
	VirtualMachineGuestOsFamily_DarwinGuestFamily VirtualMachineGuestOsFamily = "darwinGuestFamily"
	VirtualMachineGuestOsFamily_OtherGuestFamily  VirtualMachineGuestOsFamily = "otherGuestFamily"
)

type VirtualMachineGuestOsIdentifier string

const (
	VirtualMachineGuestOsIdentifier_DosGuest                VirtualMachineGuestOsIdentifier = "dosGuest"
	VirtualMachineGuestOsIdentifier_Win31Guest              VirtualMachineGuestOsIdentifier = "win31Guest"
	VirtualMachineGuestOsIdentifier_Win95Guest              VirtualMachineGuestOsIdentifier = "win95Guest"
	VirtualMachineGuestOsIdentifier_Win98Guest              VirtualMachineGuestOsIdentifier = "win98Guest"
	VirtualMachineGuestOsIdentifier_WinMeGuest              VirtualMachineGuestOsIdentifier = "winMeGuest"
	VirtualMachineGuestOsIdentifier_WinNTGuest              VirtualMachineGuestOsIdentifier = "winNTGuest"
	VirtualMachineGuestOsIdentifier_Win2000ProGuest         VirtualMachineGuestOsIdentifier = "win2000ProGuest"
	VirtualMachineGuestOsIdentifier_Win2000ServGuest        VirtualMachineGuestOsIdentifier = "win2000ServGuest"
	VirtualMachineGuestOsIdentifier_Win2000AdvServGuest     VirtualMachineGuestOsIdentifier = "win2000AdvServGuest"
	VirtualMachineGuestOsIdentifier_WinXPHomeGuest          VirtualMachineGuestOsIdentifier = "winXPHomeGuest"
	VirtualMachineGuestOsIdentifier_WinXPProGuest           VirtualMachineGuestOsIdentifier = "winXPProGuest"
	VirtualMachineGuestOsIdentifier_WinXPPro64Guest         VirtualMachineGuestOsIdentifier = "winXPPro64Guest"
	VirtualMachineGuestOsIdentifier_WinNetWebGuest          VirtualMachineGuestOsIdentifier = "winNetWebGuest"
	VirtualMachineGuestOsIdentifier_WinNetStandardGuest     VirtualMachineGuestOsIdentifier = "winNetStandardGuest"
	VirtualMachineGuestOsIdentifier_WinNetEnterpriseGuest   VirtualMachineGuestOsIdentifier = "winNetEnterpriseGuest"
	VirtualMachineGuestOsIdentifier_WinNetDatacenterGuest   VirtualMachineGuestOsIdentifier = "winNetDatacenterGuest"
	VirtualMachineGuestOsIdentifier_WinNetBusinessGuest     VirtualMachineGuestOsIdentifier = "winNetBusinessGuest"
	VirtualMachineGuestOsIdentifier_WinNetStandard64Guest   VirtualMachineGuestOsIdentifier = "winNetStandard64Guest"
	VirtualMachineGuestOsIdentifier_WinNetEnterprise64Guest VirtualMachineGuestOsIdentifier = "winNetEnterprise64Guest"
	VirtualMachineGuestOsIdentifier_WinLonghornGuest        VirtualMachineGuestOsIdentifier = "winLonghornGuest"
	VirtualMachineGuestOsIdentifier_WinLonghorn64Guest      VirtualMachineGuestOsIdentifier = "winLonghorn64Guest"
	VirtualMachineGuestOsIdentifier_WinNetDatacenter64Guest VirtualMachineGuestOsIdentifier = "winNetDatacenter64Guest"
	VirtualMachineGuestOsIdentifier_WinVistaGuest           VirtualMachineGuestOsIdentifier = "winVistaGuest"
	VirtualMachineGuestOsIdentifier_WinVista64Guest         VirtualMachineGuestOsIdentifier = "winVista64Guest"
	VirtualMachineGuestOsIdentifier_Windows7Guest           VirtualMachineGuestOsIdentifier = "windows7Guest"
	VirtualMachineGuestOsIdentifier_Windows7_64Guest        VirtualMachineGuestOsIdentifier = "windows7_64Guest"
	VirtualMachineGuestOsIdentifier_Windows7Server64Guest   VirtualMachineGuestOsIdentifier = "windows7Server64Guest"
	VirtualMachineGuestOsIdentifier_Windows8Guest           VirtualMachineGuestOsIdentifier = "windows8Guest"
	VirtualMachineGuestOsIdentifier_Windows8_64Guest        VirtualMachineGuestOsIdentifier = "windows8_64Guest"
	VirtualMachineGuestOsIdentifier_Windows8Server64Guest   VirtualMachineGuestOsIdentifier = "windows8Server64Guest"
	VirtualMachineGuestOsIdentifier_WindowsHyperVGuest      VirtualMachineGuestOsIdentifier = "windowsHyperVGuest"
	VirtualMachineGuestOsIdentifier_FreebsdGuest            VirtualMachineGuestOsIdentifier = "freebsdGuest"
	VirtualMachineGuestOsIdentifier_Freebsd64Guest          VirtualMachineGuestOsIdentifier = "freebsd64Guest"
	VirtualMachineGuestOsIdentifier_RedhatGuest             VirtualMachineGuestOsIdentifier = "redhatGuest"
	VirtualMachineGuestOsIdentifier_Rhel2Guest              VirtualMachineGuestOsIdentifier = "rhel2Guest"
	VirtualMachineGuestOsIdentifier_Rhel3Guest              VirtualMachineGuestOsIdentifier = "rhel3Guest"
	VirtualMachineGuestOsIdentifier_Rhel3_64Guest           VirtualMachineGuestOsIdentifier = "rhel3_64Guest"
	VirtualMachineGuestOsIdentifier_Rhel4Guest              VirtualMachineGuestOsIdentifier = "rhel4Guest"
	VirtualMachineGuestOsIdentifier_Rhel4_64Guest           VirtualMachineGuestOsIdentifier = "rhel4_64Guest"
	VirtualMachineGuestOsIdentifier_Rhel5Guest              VirtualMachineGuestOsIdentifier = "rhel5Guest"
	VirtualMachineGuestOsIdentifier_Rhel5_64Guest           VirtualMachineGuestOsIdentifier = "rhel5_64Guest"
	VirtualMachineGuestOsIdentifier_Rhel6Guest              VirtualMachineGuestOsIdentifier = "rhel6Guest"
	VirtualMachineGuestOsIdentifier_Rhel6_64Guest           VirtualMachineGuestOsIdentifier = "rhel6_64Guest"
	VirtualMachineGuestOsIdentifier_Rhel7Guest              VirtualMachineGuestOsIdentifier = "rhel7Guest"
	VirtualMachineGuestOsIdentifier_Rhel7_64Guest           VirtualMachineGuestOsIdentifier = "rhel7_64Guest"
	VirtualMachineGuestOsIdentifier_CentosGuest             VirtualMachineGuestOsIdentifier = "centosGuest"
	VirtualMachineGuestOsIdentifier_Centos64Guest           VirtualMachineGuestOsIdentifier = "centos64Guest"
	VirtualMachineGuestOsIdentifier_OracleLinuxGuest        VirtualMachineGuestOsIdentifier = "oracleLinuxGuest"
	VirtualMachineGuestOsIdentifier_OracleLinux64Guest      VirtualMachineGuestOsIdentifier = "oracleLinux64Guest"
	VirtualMachineGuestOsIdentifier_SuseGuest               VirtualMachineGuestOsIdentifier = "suseGuest"
	VirtualMachineGuestOsIdentifier_Suse64Guest             VirtualMachineGuestOsIdentifier = "suse64Guest"
	VirtualMachineGuestOsIdentifier_SlesGuest               VirtualMachineGuestOsIdentifier = "slesGuest"
	VirtualMachineGuestOsIdentifier_Sles64Guest             VirtualMachineGuestOsIdentifier = "sles64Guest"
	VirtualMachineGuestOsIdentifier_Sles10Guest             VirtualMachineGuestOsIdentifier = "sles10Guest"
	VirtualMachineGuestOsIdentifier_Sles10_64Guest          VirtualMachineGuestOsIdentifier = "sles10_64Guest"
	VirtualMachineGuestOsIdentifier_Sles11Guest             VirtualMachineGuestOsIdentifier = "sles11Guest"
	VirtualMachineGuestOsIdentifier_Sles11_64Guest          VirtualMachineGuestOsIdentifier = "sles11_64Guest"
	VirtualMachineGuestOsIdentifier_Sles12Guest             VirtualMachineGuestOsIdentifier = "sles12Guest"
	VirtualMachineGuestOsIdentifier_Sles12_64Guest          VirtualMachineGuestOsIdentifier = "sles12_64Guest"
	VirtualMachineGuestOsIdentifier_Nld9Guest               VirtualMachineGuestOsIdentifier = "nld9Guest"
	VirtualMachineGuestOsIdentifier_OesGuest                VirtualMachineGuestOsIdentifier = "oesGuest"
	VirtualMachineGuestOsIdentifier_SjdsGuest               VirtualMachineGuestOsIdentifier = "sjdsGuest"
	VirtualMachineGuestOsIdentifier_MandrakeGuest           VirtualMachineGuestOsIdentifier = "mandrakeGuest"
	VirtualMachineGuestOsIdentifier_MandrivaGuest           VirtualMachineGuestOsIdentifier = "mandrivaGuest"
	VirtualMachineGuestOsIdentifier_Mandriva64Guest         VirtualMachineGuestOsIdentifier = "mandriva64Guest"
	VirtualMachineGuestOsIdentifier_TurboLinuxGuest         VirtualMachineGuestOsIdentifier = "turboLinuxGuest"
	VirtualMachineGuestOsIdentifier_TurboLinux64Guest       VirtualMachineGuestOsIdentifier = "turboLinux64Guest"
	VirtualMachineGuestOsIdentifier_UbuntuGuest             VirtualMachineGuestOsIdentifier = "ubuntuGuest"
	VirtualMachineGuestOsIdentifier_Ubuntu64Guest           VirtualMachineGuestOsIdentifier = "ubuntu64Guest"
	VirtualMachineGuestOsIdentifier_Debian4Guest            VirtualMachineGuestOsIdentifier = "debian4Guest"
	VirtualMachineGuestOsIdentifier_Debian4_64Guest         VirtualMachineGuestOsIdentifier = "debian4_64Guest"
	VirtualMachineGuestOsIdentifier_Debian5Guest            VirtualMachineGuestOsIdentifier = "debian5Guest"
	VirtualMachineGuestOsIdentifier_Debian5_64Guest         VirtualMachineGuestOsIdentifier = "debian5_64Guest"
	VirtualMachineGuestOsIdentifier_Debian6Guest            VirtualMachineGuestOsIdentifier = "debian6Guest"
	VirtualMachineGuestOsIdentifier_Debian6_64Guest         VirtualMachineGuestOsIdentifier = "debian6_64Guest"
	VirtualMachineGuestOsIdentifier_Debian7Guest            VirtualMachineGuestOsIdentifier = "debian7Guest"
	VirtualMachineGuestOsIdentifier_Debian7_64Guest         VirtualMachineGuestOsIdentifier = "debian7_64Guest"
	VirtualMachineGuestOsIdentifier_Asianux3Guest           VirtualMachineGuestOsIdentifier = "asianux3Guest"
	VirtualMachineGuestOsIdentifier_Asianux3_64Guest        VirtualMachineGuestOsIdentifier = "asianux3_64Guest"
	VirtualMachineGuestOsIdentifier_Asianux4Guest           VirtualMachineGuestOsIdentifier = "asianux4Guest"
	VirtualMachineGuestOsIdentifier_Asianux4_64Guest        VirtualMachineGuestOsIdentifier = "asianux4_64Guest"
	VirtualMachineGuestOsIdentifier_OpensuseGuest           VirtualMachineGuestOsIdentifier = "opensuseGuest"
	VirtualMachineGuestOsIdentifier_Opensuse64Guest         VirtualMachineGuestOsIdentifier = "opensuse64Guest"
	VirtualMachineGuestOsIdentifier_FedoraGuest             VirtualMachineGuestOsIdentifier = "fedoraGuest"
	VirtualMachineGuestOsIdentifier_Fedora64Guest           VirtualMachineGuestOsIdentifier = "fedora64Guest"
	VirtualMachineGuestOsIdentifier_Other24xLinuxGuest      VirtualMachineGuestOsIdentifier = "other24xLinuxGuest"
	VirtualMachineGuestOsIdentifier_Other26xLinuxGuest      VirtualMachineGuestOsIdentifier = "other26xLinuxGuest"
	VirtualMachineGuestOsIdentifier_OtherLinuxGuest         VirtualMachineGuestOsIdentifier = "otherLinuxGuest"
	VirtualMachineGuestOsIdentifier_Other3xLinuxGuest       VirtualMachineGuestOsIdentifier = "other3xLinuxGuest"
	VirtualMachineGuestOsIdentifier_GenericLinuxGuest       VirtualMachineGuestOsIdentifier = "genericLinuxGuest"
	VirtualMachineGuestOsIdentifier_Other24xLinux64Guest    VirtualMachineGuestOsIdentifier = "other24xLinux64Guest"
	VirtualMachineGuestOsIdentifier_Other26xLinux64Guest    VirtualMachineGuestOsIdentifier = "other26xLinux64Guest"
	VirtualMachineGuestOsIdentifier_Other3xLinux64Guest     VirtualMachineGuestOsIdentifier = "other3xLinux64Guest"
	VirtualMachineGuestOsIdentifier_OtherLinux64Guest       VirtualMachineGuestOsIdentifier = "otherLinux64Guest"
	VirtualMachineGuestOsIdentifier_Solaris6Guest           VirtualMachineGuestOsIdentifier = "solaris6Guest"
	VirtualMachineGuestOsIdentifier_Solaris7Guest           VirtualMachineGuestOsIdentifier = "solaris7Guest"
	VirtualMachineGuestOsIdentifier_Solaris8Guest           VirtualMachineGuestOsIdentifier = "solaris8Guest"
	VirtualMachineGuestOsIdentifier_Solaris9Guest           VirtualMachineGuestOsIdentifier = "solaris9Guest"
	VirtualMachineGuestOsIdentifier_Solaris10Guest          VirtualMachineGuestOsIdentifier = "solaris10Guest"
	VirtualMachineGuestOsIdentifier_Solaris10_64Guest       VirtualMachineGuestOsIdentifier = "solaris10_64Guest"
	VirtualMachineGuestOsIdentifier_Solaris11_64Guest       VirtualMachineGuestOsIdentifier = "solaris11_64Guest"
	VirtualMachineGuestOsIdentifier_Os2Guest                VirtualMachineGuestOsIdentifier = "os2Guest"
	VirtualMachineGuestOsIdentifier_EComStationGuest        VirtualMachineGuestOsIdentifier = "eComStationGuest"
	VirtualMachineGuestOsIdentifier_EComStation2Guest       VirtualMachineGuestOsIdentifier = "eComStation2Guest"
	VirtualMachineGuestOsIdentifier_Netware4Guest           VirtualMachineGuestOsIdentifier = "netware4Guest"
	VirtualMachineGuestOsIdentifier_Netware5Guest           VirtualMachineGuestOsIdentifier = "netware5Guest"
	VirtualMachineGuestOsIdentifier_Netware6Guest           VirtualMachineGuestOsIdentifier = "netware6Guest"
	VirtualMachineGuestOsIdentifier_OpenServer5Guest        VirtualMachineGuestOsIdentifier = "openServer5Guest"
	VirtualMachineGuestOsIdentifier_OpenServer6Guest        VirtualMachineGuestOsIdentifier = "openServer6Guest"
	VirtualMachineGuestOsIdentifier_UnixWare7Guest          VirtualMachineGuestOsIdentifier = "unixWare7Guest"
	VirtualMachineGuestOsIdentifier_DarwinGuest             VirtualMachineGuestOsIdentifier = "darwinGuest"
	VirtualMachineGuestOsIdentifier_Darwin64Guest           VirtualMachineGuestOsIdentifier = "darwin64Guest"
	VirtualMachineGuestOsIdentifier_Darwin10Guest           VirtualMachineGuestOsIdentifier = "darwin10Guest"
	VirtualMachineGuestOsIdentifier_Darwin10_64Guest        VirtualMachineGuestOsIdentifier = "darwin10_64Guest"
	VirtualMachineGuestOsIdentifier_Darwin11Guest           VirtualMachineGuestOsIdentifier = "darwin11Guest"
	VirtualMachineGuestOsIdentifier_Darwin11_64Guest        VirtualMachineGuestOsIdentifier = "darwin11_64Guest"
	VirtualMachineGuestOsIdentifier_Darwin12_64Guest        VirtualMachineGuestOsIdentifier = "darwin12_64Guest"
	VirtualMachineGuestOsIdentifier_Darwin13_64Guest        VirtualMachineGuestOsIdentifier = "darwin13_64Guest"
	VirtualMachineGuestOsIdentifier_VmkernelGuest           VirtualMachineGuestOsIdentifier = "vmkernelGuest"
	VirtualMachineGuestOsIdentifier_Vmkernel5Guest          VirtualMachineGuestOsIdentifier = "vmkernel5Guest"
	VirtualMachineGuestOsIdentifier_OtherGuest              VirtualMachineGuestOsIdentifier = "otherGuest"
	VirtualMachineGuestOsIdentifier_OtherGuest64            VirtualMachineGuestOsIdentifier = "otherGuest64"
)

type GuestOsDescriptorFirmwareType string

const (
	GuestOsDescriptorFirmwareType_Bios GuestOsDescriptorFirmwareType = "bios"
	GuestOsDescriptorFirmwareType_Efi  GuestOsDescriptorFirmwareType = "efi"
)

type GuestOsDescriptorSupportLevel string

const (
	GuestOsDescriptorSupportLevel_Experimental GuestOsDescriptorSupportLevel = "experimental"
	GuestOsDescriptorSupportLevel_Legacy       GuestOsDescriptorSupportLevel = "legacy"
	GuestOsDescriptorSupportLevel_Terminated   GuestOsDescriptorSupportLevel = "terminated"
	GuestOsDescriptorSupportLevel_Supported    GuestOsDescriptorSupportLevel = "supported"
	GuestOsDescriptorSupportLevel_Unsupported  GuestOsDescriptorSupportLevel = "unsupported"
	GuestOsDescriptorSupportLevel_Deprecated   GuestOsDescriptorSupportLevel = "deprecated"
	GuestOsDescriptorSupportLevel_TechPreview  GuestOsDescriptorSupportLevel = "techPreview"
)

type VirtualMachineMetadataManagerVmMetadataOwnerOwner string

const (
	VirtualMachineMetadataManagerVmMetadataOwnerOwner_ComVmwareVsphereHA VirtualMachineMetadataManagerVmMetadataOwnerOwner = "ComVmwareVsphereHA"
)

type VirtualMachineMetadataManagerVmMetadataOp string

const (
	VirtualMachineMetadataManagerVmMetadataOp_Update VirtualMachineMetadataManagerVmMetadataOp = "Update"
	VirtualMachineMetadataManagerVmMetadataOp_Remove VirtualMachineMetadataManagerVmMetadataOp = "Remove"
)

type VirtualMachineRelocateTransformation string

const (
	VirtualMachineRelocateTransformation_Flat   VirtualMachineRelocateTransformation = "flat"
	VirtualMachineRelocateTransformation_Sparse VirtualMachineRelocateTransformation = "sparse"
)

type VirtualMachineRelocateDiskMoveOptions string

const (
	VirtualMachineRelocateDiskMoveOptions_MoveAllDiskBackingsAndAllowSharing    VirtualMachineRelocateDiskMoveOptions = "moveAllDiskBackingsAndAllowSharing"
	VirtualMachineRelocateDiskMoveOptions_MoveAllDiskBackingsAndDisallowSharing VirtualMachineRelocateDiskMoveOptions = "moveAllDiskBackingsAndDisallowSharing"
	VirtualMachineRelocateDiskMoveOptions_MoveChildMostDiskBacking              VirtualMachineRelocateDiskMoveOptions = "moveChildMostDiskBacking"
	VirtualMachineRelocateDiskMoveOptions_CreateNewChildDiskBacking             VirtualMachineRelocateDiskMoveOptions = "createNewChildDiskBacking"
	VirtualMachineRelocateDiskMoveOptions_MoveAllDiskBackingsAndConsolidate     VirtualMachineRelocateDiskMoveOptions = "moveAllDiskBackingsAndConsolidate"
)

type ScheduledHardwareUpgradeInfoHardwareUpgradePolicy string

const (
	ScheduledHardwareUpgradeInfoHardwareUpgradePolicy_Never          ScheduledHardwareUpgradeInfoHardwareUpgradePolicy = "never"
	ScheduledHardwareUpgradeInfoHardwareUpgradePolicy_OnSoftPowerOff ScheduledHardwareUpgradeInfoHardwareUpgradePolicy = "onSoftPowerOff"
	ScheduledHardwareUpgradeInfoHardwareUpgradePolicy_Always         ScheduledHardwareUpgradeInfoHardwareUpgradePolicy = "always"
)

type ScheduledHardwareUpgradeInfoHardwareUpgradeStatus string

const (
	ScheduledHardwareUpgradeInfoHardwareUpgradeStatus_None    ScheduledHardwareUpgradeInfoHardwareUpgradeStatus = "none"
	ScheduledHardwareUpgradeInfoHardwareUpgradeStatus_Pending ScheduledHardwareUpgradeInfoHardwareUpgradeStatus = "pending"
	ScheduledHardwareUpgradeInfoHardwareUpgradeStatus_Success ScheduledHardwareUpgradeInfoHardwareUpgradeStatus = "success"
	ScheduledHardwareUpgradeInfoHardwareUpgradeStatus_Failed  ScheduledHardwareUpgradeInfoHardwareUpgradeStatus = "failed"
)

type VirtualMachineScsiPassthroughType string

const (
	VirtualMachineScsiPassthroughType_Disk      VirtualMachineScsiPassthroughType = "disk"
	VirtualMachineScsiPassthroughType_Tape      VirtualMachineScsiPassthroughType = "tape"
	VirtualMachineScsiPassthroughType_Printer   VirtualMachineScsiPassthroughType = "printer"
	VirtualMachineScsiPassthroughType_Processor VirtualMachineScsiPassthroughType = "processor"
	VirtualMachineScsiPassthroughType_Worm      VirtualMachineScsiPassthroughType = "worm"
	VirtualMachineScsiPassthroughType_Cdrom     VirtualMachineScsiPassthroughType = "cdrom"
	VirtualMachineScsiPassthroughType_Scanner   VirtualMachineScsiPassthroughType = "scanner"
	VirtualMachineScsiPassthroughType_Optical   VirtualMachineScsiPassthroughType = "optical"
	VirtualMachineScsiPassthroughType_Media     VirtualMachineScsiPassthroughType = "media"
	VirtualMachineScsiPassthroughType_Com       VirtualMachineScsiPassthroughType = "com"
	VirtualMachineScsiPassthroughType_Raid      VirtualMachineScsiPassthroughType = "raid"
	VirtualMachineScsiPassthroughType_Unknown   VirtualMachineScsiPassthroughType = "unknown"
)

type VirtualMachineTargetInfoConfigurationTag string

const (
	VirtualMachineTargetInfoConfigurationTag_Compliant   VirtualMachineTargetInfoConfigurationTag = "compliant"
	VirtualMachineTargetInfoConfigurationTag_ClusterWide VirtualMachineTargetInfoConfigurationTag = "clusterWide"
)

type UpgradePolicy string

const (
	UpgradePolicy_Manual              UpgradePolicy = "manual"
	UpgradePolicy_UpgradeAtPowerCycle UpgradePolicy = "upgradeAtPowerCycle"
)

type VirtualMachineUsbInfoSpeed string

const (
	VirtualMachineUsbInfoSpeed_Low          VirtualMachineUsbInfoSpeed = "low"
	VirtualMachineUsbInfoSpeed_Full         VirtualMachineUsbInfoSpeed = "full"
	VirtualMachineUsbInfoSpeed_High         VirtualMachineUsbInfoSpeed = "high"
	VirtualMachineUsbInfoSpeed_SuperSpeed   VirtualMachineUsbInfoSpeed = "superSpeed"
	VirtualMachineUsbInfoSpeed_UnknownSpeed VirtualMachineUsbInfoSpeed = "unknownSpeed"
)

type VirtualMachineUsbInfoFamily string

const (
	VirtualMachineUsbInfoFamily_Audio           VirtualMachineUsbInfoFamily = "audio"
	VirtualMachineUsbInfoFamily_Hid             VirtualMachineUsbInfoFamily = "hid"
	VirtualMachineUsbInfoFamily_Hid_bootable    VirtualMachineUsbInfoFamily = "hid_bootable"
	VirtualMachineUsbInfoFamily_Physical        VirtualMachineUsbInfoFamily = "physical"
	VirtualMachineUsbInfoFamily_Communication   VirtualMachineUsbInfoFamily = "communication"
	VirtualMachineUsbInfoFamily_Imaging         VirtualMachineUsbInfoFamily = "imaging"
	VirtualMachineUsbInfoFamily_Printer         VirtualMachineUsbInfoFamily = "printer"
	VirtualMachineUsbInfoFamily_Storage         VirtualMachineUsbInfoFamily = "storage"
	VirtualMachineUsbInfoFamily_Hub             VirtualMachineUsbInfoFamily = "hub"
	VirtualMachineUsbInfoFamily_Smart_card      VirtualMachineUsbInfoFamily = "smart_card"
	VirtualMachineUsbInfoFamily_Security        VirtualMachineUsbInfoFamily = "security"
	VirtualMachineUsbInfoFamily_Video           VirtualMachineUsbInfoFamily = "video"
	VirtualMachineUsbInfoFamily_Wireless        VirtualMachineUsbInfoFamily = "wireless"
	VirtualMachineUsbInfoFamily_Bluetooth       VirtualMachineUsbInfoFamily = "bluetooth"
	VirtualMachineUsbInfoFamily_Wusb            VirtualMachineUsbInfoFamily = "wusb"
	VirtualMachineUsbInfoFamily_Pda             VirtualMachineUsbInfoFamily = "pda"
	VirtualMachineUsbInfoFamily_Vendor_specific VirtualMachineUsbInfoFamily = "vendor_specific"
	VirtualMachineUsbInfoFamily_Other           VirtualMachineUsbInfoFamily = "other"
	VirtualMachineUsbInfoFamily_UnknownFamily   VirtualMachineUsbInfoFamily = "unknownFamily"
)

type CheckTestType string

const (
	CheckTestType_SourceTests       CheckTestType = "sourceTests"
	CheckTestType_HostTests         CheckTestType = "hostTests"
	CheckTestType_ResourcePoolTests CheckTestType = "resourcePoolTests"
	CheckTestType_DatastoreTests    CheckTestType = "datastoreTests"
	CheckTestType_NetworkTests      CheckTestType = "networkTests"
)

type CustomizationNetBIOSMode string

const (
	CustomizationNetBIOSMode_EnableNetBIOSViaDhcp CustomizationNetBIOSMode = "enableNetBIOSViaDhcp"
	CustomizationNetBIOSMode_EnableNetBIOS        CustomizationNetBIOSMode = "enableNetBIOS"
	CustomizationNetBIOSMode_DisableNetBIOS       CustomizationNetBIOSMode = "disableNetBIOS"
)

type CustomizationSysprepRebootOption string

const (
	CustomizationSysprepRebootOption_Reboot   CustomizationSysprepRebootOption = "reboot"
	CustomizationSysprepRebootOption_Noreboot CustomizationSysprepRebootOption = "noreboot"
	CustomizationSysprepRebootOption_Shutdown CustomizationSysprepRebootOption = "shutdown"
)

type CustomizationLicenseDataMode string

const (
	CustomizationLicenseDataMode_PerServer CustomizationLicenseDataMode = "perServer"
	CustomizationLicenseDataMode_PerSeat   CustomizationLicenseDataMode = "perSeat"
)

type VirtualDeviceConnectInfoStatus string

const (
	VirtualDeviceConnectInfoStatus_Ok                 VirtualDeviceConnectInfoStatus = "ok"
	VirtualDeviceConnectInfoStatus_RecoverableError   VirtualDeviceConnectInfoStatus = "recoverableError"
	VirtualDeviceConnectInfoStatus_UnrecoverableError VirtualDeviceConnectInfoStatus = "unrecoverableError"
	VirtualDeviceConnectInfoStatus_Untried            VirtualDeviceConnectInfoStatus = "untried"
)

type VirtualDeviceFileExtension string

const (
	VirtualDeviceFileExtension_Iso  VirtualDeviceFileExtension = "iso"
	VirtualDeviceFileExtension_Flp  VirtualDeviceFileExtension = "flp"
	VirtualDeviceFileExtension_Vmdk VirtualDeviceFileExtension = "vmdk"
	VirtualDeviceFileExtension_Dsk  VirtualDeviceFileExtension = "dsk"
	VirtualDeviceFileExtension_Rdm  VirtualDeviceFileExtension = "rdm"
)

type VirtualDeviceURIBackingOptionDirection string

const (
	VirtualDeviceURIBackingOptionDirection_Server VirtualDeviceURIBackingOptionDirection = "server"
	VirtualDeviceURIBackingOptionDirection_Client VirtualDeviceURIBackingOptionDirection = "client"
)

type VirtualDeviceConfigSpecOperation string

const (
	VirtualDeviceConfigSpecOperation_Add    VirtualDeviceConfigSpecOperation = "add"
	VirtualDeviceConfigSpecOperation_Remove VirtualDeviceConfigSpecOperation = "remove"
	VirtualDeviceConfigSpecOperation_Edit   VirtualDeviceConfigSpecOperation = "edit"
)

type VirtualDeviceConfigSpecFileOperation string

const (
	VirtualDeviceConfigSpecFileOperation_Create  VirtualDeviceConfigSpecFileOperation = "create"
	VirtualDeviceConfigSpecFileOperation_Destroy VirtualDeviceConfigSpecFileOperation = "destroy"
	VirtualDeviceConfigSpecFileOperation_Replace VirtualDeviceConfigSpecFileOperation = "replace"
)

type VirtualDiskDeltaDiskFormat string

const (
	VirtualDiskDeltaDiskFormat_RedoLogFormat  VirtualDiskDeltaDiskFormat = "redoLogFormat"
	VirtualDiskDeltaDiskFormat_NativeFormat   VirtualDiskDeltaDiskFormat = "nativeFormat"
	VirtualDiskDeltaDiskFormat_SeSparseFormat VirtualDiskDeltaDiskFormat = "seSparseFormat"
)

type VirtualDiskVFlashCacheConfigInfoCacheConsistencyType string

const (
	VirtualDiskVFlashCacheConfigInfoCacheConsistencyType_Strong VirtualDiskVFlashCacheConfigInfoCacheConsistencyType = "strong"
	VirtualDiskVFlashCacheConfigInfoCacheConsistencyType_Weak   VirtualDiskVFlashCacheConfigInfoCacheConsistencyType = "weak"
)

type VirtualDiskVFlashCacheConfigInfoCacheMode string

const (
	VirtualDiskVFlashCacheConfigInfoCacheMode_Write_thru VirtualDiskVFlashCacheConfigInfoCacheMode = "write_thru"
	VirtualDiskVFlashCacheConfigInfoCacheMode_Write_back VirtualDiskVFlashCacheConfigInfoCacheMode = "write_back"
)

type VirtualDiskMode string

const (
	VirtualDiskMode_Persistent                VirtualDiskMode = "persistent"
	VirtualDiskMode_Nonpersistent             VirtualDiskMode = "nonpersistent"
	VirtualDiskMode_Undoable                  VirtualDiskMode = "undoable"
	VirtualDiskMode_Independent_persistent    VirtualDiskMode = "independent_persistent"
	VirtualDiskMode_Independent_nonpersistent VirtualDiskMode = "independent_nonpersistent"
	VirtualDiskMode_Append                    VirtualDiskMode = "append"
)

type VirtualDiskCompatibilityMode string

const (
	VirtualDiskCompatibilityMode_VirtualMode  VirtualDiskCompatibilityMode = "virtualMode"
	VirtualDiskCompatibilityMode_PhysicalMode VirtualDiskCompatibilityMode = "physicalMode"
)

type VirtualEthernetCardLegacyNetworkDeviceName string

const (
	VirtualEthernetCardLegacyNetworkDeviceName_Bridged  VirtualEthernetCardLegacyNetworkDeviceName = "bridged"
	VirtualEthernetCardLegacyNetworkDeviceName_Nat      VirtualEthernetCardLegacyNetworkDeviceName = "nat"
	VirtualEthernetCardLegacyNetworkDeviceName_Hostonly VirtualEthernetCardLegacyNetworkDeviceName = "hostonly"
)

type VirtualEthernetCardMacType string

const (
	VirtualEthernetCardMacType_Manual    VirtualEthernetCardMacType = "manual"
	VirtualEthernetCardMacType_Generated VirtualEthernetCardMacType = "generated"
	VirtualEthernetCardMacType_Assigned  VirtualEthernetCardMacType = "assigned"
)

type VirtualPointingDeviceHostChoice string

const (
	VirtualPointingDeviceHostChoice_Autodetect           VirtualPointingDeviceHostChoice = "autodetect"
	VirtualPointingDeviceHostChoice_IntellimouseExplorer VirtualPointingDeviceHostChoice = "intellimouseExplorer"
	VirtualPointingDeviceHostChoice_IntellimousePs2      VirtualPointingDeviceHostChoice = "intellimousePs2"
	VirtualPointingDeviceHostChoice_LogitechMouseman     VirtualPointingDeviceHostChoice = "logitechMouseman"
	VirtualPointingDeviceHostChoice_Microsoft_serial     VirtualPointingDeviceHostChoice = "microsoft_serial"
	VirtualPointingDeviceHostChoice_MouseSystems         VirtualPointingDeviceHostChoice = "mouseSystems"
	VirtualPointingDeviceHostChoice_MousemanSerial       VirtualPointingDeviceHostChoice = "mousemanSerial"
	VirtualPointingDeviceHostChoice_Ps2                  VirtualPointingDeviceHostChoice = "ps2"
)

type VirtualSCSISharing string

const (
	VirtualSCSISharing_NoSharing       VirtualSCSISharing = "noSharing"
	VirtualSCSISharing_VirtualSharing  VirtualSCSISharing = "virtualSharing"
	VirtualSCSISharing_PhysicalSharing VirtualSCSISharing = "physicalSharing"
)

type VirtualSerialPortEndPoint string

const (
	VirtualSerialPortEndPoint_Client VirtualSerialPortEndPoint = "client"
	VirtualSerialPortEndPoint_Server VirtualSerialPortEndPoint = "server"
)

type VirtualMachineVideoCardUse3dRenderer string

const (
	VirtualMachineVideoCardUse3dRenderer_Automatic VirtualMachineVideoCardUse3dRenderer = "automatic"
	VirtualMachineVideoCardUse3dRenderer_Software  VirtualMachineVideoCardUse3dRenderer = "software"
	VirtualMachineVideoCardUse3dRenderer_Hardware  VirtualMachineVideoCardUse3dRenderer = "hardware"
)

type GuestFileType string

const (
	GuestFileType_File      GuestFileType = "file"
	GuestFileType_Directory GuestFileType = "directory"
	GuestFileType_Symlink   GuestFileType = "symlink"
)

type VsanHostDecommissionModeObjectAction string

const (
	VsanHostDecommissionModeObjectAction_NoAction                  VsanHostDecommissionModeObjectAction = "noAction"
	VsanHostDecommissionModeObjectAction_EnsureObjectAccessibility VsanHostDecommissionModeObjectAction = "ensureObjectAccessibility"
	VsanHostDecommissionModeObjectAction_EvacuateAllData           VsanHostDecommissionModeObjectAction = "evacuateAllData"
)

type VsanHostDiskResultState string

const (
	VsanHostDiskResultState_InUse      VsanHostDiskResultState = "inUse"
	VsanHostDiskResultState_Eligible   VsanHostDiskResultState = "eligible"
	VsanHostDiskResultState_Ineligible VsanHostDiskResultState = "ineligible"
)

type VsanHostHealthState string

const (
	VsanHostHealthState_Unknown   VsanHostHealthState = "unknown"
	VsanHostHealthState_Healthy   VsanHostHealthState = "healthy"
	VsanHostHealthState_Unhealthy VsanHostHealthState = "unhealthy"
)

type VsanHostNodeState string

const (
	VsanHostNodeState_Error                   VsanHostNodeState = "error"
	VsanHostNodeState_Disabled                VsanHostNodeState = "disabled"
	VsanHostNodeState_Agent                   VsanHostNodeState = "agent"
	VsanHostNodeState_Master                  VsanHostNodeState = "master"
	VsanHostNodeState_Backup                  VsanHostNodeState = "backup"
	VsanHostNodeState_Starting                VsanHostNodeState = "starting"
	VsanHostNodeState_Stopping                VsanHostNodeState = "stopping"
	VsanHostNodeState_EnteringMaintenanceMode VsanHostNodeState = "enteringMaintenanceMode"
	VsanHostNodeState_ExitingMaintenanceMode  VsanHostNodeState = "exitingMaintenanceMode"
	VsanHostNodeState_Decommissioning         VsanHostNodeState = "decommissioning"
)

type VsanDiskIssueType string

const (
	VsanDiskIssueType_NonExist      VsanDiskIssueType = "nonExist"
	VsanDiskIssueType_StampMismatch VsanDiskIssueType = "stampMismatch"
	VsanDiskIssueType_Unknown       VsanDiskIssueType = "unknown"
)

type AboutInfo struct {
	*DynamicData

	name                  string `xml:"name,omitempty"`
	fullName              string `xml:"fullName,omitempty"`
	vendor                string `xml:"vendor,omitempty"`
	version               string `xml:"version,omitempty"`
	build                 string `xml:"build,omitempty"`
	localeVersion         string `xml:"localeVersion,omitempty"`
	localeBuild           string `xml:"localeBuild,omitempty"`
	osType                string `xml:"osType,omitempty"`
	productLineId         string `xml:"productLineId,omitempty"`
	apiType               string `xml:"apiType,omitempty"`
	apiVersion            string `xml:"apiVersion,omitempty"`
	instanceUuid          string `xml:"instanceUuid,omitempty"`
	licenseProductName    string `xml:"licenseProductName,omitempty"`
	licenseProductVersion string `xml:"licenseProductVersion,omitempty"`
}

type AuthorizationDescription struct {
	*DynamicData

	privilege      []*ElementDescription `xml:"privilege,omitempty"`
	privilegeGroup []*ElementDescription `xml:"privilegeGroup,omitempty"`
}

type Permission struct {
	*DynamicData

	entity    *ManagedObjectReference `xml:"entity,omitempty"`
	principal string                  `xml:"principal,omitempty"`
	group     bool                    `xml:"group,omitempty"`
	roleId    int32                   `xml:"roleId,omitempty"`
	propagate bool                    `xml:"propagate,omitempty"`
}

type ArrayOfPermission struct {
	Permission []*Permission `xml:"Permission,omitempty"`
}

type AuthorizationRole struct {
	*DynamicData

	roleId    int32        `xml:"roleId,omitempty"`
	system    bool         `xml:"system,omitempty"`
	name      string       `xml:"name,omitempty"`
	info      *Description `xml:"info,omitempty"`
	privilege []string     `xml:"privilege,omitempty"`
}

type ArrayOfAuthorizationRole struct {
	AuthorizationRole []*AuthorizationRole `xml:"AuthorizationRole,omitempty"`
}

type AuthorizationPrivilege struct {
	*DynamicData

	privId        string `xml:"privId,omitempty"`
	onParent      bool   `xml:"onParent,omitempty"`
	name          string `xml:"name,omitempty"`
	privGroupName string `xml:"privGroupName,omitempty"`
}

type ArrayOfAuthorizationPrivilege struct {
	AuthorizationPrivilege []*AuthorizationPrivilege `xml:"AuthorizationPrivilege,omitempty"`
}

type PrivilegeAvailability struct {
	*DynamicData

	privId    string `xml:"privId,omitempty"`
	isGranted bool   `xml:"isGranted,omitempty"`
}

type ArrayOfPrivilegeAvailability struct {
	PrivilegeAvailability []*PrivilegeAvailability `xml:"PrivilegeAvailability,omitempty"`
}

type EntityPrivilege struct {
	*DynamicData

	entity           *ManagedObjectReference  `xml:"entity,omitempty"`
	privAvailability []*PrivilegeAvailability `xml:"privAvailability,omitempty"`
}

type ArrayOfEntityPrivilege struct {
	EntityPrivilege []*EntityPrivilege `xml:"EntityPrivilege,omitempty"`
}

type BoolPolicy struct {
	*InheritablePolicy

	value bool `xml:"value,omitempty"`
}

type Capability struct {
	*DynamicData

	provisioningSupported            bool       `xml:"provisioningSupported,omitempty"`
	multiHostSupported               bool       `xml:"multiHostSupported,omitempty"`
	userShellAccessSupported         bool       `xml:"userShellAccessSupported,omitempty"`
	supportedEVCMode                 []*EVCMode `xml:"supportedEVCMode,omitempty"`
	networkBackupAndRestoreSupported bool       `xml:"networkBackupAndRestoreSupported,omitempty"`
}

type ClusterComputeResourceSummary struct {
	*ComputeResourceSummary

	currentFailoverLevel int32                           `xml:"currentFailoverLevel,omitempty"`
	admissionControlInfo *ClusterDasAdmissionControlInfo `xml:"admissionControlInfo,omitempty"`
	numVmotions          int32                           `xml:"numVmotions,omitempty"`
	targetBalance        int32                           `xml:"targetBalance,omitempty"`
	currentBalance       int32                           `xml:"currentBalance,omitempty"`
	currentEVCModeKey    string                          `xml:"currentEVCModeKey,omitempty"`
	dasData              *ClusterDasData                 `xml:"dasData,omitempty"`
}

type ComputeResourceSummary struct {
	*DynamicData

	totalCpu          int32                `xml:"totalCpu,omitempty"`
	totalMemory       int64                `xml:"totalMemory,omitempty"`
	numCpuCores       int16                `xml:"numCpuCores,omitempty"`
	numCpuThreads     int16                `xml:"numCpuThreads,omitempty"`
	effectiveCpu      int32                `xml:"effectiveCpu,omitempty"`
	effectiveMemory   int64                `xml:"effectiveMemory,omitempty"`
	numHosts          int32                `xml:"numHosts,omitempty"`
	numEffectiveHosts int32                `xml:"numEffectiveHosts,omitempty"`
	overallStatus     *ManagedEntityStatus `xml:"overallStatus,omitempty"`
}

type ComputeResourceConfigInfo struct {
	*DynamicData

	vmSwapPlacement           string `xml:"vmSwapPlacement,omitempty"`
	spbmEnabled               bool   `xml:"spbmEnabled,omitempty"`
	defaultHardwareVersionKey string `xml:"defaultHardwareVersionKey,omitempty"`
}

type ComputeResourceHostSPBMLicenseInfo struct {
	*DynamicData

	host         *ManagedObjectReference                                 `xml:"host,omitempty"`
	licenseState *ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState `xml:"licenseState,omitempty"`
}

type ArrayOfComputeResourceHostSPBMLicenseInfo struct {
	ComputeResourceHostSPBMLicenseInfo []*ComputeResourceHostSPBMLicenseInfo `xml:"ComputeResourceHostSPBMLicenseInfo,omitempty"`
}

type ComputeResourceConfigSpec struct {
	*DynamicData

	vmSwapPlacement           string `xml:"vmSwapPlacement,omitempty"`
	spbmEnabled               bool   `xml:"spbmEnabled,omitempty"`
	defaultHardwareVersionKey string `xml:"defaultHardwareVersionKey,omitempty"`
}

type CustomFieldDef struct {
	*DynamicData

	key                     int32               `xml:"key,omitempty"`
	name                    string              `xml:"name,omitempty"`
	type_                   string              `xml:"type,omitempty"`
	managedObjectType       string              `xml:"managedObjectType,omitempty"`
	fieldDefPrivileges      *PrivilegePolicyDef `xml:"fieldDefPrivileges,omitempty"`
	fieldInstancePrivileges *PrivilegePolicyDef `xml:"fieldInstancePrivileges,omitempty"`
}

type ArrayOfCustomFieldDef struct {
	CustomFieldDef []*CustomFieldDef `xml:"CustomFieldDef,omitempty"`
}

type CustomFieldValue struct {
	*DynamicData

	key int32 `xml:"key,omitempty"`
}

type ArrayOfCustomFieldValue struct {
	CustomFieldValue []*CustomFieldValue `xml:"CustomFieldValue,omitempty"`
}

type CustomFieldStringValue struct {
	*CustomFieldValue

	value string `xml:"value,omitempty"`
}

type CustomizationSpecInfo struct {
	*DynamicData

	name           string    `xml:"name,omitempty"`
	description    string    `xml:"description,omitempty"`
	type_          string    `xml:"type,omitempty"`
	changeVersion  string    `xml:"changeVersion,omitempty"`
	lastUpdateTime time.Time `xml:"lastUpdateTime,omitempty"`
}

type ArrayOfCustomizationSpecInfo struct {
	CustomizationSpecInfo []*CustomizationSpecInfo `xml:"CustomizationSpecInfo,omitempty"`
}

type CustomizationSpecItem struct {
	*DynamicData

	info *CustomizationSpecInfo `xml:"info,omitempty"`
	spec *CustomizationSpec     `xml:"spec,omitempty"`
}

type DatacenterConfigInfo struct {
	*DynamicData

	defaultHardwareVersionKey string `xml:"defaultHardwareVersionKey,omitempty"`
}

type DatacenterConfigSpec struct {
	*DynamicData

	defaultHardwareVersionKey string `xml:"defaultHardwareVersionKey,omitempty"`
}

type DatastoreSummary struct {
	*DynamicData

	datastore          *ManagedObjectReference `xml:"datastore,omitempty"`
	name               string                  `xml:"name,omitempty"`
	url                string                  `xml:"url,omitempty"`
	capacity           int64                   `xml:"capacity,omitempty"`
	freeSpace          int64                   `xml:"freeSpace,omitempty"`
	uncommitted        int64                   `xml:"uncommitted,omitempty"`
	accessible         bool                    `xml:"accessible,omitempty"`
	multipleHostAccess bool                    `xml:"multipleHostAccess,omitempty"`
	type_              string                  `xml:"type,omitempty"`
	maintenanceMode    string                  `xml:"maintenanceMode,omitempty"`
}

type DatastoreInfo struct {
	*DynamicData

	name                   string    `xml:"name,omitempty"`
	url                    string    `xml:"url,omitempty"`
	freeSpace              int64     `xml:"freeSpace,omitempty"`
	maxFileSize            int64     `xml:"maxFileSize,omitempty"`
	maxVirtualDiskCapacity int64     `xml:"maxVirtualDiskCapacity,omitempty"`
	timestamp              time.Time `xml:"timestamp,omitempty"`
	containerId            string    `xml:"containerId,omitempty"`
}

type DatastoreCapability struct {
	*DynamicData

	directoryHierarchySupported      bool `xml:"directoryHierarchySupported,omitempty"`
	rawDiskMappingsSupported         bool `xml:"rawDiskMappingsSupported,omitempty"`
	perFileThinProvisioningSupported bool `xml:"perFileThinProvisioningSupported,omitempty"`
	storageIORMSupported             bool `xml:"storageIORMSupported,omitempty"`
	nativeSnapshotSupported          bool `xml:"nativeSnapshotSupported,omitempty"`
	topLevelDirectoryCreateSupported bool `xml:"topLevelDirectoryCreateSupported,omitempty"`
	seSparseSupported                bool `xml:"seSparseSupported,omitempty"`
}

type DatastoreHostMount struct {
	*DynamicData

	key       *ManagedObjectReference `xml:"key,omitempty"`
	mountInfo *HostMountInfo          `xml:"mountInfo,omitempty"`
}

type ArrayOfDatastoreHostMount struct {
	DatastoreHostMount []*DatastoreHostMount `xml:"DatastoreHostMount,omitempty"`
}

type DatastoreMountPathDatastorePair struct {
	*DynamicData

	oldMountPath string                  `xml:"oldMountPath,omitempty"`
	datastore    *ManagedObjectReference `xml:"datastore,omitempty"`
}

type ArrayOfDatastoreMountPathDatastorePair struct {
	DatastoreMountPathDatastorePair []*DatastoreMountPathDatastorePair `xml:"DatastoreMountPathDatastorePair,omitempty"`
}

type Description struct {
	*DynamicData

	label   string `xml:"label,omitempty"`
	summary string `xml:"summary,omitempty"`
}

type DiagnosticManagerLogDescriptor struct {
	*DynamicData

	key      string       `xml:"key,omitempty"`
	fileName string       `xml:"fileName,omitempty"`
	creator  string       `xml:"creator,omitempty"`
	format   string       `xml:"format,omitempty"`
	mimeType string       `xml:"mimeType,omitempty"`
	info     *Description `xml:"info,omitempty"`
}

type ArrayOfDiagnosticManagerLogDescriptor struct {
	DiagnosticManagerLogDescriptor []*DiagnosticManagerLogDescriptor `xml:"DiagnosticManagerLogDescriptor,omitempty"`
}

type DiagnosticManagerLogHeader struct {
	*DynamicData

	lineStart int32    `xml:"lineStart,omitempty"`
	lineEnd   int32    `xml:"lineEnd,omitempty"`
	lineText  []string `xml:"lineText,omitempty"`
}

type DiagnosticManagerBundleInfo struct {
	*DynamicData

	system *ManagedObjectReference `xml:"system,omitempty"`
	url    string                  `xml:"url,omitempty"`
}

type ArrayOfDiagnosticManagerBundleInfo struct {
	DiagnosticManagerBundleInfo []*DiagnosticManagerBundleInfo `xml:"DiagnosticManagerBundleInfo,omitempty"`
}

type DVSContactInfo struct {
	*DynamicData

	name    string `xml:"name,omitempty"`
	contact string `xml:"contact,omitempty"`
}

type DVSNetworkResourceManagementCapability struct {
	*DynamicData

	networkResourceManagementSupported       bool  `xml:"networkResourceManagementSupported,omitempty"`
	networkResourcePoolHighShareValue        int32 `xml:"networkResourcePoolHighShareValue,omitempty"`
	qosSupported                             bool  `xml:"qosSupported,omitempty"`
	userDefinedNetworkResourcePoolsSupported bool  `xml:"userDefinedNetworkResourcePoolsSupported,omitempty"`
}

type DVSRollbackCapability struct {
	*DynamicData

	rollbackSupported bool `xml:"rollbackSupported,omitempty"`
}

type DVSBackupRestoreCapability struct {
	*DynamicData

	backupRestoreSupported bool `xml:"backupRestoreSupported,omitempty"`
}

type DVSFeatureCapability struct {
	*DynamicData

	networkResourceManagementSupported  bool                                    `xml:"networkResourceManagementSupported,omitempty"`
	vmDirectPathGen2Supported           bool                                    `xml:"vmDirectPathGen2Supported,omitempty"`
	nicTeamingPolicy                    []string                                `xml:"nicTeamingPolicy,omitempty"`
	networkResourcePoolHighShareValue   int32                                   `xml:"networkResourcePoolHighShareValue,omitempty"`
	networkResourceManagementCapability *DVSNetworkResourceManagementCapability `xml:"networkResourceManagementCapability,omitempty"`
	healthCheckCapability               *DVSHealthCheckCapability               `xml:"healthCheckCapability,omitempty"`
	rollbackCapability                  *DVSRollbackCapability                  `xml:"rollbackCapability,omitempty"`
	backupRestoreCapability             *DVSBackupRestoreCapability             `xml:"backupRestoreCapability,omitempty"`
	networkFilterSupported              bool                                    `xml:"networkFilterSupported,omitempty"`
}

type DVSHealthCheckCapability struct {
	*DynamicData
}

type DVSCapability struct {
	*DynamicData

	dvsOperationSupported              bool                                       `xml:"dvsOperationSupported,omitempty"`
	dvPortGroupOperationSupported      bool                                       `xml:"dvPortGroupOperationSupported,omitempty"`
	dvPortOperationSupported           bool                                       `xml:"dvPortOperationSupported,omitempty"`
	compatibleHostComponentProductInfo []*DistributedVirtualSwitchHostProductSpec `xml:"compatibleHostComponentProductInfo,omitempty"`
	featuresSupported                  *DVSFeatureCapability                      `xml:"featuresSupported,omitempty"`
}

type DVSSummary struct {
	*DynamicData

	name          string                               `xml:"name,omitempty"`
	uuid          string                               `xml:"uuid,omitempty"`
	numPorts      int32                                `xml:"numPorts,omitempty"`
	productInfo   *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty"`
	hostMember    []*ManagedObjectReference            `xml:"hostMember,omitempty"`
	vm            []*ManagedObjectReference            `xml:"vm,omitempty"`
	host          []*ManagedObjectReference            `xml:"host,omitempty"`
	portgroupName []string                             `xml:"portgroupName,omitempty"`
	description   string                               `xml:"description,omitempty"`
	contact       *DVSContactInfo                      `xml:"contact,omitempty"`
	numHosts      int32                                `xml:"numHosts,omitempty"`
}

type DVSPolicy struct {
	*DynamicData

	autoPreInstallAllowed bool `xml:"autoPreInstallAllowed,omitempty"`
	autoUpgradeAllowed    bool `xml:"autoUpgradeAllowed,omitempty"`
	partialUpgradeAllowed bool `xml:"partialUpgradeAllowed,omitempty"`
}

type DVSUplinkPortPolicy struct {
	*DynamicData
}

type DVSNameArrayUplinkPortPolicy struct {
	*DVSUplinkPortPolicy

	uplinkPortName []string `xml:"uplinkPortName,omitempty"`
}

type DVSConfigSpec struct {
	*DynamicData

	configVersion                 string                                          `xml:"configVersion,omitempty"`
	name                          string                                          `xml:"name,omitempty"`
	numStandalonePorts            int32                                           `xml:"numStandalonePorts,omitempty"`
	maxPorts                      int32                                           `xml:"maxPorts,omitempty"`
	uplinkPortPolicy              *DVSUplinkPortPolicy                            `xml:"uplinkPortPolicy,omitempty"`
	uplinkPortgroup               []*ManagedObjectReference                       `xml:"uplinkPortgroup,omitempty"`
	defaultPortConfig             *DVPortSetting                                  `xml:"defaultPortConfig,omitempty"`
	host                          []*DistributedVirtualSwitchHostMemberConfigSpec `xml:"host,omitempty"`
	extensionKey                  string                                          `xml:"extensionKey,omitempty"`
	description                   string                                          `xml:"description,omitempty"`
	policy                        *DVSPolicy                                      `xml:"policy,omitempty"`
	vendorSpecificConfig          []*DistributedVirtualSwitchKeyedOpaqueBlob      `xml:"vendorSpecificConfig,omitempty"`
	contact                       *DVSContactInfo                                 `xml:"contact,omitempty"`
	switchIpAddress               string                                          `xml:"switchIpAddress,omitempty"`
	defaultProxySwitchMaxNumPorts int32                                           `xml:"defaultProxySwitchMaxNumPorts,omitempty"`
}

type DVSCreateSpec struct {
	*DynamicData

	configSpec  *DVSConfigSpec                       `xml:"configSpec,omitempty"`
	productInfo *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty"`
	capability  *DVSCapability                       `xml:"capability,omitempty"`
}

type DVSConfigInfo struct {
	*DynamicData

	uuid                             string                                     `xml:"uuid,omitempty"`
	name                             string                                     `xml:"name,omitempty"`
	numStandalonePorts               int32                                      `xml:"numStandalonePorts,omitempty"`
	numPorts                         int32                                      `xml:"numPorts,omitempty"`
	maxPorts                         int32                                      `xml:"maxPorts,omitempty"`
	uplinkPortPolicy                 *DVSUplinkPortPolicy                       `xml:"uplinkPortPolicy,omitempty"`
	uplinkPortgroup                  []*ManagedObjectReference                  `xml:"uplinkPortgroup,omitempty"`
	defaultPortConfig                *DVPortSetting                             `xml:"defaultPortConfig,omitempty"`
	host                             []*DistributedVirtualSwitchHostMember      `xml:"host,omitempty"`
	productInfo                      *DistributedVirtualSwitchProductSpec       `xml:"productInfo,omitempty"`
	targetInfo                       *DistributedVirtualSwitchProductSpec       `xml:"targetInfo,omitempty"`
	extensionKey                     string                                     `xml:"extensionKey,omitempty"`
	vendorSpecificConfig             []*DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty"`
	policy                           *DVSPolicy                                 `xml:"policy,omitempty"`
	description                      string                                     `xml:"description,omitempty"`
	configVersion                    string                                     `xml:"configVersion,omitempty"`
	contact                          *DVSContactInfo                            `xml:"contact,omitempty"`
	switchIpAddress                  string                                     `xml:"switchIpAddress,omitempty"`
	createTime                       time.Time                                  `xml:"createTime,omitempty"`
	networkResourceManagementEnabled bool                                       `xml:"networkResourceManagementEnabled,omitempty"`
	defaultProxySwitchMaxNumPorts    int32                                      `xml:"defaultProxySwitchMaxNumPorts,omitempty"`
	healthCheckConfig                []*DVSHealthCheckConfig                    `xml:"healthCheckConfig,omitempty"`
}

type DVSHealthCheckConfig struct {
	*DynamicData

	enable   bool  `xml:"enable,omitempty"`
	interval int32 `xml:"interval,omitempty"`
}

type ArrayOfDVSHealthCheckConfig struct {
	DVSHealthCheckConfig []*DVSHealthCheckConfig `xml:"DVSHealthCheckConfig,omitempty"`
}

type DVSRuntimeInfo struct {
	*DynamicData

	hostMemberRuntime []*HostMemberRuntimeInfo `xml:"hostMemberRuntime,omitempty"`
}

type EVCMode struct {
	*ElementDescription

	guaranteedCPUFeatures []*HostCpuIdInfo                    `xml:"guaranteedCPUFeatures,omitempty"`
	featureCapability     []*HostFeatureCapability            `xml:"featureCapability,omitempty"`
	featureMask           []*HostFeatureMask                  `xml:"featureMask,omitempty"`
	featureRequirement    []*VirtualMachineFeatureRequirement `xml:"featureRequirement,omitempty"`
	vendor                string                              `xml:"vendor,omitempty"`
	track                 []string                            `xml:"track,omitempty"`
	vendorTier            int32                               `xml:"vendorTier,omitempty"`
}

type ArrayOfEVCMode struct {
	EVCMode []*EVCMode `xml:"EVCMode,omitempty"`
}

type ElementDescription struct {
	*Description

	key string `xml:"key,omitempty"`
}

type ArrayOfElementDescription struct {
	ElementDescription []*ElementDescription `xml:"ElementDescription,omitempty"`
}

type EnumDescription struct {
	*DynamicData

	key  string                `xml:"key,omitempty"`
	tags []*ElementDescription `xml:"tags,omitempty"`
}

type ArrayOfEnumDescription struct {
	EnumDescription []*EnumDescription `xml:"EnumDescription,omitempty"`
}

type ExtendedDescription struct {
	*Description

	messageCatalogKeyPrefix string         `xml:"messageCatalogKeyPrefix,omitempty"`
	messageArg              []*KeyAnyValue `xml:"messageArg,omitempty"`
}

type ExtendedElementDescription struct {
	*ElementDescription

	messageCatalogKeyPrefix string         `xml:"messageCatalogKeyPrefix,omitempty"`
	messageArg              []*KeyAnyValue `xml:"messageArg,omitempty"`
}

type ExtensionServerInfo struct {
	*DynamicData

	url              string       `xml:"url,omitempty"`
	description      *Description `xml:"description,omitempty"`
	company          string       `xml:"company,omitempty"`
	type_            string       `xml:"type,omitempty"`
	adminEmail       []string     `xml:"adminEmail,omitempty"`
	serverThumbprint string       `xml:"serverThumbprint,omitempty"`
}

type ArrayOfExtensionServerInfo struct {
	ExtensionServerInfo []*ExtensionServerInfo `xml:"ExtensionServerInfo,omitempty"`
}

type ExtensionClientInfo struct {
	*DynamicData

	version     string       `xml:"version,omitempty"`
	description *Description `xml:"description,omitempty"`
	company     string       `xml:"company,omitempty"`
	type_       string       `xml:"type,omitempty"`
	url         string       `xml:"url,omitempty"`
}

type ArrayOfExtensionClientInfo struct {
	ExtensionClientInfo []*ExtensionClientInfo `xml:"ExtensionClientInfo,omitempty"`
}

type ExtensionTaskTypeInfo struct {
	*DynamicData

	taskID string `xml:"taskID,omitempty"`
}

type ArrayOfExtensionTaskTypeInfo struct {
	ExtensionTaskTypeInfo []*ExtensionTaskTypeInfo `xml:"ExtensionTaskTypeInfo,omitempty"`
}

type ExtensionEventTypeInfo struct {
	*DynamicData

	eventID         string `xml:"eventID,omitempty"`
	eventTypeSchema string `xml:"eventTypeSchema,omitempty"`
}

type ArrayOfExtensionEventTypeInfo struct {
	ExtensionEventTypeInfo []*ExtensionEventTypeInfo `xml:"ExtensionEventTypeInfo,omitempty"`
}

type ExtensionFaultTypeInfo struct {
	*DynamicData

	faultID string `xml:"faultID,omitempty"`
}

type ArrayOfExtensionFaultTypeInfo struct {
	ExtensionFaultTypeInfo []*ExtensionFaultTypeInfo `xml:"ExtensionFaultTypeInfo,omitempty"`
}

type ExtensionPrivilegeInfo struct {
	*DynamicData

	privID        string `xml:"privID,omitempty"`
	privGroupName string `xml:"privGroupName,omitempty"`
}

type ArrayOfExtensionPrivilegeInfo struct {
	ExtensionPrivilegeInfo []*ExtensionPrivilegeInfo `xml:"ExtensionPrivilegeInfo,omitempty"`
}

type ExtensionResourceInfo struct {
	*DynamicData

	locale string      `xml:"locale,omitempty"`
	module string      `xml:"module,omitempty"`
	data   []*KeyValue `xml:"data,omitempty"`
}

type ArrayOfExtensionResourceInfo struct {
	ExtensionResourceInfo []*ExtensionResourceInfo `xml:"ExtensionResourceInfo,omitempty"`
}

type ExtensionHealthInfo struct {
	*DynamicData

	url string `xml:"url,omitempty"`
}

type ExtensionOvfConsumerInfo struct {
	*DynamicData

	callbackUrl string   `xml:"callbackUrl,omitempty"`
	sectionType []string `xml:"sectionType,omitempty"`
}

type Extension struct {
	*DynamicData

	description            *Description              `xml:"description,omitempty"`
	key                    string                    `xml:"key,omitempty"`
	company                string                    `xml:"company,omitempty"`
	type_                  string                    `xml:"type,omitempty"`
	version                string                    `xml:"version,omitempty"`
	subjectName            string                    `xml:"subjectName,omitempty"`
	server                 []*ExtensionServerInfo    `xml:"server,omitempty"`
	client                 []*ExtensionClientInfo    `xml:"client,omitempty"`
	taskList               []*ExtensionTaskTypeInfo  `xml:"taskList,omitempty"`
	eventList              []*ExtensionEventTypeInfo `xml:"eventList,omitempty"`
	faultList              []*ExtensionFaultTypeInfo `xml:"faultList,omitempty"`
	privilegeList          []*ExtensionPrivilegeInfo `xml:"privilegeList,omitempty"`
	resourceList           []*ExtensionResourceInfo  `xml:"resourceList,omitempty"`
	lastHeartbeatTime      time.Time                 `xml:"lastHeartbeatTime,omitempty"`
	healthInfo             *ExtensionHealthInfo      `xml:"healthInfo,omitempty"`
	ovfConsumerInfo        *ExtensionOvfConsumerInfo `xml:"ovfConsumerInfo,omitempty"`
	extendedProductInfo    *ExtExtendedProductInfo   `xml:"extendedProductInfo,omitempty"`
	managedEntityInfo      []*ExtManagedEntityInfo   `xml:"managedEntityInfo,omitempty"`
	shownInSolutionManager bool                      `xml:"shownInSolutionManager,omitempty"`
	solutionManagerInfo    *ExtSolutionManagerInfo   `xml:"solutionManagerInfo,omitempty"`
}

type ArrayOfExtension struct {
	Extension []*Extension `xml:"Extension,omitempty"`
}

type ExtensionManagerIpAllocationUsage struct {
	*DynamicData

	extensionKey string `xml:"extensionKey,omitempty"`
	numAddresses int32  `xml:"numAddresses,omitempty"`
}

type ArrayOfExtensionManagerIpAllocationUsage struct {
	ExtensionManagerIpAllocationUsage []*ExtensionManagerIpAllocationUsage `xml:"ExtensionManagerIpAllocationUsage,omitempty"`
}

type ReplicationVmProgressInfo struct {
	*DynamicData

	progress              int32 `xml:"progress,omitempty"`
	bytesTransferred      int64 `xml:"bytesTransferred,omitempty"`
	bytesToTransfer       int64 `xml:"bytesToTransfer,omitempty"`
	checksumTotalBytes    int64 `xml:"checksumTotalBytes,omitempty"`
	checksumComparedBytes int64 `xml:"checksumComparedBytes,omitempty"`
}

type HbrManagerReplicationVmInfo struct {
	*DynamicData

	state        string                     `xml:"state,omitempty"`
	progressInfo *ReplicationVmProgressInfo `xml:"progressInfo,omitempty"`
	imageId      string                     `xml:"imageId,omitempty"`
	lastError    *LocalizedMethodFault      `xml:"lastError,omitempty"`
}

type HostServiceTicket struct {
	*DynamicData

	host           string `xml:"host,omitempty"`
	port           int32  `xml:"port,omitempty"`
	sslThumbprint  string `xml:"sslThumbprint,omitempty"`
	service        string `xml:"service,omitempty"`
	serviceVersion string `xml:"serviceVersion,omitempty"`
	sessionId      string `xml:"sessionId,omitempty"`
}

type HostSystemReconnectSpec struct {
	*DynamicData

	syncState bool `xml:"syncState,omitempty"`
}

type HttpNfcLeaseDatastoreLeaseInfo struct {
	*DynamicData

	datastoreKey string                  `xml:"datastoreKey,omitempty"`
	hosts        []*HttpNfcLeaseHostInfo `xml:"hosts,omitempty"`
}

type ArrayOfHttpNfcLeaseDatastoreLeaseInfo struct {
	HttpNfcLeaseDatastoreLeaseInfo []*HttpNfcLeaseDatastoreLeaseInfo `xml:"HttpNfcLeaseDatastoreLeaseInfo,omitempty"`
}

type HttpNfcLeaseHostInfo struct {
	*DynamicData

	url           string `xml:"url,omitempty"`
	sslThumbprint string `xml:"sslThumbprint,omitempty"`
}

type ArrayOfHttpNfcLeaseHostInfo struct {
	HttpNfcLeaseHostInfo []*HttpNfcLeaseHostInfo `xml:"HttpNfcLeaseHostInfo,omitempty"`
}

type HttpNfcLeaseInfo struct {
	*DynamicData

	lease                 *ManagedObjectReference           `xml:"lease,omitempty"`
	entity                *ManagedObjectReference           `xml:"entity,omitempty"`
	deviceUrl             []*HttpNfcLeaseDeviceUrl          `xml:"deviceUrl,omitempty"`
	totalDiskCapacityInKB int64                             `xml:"totalDiskCapacityInKB,omitempty"`
	leaseTimeout          int32                             `xml:"leaseTimeout,omitempty"`
	hostMap               []*HttpNfcLeaseDatastoreLeaseInfo `xml:"hostMap,omitempty"`
}

type HttpNfcLeaseDeviceUrl struct {
	*DynamicData

	key           string `xml:"key,omitempty"`
	importKey     string `xml:"importKey,omitempty"`
	url           string `xml:"url,omitempty"`
	sslThumbprint string `xml:"sslThumbprint,omitempty"`
	disk          bool   `xml:"disk,omitempty"`
	targetId      string `xml:"targetId,omitempty"`
	datastoreKey  string `xml:"datastoreKey,omitempty"`
	fileSize      int64  `xml:"fileSize,omitempty"`
}

type ArrayOfHttpNfcLeaseDeviceUrl struct {
	HttpNfcLeaseDeviceUrl []*HttpNfcLeaseDeviceUrl `xml:"HttpNfcLeaseDeviceUrl,omitempty"`
}

type HttpNfcLeaseManifestEntry struct {
	*DynamicData

	key           string `xml:"key,omitempty"`
	sha1          string `xml:"sha1,omitempty"`
	size          int64  `xml:"size,omitempty"`
	disk          bool   `xml:"disk,omitempty"`
	capacity      int64  `xml:"capacity,omitempty"`
	populatedSize int64  `xml:"populatedSize,omitempty"`
}

type ArrayOfHttpNfcLeaseManifestEntry struct {
	HttpNfcLeaseManifestEntry []*HttpNfcLeaseManifestEntry `xml:"HttpNfcLeaseManifestEntry,omitempty"`
}

type ImportSpec struct {
	*DynamicData

	entityConfig     *VAppEntityConfigInfo `xml:"entityConfig,omitempty"`
	instantiationOst *OvfConsumerOstNode   `xml:"instantiationOst,omitempty"`
}

type ArrayOfImportSpec struct {
	ImportSpec []*ImportSpec `xml:"ImportSpec,omitempty"`
}

type InheritablePolicy struct {
	*DynamicData

	inherited bool `xml:"inherited,omitempty"`
}

type IntExpression struct {
	*NegatableExpression

	value int32 `xml:"value,omitempty"`
}

type IntPolicy struct {
	*InheritablePolicy

	value int32 `xml:"value,omitempty"`
}

type IpAddress struct {
	*NegatableExpression
}

type IpPoolManagerIpAllocation struct {
	*DynamicData

	ipAddress    string `xml:"ipAddress,omitempty"`
	allocationId string `xml:"allocationId,omitempty"`
}

type ArrayOfIpPoolManagerIpAllocation struct {
	IpPoolManagerIpAllocation []*IpPoolManagerIpAllocation `xml:"IpPoolManagerIpAllocation,omitempty"`
}

type IpRange struct {
	*IpAddress

	addressPrefix string `xml:"addressPrefix,omitempty"`
	prefixLength  int32  `xml:"prefixLength,omitempty"`
}

type KeyValue struct {
	*DynamicData

	key   string `xml:"key,omitempty"`
	value string `xml:"value,omitempty"`
}

type ArrayOfKeyValue struct {
	KeyValue []*KeyValue `xml:"KeyValue,omitempty"`
}

type LatencySensitivity struct {
	*DynamicData

	level       *LatencySensitivitySensitivityLevel `xml:"level,omitempty"`
	sensitivity int32                               `xml:"sensitivity,omitempty"`
}

type LicenseAssignmentManagerLicenseAssignment struct {
	*DynamicData

	entityId          string                     `xml:"entityId,omitempty"`
	scope             string                     `xml:"scope,omitempty"`
	entityDisplayName string                     `xml:"entityDisplayName,omitempty"`
	assignedLicense   *LicenseManagerLicenseInfo `xml:"assignedLicense,omitempty"`
	properties        []*KeyAnyValue             `xml:"properties,omitempty"`
}

type ArrayOfLicenseAssignmentManagerLicenseAssignment struct {
	LicenseAssignmentManagerLicenseAssignment []*LicenseAssignmentManagerLicenseAssignment `xml:"LicenseAssignmentManagerLicenseAssignment,omitempty"`
}

type LicenseSource struct {
	*DynamicData
}

type LicenseServerSource struct {
	*LicenseSource

	licenseServer string `xml:"licenseServer,omitempty"`
}

type LocalLicenseSource struct {
	*LicenseSource

	licenseKeys string `xml:"licenseKeys,omitempty"`
}

type EvaluationLicenseSource struct {
	*LicenseSource

	remainingHours int64 `xml:"remainingHours,omitempty"`
}

type LicenseFeatureInfo struct {
	*DynamicData

	key                string                   `xml:"key,omitempty"`
	featureName        string                   `xml:"featureName,omitempty"`
	featureDescription string                   `xml:"featureDescription,omitempty"`
	state              *LicenseFeatureInfoState `xml:"state,omitempty"`
	costUnit           string                   `xml:"costUnit,omitempty"`
	sourceRestriction  string                   `xml:"sourceRestriction,omitempty"`
	dependentKey       []string                 `xml:"dependentKey,omitempty"`
	edition            bool                     `xml:"edition,omitempty"`
	expiresOn          time.Time                `xml:"expiresOn,omitempty"`
}

type ArrayOfLicenseFeatureInfo struct {
	LicenseFeatureInfo []*LicenseFeatureInfo `xml:"LicenseFeatureInfo,omitempty"`
}

type LicenseReservationInfo struct {
	*DynamicData

	key      string                       `xml:"key,omitempty"`
	state    *LicenseReservationInfoState `xml:"state,omitempty"`
	required int32                        `xml:"required,omitempty"`
}

type ArrayOfLicenseReservationInfo struct {
	LicenseReservationInfo []*LicenseReservationInfo `xml:"LicenseReservationInfo,omitempty"`
}

type LicenseAvailabilityInfo struct {
	*DynamicData

	feature   *LicenseFeatureInfo `xml:"feature,omitempty"`
	total     int32               `xml:"total,omitempty"`
	available int32               `xml:"available,omitempty"`
}

type ArrayOfLicenseAvailabilityInfo struct {
	LicenseAvailabilityInfo []*LicenseAvailabilityInfo `xml:"LicenseAvailabilityInfo,omitempty"`
}

type LicenseDiagnostics struct {
	*DynamicData

	sourceLastChanged      time.Time            `xml:"sourceLastChanged,omitempty"`
	sourceLost             string               `xml:"sourceLost,omitempty"`
	sourceLatency          float32              `xml:"sourceLatency,omitempty"`
	licenseRequests        string               `xml:"licenseRequests,omitempty"`
	licenseRequestFailures string               `xml:"licenseRequestFailures,omitempty"`
	licenseFeatureUnknowns string               `xml:"licenseFeatureUnknowns,omitempty"`
	opState                *LicenseManagerState `xml:"opState,omitempty"`
	lastStatusUpdate       time.Time            `xml:"lastStatusUpdate,omitempty"`
	opFailureMessage       string               `xml:"opFailureMessage,omitempty"`
}

type LicenseUsageInfo struct {
	*DynamicData

	source          *LicenseSource            `xml:"source,omitempty"`
	sourceAvailable bool                      `xml:"sourceAvailable,omitempty"`
	reservationInfo []*LicenseReservationInfo `xml:"reservationInfo,omitempty"`
	featureInfo     []*LicenseFeatureInfo     `xml:"featureInfo,omitempty"`
}

type LicenseManagerEvaluationInfo struct {
	*DynamicData

	properties []*KeyAnyValue `xml:"properties,omitempty"`
}

type HostLicensableResourceInfo struct {
	*DynamicData

	resource []*KeyAnyValue `xml:"resource,omitempty"`
}

type LicenseManagerLicenseInfo struct {
	*DynamicData

	licenseKey string         `xml:"licenseKey,omitempty"`
	editionKey string         `xml:"editionKey,omitempty"`
	name       string         `xml:"name,omitempty"`
	total      int32          `xml:"total,omitempty"`
	used       int32          `xml:"used,omitempty"`
	costUnit   string         `xml:"costUnit,omitempty"`
	properties []*KeyAnyValue `xml:"properties,omitempty"`
	labels     []*KeyValue    `xml:"labels,omitempty"`
}

type ArrayOfLicenseManagerLicenseInfo struct {
	LicenseManagerLicenseInfo []*LicenseManagerLicenseInfo `xml:"LicenseManagerLicenseInfo,omitempty"`
}

type LocalizationManagerMessageCatalog struct {
	*DynamicData

	moduleName   string    `xml:"moduleName,omitempty"`
	catalogName  string    `xml:"catalogName,omitempty"`
	locale       string    `xml:"locale,omitempty"`
	catalogUri   string    `xml:"catalogUri,omitempty"`
	lastModified time.Time `xml:"lastModified,omitempty"`
	md5sum       string    `xml:"md5sum,omitempty"`
	version      string    `xml:"version,omitempty"`
}

type ArrayOfLocalizationManagerMessageCatalog struct {
	LocalizationManagerMessageCatalog []*LocalizationManagerMessageCatalog `xml:"LocalizationManagerMessageCatalog,omitempty"`
}

type LongPolicy struct {
	*InheritablePolicy

	value int64 `xml:"value,omitempty"`
}

type MacAddress struct {
	*NegatableExpression
}

type MacRange struct {
	*MacAddress

	address string `xml:"address,omitempty"`
	mask    string `xml:"mask,omitempty"`
}

type MethodDescription struct {
	*Description

	key string `xml:"key,omitempty"`
}

type NegatableExpression struct {
	*DynamicData

	negate bool `xml:"negate,omitempty"`
}

type NetworkSummary struct {
	*DynamicData

	network    *ManagedObjectReference `xml:"network,omitempty"`
	name       string                  `xml:"name,omitempty"`
	accessible bool                    `xml:"accessible,omitempty"`
	ipPoolName string                  `xml:"ipPoolName,omitempty"`
	ipPoolId   int32                   `xml:"ipPoolId,omitempty"`
}

type NumericRange struct {
	*DynamicData

	start int32 `xml:"start,omitempty"`
	end   int32 `xml:"end,omitempty"`
}

type ArrayOfNumericRange struct {
	NumericRange []*NumericRange `xml:"NumericRange,omitempty"`
}

type OpaqueNetworkSummary struct {
	*NetworkSummary

	opaqueNetworkId   string `xml:"opaqueNetworkId,omitempty"`
	opaqueNetworkType string `xml:"opaqueNetworkType,omitempty"`
}

type OvfConsumerOvfSection struct {
	*DynamicData

	lineNumber int32  `xml:"lineNumber,omitempty"`
	xml        string `xml:"xml,omitempty"`
}

type ArrayOfOvfConsumerOvfSection struct {
	OvfConsumerOvfSection []*OvfConsumerOvfSection `xml:"OvfConsumerOvfSection,omitempty"`
}

type OvfConsumerOstNode struct {
	*DynamicData

	id      string                   `xml:"id,omitempty"`
	type_   string                   `xml:"type,omitempty"`
	section []*OvfConsumerOvfSection `xml:"section,omitempty"`
	child   []*OvfConsumerOstNode    `xml:"child,omitempty"`
	entity  *ManagedObjectReference  `xml:"entity,omitempty"`
}

type ArrayOfOvfConsumerOstNode struct {
	OvfConsumerOstNode []*OvfConsumerOstNode `xml:"OvfConsumerOstNode,omitempty"`
}

type OvfOptionInfo struct {
	*DynamicData

	option      string              `xml:"option,omitempty"`
	description *LocalizableMessage `xml:"description,omitempty"`
}

type ArrayOfOvfOptionInfo struct {
	OvfOptionInfo []*OvfOptionInfo `xml:"OvfOptionInfo,omitempty"`
}

type OvfDeploymentOption struct {
	*DynamicData

	key         string `xml:"key,omitempty"`
	label       string `xml:"label,omitempty"`
	description string `xml:"description,omitempty"`
}

type ArrayOfOvfDeploymentOption struct {
	OvfDeploymentOption []*OvfDeploymentOption `xml:"OvfDeploymentOption,omitempty"`
}

type OvfManagerCommonParams struct {
	*DynamicData

	locale           string      `xml:"locale,omitempty"`
	deploymentOption string      `xml:"deploymentOption,omitempty"`
	msgBundle        []*KeyValue `xml:"msgBundle,omitempty"`
	importOption     []string    `xml:"importOption,omitempty"`
}

type OvfValidateHostParams struct {
	*OvfManagerCommonParams
}

type OvfValidateHostResult struct {
	*DynamicData

	downloadSize              int64                   `xml:"downloadSize,omitempty"`
	flatDeploymentSize        int64                   `xml:"flatDeploymentSize,omitempty"`
	sparseDeploymentSize      int64                   `xml:"sparseDeploymentSize,omitempty"`
	error                     []*LocalizedMethodFault `xml:"error,omitempty"`
	warning                   []*LocalizedMethodFault `xml:"warning,omitempty"`
	supportedDiskProvisioning []string                `xml:"supportedDiskProvisioning,omitempty"`
}

type OvfParseDescriptorParams struct {
	*OvfManagerCommonParams
}

type OvfParseDescriptorResult struct {
	*DynamicData

	eula                            []string                `xml:"eula,omitempty"`
	network                         []*OvfNetworkInfo       `xml:"network,omitempty"`
	ipAllocationScheme              []string                `xml:"ipAllocationScheme,omitempty"`
	ipProtocols                     []string                `xml:"ipProtocols,omitempty"`
	property                        []*VAppPropertyInfo     `xml:"property,omitempty"`
	productInfo                     *VAppProductInfo        `xml:"productInfo,omitempty"`
	annotation                      string                  `xml:"annotation,omitempty"`
	approximateDownloadSize         int64                   `xml:"approximateDownloadSize,omitempty"`
	approximateFlatDeploymentSize   int64                   `xml:"approximateFlatDeploymentSize,omitempty"`
	approximateSparseDeploymentSize int64                   `xml:"approximateSparseDeploymentSize,omitempty"`
	defaultEntityName               string                  `xml:"defaultEntityName,omitempty"`
	virtualApp                      bool                    `xml:"virtualApp,omitempty"`
	deploymentOption                []*OvfDeploymentOption  `xml:"deploymentOption,omitempty"`
	defaultDeploymentOption         string                  `xml:"defaultDeploymentOption,omitempty"`
	entityName                      []*KeyValue             `xml:"entityName,omitempty"`
	annotatedOst                    *OvfConsumerOstNode     `xml:"annotatedOst,omitempty"`
	error                           []*LocalizedMethodFault `xml:"error,omitempty"`
	warning                         []*LocalizedMethodFault `xml:"warning,omitempty"`
}

type OvfNetworkInfo struct {
	*DynamicData

	name        string `xml:"name,omitempty"`
	description string `xml:"description,omitempty"`
}

type ArrayOfOvfNetworkInfo struct {
	OvfNetworkInfo []*OvfNetworkInfo `xml:"OvfNetworkInfo,omitempty"`
}

type OvfCreateImportSpecParams struct {
	*OvfManagerCommonParams

	entityName         string                  `xml:"entityName,omitempty"`
	hostSystem         *ManagedObjectReference `xml:"hostSystem,omitempty"`
	networkMapping     []*OvfNetworkMapping    `xml:"networkMapping,omitempty"`
	ipAllocationPolicy string                  `xml:"ipAllocationPolicy,omitempty"`
	ipProtocol         string                  `xml:"ipProtocol,omitempty"`
	propertyMapping    []*KeyValue             `xml:"propertyMapping,omitempty"`
	resourceMapping    []*OvfResourceMap       `xml:"resourceMapping,omitempty"`
	diskProvisioning   string                  `xml:"diskProvisioning,omitempty"`
	instantiationOst   *OvfConsumerOstNode     `xml:"instantiationOst,omitempty"`
}

type OvfResourceMap struct {
	*DynamicData

	source       string                  `xml:"source,omitempty"`
	parent       *ManagedObjectReference `xml:"parent,omitempty"`
	resourceSpec *ResourceConfigSpec     `xml:"resourceSpec,omitempty"`
	datastore    *ManagedObjectReference `xml:"datastore,omitempty"`
}

type ArrayOfOvfResourceMap struct {
	OvfResourceMap []*OvfResourceMap `xml:"OvfResourceMap,omitempty"`
}

type OvfNetworkMapping struct {
	*DynamicData

	name    string                  `xml:"name,omitempty"`
	network *ManagedObjectReference `xml:"network,omitempty"`
}

type ArrayOfOvfNetworkMapping struct {
	OvfNetworkMapping []*OvfNetworkMapping `xml:"OvfNetworkMapping,omitempty"`
}

type OvfCreateImportSpecResult struct {
	*DynamicData

	importSpec *ImportSpec             `xml:"importSpec,omitempty"`
	fileItem   []*OvfFileItem          `xml:"fileItem,omitempty"`
	warning    []*LocalizedMethodFault `xml:"warning,omitempty"`
	error      []*LocalizedMethodFault `xml:"error,omitempty"`
}

type OvfFileItem struct {
	*DynamicData

	deviceId          string `xml:"deviceId,omitempty"`
	path              string `xml:"path,omitempty"`
	compressionMethod string `xml:"compressionMethod,omitempty"`
	chunkSize         int64  `xml:"chunkSize,omitempty"`
	size              int64  `xml:"size,omitempty"`
	cimType           int32  `xml:"cimType,omitempty"`
	create            bool   `xml:"create,omitempty"`
}

type ArrayOfOvfFileItem struct {
	OvfFileItem []*OvfFileItem `xml:"OvfFileItem,omitempty"`
}

type OvfCreateDescriptorParams struct {
	*DynamicData

	ovfFiles          []*OvfFile              `xml:"ovfFiles,omitempty"`
	name              string                  `xml:"name,omitempty"`
	description       string                  `xml:"description,omitempty"`
	includeImageFiles bool                    `xml:"includeImageFiles,omitempty"`
	exportOption      []string                `xml:"exportOption,omitempty"`
	snapshot          *ManagedObjectReference `xml:"snapshot,omitempty"`
}

type OvfCreateDescriptorResult struct {
	*DynamicData

	ovfDescriptor     string                  `xml:"ovfDescriptor,omitempty"`
	error             []*LocalizedMethodFault `xml:"error,omitempty"`
	warning           []*LocalizedMethodFault `xml:"warning,omitempty"`
	includeImageFiles bool                    `xml:"includeImageFiles,omitempty"`
}

type OvfFile struct {
	*DynamicData

	deviceId          string `xml:"deviceId,omitempty"`
	path              string `xml:"path,omitempty"`
	compressionMethod string `xml:"compressionMethod,omitempty"`
	chunkSize         int64  `xml:"chunkSize,omitempty"`
	size              int64  `xml:"size,omitempty"`
	capacity          int64  `xml:"capacity,omitempty"`
	populatedSize     int64  `xml:"populatedSize,omitempty"`
}

type ArrayOfOvfFile struct {
	OvfFile []*OvfFile `xml:"OvfFile,omitempty"`
}

type PasswordField struct {
	*DynamicData

	value string `xml:"value,omitempty"`
}

type PerformanceDescription struct {
	*DynamicData

	counterType []*ElementDescription `xml:"counterType,omitempty"`
	statsType   []*ElementDescription `xml:"statsType,omitempty"`
}

type PerfProviderSummary struct {
	*DynamicData

	entity           *ManagedObjectReference `xml:"entity,omitempty"`
	currentSupported bool                    `xml:"currentSupported,omitempty"`
	summarySupported bool                    `xml:"summarySupported,omitempty"`
	refreshRate      int32                   `xml:"refreshRate,omitempty"`
}

type PerfCounterInfo struct {
	*DynamicData

	key                 int32               `xml:"key,omitempty"`
	nameInfo            *ElementDescription `xml:"nameInfo,omitempty"`
	groupInfo           *ElementDescription `xml:"groupInfo,omitempty"`
	unitInfo            *ElementDescription `xml:"unitInfo,omitempty"`
	rollupType          *PerfSummaryType    `xml:"rollupType,omitempty"`
	statsType           *PerfStatsType      `xml:"statsType,omitempty"`
	level               int32               `xml:"level,omitempty"`
	perDeviceLevel      int32               `xml:"perDeviceLevel,omitempty"`
	associatedCounterId []int32             `xml:"associatedCounterId,omitempty"`
}

type ArrayOfPerfCounterInfo struct {
	PerfCounterInfo []*PerfCounterInfo `xml:"PerfCounterInfo,omitempty"`
}

type PerfMetricId struct {
	*DynamicData

	counterId int32  `xml:"counterId,omitempty"`
	instance  string `xml:"instance,omitempty"`
}

type ArrayOfPerfMetricId struct {
	PerfMetricId []*PerfMetricId `xml:"PerfMetricId,omitempty"`
}

type PerfQuerySpec struct {
	*DynamicData

	entity     *ManagedObjectReference `xml:"entity,omitempty"`
	startTime  time.Time               `xml:"startTime,omitempty"`
	endTime    time.Time               `xml:"endTime,omitempty"`
	maxSample  int32                   `xml:"maxSample,omitempty"`
	metricId   []*PerfMetricId         `xml:"metricId,omitempty"`
	intervalId int32                   `xml:"intervalId,omitempty"`
	format     string                  `xml:"format,omitempty"`
}

type ArrayOfPerfQuerySpec struct {
	PerfQuerySpec []*PerfQuerySpec `xml:"PerfQuerySpec,omitempty"`
}

type PerfSampleInfo struct {
	*DynamicData

	timestamp time.Time `xml:"timestamp,omitempty"`
	interval  int32     `xml:"interval,omitempty"`
}

type ArrayOfPerfSampleInfo struct {
	PerfSampleInfo []*PerfSampleInfo `xml:"PerfSampleInfo,omitempty"`
}

type PerfMetricSeries struct {
	*DynamicData

	id *PerfMetricId `xml:"id,omitempty"`
}

type ArrayOfPerfMetricSeries struct {
	PerfMetricSeries []*PerfMetricSeries `xml:"PerfMetricSeries,omitempty"`
}

type PerfMetricIntSeries struct {
	*PerfMetricSeries

	value []int64 `xml:"value,omitempty"`
}

type PerfMetricSeriesCSV struct {
	*PerfMetricSeries

	value string `xml:"value,omitempty"`
}

type ArrayOfPerfMetricSeriesCSV struct {
	PerfMetricSeriesCSV []*PerfMetricSeriesCSV `xml:"PerfMetricSeriesCSV,omitempty"`
}

type PerfEntityMetricBase struct {
	*DynamicData

	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type ArrayOfPerfEntityMetricBase struct {
	PerfEntityMetricBase []*PerfEntityMetricBase `xml:"PerfEntityMetricBase,omitempty"`
}

type PerfEntityMetric struct {
	*PerfEntityMetricBase

	sampleInfo []*PerfSampleInfo   `xml:"sampleInfo,omitempty"`
	value      []*PerfMetricSeries `xml:"value,omitempty"`
}

type PerfEntityMetricCSV struct {
	*PerfEntityMetricBase

	sampleInfoCSV string                 `xml:"sampleInfoCSV,omitempty"`
	value         []*PerfMetricSeriesCSV `xml:"value,omitempty"`
}

type PerfCompositeMetric struct {
	*DynamicData

	entity      *PerfEntityMetricBase   `xml:"entity,omitempty"`
	childEntity []*PerfEntityMetricBase `xml:"childEntity,omitempty"`
}

type PerformanceManagerCounterLevelMapping struct {
	*DynamicData

	counterId      int32 `xml:"counterId,omitempty"`
	aggregateLevel int32 `xml:"aggregateLevel,omitempty"`
	perDeviceLevel int32 `xml:"perDeviceLevel,omitempty"`
}

type ArrayOfPerformanceManagerCounterLevelMapping struct {
	PerformanceManagerCounterLevelMapping []*PerformanceManagerCounterLevelMapping `xml:"PerformanceManagerCounterLevelMapping,omitempty"`
}

type PerfInterval struct {
	*DynamicData

	key            int32  `xml:"key,omitempty"`
	samplingPeriod int32  `xml:"samplingPeriod,omitempty"`
	name           string `xml:"name,omitempty"`
	length         int32  `xml:"length,omitempty"`
	level          int32  `xml:"level,omitempty"`
	enabled        bool   `xml:"enabled,omitempty"`
}

type ArrayOfPerfInterval struct {
	PerfInterval []*PerfInterval `xml:"PerfInterval,omitempty"`
}

type PosixUserSearchResult struct {
	*UserSearchResult

	id          int32 `xml:"id,omitempty"`
	shellAccess bool  `xml:"shellAccess,omitempty"`
}

type PrivilegePolicyDef struct {
	*DynamicData

	createPrivilege string `xml:"createPrivilege,omitempty"`
	readPrivilege   string `xml:"readPrivilege,omitempty"`
	updatePrivilege string `xml:"updatePrivilege,omitempty"`
	deletePrivilege string `xml:"deletePrivilege,omitempty"`
}

type ResourceAllocationInfo struct {
	*DynamicData

	reservation           int64       `xml:"reservation,omitempty"`
	expandableReservation bool        `xml:"expandableReservation,omitempty"`
	limit                 int64       `xml:"limit,omitempty"`
	shares                *SharesInfo `xml:"shares,omitempty"`
	overheadLimit         int64       `xml:"overheadLimit,omitempty"`
}

type ResourceAllocationOption struct {
	*DynamicData

	sharesOption *SharesOption `xml:"sharesOption,omitempty"`
}

type ResourceConfigOption struct {
	*DynamicData

	cpuAllocationOption    *ResourceAllocationOption `xml:"cpuAllocationOption,omitempty"`
	memoryAllocationOption *ResourceAllocationOption `xml:"memoryAllocationOption,omitempty"`
}

type ResourceConfigSpec struct {
	*DynamicData

	entity           *ManagedObjectReference `xml:"entity,omitempty"`
	changeVersion    string                  `xml:"changeVersion,omitempty"`
	lastModified     time.Time               `xml:"lastModified,omitempty"`
	cpuAllocation    *ResourceAllocationInfo `xml:"cpuAllocation,omitempty"`
	memoryAllocation *ResourceAllocationInfo `xml:"memoryAllocation,omitempty"`
}

type ArrayOfResourceConfigSpec struct {
	ResourceConfigSpec []*ResourceConfigSpec `xml:"ResourceConfigSpec,omitempty"`
}

type DatabaseSizeParam struct {
	*DynamicData

	inventoryDesc *InventoryDescription             `xml:"inventoryDesc,omitempty"`
	perfStatsDesc *PerformanceStatisticsDescription `xml:"perfStatsDesc,omitempty"`
}

type InventoryDescription struct {
	*DynamicData

	numHosts           int32 `xml:"numHosts,omitempty"`
	numVirtualMachines int32 `xml:"numVirtualMachines,omitempty"`
	numResourcePools   int32 `xml:"numResourcePools,omitempty"`
	numClusters        int32 `xml:"numClusters,omitempty"`
	numCpuDev          int32 `xml:"numCpuDev,omitempty"`
	numNetDev          int32 `xml:"numNetDev,omitempty"`
	numDiskDev         int32 `xml:"numDiskDev,omitempty"`
	numvCpuDev         int32 `xml:"numvCpuDev,omitempty"`
	numvNetDev         int32 `xml:"numvNetDev,omitempty"`
	numvDiskDev        int32 `xml:"numvDiskDev,omitempty"`
}

type PerformanceStatisticsDescription struct {
	*DynamicData

	intervals []*PerfInterval `xml:"intervals,omitempty"`
}

type DatabaseSizeEstimate struct {
	*DynamicData

	size int64 `xml:"size,omitempty"`
}

type ResourcePoolResourceUsage struct {
	*DynamicData

	reservationUsed      int64 `xml:"reservationUsed,omitempty"`
	reservationUsedForVm int64 `xml:"reservationUsedForVm,omitempty"`
	unreservedForPool    int64 `xml:"unreservedForPool,omitempty"`
	unreservedForVm      int64 `xml:"unreservedForVm,omitempty"`
	overallUsage         int64 `xml:"overallUsage,omitempty"`
	maxUsage             int64 `xml:"maxUsage,omitempty"`
}

type ResourcePoolRuntimeInfo struct {
	*DynamicData

	memory        *ResourcePoolResourceUsage `xml:"memory,omitempty"`
	cpu           *ResourcePoolResourceUsage `xml:"cpu,omitempty"`
	overallStatus *ManagedEntityStatus       `xml:"overallStatus,omitempty"`
}

type ResourcePoolQuickStats struct {
	*DynamicData

	overallCpuUsage              int64 `xml:"overallCpuUsage,omitempty"`
	overallCpuDemand             int64 `xml:"overallCpuDemand,omitempty"`
	guestMemoryUsage             int64 `xml:"guestMemoryUsage,omitempty"`
	hostMemoryUsage              int64 `xml:"hostMemoryUsage,omitempty"`
	distributedCpuEntitlement    int64 `xml:"distributedCpuEntitlement,omitempty"`
	distributedMemoryEntitlement int64 `xml:"distributedMemoryEntitlement,omitempty"`
	staticCpuEntitlement         int32 `xml:"staticCpuEntitlement,omitempty"`
	staticMemoryEntitlement      int32 `xml:"staticMemoryEntitlement,omitempty"`
	privateMemory                int64 `xml:"privateMemory,omitempty"`
	sharedMemory                 int64 `xml:"sharedMemory,omitempty"`
	swappedMemory                int64 `xml:"swappedMemory,omitempty"`
	balloonedMemory              int64 `xml:"balloonedMemory,omitempty"`
	overheadMemory               int64 `xml:"overheadMemory,omitempty"`
	consumedOverheadMemory       int64 `xml:"consumedOverheadMemory,omitempty"`
	compressedMemory             int64 `xml:"compressedMemory,omitempty"`
}

type ResourcePoolSummary struct {
	*DynamicData

	name               string                   `xml:"name,omitempty"`
	config             *ResourceConfigSpec      `xml:"config,omitempty"`
	runtime            *ResourcePoolRuntimeInfo `xml:"runtime,omitempty"`
	quickStats         *ResourcePoolQuickStats  `xml:"quickStats,omitempty"`
	configuredMemoryMB int32                    `xml:"configuredMemoryMB,omitempty"`
}

type SelectionSet struct {
	*DynamicData
}

type ArrayOfSelectionSet struct {
	SelectionSet []*SelectionSet `xml:"SelectionSet,omitempty"`
}

type HostVMotionCompatibility struct {
	*DynamicData

	host          *ManagedObjectReference `xml:"host,omitempty"`
	compatibility []string                `xml:"compatibility,omitempty"`
}

type ArrayOfHostVMotionCompatibility struct {
	HostVMotionCompatibility []*HostVMotionCompatibility `xml:"HostVMotionCompatibility,omitempty"`
}

type ProductComponentInfo struct {
	*DynamicData

	id      string `xml:"id,omitempty"`
	name    string `xml:"name,omitempty"`
	version string `xml:"version,omitempty"`
	release int32  `xml:"release,omitempty"`
}

type ArrayOfProductComponentInfo struct {
	ProductComponentInfo []*ProductComponentInfo `xml:"ProductComponentInfo,omitempty"`
}

type ServiceContent struct {
	*DynamicData

	rootFolder                *ManagedObjectReference `xml:"rootFolder,omitempty"`
	propertyCollector         *ManagedObjectReference `xml:"propertyCollector,omitempty"`
	viewManager               *ManagedObjectReference `xml:"viewManager,omitempty"`
	about                     *AboutInfo              `xml:"about,omitempty"`
	setting                   *ManagedObjectReference `xml:"setting,omitempty"`
	userDirectory             *ManagedObjectReference `xml:"userDirectory,omitempty"`
	sessionManager            *ManagedObjectReference `xml:"sessionManager,omitempty"`
	authorizationManager      *ManagedObjectReference `xml:"authorizationManager,omitempty"`
	serviceManager            *ManagedObjectReference `xml:"serviceManager,omitempty"`
	perfManager               *ManagedObjectReference `xml:"perfManager,omitempty"`
	scheduledTaskManager      *ManagedObjectReference `xml:"scheduledTaskManager,omitempty"`
	alarmManager              *ManagedObjectReference `xml:"alarmManager,omitempty"`
	eventManager              *ManagedObjectReference `xml:"eventManager,omitempty"`
	taskManager               *ManagedObjectReference `xml:"taskManager,omitempty"`
	extensionManager          *ManagedObjectReference `xml:"extensionManager,omitempty"`
	customizationSpecManager  *ManagedObjectReference `xml:"customizationSpecManager,omitempty"`
	customFieldsManager       *ManagedObjectReference `xml:"customFieldsManager,omitempty"`
	accountManager            *ManagedObjectReference `xml:"accountManager,omitempty"`
	diagnosticManager         *ManagedObjectReference `xml:"diagnosticManager,omitempty"`
	licenseManager            *ManagedObjectReference `xml:"licenseManager,omitempty"`
	searchIndex               *ManagedObjectReference `xml:"searchIndex,omitempty"`
	fileManager               *ManagedObjectReference `xml:"fileManager,omitempty"`
	datastoreNamespaceManager *ManagedObjectReference `xml:"datastoreNamespaceManager,omitempty"`
	virtualDiskManager        *ManagedObjectReference `xml:"virtualDiskManager,omitempty"`
	virtualizationManager     *ManagedObjectReference `xml:"virtualizationManager,omitempty"`
	snmpSystem                *ManagedObjectReference `xml:"snmpSystem,omitempty"`
	vmProvisioningChecker     *ManagedObjectReference `xml:"vmProvisioningChecker,omitempty"`
	vmCompatibilityChecker    *ManagedObjectReference `xml:"vmCompatibilityChecker,omitempty"`
	ovfManager                *ManagedObjectReference `xml:"ovfManager,omitempty"`
	ipPoolManager             *ManagedObjectReference `xml:"ipPoolManager,omitempty"`
	dvSwitchManager           *ManagedObjectReference `xml:"dvSwitchManager,omitempty"`
	hostProfileManager        *ManagedObjectReference `xml:"hostProfileManager,omitempty"`
	clusterProfileManager     *ManagedObjectReference `xml:"clusterProfileManager,omitempty"`
	complianceManager         *ManagedObjectReference `xml:"complianceManager,omitempty"`
	localizationManager       *ManagedObjectReference `xml:"localizationManager,omitempty"`
	storageResourceManager    *ManagedObjectReference `xml:"storageResourceManager,omitempty"`
	guestOperationsManager    *ManagedObjectReference `xml:"guestOperationsManager,omitempty"`
}

type ServiceManagerServiceInfo struct {
	*DynamicData

	serviceName string                  `xml:"serviceName,omitempty"`
	location    []string                `xml:"location,omitempty"`
	service     *ManagedObjectReference `xml:"service,omitempty"`
	description string                  `xml:"description,omitempty"`
}

type ArrayOfServiceManagerServiceInfo struct {
	ServiceManagerServiceInfo []*ServiceManagerServiceInfo `xml:"ServiceManagerServiceInfo,omitempty"`
}

type SessionManagerLocalTicket struct {
	*DynamicData

	userName         string `xml:"userName,omitempty"`
	passwordFilePath string `xml:"passwordFilePath,omitempty"`
}

type SessionManagerGenericServiceTicket struct {
	*DynamicData

	id            string `xml:"id,omitempty"`
	hostName      string `xml:"hostName,omitempty"`
	sslThumbprint string `xml:"sslThumbprint,omitempty"`
}

type SessionManagerServiceRequestSpec struct {
	*DynamicData
}

type SessionManagerVmomiServiceRequestSpec struct {
	*SessionManagerServiceRequestSpec

	method string `xml:"method,omitempty"`
}

type SessionManagerHttpServiceRequestSpec struct {
	*SessionManagerServiceRequestSpec

	method string `xml:"method,omitempty"`
	url    string `xml:"url,omitempty"`
}

type SharesInfo struct {
	*DynamicData

	shares int32        `xml:"shares,omitempty"`
	level  *SharesLevel `xml:"level,omitempty"`
}

type SharesOption struct {
	*DynamicData

	sharesOption *IntOption   `xml:"sharesOption,omitempty"`
	defaultLevel *SharesLevel `xml:"defaultLevel,omitempty"`
}

type SingleIp struct {
	*IpAddress

	address string `xml:"address,omitempty"`
}

type SingleMac struct {
	*MacAddress

	address string `xml:"address,omitempty"`
}

type StoragePodSummary struct {
	*DynamicData

	name      string `xml:"name,omitempty"`
	capacity  int64  `xml:"capacity,omitempty"`
	freeSpace int64  `xml:"freeSpace,omitempty"`
}

type StorageIOAllocationInfo struct {
	*DynamicData

	limit       int64       `xml:"limit,omitempty"`
	shares      *SharesInfo `xml:"shares,omitempty"`
	reservation int32       `xml:"reservation,omitempty"`
}

type StorageIOAllocationOption struct {
	*DynamicData

	limitOption  *LongOption   `xml:"limitOption,omitempty"`
	sharesOption *SharesOption `xml:"sharesOption,omitempty"`
}

type StorageIORMInfo struct {
	*DynamicData

	enabled                  bool   `xml:"enabled,omitempty"`
	congestionThresholdMode  string `xml:"congestionThresholdMode,omitempty"`
	congestionThreshold      int32  `xml:"congestionThreshold,omitempty"`
	percentOfPeakThroughput  int32  `xml:"percentOfPeakThroughput,omitempty"`
	statsCollectionEnabled   bool   `xml:"statsCollectionEnabled,omitempty"`
	statsAggregationDisabled bool   `xml:"statsAggregationDisabled,omitempty"`
}

type StorageIORMConfigSpec struct {
	*DynamicData

	enabled                  bool   `xml:"enabled,omitempty"`
	congestionThresholdMode  string `xml:"congestionThresholdMode,omitempty"`
	congestionThreshold      int32  `xml:"congestionThreshold,omitempty"`
	percentOfPeakThroughput  int32  `xml:"percentOfPeakThroughput,omitempty"`
	statsCollectionEnabled   bool   `xml:"statsCollectionEnabled,omitempty"`
	statsAggregationDisabled bool   `xml:"statsAggregationDisabled,omitempty"`
}

type StorageIORMConfigOption struct {
	*DynamicData

	enabledOption                *BoolOption `xml:"enabledOption,omitempty"`
	congestionThresholdOption    *IntOption  `xml:"congestionThresholdOption,omitempty"`
	statsCollectionEnabledOption *BoolOption `xml:"statsCollectionEnabledOption,omitempty"`
}

type StoragePerformanceSummary struct {
	*DynamicData

	interval              int32     `xml:"interval,omitempty"`
	percentile            []int32   `xml:"percentile,omitempty"`
	datastoreReadLatency  []float64 `xml:"datastoreReadLatency,omitempty"`
	datastoreWriteLatency []float64 `xml:"datastoreWriteLatency,omitempty"`
	datastoreVmLatency    []float64 `xml:"datastoreVmLatency,omitempty"`
	datastoreReadIops     []float64 `xml:"datastoreReadIops,omitempty"`
	datastoreWriteIops    []float64 `xml:"datastoreWriteIops,omitempty"`
	siocActivityDuration  int32     `xml:"siocActivityDuration,omitempty"`
}

type ArrayOfStoragePerformanceSummary struct {
	StoragePerformanceSummary []*StoragePerformanceSummary `xml:"StoragePerformanceSummary,omitempty"`
}

type PodStorageDrsEntry struct {
	*DynamicData

	storageDrsConfig *StorageDrsConfigInfo    `xml:"storageDrsConfig,omitempty"`
	recommendation   []*ClusterRecommendation `xml:"recommendation,omitempty"`
	drsFault         []*ClusterDrsFaults      `xml:"drsFault,omitempty"`
	actionHistory    []*ClusterActionHistory  `xml:"actionHistory,omitempty"`
}

type StringExpression struct {
	*NegatableExpression

	value string `xml:"value,omitempty"`
}

type StringPolicy struct {
	*InheritablePolicy

	value string `xml:"value,omitempty"`
}

type Tag struct {
	*DynamicData

	key string `xml:"key,omitempty"`
}

type ArrayOfTag struct {
	Tag []*Tag `xml:"Tag,omitempty"`
}

type TaskDescription struct {
	*DynamicData

	methodInfo []*ElementDescription `xml:"methodInfo,omitempty"`
	state      []*ElementDescription `xml:"state,omitempty"`
	reason     []*TypeDescription    `xml:"reason,omitempty"`
}

type TaskFilterSpecByEntity struct {
	*DynamicData

	entity    *ManagedObjectReference        `xml:"entity,omitempty"`
	recursion *TaskFilterSpecRecursionOption `xml:"recursion,omitempty"`
}

type TaskFilterSpecByTime struct {
	*DynamicData

	timeType  *TaskFilterSpecTimeOption `xml:"timeType,omitempty"`
	beginTime time.Time                 `xml:"beginTime,omitempty"`
	endTime   time.Time                 `xml:"endTime,omitempty"`
}

type TaskFilterSpecByUsername struct {
	*DynamicData

	systemUser bool     `xml:"systemUser,omitempty"`
	userList   []string `xml:"userList,omitempty"`
}

type TaskFilterSpec struct {
	*DynamicData

	entity        *TaskFilterSpecByEntity   `xml:"entity,omitempty"`
	time          *TaskFilterSpecByTime     `xml:"time,omitempty"`
	userName      *TaskFilterSpecByUsername `xml:"userName,omitempty"`
	state         []*TaskInfoState          `xml:"state,omitempty"`
	alarm         *ManagedObjectReference   `xml:"alarm,omitempty"`
	scheduledTask *ManagedObjectReference   `xml:"scheduledTask,omitempty"`
	eventChainId  []int32                   `xml:"eventChainId,omitempty"`
	tag           []string                  `xml:"tag,omitempty"`
	parentTaskKey []string                  `xml:"parentTaskKey,omitempty"`
	rootTaskKey   []string                  `xml:"rootTaskKey,omitempty"`
}

type ArrayOfTaskInfoState struct {
	TaskInfoState []*TaskInfoState `xml:"TaskInfoState,omitempty"`
}

type TaskInfo struct {
	*DynamicData

	key           string                    `xml:"key,omitempty"`
	task          *ManagedObjectReference   `xml:"task,omitempty"`
	description   *LocalizableMessage       `xml:"description,omitempty"`
	name          string                    `xml:"name,omitempty"`
	descriptionId string                    `xml:"descriptionId,omitempty"`
	entity        *ManagedObjectReference   `xml:"entity,omitempty"`
	entityName    string                    `xml:"entityName,omitempty"`
	locked        []*ManagedObjectReference `xml:"locked,omitempty"`
	state         *TaskInfoState            `xml:"state,omitempty"`
	cancelled     bool                      `xml:"cancelled,omitempty"`
	cancelable    bool                      `xml:"cancelable,omitempty"`
	error         *LocalizedMethodFault     `xml:"error,omitempty"`
	result        interface{}               `xml:"result,omitempty"`
	progress      int32                     `xml:"progress,omitempty"`
	reason        *TaskReason               `xml:"reason,omitempty"`
	queueTime     time.Time                 `xml:"queueTime,omitempty"`
	startTime     time.Time                 `xml:"startTime,omitempty"`
	completeTime  time.Time                 `xml:"completeTime,omitempty"`
	eventChainId  int32                     `xml:"eventChainId,omitempty"`
	changeTag     string                    `xml:"changeTag,omitempty"`
	parentTaskKey string                    `xml:"parentTaskKey,omitempty"`
	rootTaskKey   string                    `xml:"rootTaskKey,omitempty"`
}

type ArrayOfTaskInfo struct {
	TaskInfo []*TaskInfo `xml:"TaskInfo,omitempty"`
}

type TaskReason struct {
	*DynamicData
}

type TaskReasonSystem struct {
	*TaskReason
}

type TaskReasonUser struct {
	*TaskReason

	userName string `xml:"userName,omitempty"`
}

type TaskReasonAlarm struct {
	*TaskReason

	alarmName  string                  `xml:"alarmName,omitempty"`
	alarm      *ManagedObjectReference `xml:"alarm,omitempty"`
	entityName string                  `xml:"entityName,omitempty"`
	entity     *ManagedObjectReference `xml:"entity,omitempty"`
}

type TaskReasonSchedule struct {
	*TaskReason

	name          string                  `xml:"name,omitempty"`
	scheduledTask *ManagedObjectReference `xml:"scheduledTask,omitempty"`
}

type TypeDescription struct {
	*Description

	key string `xml:"key,omitempty"`
}

type ArrayOfTypeDescription struct {
	TypeDescription []*TypeDescription `xml:"TypeDescription,omitempty"`
}

type UpdateVirtualMachineFilesResultFailedVmFileInfo struct {
	*DynamicData

	vmFile string                `xml:"vmFile,omitempty"`
	fault  *LocalizedMethodFault `xml:"fault,omitempty"`
}

type ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo struct {
	UpdateVirtualMachineFilesResultFailedVmFileInfo []*UpdateVirtualMachineFilesResultFailedVmFileInfo `xml:"UpdateVirtualMachineFilesResultFailedVmFileInfo,omitempty"`
}

type UpdateVirtualMachineFilesResult struct {
	*DynamicData

	failedVmFile []*UpdateVirtualMachineFilesResultFailedVmFileInfo `xml:"failedVmFile,omitempty"`
}

type UserSearchResult struct {
	*DynamicData

	principal string `xml:"principal,omitempty"`
	fullName  string `xml:"fullName,omitempty"`
	group     bool   `xml:"group,omitempty"`
}

type ArrayOfUserSearchResult struct {
	UserSearchResult []*UserSearchResult `xml:"UserSearchResult,omitempty"`
}

type UserSession struct {
	*DynamicData

	key              string    `xml:"key,omitempty"`
	userName         string    `xml:"userName,omitempty"`
	fullName         string    `xml:"fullName,omitempty"`
	loginTime        time.Time `xml:"loginTime,omitempty"`
	lastActiveTime   time.Time `xml:"lastActiveTime,omitempty"`
	locale           string    `xml:"locale,omitempty"`
	messageLocale    string    `xml:"messageLocale,omitempty"`
	extensionSession bool      `xml:"extensionSession,omitempty"`
	ipAddress        string    `xml:"ipAddress,omitempty"`
	userAgent        string    `xml:"userAgent,omitempty"`
	callCount        int64     `xml:"callCount,omitempty"`
}

type ArrayOfUserSession struct {
	UserSession []*UserSession `xml:"UserSession,omitempty"`
}

type VirtualAppSummary struct {
	*ResourcePoolSummary

	product             *VAppProductInfo     `xml:"product,omitempty"`
	vAppState           *VirtualAppVAppState `xml:"vAppState,omitempty"`
	suspended           bool                 `xml:"suspended,omitempty"`
	installBootRequired bool                 `xml:"installBootRequired,omitempty"`
	instanceUuid        string               `xml:"instanceUuid,omitempty"`
}

type VirtualAppLinkInfo struct {
	*DynamicData

	key               *ManagedObjectReference `xml:"key,omitempty"`
	destroyWithParent bool                    `xml:"destroyWithParent,omitempty"`
}

type ArrayOfVirtualAppLinkInfo struct {
	VirtualAppLinkInfo []*VirtualAppLinkInfo `xml:"VirtualAppLinkInfo,omitempty"`
}

type VirtualDiskSpec struct {
	*DynamicData

	diskType    string `xml:"diskType,omitempty"`
	adapterType string `xml:"adapterType,omitempty"`
}

type FileBackedVirtualDiskSpec struct {
	*VirtualDiskSpec

	capacityKb int64                        `xml:"capacityKb,omitempty"`
	profile    []*VirtualMachineProfileSpec `xml:"profile,omitempty"`
}

type SeSparseVirtualDiskSpec struct {
	*FileBackedVirtualDiskSpec

	grainSizeKb int32 `xml:"grainSizeKb,omitempty"`
}

type DeviceBackedVirtualDiskSpec struct {
	*VirtualDiskSpec

	device string `xml:"device,omitempty"`
}

type StorageRequirement struct {
	*DynamicData

	datastore             *ManagedObjectReference `xml:"datastore,omitempty"`
	freeSpaceRequiredInKb int64                   `xml:"freeSpaceRequiredInKb,omitempty"`
}

type ArrayOfStorageRequirement struct {
	StorageRequirement []*StorageRequirement `xml:"StorageRequirement,omitempty"`
}

type VirtualMachineTicket struct {
	*DynamicData

	ticket        string `xml:"ticket,omitempty"`
	cfgFile       string `xml:"cfgFile,omitempty"`
	host          string `xml:"host,omitempty"`
	port          int32  `xml:"port,omitempty"`
	sslThumbprint string `xml:"sslThumbprint,omitempty"`
}

type VirtualMachineMksTicket struct {
	*DynamicData

	ticket        string `xml:"ticket,omitempty"`
	cfgFile       string `xml:"cfgFile,omitempty"`
	host          string `xml:"host,omitempty"`
	port          int32  `xml:"port,omitempty"`
	sslThumbprint string `xml:"sslThumbprint,omitempty"`
}

type VirtualMachineDisplayTopology struct {
	*DynamicData

	x      int32 `xml:"x,omitempty"`
	y      int32 `xml:"y,omitempty"`
	width  int32 `xml:"width,omitempty"`
	height int32 `xml:"height,omitempty"`
}

type ArrayOfVirtualMachineDisplayTopology struct {
	VirtualMachineDisplayTopology []*VirtualMachineDisplayTopology `xml:"VirtualMachineDisplayTopology,omitempty"`
}

type DiskChangeExtent struct {
	*DynamicData

	start  int64 `xml:"start,omitempty"`
	length int64 `xml:"length,omitempty"`
}

type ArrayOfDiskChangeExtent struct {
	DiskChangeExtent []*DiskChangeExtent `xml:"DiskChangeExtent,omitempty"`
}

type DiskChangeInfo struct {
	*DynamicData

	startOffset int64               `xml:"startOffset,omitempty"`
	length      int64               `xml:"length,omitempty"`
	changedArea []*DiskChangeExtent `xml:"changedArea,omitempty"`
}

type VirtualMachineWipeResult struct {
	*DynamicData

	diskId              int32 `xml:"diskId,omitempty"`
	shrinkableDiskSpace int64 `xml:"shrinkableDiskSpace,omitempty"`
}

type Action struct {
	*DynamicData
}

type MethodActionArgument struct {
	*DynamicData

	value interface{} `xml:"value,omitempty"`
}

type ArrayOfMethodActionArgument struct {
	MethodActionArgument []*MethodActionArgument `xml:"MethodActionArgument,omitempty"`
}

type MethodAction struct {
	*Action

	name     string                  `xml:"name,omitempty"`
	argument []*MethodActionArgument `xml:"argument,omitempty"`
}

type SendEmailAction struct {
	*Action

	toList  string `xml:"toList,omitempty"`
	ccList  string `xml:"ccList,omitempty"`
	subject string `xml:"subject,omitempty"`
	body    string `xml:"body,omitempty"`
}

type SendSNMPAction struct {
	*Action
}

type RunScriptAction struct {
	*Action

	script string `xml:"script,omitempty"`
}

type CreateTaskAction struct {
	*Action

	taskTypeId string `xml:"taskTypeId,omitempty"`
	cancelable bool   `xml:"cancelable,omitempty"`
}

type AlarmAction struct {
	*DynamicData
}

type ArrayOfAlarmAction struct {
	AlarmAction []*AlarmAction `xml:"AlarmAction,omitempty"`
}

type AlarmTriggeringActionTransitionSpec struct {
	*DynamicData

	startState *ManagedEntityStatus `xml:"startState,omitempty"`
	finalState *ManagedEntityStatus `xml:"finalState,omitempty"`
	repeats    bool                 `xml:"repeats,omitempty"`
}

type ArrayOfAlarmTriggeringActionTransitionSpec struct {
	AlarmTriggeringActionTransitionSpec []*AlarmTriggeringActionTransitionSpec `xml:"AlarmTriggeringActionTransitionSpec,omitempty"`
}

type AlarmTriggeringAction struct {
	*AlarmAction

	action          *Action                                `xml:"action,omitempty"`
	transitionSpecs []*AlarmTriggeringActionTransitionSpec `xml:"transitionSpecs,omitempty"`
	green2yellow    bool                                   `xml:"green2yellow,omitempty"`
	yellow2red      bool                                   `xml:"yellow2red,omitempty"`
	red2yellow      bool                                   `xml:"red2yellow,omitempty"`
	yellow2green    bool                                   `xml:"yellow2green,omitempty"`
}

type GroupAlarmAction struct {
	*AlarmAction

	action []*AlarmAction `xml:"action,omitempty"`
}

type AlarmDescription struct {
	*DynamicData

	expr                               []*TypeDescription    `xml:"expr,omitempty"`
	stateOperator                      []*ElementDescription `xml:"stateOperator,omitempty"`
	metricOperator                     []*ElementDescription `xml:"metricOperator,omitempty"`
	hostSystemConnectionState          []*ElementDescription `xml:"hostSystemConnectionState,omitempty"`
	virtualMachinePowerState           []*ElementDescription `xml:"virtualMachinePowerState,omitempty"`
	datastoreConnectionState           []*ElementDescription `xml:"datastoreConnectionState,omitempty"`
	hostSystemPowerState               []*ElementDescription `xml:"hostSystemPowerState,omitempty"`
	virtualMachineGuestHeartbeatStatus []*ElementDescription `xml:"virtualMachineGuestHeartbeatStatus,omitempty"`
	entityStatus                       []*ElementDescription `xml:"entityStatus,omitempty"`
	action                             []*TypeDescription    `xml:"action,omitempty"`
}

type AlarmExpression struct {
	*DynamicData
}

type ArrayOfAlarmExpression struct {
	AlarmExpression []*AlarmExpression `xml:"AlarmExpression,omitempty"`
}

type AndAlarmExpression struct {
	*AlarmExpression

	expression []*AlarmExpression `xml:"expression,omitempty"`
}

type OrAlarmExpression struct {
	*AlarmExpression

	expression []*AlarmExpression `xml:"expression,omitempty"`
}

type StateAlarmExpression struct {
	*AlarmExpression

	operator  *StateAlarmOperator `xml:"operator,omitempty"`
	type_     string              `xml:"type,omitempty"`
	statePath string              `xml:"statePath,omitempty"`
	yellow    string              `xml:"yellow,omitempty"`
	red       string              `xml:"red,omitempty"`
}

type EventAlarmExpressionComparison struct {
	*DynamicData

	attributeName string `xml:"attributeName,omitempty"`
	operator      string `xml:"operator,omitempty"`
	value         string `xml:"value,omitempty"`
}

type ArrayOfEventAlarmExpressionComparison struct {
	EventAlarmExpressionComparison []*EventAlarmExpressionComparison `xml:"EventAlarmExpressionComparison,omitempty"`
}

type EventAlarmExpression struct {
	*AlarmExpression

	comparisons []*EventAlarmExpressionComparison `xml:"comparisons,omitempty"`
	eventType   string                            `xml:"eventType,omitempty"`
	eventTypeId string                            `xml:"eventTypeId,omitempty"`
	objectType  string                            `xml:"objectType,omitempty"`
	status      *ManagedEntityStatus              `xml:"status,omitempty"`
}

type MetricAlarmExpression struct {
	*AlarmExpression

	operator       *MetricAlarmOperator `xml:"operator,omitempty"`
	type_          string               `xml:"type,omitempty"`
	metric         *PerfMetricId        `xml:"metric,omitempty"`
	yellow         int32                `xml:"yellow,omitempty"`
	yellowInterval int32                `xml:"yellowInterval,omitempty"`
	red            int32                `xml:"red,omitempty"`
	redInterval    int32                `xml:"redInterval,omitempty"`
}

type AlarmInfo struct {
	*AlarmSpec

	key              string                  `xml:"key,omitempty"`
	alarm            *ManagedObjectReference `xml:"alarm,omitempty"`
	entity           *ManagedObjectReference `xml:"entity,omitempty"`
	lastModifiedTime time.Time               `xml:"lastModifiedTime,omitempty"`
	lastModifiedUser string                  `xml:"lastModifiedUser,omitempty"`
	creationEventId  int32                   `xml:"creationEventId,omitempty"`
}

type AlarmSetting struct {
	*DynamicData

	toleranceRange     int32 `xml:"toleranceRange,omitempty"`
	reportingFrequency int32 `xml:"reportingFrequency,omitempty"`
}

type AlarmSpec struct {
	*DynamicData

	name            string           `xml:"name,omitempty"`
	systemName      string           `xml:"systemName,omitempty"`
	description     string           `xml:"description,omitempty"`
	enabled         bool             `xml:"enabled,omitempty"`
	expression      *AlarmExpression `xml:"expression,omitempty"`
	action          *AlarmAction     `xml:"action,omitempty"`
	actionFrequency int32            `xml:"actionFrequency,omitempty"`
	setting         *AlarmSetting    `xml:"setting,omitempty"`
}

type AlarmState struct {
	*DynamicData

	key                string                  `xml:"key,omitempty"`
	entity             *ManagedObjectReference `xml:"entity,omitempty"`
	alarm              *ManagedObjectReference `xml:"alarm,omitempty"`
	overallStatus      *ManagedEntityStatus    `xml:"overallStatus,omitempty"`
	time               time.Time               `xml:"time,omitempty"`
	acknowledged       bool                    `xml:"acknowledged,omitempty"`
	acknowledgedByUser string                  `xml:"acknowledgedByUser,omitempty"`
	acknowledgedTime   time.Time               `xml:"acknowledgedTime,omitempty"`
}

type ArrayOfAlarmState struct {
	AlarmState []*AlarmState `xml:"AlarmState,omitempty"`
}

type ClusterAction struct {
	*DynamicData

	type_  string                  `xml:"type,omitempty"`
	target *ManagedObjectReference `xml:"target,omitempty"`
}

type ArrayOfClusterAction struct {
	ClusterAction []*ClusterAction `xml:"ClusterAction,omitempty"`
}

type ClusterActionHistory struct {
	*DynamicData

	action *ClusterAction `xml:"action,omitempty"`
	time   time.Time      `xml:"time,omitempty"`
}

type ArrayOfClusterActionHistory struct {
	ClusterActionHistory []*ClusterActionHistory `xml:"ClusterActionHistory,omitempty"`
}

type ClusterAffinityRuleSpec struct {
	*ClusterRuleInfo

	vm []*ManagedObjectReference `xml:"vm,omitempty"`
}

type ClusterAntiAffinityRuleSpec struct {
	*ClusterRuleInfo

	vm []*ManagedObjectReference `xml:"vm,omitempty"`
}

type ClusterAttemptedVmInfo struct {
	*DynamicData

	vm   *ManagedObjectReference `xml:"vm,omitempty"`
	task *ManagedObjectReference `xml:"task,omitempty"`
}

type ArrayOfClusterAttemptedVmInfo struct {
	ClusterAttemptedVmInfo []*ClusterAttemptedVmInfo `xml:"ClusterAttemptedVmInfo,omitempty"`
}

type ClusterConfigInfo struct {
	*DynamicData

	dasConfig   *ClusterDasConfigInfo     `xml:"dasConfig,omitempty"`
	dasVmConfig []*ClusterDasVmConfigInfo `xml:"dasVmConfig,omitempty"`
	drsConfig   *ClusterDrsConfigInfo     `xml:"drsConfig,omitempty"`
	drsVmConfig []*ClusterDrsVmConfigInfo `xml:"drsVmConfig,omitempty"`
	rule        []*ClusterRuleInfo        `xml:"rule,omitempty"`
}

type ClusterDrsConfigInfo struct {
	*DynamicData

	enabled                   bool           `xml:"enabled,omitempty"`
	enableVmBehaviorOverrides bool           `xml:"enableVmBehaviorOverrides,omitempty"`
	defaultVmBehavior         *DrsBehavior   `xml:"defaultVmBehavior,omitempty"`
	vmotionRate               int32          `xml:"vmotionRate,omitempty"`
	option                    []*OptionValue `xml:"option,omitempty"`
}

type ClusterDrsVmConfigInfo struct {
	*DynamicData

	key      *ManagedObjectReference `xml:"key,omitempty"`
	enabled  bool                    `xml:"enabled,omitempty"`
	behavior *DrsBehavior            `xml:"behavior,omitempty"`
}

type ArrayOfClusterDrsVmConfigInfo struct {
	ClusterDrsVmConfigInfo []*ClusterDrsVmConfigInfo `xml:"ClusterDrsVmConfigInfo,omitempty"`
}

type ClusterConfigInfoEx struct {
	*ComputeResourceConfigInfo

	dasConfig      *ClusterDasConfigInfo       `xml:"dasConfig,omitempty"`
	dasVmConfig    []*ClusterDasVmConfigInfo   `xml:"dasVmConfig,omitempty"`
	drsConfig      *ClusterDrsConfigInfo       `xml:"drsConfig,omitempty"`
	drsVmConfig    []*ClusterDrsVmConfigInfo   `xml:"drsVmConfig,omitempty"`
	rule           []*ClusterRuleInfo          `xml:"rule,omitempty"`
	dpmConfigInfo  *ClusterDpmConfigInfo       `xml:"dpmConfigInfo,omitempty"`
	dpmHostConfig  []*ClusterDpmHostConfigInfo `xml:"dpmHostConfig,omitempty"`
	vsanConfigInfo *VsanClusterConfigInfo      `xml:"vsanConfigInfo,omitempty"`
	vsanHostConfig []*VsanHostConfigInfo       `xml:"vsanHostConfig,omitempty"`
	group          []*ClusterGroupInfo         `xml:"group,omitempty"`
}

type ClusterDpmConfigInfo struct {
	*DynamicData

	enabled             bool           `xml:"enabled,omitempty"`
	defaultDpmBehavior  *DpmBehavior   `xml:"defaultDpmBehavior,omitempty"`
	hostPowerActionRate int32          `xml:"hostPowerActionRate,omitempty"`
	option              []*OptionValue `xml:"option,omitempty"`
}

type ClusterDpmHostConfigInfo struct {
	*DynamicData

	key      *ManagedObjectReference `xml:"key,omitempty"`
	enabled  bool                    `xml:"enabled,omitempty"`
	behavior *DpmBehavior            `xml:"behavior,omitempty"`
}

type ArrayOfClusterDpmHostConfigInfo struct {
	ClusterDpmHostConfigInfo []*ClusterDpmHostConfigInfo `xml:"ClusterDpmHostConfigInfo,omitempty"`
}

type ClusterConfigSpec struct {
	*DynamicData

	dasConfig       *ClusterDasConfigInfo     `xml:"dasConfig,omitempty"`
	dasVmConfigSpec []*ClusterDasVmConfigSpec `xml:"dasVmConfigSpec,omitempty"`
	drsConfig       *ClusterDrsConfigInfo     `xml:"drsConfig,omitempty"`
	drsVmConfigSpec []*ClusterDrsVmConfigSpec `xml:"drsVmConfigSpec,omitempty"`
	rulesSpec       []*ClusterRuleSpec        `xml:"rulesSpec,omitempty"`
}

type ClusterDasVmConfigSpec struct {
	*ArrayUpdateSpec

	info *ClusterDasVmConfigInfo `xml:"info,omitempty"`
}

type ArrayOfClusterDasVmConfigSpec struct {
	ClusterDasVmConfigSpec []*ClusterDasVmConfigSpec `xml:"ClusterDasVmConfigSpec,omitempty"`
}

type ClusterDrsVmConfigSpec struct {
	*ArrayUpdateSpec

	info *ClusterDrsVmConfigInfo `xml:"info,omitempty"`
}

type ArrayOfClusterDrsVmConfigSpec struct {
	ClusterDrsVmConfigSpec []*ClusterDrsVmConfigSpec `xml:"ClusterDrsVmConfigSpec,omitempty"`
}

type ClusterConfigSpecEx struct {
	*ComputeResourceConfigSpec

	dasConfig          *ClusterDasConfigInfo       `xml:"dasConfig,omitempty"`
	dasVmConfigSpec    []*ClusterDasVmConfigSpec   `xml:"dasVmConfigSpec,omitempty"`
	drsConfig          *ClusterDrsConfigInfo       `xml:"drsConfig,omitempty"`
	drsVmConfigSpec    []*ClusterDrsVmConfigSpec   `xml:"drsVmConfigSpec,omitempty"`
	rulesSpec          []*ClusterRuleSpec          `xml:"rulesSpec,omitempty"`
	dpmConfig          *ClusterDpmConfigInfo       `xml:"dpmConfig,omitempty"`
	dpmHostConfigSpec  []*ClusterDpmHostConfigSpec `xml:"dpmHostConfigSpec,omitempty"`
	vsanConfig         *VsanClusterConfigInfo      `xml:"vsanConfig,omitempty"`
	vsanHostConfigSpec []*VsanHostConfigInfo       `xml:"vsanHostConfigSpec,omitempty"`
	groupSpec          []*ClusterGroupSpec         `xml:"groupSpec,omitempty"`
}

type ClusterDpmHostConfigSpec struct {
	*ArrayUpdateSpec

	info *ClusterDpmHostConfigInfo `xml:"info,omitempty"`
}

type ArrayOfClusterDpmHostConfigSpec struct {
	ClusterDpmHostConfigSpec []*ClusterDpmHostConfigSpec `xml:"ClusterDpmHostConfigSpec,omitempty"`
}

type ClusterGroupSpec struct {
	*ArrayUpdateSpec

	info *ClusterGroupInfo `xml:"info,omitempty"`
}

type ArrayOfClusterGroupSpec struct {
	ClusterGroupSpec []*ClusterGroupSpec `xml:"ClusterGroupSpec,omitempty"`
}

type ClusterDasAamHostInfo struct {
	*ClusterDasHostInfo

	hostDasState []*ClusterDasAamNodeState `xml:"hostDasState,omitempty"`
	primaryHosts []string                  `xml:"primaryHosts,omitempty"`
}

type ClusterDasAamNodeState struct {
	*DynamicData

	host         *ManagedObjectReference `xml:"host,omitempty"`
	name         string                  `xml:"name,omitempty"`
	configState  string                  `xml:"configState,omitempty"`
	runtimeState string                  `xml:"runtimeState,omitempty"`
}

type ArrayOfClusterDasAamNodeState struct {
	ClusterDasAamNodeState []*ClusterDasAamNodeState `xml:"ClusterDasAamNodeState,omitempty"`
}

type ClusterDasAdmissionControlInfo struct {
	*DynamicData
}

type ClusterDasAdmissionControlPolicy struct {
	*DynamicData
}

type DasHeartbeatDatastoreInfo struct {
	*DynamicData

	datastore *ManagedObjectReference   `xml:"datastore,omitempty"`
	hosts     []*ManagedObjectReference `xml:"hosts,omitempty"`
}

type ArrayOfDasHeartbeatDatastoreInfo struct {
	DasHeartbeatDatastoreInfo []*DasHeartbeatDatastoreInfo `xml:"DasHeartbeatDatastoreInfo,omitempty"`
}

type ClusterDasAdvancedRuntimeInfo struct {
	*DynamicData

	dasHostInfo            *ClusterDasHostInfo          `xml:"dasHostInfo,omitempty"`
	heartbeatDatastoreInfo []*DasHeartbeatDatastoreInfo `xml:"heartbeatDatastoreInfo,omitempty"`
}

type ClusterDasConfigInfo struct {
	*DynamicData

	enabled                    bool                              `xml:"enabled,omitempty"`
	vmMonitoring               string                            `xml:"vmMonitoring,omitempty"`
	hostMonitoring             string                            `xml:"hostMonitoring,omitempty"`
	failoverLevel              int32                             `xml:"failoverLevel,omitempty"`
	admissionControlPolicy     *ClusterDasAdmissionControlPolicy `xml:"admissionControlPolicy,omitempty"`
	admissionControlEnabled    bool                              `xml:"admissionControlEnabled,omitempty"`
	defaultVmSettings          *ClusterDasVmSettings             `xml:"defaultVmSettings,omitempty"`
	option                     []*OptionValue                    `xml:"option,omitempty"`
	heartbeatDatastore         []*ManagedObjectReference         `xml:"heartbeatDatastore,omitempty"`
	hBDatastoreCandidatePolicy string                            `xml:"hBDatastoreCandidatePolicy,omitempty"`
}

type ClusterDasData struct {
	*DynamicData
}

type ClusterDasDataSummary struct {
	*ClusterDasData

	hostListVersion      int64 `xml:"hostListVersion,omitempty"`
	clusterConfigVersion int64 `xml:"clusterConfigVersion,omitempty"`
	compatListVersion    int64 `xml:"compatListVersion,omitempty"`
}

type ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo struct {
	*DynamicData

	numVcpus int32 `xml:"numVcpus,omitempty"`
	cpuMHz   int32 `xml:"cpuMHz,omitempty"`
	memoryMB int32 `xml:"memoryMB,omitempty"`
}

type ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots struct {
	*DynamicData

	host  *ManagedObjectReference `xml:"host,omitempty"`
	slots int32                   `xml:"slots,omitempty"`
}

type ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots struct {
	ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots []*ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots `xml:"ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots,omitempty"`
}

type ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots struct {
	*DynamicData

	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	slots int32                   `xml:"slots,omitempty"`
}

type ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots struct {
	ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots []*ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots `xml:"ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots,omitempty"`
}

type ClusterDasFailoverLevelAdvancedRuntimeInfo struct {
	*ClusterDasAdvancedRuntimeInfo

	slotInfo                  *ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo    `xml:"slotInfo,omitempty"`
	totalSlots                int32                                                  `xml:"totalSlots,omitempty"`
	usedSlots                 int32                                                  `xml:"usedSlots,omitempty"`
	unreservedSlots           int32                                                  `xml:"unreservedSlots,omitempty"`
	totalVms                  int32                                                  `xml:"totalVms,omitempty"`
	totalHosts                int32                                                  `xml:"totalHosts,omitempty"`
	totalGoodHosts            int32                                                  `xml:"totalGoodHosts,omitempty"`
	hostSlots                 []*ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots `xml:"hostSlots,omitempty"`
	vmsRequiringMultipleSlots []*ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots   `xml:"vmsRequiringMultipleSlots,omitempty"`
}

type ClusterDasFdmHostState struct {
	*DynamicData

	state         string                  `xml:"state,omitempty"`
	stateReporter *ManagedObjectReference `xml:"stateReporter,omitempty"`
}

type ClusterDasHostInfo struct {
	*DynamicData
}

type ClusterDasHostRecommendation struct {
	*DynamicData

	host      *ManagedObjectReference `xml:"host,omitempty"`
	drsRating int32                   `xml:"drsRating,omitempty"`
}

type ClusterDasVmConfigInfo struct {
	*DynamicData

	key                 *ManagedObjectReference `xml:"key,omitempty"`
	restartPriority     *DasVmPriority          `xml:"restartPriority,omitempty"`
	powerOffOnIsolation bool                    `xml:"powerOffOnIsolation,omitempty"`
	dasSettings         *ClusterDasVmSettings   `xml:"dasSettings,omitempty"`
}

type ArrayOfClusterDasVmConfigInfo struct {
	ClusterDasVmConfigInfo []*ClusterDasVmConfigInfo `xml:"ClusterDasVmConfigInfo,omitempty"`
}

type ClusterDasVmSettings struct {
	*DynamicData

	restartPriority           string                            `xml:"restartPriority,omitempty"`
	isolationResponse         string                            `xml:"isolationResponse,omitempty"`
	vmToolsMonitoringSettings *ClusterVmToolsMonitoringSettings `xml:"vmToolsMonitoringSettings,omitempty"`
}

type ClusterDrsFaultsFaultsByVm struct {
	*DynamicData

	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	fault []*LocalizedMethodFault `xml:"fault,omitempty"`
}

type ArrayOfClusterDrsFaultsFaultsByVm struct {
	ClusterDrsFaultsFaultsByVm []*ClusterDrsFaultsFaultsByVm `xml:"ClusterDrsFaultsFaultsByVm,omitempty"`
}

type ClusterDrsFaultsFaultsByVirtualDisk struct {
	*ClusterDrsFaultsFaultsByVm

	disk *VirtualDiskId `xml:"disk,omitempty"`
}

type ClusterDrsFaults struct {
	*DynamicData

	reason     string                        `xml:"reason,omitempty"`
	faultsByVm []*ClusterDrsFaultsFaultsByVm `xml:"faultsByVm,omitempty"`
}

type ArrayOfClusterDrsFaults struct {
	ClusterDrsFaults []*ClusterDrsFaults `xml:"ClusterDrsFaults,omitempty"`
}

type ClusterDrsMigration struct {
	*DynamicData

	key                   string                  `xml:"key,omitempty"`
	time                  time.Time               `xml:"time,omitempty"`
	vm                    *ManagedObjectReference `xml:"vm,omitempty"`
	cpuLoad               int32                   `xml:"cpuLoad,omitempty"`
	memoryLoad            int64                   `xml:"memoryLoad,omitempty"`
	source                *ManagedObjectReference `xml:"source,omitempty"`
	sourceCpuLoad         int32                   `xml:"sourceCpuLoad,omitempty"`
	sourceMemoryLoad      int64                   `xml:"sourceMemoryLoad,omitempty"`
	destination           *ManagedObjectReference `xml:"destination,omitempty"`
	destinationCpuLoad    int32                   `xml:"destinationCpuLoad,omitempty"`
	destinationMemoryLoad int64                   `xml:"destinationMemoryLoad,omitempty"`
}

type ArrayOfClusterDrsMigration struct {
	ClusterDrsMigration []*ClusterDrsMigration `xml:"ClusterDrsMigration,omitempty"`
}

type ClusterDrsRecommendation struct {
	*DynamicData

	key           string                 `xml:"key,omitempty"`
	rating        int32                  `xml:"rating,omitempty"`
	reason        string                 `xml:"reason,omitempty"`
	reasonText    string                 `xml:"reasonText,omitempty"`
	migrationList []*ClusterDrsMigration `xml:"migrationList,omitempty"`
}

type ArrayOfClusterDrsRecommendation struct {
	ClusterDrsRecommendation []*ClusterDrsRecommendation `xml:"ClusterDrsRecommendation,omitempty"`
}

type ClusterEnterMaintenanceResult struct {
	*DynamicData

	recommendations []*ClusterRecommendation `xml:"recommendations,omitempty"`
	fault           *ClusterDrsFaults        `xml:"fault,omitempty"`
}

type ClusterFailoverHostAdmissionControlInfoHostStatus struct {
	*DynamicData

	host   *ManagedObjectReference `xml:"host,omitempty"`
	status *ManagedEntityStatus    `xml:"status,omitempty"`
}

type ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus struct {
	ClusterFailoverHostAdmissionControlInfoHostStatus []*ClusterFailoverHostAdmissionControlInfoHostStatus `xml:"ClusterFailoverHostAdmissionControlInfoHostStatus,omitempty"`
}

type ClusterFailoverHostAdmissionControlInfo struct {
	*ClusterDasAdmissionControlInfo

	hostStatus []*ClusterFailoverHostAdmissionControlInfoHostStatus `xml:"hostStatus,omitempty"`
}

type ClusterFailoverHostAdmissionControlPolicy struct {
	*ClusterDasAdmissionControlPolicy

	failoverHosts []*ManagedObjectReference `xml:"failoverHosts,omitempty"`
}

type ClusterFailoverLevelAdmissionControlInfo struct {
	*ClusterDasAdmissionControlInfo

	currentFailoverLevel int32 `xml:"currentFailoverLevel,omitempty"`
}

type ClusterFailoverLevelAdmissionControlPolicy struct {
	*ClusterDasAdmissionControlPolicy

	failoverLevel int32              `xml:"failoverLevel,omitempty"`
	slotPolicy    *ClusterSlotPolicy `xml:"slotPolicy,omitempty"`
}

type ClusterFailoverResourcesAdmissionControlInfo struct {
	*ClusterDasAdmissionControlInfo

	currentCpuFailoverResourcesPercent    int32 `xml:"currentCpuFailoverResourcesPercent,omitempty"`
	currentMemoryFailoverResourcesPercent int32 `xml:"currentMemoryFailoverResourcesPercent,omitempty"`
}

type ClusterFailoverResourcesAdmissionControlPolicy struct {
	*ClusterDasAdmissionControlPolicy

	cpuFailoverResourcesPercent    int32 `xml:"cpuFailoverResourcesPercent,omitempty"`
	memoryFailoverResourcesPercent int32 `xml:"memoryFailoverResourcesPercent,omitempty"`
}

type ClusterGroupInfo struct {
	*DynamicData

	name        string `xml:"name,omitempty"`
	userCreated bool   `xml:"userCreated,omitempty"`
}

type ArrayOfClusterGroupInfo struct {
	ClusterGroupInfo []*ClusterGroupInfo `xml:"ClusterGroupInfo,omitempty"`
}

type ClusterHostGroup struct {
	*ClusterGroupInfo

	host []*ManagedObjectReference `xml:"host,omitempty"`
}

type ClusterHostPowerAction struct {
	*ClusterAction

	operationType        *HostPowerOperationType `xml:"operationType,omitempty"`
	powerConsumptionWatt int32                   `xml:"powerConsumptionWatt,omitempty"`
	cpuCapacityMHz       int32                   `xml:"cpuCapacityMHz,omitempty"`
	memCapacityMB        int32                   `xml:"memCapacityMB,omitempty"`
}

type ClusterHostRecommendation struct {
	*DynamicData

	host   *ManagedObjectReference `xml:"host,omitempty"`
	rating int32                   `xml:"rating,omitempty"`
}

type ArrayOfClusterHostRecommendation struct {
	ClusterHostRecommendation []*ClusterHostRecommendation `xml:"ClusterHostRecommendation,omitempty"`
}

type ClusterInitialPlacementAction struct {
	*ClusterAction

	targetHost *ManagedObjectReference `xml:"targetHost,omitempty"`
	pool       *ManagedObjectReference `xml:"pool,omitempty"`
}

type ClusterMigrationAction struct {
	*ClusterAction

	drsMigration *ClusterDrsMigration `xml:"drsMigration,omitempty"`
}

type ClusterNotAttemptedVmInfo struct {
	*DynamicData

	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	fault *LocalizedMethodFault   `xml:"fault,omitempty"`
}

type ArrayOfClusterNotAttemptedVmInfo struct {
	ClusterNotAttemptedVmInfo []*ClusterNotAttemptedVmInfo `xml:"ClusterNotAttemptedVmInfo,omitempty"`
}

type ClusterPowerOnVmResult struct {
	*DynamicData

	attempted       []*ClusterAttemptedVmInfo    `xml:"attempted,omitempty"`
	notAttempted    []*ClusterNotAttemptedVmInfo `xml:"notAttempted,omitempty"`
	recommendations []*ClusterRecommendation     `xml:"recommendations,omitempty"`
}

type ClusterRecommendation struct {
	*DynamicData

	key          string                  `xml:"key,omitempty"`
	type_        string                  `xml:"type,omitempty"`
	time         time.Time               `xml:"time,omitempty"`
	rating       int32                   `xml:"rating,omitempty"`
	reason       string                  `xml:"reason,omitempty"`
	reasonText   string                  `xml:"reasonText,omitempty"`
	prerequisite []string                `xml:"prerequisite,omitempty"`
	action       []*ClusterAction        `xml:"action,omitempty"`
	target       *ManagedObjectReference `xml:"target,omitempty"`
}

type ArrayOfClusterRecommendation struct {
	ClusterRecommendation []*ClusterRecommendation `xml:"ClusterRecommendation,omitempty"`
}

type ClusterRuleInfo struct {
	*DynamicData

	key          int32                `xml:"key,omitempty"`
	status       *ManagedEntityStatus `xml:"status,omitempty"`
	enabled      bool                 `xml:"enabled,omitempty"`
	name         string               `xml:"name,omitempty"`
	mandatory    bool                 `xml:"mandatory,omitempty"`
	userCreated  bool                 `xml:"userCreated,omitempty"`
	inCompliance bool                 `xml:"inCompliance,omitempty"`
}

type ArrayOfClusterRuleInfo struct {
	ClusterRuleInfo []*ClusterRuleInfo `xml:"ClusterRuleInfo,omitempty"`
}

type ClusterRuleSpec struct {
	*ArrayUpdateSpec

	info *ClusterRuleInfo `xml:"info,omitempty"`
}

type ArrayOfClusterRuleSpec struct {
	ClusterRuleSpec []*ClusterRuleSpec `xml:"ClusterRuleSpec,omitempty"`
}

type ClusterSlotPolicy struct {
	*DynamicData
}

type ClusterFixedSizeSlotPolicy struct {
	*ClusterSlotPolicy

	cpu    int32 `xml:"cpu,omitempty"`
	memory int32 `xml:"memory,omitempty"`
}

type ClusterVmGroup struct {
	*ClusterGroupInfo

	vm []*ManagedObjectReference `xml:"vm,omitempty"`
}

type ClusterVmHostRuleInfo struct {
	*ClusterRuleInfo

	vmGroupName             string `xml:"vmGroupName,omitempty"`
	affineHostGroupName     string `xml:"affineHostGroupName,omitempty"`
	antiAffineHostGroupName string `xml:"antiAffineHostGroupName,omitempty"`
}

type ClusterVmToolsMonitoringSettings struct {
	*DynamicData

	enabled          bool   `xml:"enabled,omitempty"`
	vmMonitoring     string `xml:"vmMonitoring,omitempty"`
	clusterSettings  bool   `xml:"clusterSettings,omitempty"`
	failureInterval  int32  `xml:"failureInterval,omitempty"`
	minUpTime        int32  `xml:"minUpTime,omitempty"`
	maxFailures      int32  `xml:"maxFailures,omitempty"`
	maxFailureWindow int32  `xml:"maxFailureWindow,omitempty"`
}

type DVPortConfigSpec struct {
	*DynamicData

	operation     string                    `xml:"operation,omitempty"`
	key           string                    `xml:"key,omitempty"`
	name          string                    `xml:"name,omitempty"`
	scope         []*ManagedObjectReference `xml:"scope,omitempty"`
	description   string                    `xml:"description,omitempty"`
	setting       *DVPortSetting            `xml:"setting,omitempty"`
	configVersion string                    `xml:"configVersion,omitempty"`
}

type ArrayOfDVPortConfigSpec struct {
	DVPortConfigSpec []*DVPortConfigSpec `xml:"DVPortConfigSpec,omitempty"`
}

type DVPortConfigInfo struct {
	*DynamicData

	name          string                    `xml:"name,omitempty"`
	scope         []*ManagedObjectReference `xml:"scope,omitempty"`
	description   string                    `xml:"description,omitempty"`
	setting       *DVPortSetting            `xml:"setting,omitempty"`
	configVersion string                    `xml:"configVersion,omitempty"`
}

type DVSTrafficShapingPolicy struct {
	*InheritablePolicy

	enabled          *BoolPolicy `xml:"enabled,omitempty"`
	averageBandwidth *LongPolicy `xml:"averageBandwidth,omitempty"`
	peakBandwidth    *LongPolicy `xml:"peakBandwidth,omitempty"`
	burstSize        *LongPolicy `xml:"burstSize,omitempty"`
}

type DVSHostLocalPortInfo struct {
	*DynamicData

	switchUuid string         `xml:"switchUuid,omitempty"`
	portKey    string         `xml:"portKey,omitempty"`
	setting    *DVPortSetting `xml:"setting,omitempty"`
	vnic       string         `xml:"vnic,omitempty"`
}

type DVSVendorSpecificConfig struct {
	*InheritablePolicy

	keyValue []*DistributedVirtualSwitchKeyedOpaqueBlob `xml:"keyValue,omitempty"`
}

type DvsFilterParameter struct {
	*DynamicData

	parameters []string `xml:"parameters,omitempty"`
}

type DvsFilterConfig struct {
	*InheritablePolicy

	key        string              `xml:"key,omitempty"`
	agentName  string              `xml:"agentName,omitempty"`
	slotNumber string              `xml:"slotNumber,omitempty"`
	parameters *DvsFilterParameter `xml:"parameters,omitempty"`
	onFailure  string              `xml:"onFailure,omitempty"`
}

type ArrayOfDvsFilterConfig struct {
	DvsFilterConfig []*DvsFilterConfig `xml:"DvsFilterConfig,omitempty"`
}

type DvsTrafficFilterConfig struct {
	*DvsFilterConfig

	trafficRuleset *DvsTrafficRuleset `xml:"trafficRuleset,omitempty"`
}

type DvsFilterConfigSpec struct {
	*DvsFilterConfig

	operation string `xml:"operation,omitempty"`
}

type DvsTrafficFilterConfigSpec struct {
	*DvsTrafficFilterConfig

	operation string `xml:"operation,omitempty"`
}

type DvsFilterPolicy struct {
	*InheritablePolicy

	filterConfig []*DvsFilterConfig `xml:"filterConfig,omitempty"`
}

type DVPortSetting struct {
	*DynamicData

	blocked                 *BoolPolicy              `xml:"blocked,omitempty"`
	vmDirectPathGen2Allowed *BoolPolicy              `xml:"vmDirectPathGen2Allowed,omitempty"`
	inShapingPolicy         *DVSTrafficShapingPolicy `xml:"inShapingPolicy,omitempty"`
	outShapingPolicy        *DVSTrafficShapingPolicy `xml:"outShapingPolicy,omitempty"`
	vendorSpecificConfig    *DVSVendorSpecificConfig `xml:"vendorSpecificConfig,omitempty"`
	networkResourcePoolKey  *StringPolicy            `xml:"networkResourcePoolKey,omitempty"`
	filterPolicy            *DvsFilterPolicy         `xml:"filterPolicy,omitempty"`
}

type DVPortStatus struct {
	*DynamicData

	linkUp                                 bool            `xml:"linkUp,omitempty"`
	blocked                                bool            `xml:"blocked,omitempty"`
	vlanIds                                []*NumericRange `xml:"vlanIds,omitempty"`
	trunkingMode                           bool            `xml:"trunkingMode,omitempty"`
	mtu                                    int32           `xml:"mtu,omitempty"`
	linkPeer                               string          `xml:"linkPeer,omitempty"`
	macAddress                             string          `xml:"macAddress,omitempty"`
	statusDetail                           string          `xml:"statusDetail,omitempty"`
	vmDirectPathGen2Active                 bool            `xml:"vmDirectPathGen2Active,omitempty"`
	vmDirectPathGen2InactiveReasonNetwork  []string        `xml:"vmDirectPathGen2InactiveReasonNetwork,omitempty"`
	vmDirectPathGen2InactiveReasonOther    []string        `xml:"vmDirectPathGen2InactiveReasonOther,omitempty"`
	vmDirectPathGen2InactiveReasonExtended string          `xml:"vmDirectPathGen2InactiveReasonExtended,omitempty"`
}

type DVPortState struct {
	*DynamicData

	runtimeInfo         *DVPortStatus                              `xml:"runtimeInfo,omitempty"`
	stats               *DistributedVirtualSwitchPortStatistics    `xml:"stats,omitempty"`
	vendorSpecificState []*DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificState,omitempty"`
}

type DistributedVirtualPort struct {
	*DynamicData

	key              string                                 `xml:"key,omitempty"`
	config           *DVPortConfigInfo                      `xml:"config,omitempty"`
	dvsUuid          string                                 `xml:"dvsUuid,omitempty"`
	portgroupKey     string                                 `xml:"portgroupKey,omitempty"`
	proxyHost        *ManagedObjectReference                `xml:"proxyHost,omitempty"`
	connectee        *DistributedVirtualSwitchPortConnectee `xml:"connectee,omitempty"`
	conflict         bool                                   `xml:"conflict,omitempty"`
	conflictPortKey  string                                 `xml:"conflictPortKey,omitempty"`
	state            *DVPortState                           `xml:"state,omitempty"`
	connectionCookie int32                                  `xml:"connectionCookie,omitempty"`
	lastStatusChange time.Time                              `xml:"lastStatusChange,omitempty"`
	hostLocalPort    bool                                   `xml:"hostLocalPort,omitempty"`
}

type ArrayOfDistributedVirtualPort struct {
	DistributedVirtualPort []*DistributedVirtualPort `xml:"DistributedVirtualPort,omitempty"`
}

type DVPortgroupPolicy struct {
	*DynamicData

	blockOverrideAllowed               bool `xml:"blockOverrideAllowed,omitempty"`
	shapingOverrideAllowed             bool `xml:"shapingOverrideAllowed,omitempty"`
	vendorConfigOverrideAllowed        bool `xml:"vendorConfigOverrideAllowed,omitempty"`
	livePortMovingAllowed              bool `xml:"livePortMovingAllowed,omitempty"`
	portConfigResetAtDisconnect        bool `xml:"portConfigResetAtDisconnect,omitempty"`
	networkResourcePoolOverrideAllowed bool `xml:"networkResourcePoolOverrideAllowed,omitempty"`
	trafficFilterOverrideAllowed       bool `xml:"trafficFilterOverrideAllowed,omitempty"`
}

type DVPortgroupConfigSpec struct {
	*DynamicData

	configVersion        string                                     `xml:"configVersion,omitempty"`
	name                 string                                     `xml:"name,omitempty"`
	numPorts             int32                                      `xml:"numPorts,omitempty"`
	portNameFormat       string                                     `xml:"portNameFormat,omitempty"`
	defaultPortConfig    *DVPortSetting                             `xml:"defaultPortConfig,omitempty"`
	description          string                                     `xml:"description,omitempty"`
	type_                string                                     `xml:"type,omitempty"`
	scope                []*ManagedObjectReference                  `xml:"scope,omitempty"`
	policy               *DVPortgroupPolicy                         `xml:"policy,omitempty"`
	vendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty"`
	autoExpand           bool                                       `xml:"autoExpand,omitempty"`
}

type ArrayOfDVPortgroupConfigSpec struct {
	DVPortgroupConfigSpec []*DVPortgroupConfigSpec `xml:"DVPortgroupConfigSpec,omitempty"`
}

type DVPortgroupConfigInfo struct {
	*DynamicData

	key                      string                                     `xml:"key,omitempty"`
	name                     string                                     `xml:"name,omitempty"`
	numPorts                 int32                                      `xml:"numPorts,omitempty"`
	distributedVirtualSwitch *ManagedObjectReference                    `xml:"distributedVirtualSwitch,omitempty"`
	defaultPortConfig        *DVPortSetting                             `xml:"defaultPortConfig,omitempty"`
	description              string                                     `xml:"description,omitempty"`
	type_                    string                                     `xml:"type,omitempty"`
	policy                   *DVPortgroupPolicy                         `xml:"policy,omitempty"`
	portNameFormat           string                                     `xml:"portNameFormat,omitempty"`
	scope                    []*ManagedObjectReference                  `xml:"scope,omitempty"`
	vendorSpecificConfig     []*DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty"`
	configVersion            string                                     `xml:"configVersion,omitempty"`
	autoExpand               bool                                       `xml:"autoExpand,omitempty"`
}

type DistributedVirtualPortgroupInfo struct {
	*DynamicData

	switchName      string                  `xml:"switchName,omitempty"`
	switchUuid      string                  `xml:"switchUuid,omitempty"`
	portgroupName   string                  `xml:"portgroupName,omitempty"`
	portgroupKey    string                  `xml:"portgroupKey,omitempty"`
	portgroupType   string                  `xml:"portgroupType,omitempty"`
	uplinkPortgroup bool                    `xml:"uplinkPortgroup,omitempty"`
	portgroup       *ManagedObjectReference `xml:"portgroup,omitempty"`
}

type ArrayOfDistributedVirtualPortgroupInfo struct {
	DistributedVirtualPortgroupInfo []*DistributedVirtualPortgroupInfo `xml:"DistributedVirtualPortgroupInfo,omitempty"`
}

type DVPortgroupSelection struct {
	*SelectionSet

	dvsUuid      string   `xml:"dvsUuid,omitempty"`
	portgroupKey []string `xml:"portgroupKey,omitempty"`
}

type DistributedVirtualSwitchInfo struct {
	*DynamicData

	switchName               string                  `xml:"switchName,omitempty"`
	switchUuid               string                  `xml:"switchUuid,omitempty"`
	distributedVirtualSwitch *ManagedObjectReference `xml:"distributedVirtualSwitch,omitempty"`
}

type ArrayOfDistributedVirtualSwitchInfo struct {
	DistributedVirtualSwitchInfo []*DistributedVirtualSwitchInfo `xml:"DistributedVirtualSwitchInfo,omitempty"`
}

type DVSManagerDvsConfigTarget struct {
	*DynamicData

	distributedVirtualPortgroup []*DistributedVirtualPortgroupInfo `xml:"distributedVirtualPortgroup,omitempty"`
	distributedVirtualSwitch    []*DistributedVirtualSwitchInfo    `xml:"distributedVirtualSwitch,omitempty"`
}

type DistributedVirtualSwitchManagerCompatibilityResult struct {
	*DynamicData

	host  *ManagedObjectReference `xml:"host,omitempty"`
	error []*LocalizedMethodFault `xml:"error,omitempty"`
}

type ArrayOfDistributedVirtualSwitchManagerCompatibilityResult struct {
	DistributedVirtualSwitchManagerCompatibilityResult []*DistributedVirtualSwitchManagerCompatibilityResult `xml:"DistributedVirtualSwitchManagerCompatibilityResult,omitempty"`
}

type DistributedVirtualSwitchManagerHostContainer struct {
	*DynamicData

	container *ManagedObjectReference `xml:"container,omitempty"`
	recursive bool                    `xml:"recursive,omitempty"`
}

type DistributedVirtualSwitchManagerHostDvsFilterSpec struct {
	*DynamicData

	inclusive bool `xml:"inclusive,omitempty"`
}

type ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec struct {
	DistributedVirtualSwitchManagerHostDvsFilterSpec []*DistributedVirtualSwitchManagerHostDvsFilterSpec `xml:"DistributedVirtualSwitchManagerHostDvsFilterSpec,omitempty"`
}

type DistributedVirtualSwitchManagerHostArrayFilter struct {
	*DistributedVirtualSwitchManagerHostDvsFilterSpec

	host []*ManagedObjectReference `xml:"host,omitempty"`
}

type DistributedVirtualSwitchManagerHostContainerFilter struct {
	*DistributedVirtualSwitchManagerHostDvsFilterSpec

	hostContainer *DistributedVirtualSwitchManagerHostContainer `xml:"hostContainer,omitempty"`
}

type DistributedVirtualSwitchManagerHostDvsMembershipFilter struct {
	*DistributedVirtualSwitchManagerHostDvsFilterSpec

	distributedVirtualSwitch *ManagedObjectReference `xml:"distributedVirtualSwitch,omitempty"`
}

type DistributedVirtualSwitchManagerDvsProductSpec struct {
	*DynamicData

	newSwitchProductSpec     *DistributedVirtualSwitchProductSpec `xml:"newSwitchProductSpec,omitempty"`
	distributedVirtualSwitch *ManagedObjectReference              `xml:"distributedVirtualSwitch,omitempty"`
}

type DistributedVirtualSwitchManagerImportResult struct {
	*DynamicData

	distributedVirtualSwitch    []*ManagedObjectReference                `xml:"distributedVirtualSwitch,omitempty"`
	distributedVirtualPortgroup []*ManagedObjectReference                `xml:"distributedVirtualPortgroup,omitempty"`
	importFault                 []*ImportOperationBulkFaultFaultOnImport `xml:"importFault,omitempty"`
}

type DVSSelection struct {
	*SelectionSet

	dvsUuid string `xml:"dvsUuid,omitempty"`
}

type EntityBackupConfig struct {
	*DynamicData

	entityType    string                  `xml:"entityType,omitempty"`
	configBlob    []byte                  `xml:"configBlob,omitempty"`
	key           string                  `xml:"key,omitempty"`
	name          string                  `xml:"name,omitempty"`
	container     *ManagedObjectReference `xml:"container,omitempty"`
	configVersion string                  `xml:"configVersion,omitempty"`
}

type ArrayOfEntityBackupConfig struct {
	EntityBackupConfig []*EntityBackupConfig `xml:"EntityBackupConfig,omitempty"`
}

type EntityBackup struct {
	*DynamicData
}

type DistributedVirtualSwitchHostMemberConfigSpec struct {
	*DynamicData

	operation            string                                     `xml:"operation,omitempty"`
	host                 *ManagedObjectReference                    `xml:"host,omitempty"`
	backing              *DistributedVirtualSwitchHostMemberBacking `xml:"backing,omitempty"`
	maxProxySwitchPorts  int32                                      `xml:"maxProxySwitchPorts,omitempty"`
	vendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty"`
}

type ArrayOfDistributedVirtualSwitchHostMemberConfigSpec struct {
	DistributedVirtualSwitchHostMemberConfigSpec []*DistributedVirtualSwitchHostMemberConfigSpec `xml:"DistributedVirtualSwitchHostMemberConfigSpec,omitempty"`
}

type DistributedVirtualSwitchHostMemberPnicSpec struct {
	*DynamicData

	pnicDevice         string `xml:"pnicDevice,omitempty"`
	uplinkPortKey      string `xml:"uplinkPortKey,omitempty"`
	uplinkPortgroupKey string `xml:"uplinkPortgroupKey,omitempty"`
	connectionCookie   int32  `xml:"connectionCookie,omitempty"`
}

type ArrayOfDistributedVirtualSwitchHostMemberPnicSpec struct {
	DistributedVirtualSwitchHostMemberPnicSpec []*DistributedVirtualSwitchHostMemberPnicSpec `xml:"DistributedVirtualSwitchHostMemberPnicSpec,omitempty"`
}

type DistributedVirtualSwitchHostMemberBacking struct {
	*DynamicData
}

type DistributedVirtualSwitchHostMemberPnicBacking struct {
	*DistributedVirtualSwitchHostMemberBacking

	pnicSpec []*DistributedVirtualSwitchHostMemberPnicSpec `xml:"pnicSpec,omitempty"`
}

type DistributedVirtualSwitchHostMemberRuntimeState struct {
	*DynamicData

	currentMaxProxySwitchPorts int32 `xml:"currentMaxProxySwitchPorts,omitempty"`
}

type DistributedVirtualSwitchHostMemberConfigInfo struct {
	*DynamicData

	host                 *ManagedObjectReference                    `xml:"host,omitempty"`
	maxProxySwitchPorts  int32                                      `xml:"maxProxySwitchPorts,omitempty"`
	vendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty"`
	backing              *DistributedVirtualSwitchHostMemberBacking `xml:"backing,omitempty"`
}

type HostMemberRuntimeInfo struct {
	*DynamicData

	host              *ManagedObjectReference        `xml:"host,omitempty"`
	status            string                         `xml:"status,omitempty"`
	statusDetail      string                         `xml:"statusDetail,omitempty"`
	healthCheckResult []*HostMemberHealthCheckResult `xml:"healthCheckResult,omitempty"`
}

type ArrayOfHostMemberRuntimeInfo struct {
	HostMemberRuntimeInfo []*HostMemberRuntimeInfo `xml:"HostMemberRuntimeInfo,omitempty"`
}

type HostMemberHealthCheckResult struct {
	*DynamicData

	summary string `xml:"summary,omitempty"`
}

type ArrayOfHostMemberHealthCheckResult struct {
	HostMemberHealthCheckResult []*HostMemberHealthCheckResult `xml:"HostMemberHealthCheckResult,omitempty"`
}

type HostMemberUplinkHealthCheckResult struct {
	*HostMemberHealthCheckResult

	uplinkPortKey string `xml:"uplinkPortKey,omitempty"`
}

type DistributedVirtualSwitchHostMember struct {
	*DynamicData

	runtimeState  *DistributedVirtualSwitchHostMemberRuntimeState `xml:"runtimeState,omitempty"`
	config        *DistributedVirtualSwitchHostMemberConfigInfo   `xml:"config,omitempty"`
	productInfo   *DistributedVirtualSwitchProductSpec            `xml:"productInfo,omitempty"`
	uplinkPortKey []string                                        `xml:"uplinkPortKey,omitempty"`
	status        string                                          `xml:"status,omitempty"`
	statusDetail  string                                          `xml:"statusDetail,omitempty"`
}

type ArrayOfDistributedVirtualSwitchHostMember struct {
	DistributedVirtualSwitchHostMember []*DistributedVirtualSwitchHostMember `xml:"DistributedVirtualSwitchHostMember,omitempty"`
}

type DistributedVirtualSwitchHostProductSpec struct {
	*DynamicData

	productLineId string `xml:"productLineId,omitempty"`
	version       string `xml:"version,omitempty"`
}

type ArrayOfDistributedVirtualSwitchHostProductSpec struct {
	DistributedVirtualSwitchHostProductSpec []*DistributedVirtualSwitchHostProductSpec `xml:"DistributedVirtualSwitchHostProductSpec,omitempty"`
}

type DistributedVirtualSwitchKeyedOpaqueBlob struct {
	*DynamicData

	key        string `xml:"key,omitempty"`
	opaqueData string `xml:"opaqueData,omitempty"`
}

type ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob struct {
	DistributedVirtualSwitchKeyedOpaqueBlob []*DistributedVirtualSwitchKeyedOpaqueBlob `xml:"DistributedVirtualSwitchKeyedOpaqueBlob,omitempty"`
}

type DVSNetworkResourcePoolAllocationInfo struct {
	*DynamicData

	limit       int64       `xml:"limit,omitempty"`
	shares      *SharesInfo `xml:"shares,omitempty"`
	priorityTag int32       `xml:"priorityTag,omitempty"`
}

type DVSNetworkResourcePoolConfigSpec struct {
	*DynamicData

	key            string                                `xml:"key,omitempty"`
	configVersion  string                                `xml:"configVersion,omitempty"`
	allocationInfo *DVSNetworkResourcePoolAllocationInfo `xml:"allocationInfo,omitempty"`
	name           string                                `xml:"name,omitempty"`
	description    string                                `xml:"description,omitempty"`
}

type ArrayOfDVSNetworkResourcePoolConfigSpec struct {
	DVSNetworkResourcePoolConfigSpec []*DVSNetworkResourcePoolConfigSpec `xml:"DVSNetworkResourcePoolConfigSpec,omitempty"`
}

type DVSNetworkResourcePool struct {
	*DynamicData

	key            string                                `xml:"key,omitempty"`
	name           string                                `xml:"name,omitempty"`
	description    string                                `xml:"description,omitempty"`
	configVersion  string                                `xml:"configVersion,omitempty"`
	allocationInfo *DVSNetworkResourcePoolAllocationInfo `xml:"allocationInfo,omitempty"`
}

type ArrayOfDVSNetworkResourcePool struct {
	DVSNetworkResourcePool []*DVSNetworkResourcePool `xml:"DVSNetworkResourcePool,omitempty"`
}

type DistributedVirtualSwitchPortConnectee struct {
	*DynamicData

	connectedEntity *ManagedObjectReference `xml:"connectedEntity,omitempty"`
	nicKey          string                  `xml:"nicKey,omitempty"`
	type_           string                  `xml:"type,omitempty"`
	addressHint     string                  `xml:"addressHint,omitempty"`
}

type DistributedVirtualSwitchPortConnection struct {
	*DynamicData

	switchUuid       string `xml:"switchUuid,omitempty"`
	portgroupKey     string `xml:"portgroupKey,omitempty"`
	portKey          string `xml:"portKey,omitempty"`
	connectionCookie int32  `xml:"connectionCookie,omitempty"`
}

type DistributedVirtualSwitchPortCriteria struct {
	*DynamicData

	connected    bool                    `xml:"connected,omitempty"`
	active       bool                    `xml:"active,omitempty"`
	uplinkPort   bool                    `xml:"uplinkPort,omitempty"`
	scope        *ManagedObjectReference `xml:"scope,omitempty"`
	portgroupKey []string                `xml:"portgroupKey,omitempty"`
	inside       bool                    `xml:"inside,omitempty"`
	portKey      []string                `xml:"portKey,omitempty"`
}

type DistributedVirtualSwitchPortStatistics struct {
	*DynamicData

	packetsInMulticast  int64 `xml:"packetsInMulticast,omitempty"`
	packetsOutMulticast int64 `xml:"packetsOutMulticast,omitempty"`
	bytesInMulticast    int64 `xml:"bytesInMulticast,omitempty"`
	bytesOutMulticast   int64 `xml:"bytesOutMulticast,omitempty"`
	packetsInUnicast    int64 `xml:"packetsInUnicast,omitempty"`
	packetsOutUnicast   int64 `xml:"packetsOutUnicast,omitempty"`
	bytesInUnicast      int64 `xml:"bytesInUnicast,omitempty"`
	bytesOutUnicast     int64 `xml:"bytesOutUnicast,omitempty"`
	packetsInBroadcast  int64 `xml:"packetsInBroadcast,omitempty"`
	packetsOutBroadcast int64 `xml:"packetsOutBroadcast,omitempty"`
	bytesInBroadcast    int64 `xml:"bytesInBroadcast,omitempty"`
	bytesOutBroadcast   int64 `xml:"bytesOutBroadcast,omitempty"`
	packetsInDropped    int64 `xml:"packetsInDropped,omitempty"`
	packetsOutDropped   int64 `xml:"packetsOutDropped,omitempty"`
	packetsInException  int64 `xml:"packetsInException,omitempty"`
	packetsOutException int64 `xml:"packetsOutException,omitempty"`
}

type DistributedVirtualSwitchProductSpec struct {
	*DynamicData

	name            string `xml:"name,omitempty"`
	vendor          string `xml:"vendor,omitempty"`
	version         string `xml:"version,omitempty"`
	build           string `xml:"build,omitempty"`
	forwardingClass string `xml:"forwardingClass,omitempty"`
	bundleId        string `xml:"bundleId,omitempty"`
	bundleUrl       string `xml:"bundleUrl,omitempty"`
}

type ArrayOfDistributedVirtualSwitchProductSpec struct {
	DistributedVirtualSwitchProductSpec []*DistributedVirtualSwitchProductSpec `xml:"DistributedVirtualSwitchProductSpec,omitempty"`
}

type DvsNetworkRuleQualifier struct {
	*DynamicData

	key string `xml:"key,omitempty"`
}

type ArrayOfDvsNetworkRuleQualifier struct {
	DvsNetworkRuleQualifier []*DvsNetworkRuleQualifier `xml:"DvsNetworkRuleQualifier,omitempty"`
}

type DvsNetworkRuleAction struct {
	*DynamicData
}

type DvsIpNetworkRuleQualifier struct {
	*DvsNetworkRuleQualifier

	sourceAddress      *IpAddress     `xml:"sourceAddress,omitempty"`
	destinationAddress *IpAddress     `xml:"destinationAddress,omitempty"`
	protocol           *IntExpression `xml:"protocol,omitempty"`
	sourceIpPort       *DvsIpPort     `xml:"sourceIpPort,omitempty"`
	destinationIpPort  *DvsIpPort     `xml:"destinationIpPort,omitempty"`
	tcpFlags           *IntExpression `xml:"tcpFlags,omitempty"`
}

type DvsIpPort struct {
	*NegatableExpression
}

type DvsSingleIpPort struct {
	*DvsIpPort

	portNumber int32 `xml:"portNumber,omitempty"`
}

type DvsIpPortRange struct {
	*DvsIpPort

	startPortNumber int32 `xml:"startPortNumber,omitempty"`
	endPortNumber   int32 `xml:"endPortNumber,omitempty"`
}

type DvsMacNetworkRuleQualifier struct {
	*DvsNetworkRuleQualifier

	sourceAddress      *MacAddress    `xml:"sourceAddress,omitempty"`
	destinationAddress *MacAddress    `xml:"destinationAddress,omitempty"`
	protocol           *IntExpression `xml:"protocol,omitempty"`
	vlanId             *IntExpression `xml:"vlanId,omitempty"`
}

type DvsSystemTrafficNetworkRuleQualifier struct {
	*DvsNetworkRuleQualifier

	typeOfSystemTraffic *StringExpression `xml:"typeOfSystemTraffic,omitempty"`
}

type DvsDropNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

type DvsAcceptNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

type DvsUpdateTagNetworkRuleAction struct {
	*DvsNetworkRuleAction

	qosTag  int32 `xml:"qosTag,omitempty"`
	dscpTag int32 `xml:"dscpTag,omitempty"`
}

type DvsRateLimitNetworkRuleAction struct {
	*DvsNetworkRuleAction

	packetsPerSecond int32 `xml:"packetsPerSecond,omitempty"`
}

type DvsLogNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

type DvsGreEncapNetworkRuleAction struct {
	*DvsNetworkRuleAction

	encapsulationIp *SingleIp `xml:"encapsulationIp,omitempty"`
}

type DvsMacRewriteNetworkRuleAction struct {
	*DvsNetworkRuleAction

	rewriteMac string `xml:"rewriteMac,omitempty"`
}

type DvsPuntNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

type DvsCopyNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

type DvsTrafficRule struct {
	*DynamicData

	key         string                     `xml:"key,omitempty"`
	description string                     `xml:"description,omitempty"`
	sequence    int32                      `xml:"sequence,omitempty"`
	qualifier   []*DvsNetworkRuleQualifier `xml:"qualifier,omitempty"`
	action      *DvsNetworkRuleAction      `xml:"action,omitempty"`
	direction   string                     `xml:"direction,omitempty"`
}

type ArrayOfDvsTrafficRule struct {
	DvsTrafficRule []*DvsTrafficRule `xml:"DvsTrafficRule,omitempty"`
}

type DvsTrafficRuleset struct {
	*DynamicData

	key        string            `xml:"key,omitempty"`
	enabled    bool              `xml:"enabled,omitempty"`
	precedence int32             `xml:"precedence,omitempty"`
	rules      []*DvsTrafficRule `xml:"rules,omitempty"`
}

type VMwareDVSFeatureCapability struct {
	*DVSFeatureCapability

	vspanSupported  bool                      `xml:"vspanSupported,omitempty"`
	lldpSupported   bool                      `xml:"lldpSupported,omitempty"`
	ipfixSupported  bool                      `xml:"ipfixSupported,omitempty"`
	vspanCapability *VMwareDVSVspanCapability `xml:"vspanCapability,omitempty"`
	lacpCapability  *VMwareDvsLacpCapability  `xml:"lacpCapability,omitempty"`
}

type VMwareDvsLacpCapability struct {
	*DynamicData

	lacpSupported           bool `xml:"lacpSupported,omitempty"`
	multiLacpGroupSupported bool `xml:"multiLacpGroupSupported,omitempty"`
}

type VMwareDVSHealthCheckCapability struct {
	*DVSHealthCheckCapability

	vlanMtuSupported bool `xml:"vlanMtuSupported,omitempty"`
	teamingSupported bool `xml:"teamingSupported,omitempty"`
}

type VMwareDVSVspanCapability struct {
	*DynamicData

	mixedDestSupported         bool `xml:"mixedDestSupported,omitempty"`
	dvportSupported            bool `xml:"dvportSupported,omitempty"`
	remoteSourceSupported      bool `xml:"remoteSourceSupported,omitempty"`
	remoteDestSupported        bool `xml:"remoteDestSupported,omitempty"`
	encapRemoteSourceSupported bool `xml:"encapRemoteSourceSupported,omitempty"`
}

type VMwareVspanPort struct {
	*DynamicData

	portKey                   []string `xml:"portKey,omitempty"`
	uplinkPortName            []string `xml:"uplinkPortName,omitempty"`
	wildcardPortConnecteeType []string `xml:"wildcardPortConnecteeType,omitempty"`
	vlans                     []int32  `xml:"vlans,omitempty"`
	ipAddress                 []string `xml:"ipAddress,omitempty"`
}

type VMwareVspanSession struct {
	*DynamicData

	key                   string           `xml:"key,omitempty"`
	name                  string           `xml:"name,omitempty"`
	description           string           `xml:"description,omitempty"`
	enabled               bool             `xml:"enabled,omitempty"`
	sourcePortTransmitted *VMwareVspanPort `xml:"sourcePortTransmitted,omitempty"`
	sourcePortReceived    *VMwareVspanPort `xml:"sourcePortReceived,omitempty"`
	destinationPort       *VMwareVspanPort `xml:"destinationPort,omitempty"`
	encapsulationVlanId   int32            `xml:"encapsulationVlanId,omitempty"`
	stripOriginalVlan     bool             `xml:"stripOriginalVlan,omitempty"`
	mirroredPacketLength  int32            `xml:"mirroredPacketLength,omitempty"`
	normalTrafficAllowed  bool             `xml:"normalTrafficAllowed,omitempty"`
	sessionType           string           `xml:"sessionType,omitempty"`
	samplingRate          int32            `xml:"samplingRate,omitempty"`
}

type ArrayOfVMwareVspanSession struct {
	VMwareVspanSession []*VMwareVspanSession `xml:"VMwareVspanSession,omitempty"`
}

type VMwareIpfixConfig struct {
	*DynamicData

	collectorIpAddress string `xml:"collectorIpAddress,omitempty"`
	collectorPort      int32  `xml:"collectorPort,omitempty"`
	activeFlowTimeout  int32  `xml:"activeFlowTimeout,omitempty"`
	idleFlowTimeout    int32  `xml:"idleFlowTimeout,omitempty"`
	samplingRate       int32  `xml:"samplingRate,omitempty"`
	internalFlowsOnly  bool   `xml:"internalFlowsOnly,omitempty"`
}

type VMwareDVSConfigInfo struct {
	*DVSConfigInfo

	vspanSession                []*VMwareVspanSession        `xml:"vspanSession,omitempty"`
	pvlanConfig                 []*VMwareDVSPvlanMapEntry    `xml:"pvlanConfig,omitempty"`
	maxMtu                      int32                        `xml:"maxMtu,omitempty"`
	linkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig `xml:"linkDiscoveryProtocolConfig,omitempty"`
	ipfixConfig                 *VMwareIpfixConfig           `xml:"ipfixConfig,omitempty"`
	lacpGroupConfig             []*VMwareDvsLacpGroupConfig  `xml:"lacpGroupConfig,omitempty"`
	lacpApiVersion              string                       `xml:"lacpApiVersion,omitempty"`
}

type VMwareDVSConfigSpec struct {
	*DVSConfigSpec

	pvlanConfigSpec             []*VMwareDVSPvlanConfigSpec  `xml:"pvlanConfigSpec,omitempty"`
	vspanConfigSpec             []*VMwareDVSVspanConfigSpec  `xml:"vspanConfigSpec,omitempty"`
	maxMtu                      int32                        `xml:"maxMtu,omitempty"`
	linkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig `xml:"linkDiscoveryProtocolConfig,omitempty"`
	ipfixConfig                 *VMwareIpfixConfig           `xml:"ipfixConfig,omitempty"`
	lacpApiVersion              string                       `xml:"lacpApiVersion,omitempty"`
}

type VMwareUplinkPortOrderPolicy struct {
	*InheritablePolicy

	activeUplinkPort  []string `xml:"activeUplinkPort,omitempty"`
	standbyUplinkPort []string `xml:"standbyUplinkPort,omitempty"`
}

type DVSFailureCriteria struct {
	*InheritablePolicy

	checkSpeed        *StringPolicy `xml:"checkSpeed,omitempty"`
	speed             *IntPolicy    `xml:"speed,omitempty"`
	checkDuplex       *BoolPolicy   `xml:"checkDuplex,omitempty"`
	fullDuplex        *BoolPolicy   `xml:"fullDuplex,omitempty"`
	checkErrorPercent *BoolPolicy   `xml:"checkErrorPercent,omitempty"`
	percentage        *IntPolicy    `xml:"percentage,omitempty"`
	checkBeacon       *BoolPolicy   `xml:"checkBeacon,omitempty"`
}

type VmwareUplinkPortTeamingPolicy struct {
	*InheritablePolicy

	policy          *StringPolicy                `xml:"policy,omitempty"`
	reversePolicy   *BoolPolicy                  `xml:"reversePolicy,omitempty"`
	notifySwitches  *BoolPolicy                  `xml:"notifySwitches,omitempty"`
	rollingOrder    *BoolPolicy                  `xml:"rollingOrder,omitempty"`
	failureCriteria *DVSFailureCriteria          `xml:"failureCriteria,omitempty"`
	uplinkPortOrder *VMwareUplinkPortOrderPolicy `xml:"uplinkPortOrder,omitempty"`
}

type VmwareDistributedVirtualSwitchVlanSpec struct {
	*InheritablePolicy
}

type VmwareDistributedVirtualSwitchPvlanSpec struct {
	*VmwareDistributedVirtualSwitchVlanSpec

	pvlanId int32 `xml:"pvlanId,omitempty"`
}

type VmwareDistributedVirtualSwitchVlanIdSpec struct {
	*VmwareDistributedVirtualSwitchVlanSpec

	vlanId int32 `xml:"vlanId,omitempty"`
}

type VmwareDistributedVirtualSwitchTrunkVlanSpec struct {
	*VmwareDistributedVirtualSwitchVlanSpec

	vlanId []*NumericRange `xml:"vlanId,omitempty"`
}

type DVSSecurityPolicy struct {
	*InheritablePolicy

	allowPromiscuous *BoolPolicy `xml:"allowPromiscuous,omitempty"`
	macChanges       *BoolPolicy `xml:"macChanges,omitempty"`
	forgedTransmits  *BoolPolicy `xml:"forgedTransmits,omitempty"`
}

type VMwareDVSPortSetting struct {
	*DVPortSetting

	vlan                *VmwareDistributedVirtualSwitchVlanSpec `xml:"vlan,omitempty"`
	qosTag              *IntPolicy                              `xml:"qosTag,omitempty"`
	uplinkTeamingPolicy *VmwareUplinkPortTeamingPolicy          `xml:"uplinkTeamingPolicy,omitempty"`
	securityPolicy      *DVSSecurityPolicy                      `xml:"securityPolicy,omitempty"`
	ipfixEnabled        *BoolPolicy                             `xml:"ipfixEnabled,omitempty"`
	txUplink            *BoolPolicy                             `xml:"txUplink,omitempty"`
	lacpPolicy          *VMwareUplinkLacpPolicy                 `xml:"lacpPolicy,omitempty"`
}

type VMwareDVSPortgroupPolicy struct {
	*DVPortgroupPolicy

	vlanOverrideAllowed           bool `xml:"vlanOverrideAllowed,omitempty"`
	uplinkTeamingOverrideAllowed  bool `xml:"uplinkTeamingOverrideAllowed,omitempty"`
	securityPolicyOverrideAllowed bool `xml:"securityPolicyOverrideAllowed,omitempty"`
	ipfixOverrideAllowed          bool `xml:"ipfixOverrideAllowed,omitempty"`
}

type VMwareDVSPvlanConfigSpec struct {
	*DynamicData

	pvlanEntry *VMwareDVSPvlanMapEntry `xml:"pvlanEntry,omitempty"`
	operation  string                  `xml:"operation,omitempty"`
}

type ArrayOfVMwareDVSPvlanConfigSpec struct {
	VMwareDVSPvlanConfigSpec []*VMwareDVSPvlanConfigSpec `xml:"VMwareDVSPvlanConfigSpec,omitempty"`
}

type VMwareDVSPvlanMapEntry struct {
	*DynamicData

	primaryVlanId   int32  `xml:"primaryVlanId,omitempty"`
	secondaryVlanId int32  `xml:"secondaryVlanId,omitempty"`
	pvlanType       string `xml:"pvlanType,omitempty"`
}

type ArrayOfVMwareDVSPvlanMapEntry struct {
	VMwareDVSPvlanMapEntry []*VMwareDVSPvlanMapEntry `xml:"VMwareDVSPvlanMapEntry,omitempty"`
}

type VMwareDVSVspanConfigSpec struct {
	*DynamicData

	vspanSession *VMwareVspanSession `xml:"vspanSession,omitempty"`
	operation    string              `xml:"operation,omitempty"`
}

type ArrayOfVMwareDVSVspanConfigSpec struct {
	VMwareDVSVspanConfigSpec []*VMwareDVSVspanConfigSpec `xml:"VMwareDVSVspanConfigSpec,omitempty"`
}

type VMwareDVSHealthCheckConfig struct {
	*DVSHealthCheckConfig
}

type VMwareDVSVlanMtuHealthCheckConfig struct {
	*VMwareDVSHealthCheckConfig
}

type VMwareDVSTeamingHealthCheckConfig struct {
	*VMwareDVSHealthCheckConfig
}

type VMwareDVSVlanHealthCheckResult struct {
	*HostMemberUplinkHealthCheckResult

	trunkedVlan   []*NumericRange `xml:"trunkedVlan,omitempty"`
	untrunkedVlan []*NumericRange `xml:"untrunkedVlan,omitempty"`
}

type VMwareDVSMtuHealthCheckResult struct {
	*HostMemberUplinkHealthCheckResult

	mtuMismatch             bool            `xml:"mtuMismatch,omitempty"`
	vlanSupportSwitchMtu    []*NumericRange `xml:"vlanSupportSwitchMtu,omitempty"`
	vlanNotSupportSwitchMtu []*NumericRange `xml:"vlanNotSupportSwitchMtu,omitempty"`
}

type VMwareDVSTeamingHealthCheckResult struct {
	*HostMemberHealthCheckResult

	teamingStatus string `xml:"teamingStatus,omitempty"`
}

type VMwareUplinkLacpPolicy struct {
	*InheritablePolicy

	enable *BoolPolicy   `xml:"enable,omitempty"`
	mode   *StringPolicy `xml:"mode,omitempty"`
}

type VMwareDvsLacpGroupConfig struct {
	*DynamicData

	key                  string                   `xml:"key,omitempty"`
	name                 string                   `xml:"name,omitempty"`
	mode                 string                   `xml:"mode,omitempty"`
	uplinkNum            int32                    `xml:"uplinkNum,omitempty"`
	loadbalanceAlgorithm string                   `xml:"loadbalanceAlgorithm,omitempty"`
	vlan                 *VMwareDvsLagVlanConfig  `xml:"vlan,omitempty"`
	ipfix                *VMwareDvsLagIpfixConfig `xml:"ipfix,omitempty"`
	uplinkName           []string                 `xml:"uplinkName,omitempty"`
	uplinkPortKey        []string                 `xml:"uplinkPortKey,omitempty"`
}

type ArrayOfVMwareDvsLacpGroupConfig struct {
	VMwareDvsLacpGroupConfig []*VMwareDvsLacpGroupConfig `xml:"VMwareDvsLacpGroupConfig,omitempty"`
}

type VMwareDvsLagVlanConfig struct {
	*DynamicData

	vlanId []*NumericRange `xml:"vlanId,omitempty"`
}

type VMwareDvsLagIpfixConfig struct {
	*DynamicData

	ipfixEnabled bool `xml:"ipfixEnabled,omitempty"`
}

type VMwareDvsLacpGroupSpec struct {
	*DynamicData

	lacpGroupConfig *VMwareDvsLacpGroupConfig `xml:"lacpGroupConfig,omitempty"`
	operation       string                    `xml:"operation,omitempty"`
}

type ArrayOfVMwareDvsLacpGroupSpec struct {
	VMwareDvsLacpGroupSpec []*VMwareDvsLacpGroupSpec `xml:"VMwareDvsLacpGroupSpec,omitempty"`
}

type Event struct {
	*DynamicData

	key                  int32                         `xml:"key,omitempty"`
	chainId              int32                         `xml:"chainId,omitempty"`
	createdTime          time.Time                     `xml:"createdTime,omitempty"`
	userName             string                        `xml:"userName,omitempty"`
	datacenter           *DatacenterEventArgument      `xml:"datacenter,omitempty"`
	computeResource      *ComputeResourceEventArgument `xml:"computeResource,omitempty"`
	host                 *HostEventArgument            `xml:"host,omitempty"`
	vm                   *VmEventArgument              `xml:"vm,omitempty"`
	ds                   *DatastoreEventArgument       `xml:"ds,omitempty"`
	net                  *NetworkEventArgument         `xml:"net,omitempty"`
	dvs                  *DvsEventArgument             `xml:"dvs,omitempty"`
	fullFormattedMessage string                        `xml:"fullFormattedMessage,omitempty"`
	changeTag            string                        `xml:"changeTag,omitempty"`
}

type ArrayOfEvent struct {
	Event []*Event `xml:"Event,omitempty"`
}

type GeneralEvent struct {
	*Event

	message string `xml:"message,omitempty"`
}

type GeneralHostInfoEvent struct {
	*GeneralEvent
}

type GeneralHostWarningEvent struct {
	*GeneralEvent
}

type GeneralHostErrorEvent struct {
	*GeneralEvent
}

type GeneralVmInfoEvent struct {
	*GeneralEvent
}

type GeneralVmWarningEvent struct {
	*GeneralEvent
}

type GeneralVmErrorEvent struct {
	*GeneralEvent
}

type GeneralUserEvent struct {
	*GeneralEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
}

type ExtendedEventPair struct {
	*DynamicData

	key   string `xml:"key,omitempty"`
	value string `xml:"value,omitempty"`
}

type ArrayOfExtendedEventPair struct {
	ExtendedEventPair []*ExtendedEventPair `xml:"ExtendedEventPair,omitempty"`
}

type ExtendedEvent struct {
	*GeneralEvent

	eventTypeId   string                  `xml:"eventTypeId,omitempty"`
	managedObject *ManagedObjectReference `xml:"managedObject,omitempty"`
	data          []*ExtendedEventPair    `xml:"data,omitempty"`
}

type HealthStatusChangedEvent struct {
	*Event

	componentId   string `xml:"componentId,omitempty"`
	oldStatus     string `xml:"oldStatus,omitempty"`
	newStatus     string `xml:"newStatus,omitempty"`
	componentName string `xml:"componentName,omitempty"`
}

type HostInventoryUnreadableEvent struct {
	*Event
}

type DatacenterEvent struct {
	*Event
}

type DatacenterCreatedEvent struct {
	*DatacenterEvent

	parent *FolderEventArgument `xml:"parent,omitempty"`
}

type DatacenterRenamedEvent struct {
	*DatacenterEvent

	oldName string `xml:"oldName,omitempty"`
	newName string `xml:"newName,omitempty"`
}

type SessionEvent struct {
	*Event
}

type ServerStartedSessionEvent struct {
	*SessionEvent
}

type UserLoginSessionEvent struct {
	*SessionEvent

	ipAddress string `xml:"ipAddress,omitempty"`
	userAgent string `xml:"userAgent,omitempty"`
	locale    string `xml:"locale,omitempty"`
	sessionId string `xml:"sessionId,omitempty"`
}

type UserLogoutSessionEvent struct {
	*SessionEvent

	ipAddress string    `xml:"ipAddress,omitempty"`
	userAgent string    `xml:"userAgent,omitempty"`
	callCount int64     `xml:"callCount,omitempty"`
	sessionId string    `xml:"sessionId,omitempty"`
	loginTime time.Time `xml:"loginTime,omitempty"`
}

type BadUsernameSessionEvent struct {
	*SessionEvent

	ipAddress string `xml:"ipAddress,omitempty"`
}

type AlreadyAuthenticatedSessionEvent struct {
	*SessionEvent
}

type NoAccessUserEvent struct {
	*SessionEvent

	ipAddress string `xml:"ipAddress,omitempty"`
}

type SessionTerminatedEvent struct {
	*SessionEvent

	sessionId          string `xml:"sessionId,omitempty"`
	terminatedUsername string `xml:"terminatedUsername,omitempty"`
}

type GlobalMessageChangedEvent struct {
	*SessionEvent

	message string `xml:"message,omitempty"`
}

type UpgradeEvent struct {
	*Event

	message string `xml:"message,omitempty"`
}

type InfoUpgradeEvent struct {
	*UpgradeEvent
}

type WarningUpgradeEvent struct {
	*UpgradeEvent
}

type ErrorUpgradeEvent struct {
	*UpgradeEvent
}

type UserUpgradeEvent struct {
	*UpgradeEvent
}

type HostEvent struct {
	*Event
}

type HostDasEvent struct {
	*HostEvent
}

type HostConnectedEvent struct {
	*HostEvent
}

type HostDisconnectedEvent struct {
	*HostEvent

	reason string `xml:"reason,omitempty"`
}

type HostSyncFailedEvent struct {
	*HostEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type HostConnectionLostEvent struct {
	*HostEvent
}

type HostReconnectionFailedEvent struct {
	*HostEvent
}

type HostCnxFailedNoConnectionEvent struct {
	*HostEvent
}

type HostCnxFailedBadUsernameEvent struct {
	*HostEvent
}

type HostCnxFailedBadVersionEvent struct {
	*HostEvent
}

type HostCnxFailedAlreadyManagedEvent struct {
	*HostEvent

	serverName string `xml:"serverName,omitempty"`
}

type HostCnxFailedNoLicenseEvent struct {
	*HostEvent
}

type HostCnxFailedNetworkErrorEvent struct {
	*HostEvent
}

type HostRemovedEvent struct {
	*HostEvent
}

type HostCnxFailedCcagentUpgradeEvent struct {
	*HostEvent
}

type HostCnxFailedBadCcagentEvent struct {
	*HostEvent
}

type HostCnxFailedEvent struct {
	*HostEvent
}

type HostCnxFailedAccountFailedEvent struct {
	*HostEvent
}

type HostCnxFailedNoAccessEvent struct {
	*HostEvent
}

type HostShutdownEvent struct {
	*HostEvent

	reason string `xml:"reason,omitempty"`
}

type HostCnxFailedNotFoundEvent struct {
	*HostEvent
}

type HostCnxFailedTimeoutEvent struct {
	*HostEvent
}

type HostUpgradeFailedEvent struct {
	*HostEvent
}

type EnteringMaintenanceModeEvent struct {
	*HostEvent
}

type EnteredMaintenanceModeEvent struct {
	*HostEvent
}

type ExitMaintenanceModeEvent struct {
	*HostEvent
}

type CanceledHostOperationEvent struct {
	*HostEvent
}

type TimedOutHostOperationEvent struct {
	*HostEvent
}

type HostDasEnabledEvent struct {
	*HostEvent
}

type HostDasDisabledEvent struct {
	*HostEvent
}

type HostDasEnablingEvent struct {
	*HostEvent
}

type HostDasDisablingEvent struct {
	*HostEvent
}

type HostDasErrorEvent struct {
	*HostEvent

	message string `xml:"message,omitempty"`
	reason  string `xml:"reason,omitempty"`
}

type HostDasOkEvent struct {
	*HostEvent
}

type VcAgentUpgradedEvent struct {
	*HostEvent
}

type VcAgentUninstalledEvent struct {
	*HostEvent
}

type VcAgentUpgradeFailedEvent struct {
	*HostEvent

	reason string `xml:"reason,omitempty"`
}

type VcAgentUninstallFailedEvent struct {
	*HostEvent

	reason string `xml:"reason,omitempty"`
}

type HostAddedEvent struct {
	*HostEvent
}

type HostAddFailedEvent struct {
	*HostEvent

	hostname string `xml:"hostname,omitempty"`
}

type HostIpChangedEvent struct {
	*HostEvent

	oldIP string `xml:"oldIP,omitempty"`
	newIP string `xml:"newIP,omitempty"`
}

type EnteringStandbyModeEvent struct {
	*HostEvent
}

type DrsEnteringStandbyModeEvent struct {
	*EnteringStandbyModeEvent
}

type EnteredStandbyModeEvent struct {
	*HostEvent
}

type DrsEnteredStandbyModeEvent struct {
	*EnteredStandbyModeEvent
}

type ExitingStandbyModeEvent struct {
	*HostEvent
}

type DrsExitingStandbyModeEvent struct {
	*ExitingStandbyModeEvent
}

type ExitedStandbyModeEvent struct {
	*HostEvent
}

type DrsExitedStandbyModeEvent struct {
	*ExitedStandbyModeEvent
}

type ExitStandbyModeFailedEvent struct {
	*HostEvent
}

type DrsExitStandbyModeFailedEvent struct {
	*ExitStandbyModeFailedEvent
}

type UpdatedAgentBeingRestartedEvent struct {
	*HostEvent
}

type AccountCreatedEvent struct {
	*HostEvent

	spec  *HostAccountSpec `xml:"spec,omitempty"`
	group bool             `xml:"group,omitempty"`
}

type AccountRemovedEvent struct {
	*HostEvent

	account string `xml:"account,omitempty"`
	group   bool   `xml:"group,omitempty"`
}

type UserPasswordChanged struct {
	*HostEvent

	userLogin string `xml:"userLogin,omitempty"`
}

type AccountUpdatedEvent struct {
	*HostEvent

	spec  *HostAccountSpec `xml:"spec,omitempty"`
	group bool             `xml:"group,omitempty"`
}

type UserAssignedToGroup struct {
	*HostEvent

	userLogin string `xml:"userLogin,omitempty"`
	group     string `xml:"group,omitempty"`
}

type UserUnassignedFromGroup struct {
	*HostEvent

	userLogin string `xml:"userLogin,omitempty"`
	group     string `xml:"group,omitempty"`
}

type DatastorePrincipalConfigured struct {
	*HostEvent

	datastorePrincipal string `xml:"datastorePrincipal,omitempty"`
}

type VMFSDatastoreCreatedEvent struct {
	*HostEvent

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type NASDatastoreCreatedEvent struct {
	*HostEvent

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type LocalDatastoreCreatedEvent struct {
	*HostEvent

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type VMFSDatastoreExtendedEvent struct {
	*HostEvent

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type VMFSDatastoreExpandedEvent struct {
	*HostEvent

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type DatastoreRemovedOnHostEvent struct {
	*HostEvent

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type DatastoreRenamedOnHostEvent struct {
	*HostEvent

	oldName string `xml:"oldName,omitempty"`
	newName string `xml:"newName,omitempty"`
}

type DuplicateIpDetectedEvent struct {
	*HostEvent

	duplicateIP string `xml:"duplicateIP,omitempty"`
	macAddress  string `xml:"macAddress,omitempty"`
}

type DatastoreDiscoveredEvent struct {
	*HostEvent

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type DrsResourceConfigureFailedEvent struct {
	*HostEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type DrsResourceConfigureSyncedEvent struct {
	*HostEvent
}

type HostGetShortNameFailedEvent struct {
	*HostEvent
}

type HostShortNameToIpFailedEvent struct {
	*HostEvent

	shortName string `xml:"shortName,omitempty"`
}

type HostIpToShortNameFailedEvent struct {
	*HostEvent
}

type HostPrimaryAgentNotShortNameEvent struct {
	*HostDasEvent

	primaryAgent string `xml:"primaryAgent,omitempty"`
}

type HostNotInClusterEvent struct {
	*HostDasEvent
}

type HostIsolationIpPingFailedEvent struct {
	*HostDasEvent

	isolationIp string `xml:"isolationIp,omitempty"`
}

type HostIpInconsistentEvent struct {
	*HostEvent

	ipAddress  string `xml:"ipAddress,omitempty"`
	ipAddress2 string `xml:"ipAddress2,omitempty"`
}

type HostUserWorldSwapNotEnabledEvent struct {
	*HostEvent
}

type HostNonCompliantEvent struct {
	*HostEvent
}

type HostCompliantEvent struct {
	*HostEvent
}

type HostComplianceCheckedEvent struct {
	*HostEvent

	profile *ProfileEventArgument `xml:"profile,omitempty"`
}

type ClusterComplianceCheckedEvent struct {
	*ClusterEvent

	profile *ProfileEventArgument `xml:"profile,omitempty"`
}

type ProfileEvent struct {
	*Event

	profile *ProfileEventArgument `xml:"profile,omitempty"`
}

type ProfileCreatedEvent struct {
	*ProfileEvent
}

type ProfileRemovedEvent struct {
	*ProfileEvent
}

type ProfileAssociatedEvent struct {
	*ProfileEvent
}

type ProfileDissociatedEvent struct {
	*ProfileEvent
}

type HostConfigAppliedEvent struct {
	*HostEvent
}

type ProfileReferenceHostChangedEvent struct {
	*ProfileEvent

	referenceHost *ManagedObjectReference `xml:"referenceHost,omitempty"`
}

type ProfileChangedEvent struct {
	*ProfileEvent
}

type HostProfileAppliedEvent struct {
	*HostEvent

	profile *ProfileEventArgument `xml:"profile,omitempty"`
}

type HostShortNameInconsistentEvent struct {
	*HostDasEvent

	shortName  string `xml:"shortName,omitempty"`
	shortName2 string `xml:"shortName2,omitempty"`
}

type HostNoRedundantManagementNetworkEvent struct {
	*HostDasEvent
}

type HostNoAvailableNetworksEvent struct {
	*HostDasEvent

	ips string `xml:"ips,omitempty"`
}

type HostExtraNetworksEvent struct {
	*HostDasEvent

	ips string `xml:"ips,omitempty"`
}

type HostNoHAEnabledPortGroupsEvent struct {
	*HostDasEvent
}

type HostMissingNetworksEvent struct {
	*HostDasEvent

	ips string `xml:"ips,omitempty"`
}

type VnicPortArgument struct {
	*DynamicData

	vnic string                                  `xml:"vnic,omitempty"`
	port *DistributedVirtualSwitchPortConnection `xml:"port,omitempty"`
}

type ArrayOfVnicPortArgument struct {
	VnicPortArgument []*VnicPortArgument `xml:"VnicPortArgument,omitempty"`
}

type HostVnicConnectedToCustomizedDVPortEvent struct {
	*HostEvent

	vnic *VnicPortArgument `xml:"vnic,omitempty"`
}

type GhostDvsProxySwitchDetectedEvent struct {
	*HostEvent

	switchUuid []string `xml:"switchUuid,omitempty"`
}

type GhostDvsProxySwitchRemovedEvent struct {
	*HostEvent

	switchUuid []string `xml:"switchUuid,omitempty"`
}

type VmEvent struct {
	*Event

	template bool `xml:"template,omitempty"`
}

type VmPoweredOffEvent struct {
	*VmEvent
}

type VmPoweredOnEvent struct {
	*VmEvent
}

type VmSuspendedEvent struct {
	*VmEvent
}

type VmStartingEvent struct {
	*VmEvent
}

type VmStoppingEvent struct {
	*VmEvent
}

type VmSuspendingEvent struct {
	*VmEvent
}

type VmResumingEvent struct {
	*VmEvent
}

type VmDisconnectedEvent struct {
	*VmEvent
}

type VmRemoteConsoleConnectedEvent struct {
	*VmEvent
}

type VmRemoteConsoleDisconnectedEvent struct {
	*VmEvent
}

type VmDiscoveredEvent struct {
	*VmEvent
}

type VmOrphanedEvent struct {
	*VmEvent
}

type VmBeingCreatedEvent struct {
	*VmEvent

	configSpec *VirtualMachineConfigSpec `xml:"configSpec,omitempty"`
}

type VmCreatedEvent struct {
	*VmEvent
}

type VmStartRecordingEvent struct {
	*VmEvent
}

type VmEndRecordingEvent struct {
	*VmEvent
}

type VmStartReplayingEvent struct {
	*VmEvent
}

type VmEndReplayingEvent struct {
	*VmEvent
}

type VmRegisteredEvent struct {
	*VmEvent
}

type VmAutoRenameEvent struct {
	*VmEvent

	oldName string `xml:"oldName,omitempty"`
	newName string `xml:"newName,omitempty"`
}

type VmBeingHotMigratedEvent struct {
	*VmEvent

	destHost       *HostEventArgument       `xml:"destHost,omitempty"`
	destDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty"`
	destDatastore  *DatastoreEventArgument  `xml:"destDatastore,omitempty"`
}

type VmResettingEvent struct {
	*VmEvent
}

type VmStaticMacConflictEvent struct {
	*VmEvent

	conflictedVm *VmEventArgument `xml:"conflictedVm,omitempty"`
	mac          string           `xml:"mac,omitempty"`
}

type VmMacConflictEvent struct {
	*VmEvent

	conflictedVm *VmEventArgument `xml:"conflictedVm,omitempty"`
	mac          string           `xml:"mac,omitempty"`
}

type VmBeingDeployedEvent struct {
	*VmEvent

	srcTemplate *VmEventArgument `xml:"srcTemplate,omitempty"`
}

type VmDeployFailedEvent struct {
	*VmEvent

	destDatastore *EntityEventArgument  `xml:"destDatastore,omitempty"`
	reason        *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmDeployedEvent struct {
	*VmEvent

	srcTemplate *VmEventArgument `xml:"srcTemplate,omitempty"`
}

type VmMacChangedEvent struct {
	*VmEvent

	adapter string `xml:"adapter,omitempty"`
	oldMac  string `xml:"oldMac,omitempty"`
	newMac  string `xml:"newMac,omitempty"`
}

type VmMacAssignedEvent struct {
	*VmEvent

	adapter string `xml:"adapter,omitempty"`
	mac     string `xml:"mac,omitempty"`
}

type VmUuidConflictEvent struct {
	*VmEvent

	conflictedVm *VmEventArgument `xml:"conflictedVm,omitempty"`
	uuid         string           `xml:"uuid,omitempty"`
}

type VmInstanceUuidConflictEvent struct {
	*VmEvent

	conflictedVm *VmEventArgument `xml:"conflictedVm,omitempty"`
	instanceUuid string           `xml:"instanceUuid,omitempty"`
}

type VmBeingMigratedEvent struct {
	*VmEvent

	destHost       *HostEventArgument       `xml:"destHost,omitempty"`
	destDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty"`
	destDatastore  *DatastoreEventArgument  `xml:"destDatastore,omitempty"`
}

type VmFailedMigrateEvent struct {
	*VmEvent

	destHost       *HostEventArgument       `xml:"destHost,omitempty"`
	reason         *LocalizedMethodFault    `xml:"reason,omitempty"`
	destDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty"`
	destDatastore  *DatastoreEventArgument  `xml:"destDatastore,omitempty"`
}

type VmMigratedEvent struct {
	*VmEvent

	sourceHost       *HostEventArgument       `xml:"sourceHost,omitempty"`
	sourceDatacenter *DatacenterEventArgument `xml:"sourceDatacenter,omitempty"`
	sourceDatastore  *DatastoreEventArgument  `xml:"sourceDatastore,omitempty"`
}

type VmUnsupportedStartingEvent struct {
	*VmStartingEvent

	guestId string `xml:"guestId,omitempty"`
}

type DrsVmMigratedEvent struct {
	*VmMigratedEvent
}

type DrsVmPoweredOnEvent struct {
	*VmPoweredOnEvent
}

type DrsRuleViolationEvent struct {
	*VmEvent
}

type DrsRuleComplianceEvent struct {
	*VmEvent
}

type VmRelocateSpecEvent struct {
	*VmEvent
}

type VmBeingRelocatedEvent struct {
	*VmRelocateSpecEvent

	destHost       *HostEventArgument       `xml:"destHost,omitempty"`
	destDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty"`
	destDatastore  *DatastoreEventArgument  `xml:"destDatastore,omitempty"`
}

type VmRelocatedEvent struct {
	*VmRelocateSpecEvent

	sourceHost       *HostEventArgument       `xml:"sourceHost,omitempty"`
	sourceDatacenter *DatacenterEventArgument `xml:"sourceDatacenter,omitempty"`
	sourceDatastore  *DatastoreEventArgument  `xml:"sourceDatastore,omitempty"`
}

type VmRelocateFailedEvent struct {
	*VmRelocateSpecEvent

	destHost       *HostEventArgument       `xml:"destHost,omitempty"`
	reason         *LocalizedMethodFault    `xml:"reason,omitempty"`
	destDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty"`
	destDatastore  *DatastoreEventArgument  `xml:"destDatastore,omitempty"`
}

type VmEmigratingEvent struct {
	*VmEvent
}

type VmCloneEvent struct {
	*VmEvent
}

type VmBeingClonedEvent struct {
	*VmCloneEvent

	destFolder *FolderEventArgument `xml:"destFolder,omitempty"`
	destName   string               `xml:"destName,omitempty"`
	destHost   *HostEventArgument   `xml:"destHost,omitempty"`
}

type VmBeingClonedNoFolderEvent struct {
	*VmCloneEvent

	destName string             `xml:"destName,omitempty"`
	destHost *HostEventArgument `xml:"destHost,omitempty"`
}

type VmCloneFailedEvent struct {
	*VmCloneEvent

	destFolder *FolderEventArgument  `xml:"destFolder,omitempty"`
	destName   string                `xml:"destName,omitempty"`
	destHost   *HostEventArgument    `xml:"destHost,omitempty"`
	reason     *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmClonedEvent struct {
	*VmCloneEvent

	sourceVm *VmEventArgument `xml:"sourceVm,omitempty"`
}

type VmResourceReallocatedEvent struct {
	*VmEvent
}

type VmRenamedEvent struct {
	*VmEvent

	oldName string `xml:"oldName,omitempty"`
	newName string `xml:"newName,omitempty"`
}

type VmDateRolledBackEvent struct {
	*VmEvent
}

type VmNoNetworkAccessEvent struct {
	*VmEvent

	destHost *HostEventArgument `xml:"destHost,omitempty"`
}

type VmDiskFailedEvent struct {
	*VmEvent

	disk   string                `xml:"disk,omitempty"`
	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmFailedToPowerOnEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmFailedToPowerOffEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmFailedToSuspendEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmFailedToResetEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmFailedToShutdownGuestEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmFailedToRebootGuestEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmFailedToStandbyGuestEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmRemovedEvent struct {
	*VmEvent
}

type VmGuestShutdownEvent struct {
	*VmEvent
}

type VmGuestRebootEvent struct {
	*VmEvent
}

type VmGuestStandbyEvent struct {
	*VmEvent
}

type VmUpgradingEvent struct {
	*VmEvent

	version string `xml:"version,omitempty"`
}

type VmUpgradeCompleteEvent struct {
	*VmEvent

	version string `xml:"version,omitempty"`
}

type VmUpgradeFailedEvent struct {
	*VmEvent
}

type VmRestartedOnAlternateHostEvent struct {
	*VmPoweredOnEvent

	sourceHost *HostEventArgument `xml:"sourceHost,omitempty"`
}

type VmReconfiguredEvent struct {
	*VmEvent

	configSpec *VirtualMachineConfigSpec `xml:"configSpec,omitempty"`
}

type VmMessageEvent struct {
	*VmEvent

	message     string                   `xml:"message,omitempty"`
	messageInfo []*VirtualMachineMessage `xml:"messageInfo,omitempty"`
}

type VmMessageWarningEvent struct {
	*VmEvent

	message     string                   `xml:"message,omitempty"`
	messageInfo []*VirtualMachineMessage `xml:"messageInfo,omitempty"`
}

type VmMessageErrorEvent struct {
	*VmEvent

	message     string                   `xml:"message,omitempty"`
	messageInfo []*VirtualMachineMessage `xml:"messageInfo,omitempty"`
}

type VmConfigMissingEvent struct {
	*VmEvent
}

type VmPowerOffOnIsolationEvent struct {
	*VmPoweredOffEvent

	isolatedHost *HostEventArgument `xml:"isolatedHost,omitempty"`
}

type VmShutdownOnIsolationEvent struct {
	*VmPoweredOffEvent

	isolatedHost   *HostEventArgument `xml:"isolatedHost,omitempty"`
	shutdownResult string             `xml:"shutdownResult,omitempty"`
}

type VmFailoverFailed struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmDasBeingResetEvent struct {
	*VmEvent

	reason string `xml:"reason,omitempty"`
}

type VmDasResetFailedEvent struct {
	*VmEvent
}

type VmMaxRestartCountReached struct {
	*VmEvent
}

type VmMaxFTRestartCountReached struct {
	*VmEvent
}

type VmDasBeingResetWithScreenshotEvent struct {
	*VmDasBeingResetEvent

	screenshotFilePath string `xml:"screenshotFilePath,omitempty"`
}

type NotEnoughResourcesToStartVmEvent struct {
	*VmEvent
}

type VmUuidAssignedEvent struct {
	*VmEvent

	uuid string `xml:"uuid,omitempty"`
}

type VmInstanceUuidAssignedEvent struct {
	*VmEvent

	instanceUuid string `xml:"instanceUuid,omitempty"`
}

type VmUuidChangedEvent struct {
	*VmEvent

	oldUuid string `xml:"oldUuid,omitempty"`
	newUuid string `xml:"newUuid,omitempty"`
}

type VmInstanceUuidChangedEvent struct {
	*VmEvent

	oldInstanceUuid string `xml:"oldInstanceUuid,omitempty"`
	newInstanceUuid string `xml:"newInstanceUuid,omitempty"`
}

type VmWwnConflictEvent struct {
	*VmEvent

	conflictedVms   []*VmEventArgument   `xml:"conflictedVms,omitempty"`
	conflictedHosts []*HostEventArgument `xml:"conflictedHosts,omitempty"`
	wwn             int64                `xml:"wwn,omitempty"`
}

type VmAcquiredMksTicketEvent struct {
	*VmEvent
}

type VmAcquiredTicketEvent struct {
	*VmEvent

	ticketType string `xml:"ticketType,omitempty"`
}

type HostWwnConflictEvent struct {
	*HostEvent

	conflictedVms   []*VmEventArgument   `xml:"conflictedVms,omitempty"`
	conflictedHosts []*HostEventArgument `xml:"conflictedHosts,omitempty"`
	wwn             int64                `xml:"wwn,omitempty"`
}

type VmWwnAssignedEvent struct {
	*VmEvent

	nodeWwns []int64 `xml:"nodeWwns,omitempty"`
	portWwns []int64 `xml:"portWwns,omitempty"`
}

type VmWwnChangedEvent struct {
	*VmEvent

	oldNodeWwns []int64 `xml:"oldNodeWwns,omitempty"`
	oldPortWwns []int64 `xml:"oldPortWwns,omitempty"`
	newNodeWwns []int64 `xml:"newNodeWwns,omitempty"`
	newPortWwns []int64 `xml:"newPortWwns,omitempty"`
}

type VmSecondaryAddedEvent struct {
	*VmEvent
}

type VmFaultToleranceTurnedOffEvent struct {
	*VmEvent
}

type VmFaultToleranceStateChangedEvent struct {
	*VmEvent

	oldState *VirtualMachineFaultToleranceState `xml:"oldState,omitempty"`
	newState *VirtualMachineFaultToleranceState `xml:"newState,omitempty"`
}

type VmSecondaryDisabledEvent struct {
	*VmEvent
}

type VmSecondaryDisabledBySystemEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmSecondaryEnabledEvent struct {
	*VmEvent
}

type VmStartingSecondaryEvent struct {
	*VmEvent
}

type VmSecondaryStartedEvent struct {
	*VmEvent
}

type VmFailedUpdatingSecondaryConfig struct {
	*VmEvent
}

type VmFailedStartingSecondaryEvent struct {
	*VmEvent

	reason string `xml:"reason,omitempty"`
}

type VmTimedoutStartingSecondaryEvent struct {
	*VmEvent

	timeout int64 `xml:"timeout,omitempty"`
}

type VmNoCompatibleHostForSecondaryEvent struct {
	*VmEvent
}

type VmPrimaryFailoverEvent struct {
	*VmEvent

	reason string `xml:"reason,omitempty"`
}

type VmFaultToleranceVmTerminatedEvent struct {
	*VmEvent

	reason string `xml:"reason,omitempty"`
}

type HostWwnChangedEvent struct {
	*HostEvent

	oldNodeWwns []int64 `xml:"oldNodeWwns,omitempty"`
	oldPortWwns []int64 `xml:"oldPortWwns,omitempty"`
	newNodeWwns []int64 `xml:"newNodeWwns,omitempty"`
	newPortWwns []int64 `xml:"newPortWwns,omitempty"`
}

type HostAdminDisableEvent struct {
	*HostEvent
}

type HostAdminEnableEvent struct {
	*HostEvent
}

type HostEnableAdminFailedEvent struct {
	*HostEvent

	permissions []*Permission `xml:"permissions,omitempty"`
}

type VmFailedRelayoutOnVmfs2DatastoreEvent struct {
	*VmEvent
}

type VmFailedRelayoutEvent struct {
	*VmEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type VmRelayoutSuccessfulEvent struct {
	*VmEvent
}

type VmRelayoutUpToDateEvent struct {
	*VmEvent
}

type VmConnectedEvent struct {
	*VmEvent
}

type VmPoweringOnWithCustomizedDVPortEvent struct {
	*VmEvent

	vnic []*VnicPortArgument `xml:"vnic,omitempty"`
}

type VmDasUpdateErrorEvent struct {
	*VmEvent
}

type NoMaintenanceModeDrsRecommendationForVM struct {
	*VmEvent
}

type VmDasUpdateOkEvent struct {
	*VmEvent
}

type ScheduledTaskEvent struct {
	*Event

	scheduledTask *ScheduledTaskEventArgument `xml:"scheduledTask,omitempty"`
	entity        *ManagedEntityEventArgument `xml:"entity,omitempty"`
}

type ScheduledTaskCreatedEvent struct {
	*ScheduledTaskEvent
}

type ScheduledTaskStartedEvent struct {
	*ScheduledTaskEvent
}

type ScheduledTaskRemovedEvent struct {
	*ScheduledTaskEvent
}

type ScheduledTaskReconfiguredEvent struct {
	*ScheduledTaskEvent
}

type ScheduledTaskCompletedEvent struct {
	*ScheduledTaskEvent
}

type ScheduledTaskFailedEvent struct {
	*ScheduledTaskEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type ScheduledTaskEmailCompletedEvent struct {
	*ScheduledTaskEvent

	to string `xml:"to,omitempty"`
}

type ScheduledTaskEmailFailedEvent struct {
	*ScheduledTaskEvent

	to     string                `xml:"to,omitempty"`
	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type AlarmEvent struct {
	*Event

	alarm *AlarmEventArgument `xml:"alarm,omitempty"`
}

type AlarmCreatedEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
}

type AlarmStatusChangedEvent struct {
	*AlarmEvent

	source *ManagedEntityEventArgument `xml:"source,omitempty"`
	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
	from   string                      `xml:"from,omitempty"`
	to     string                      `xml:"to,omitempty"`
}

type AlarmActionTriggeredEvent struct {
	*AlarmEvent

	source *ManagedEntityEventArgument `xml:"source,omitempty"`
	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
}

type AlarmEmailCompletedEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
	to     string                      `xml:"to,omitempty"`
}

type AlarmEmailFailedEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
	to     string                      `xml:"to,omitempty"`
	reason *LocalizedMethodFault       `xml:"reason,omitempty"`
}

type AlarmSnmpCompletedEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
}

type AlarmSnmpFailedEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
	reason *LocalizedMethodFault       `xml:"reason,omitempty"`
}

type AlarmScriptCompleteEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
	script string                      `xml:"script,omitempty"`
}

type AlarmScriptFailedEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
	script string                      `xml:"script,omitempty"`
	reason *LocalizedMethodFault       `xml:"reason,omitempty"`
}

type AlarmRemovedEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
}

type AlarmReconfiguredEvent struct {
	*AlarmEvent

	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
}

type AlarmAcknowledgedEvent struct {
	*AlarmEvent

	source *ManagedEntityEventArgument `xml:"source,omitempty"`
	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
}

type AlarmClearedEvent struct {
	*AlarmEvent

	source *ManagedEntityEventArgument `xml:"source,omitempty"`
	entity *ManagedEntityEventArgument `xml:"entity,omitempty"`
	from   string                      `xml:"from,omitempty"`
}

type CustomFieldEvent struct {
	*Event
}

type CustomFieldDefEvent struct {
	*CustomFieldEvent

	fieldKey int32  `xml:"fieldKey,omitempty"`
	name     string `xml:"name,omitempty"`
}

type CustomFieldDefAddedEvent struct {
	*CustomFieldDefEvent
}

type CustomFieldDefRemovedEvent struct {
	*CustomFieldDefEvent
}

type CustomFieldDefRenamedEvent struct {
	*CustomFieldDefEvent

	newName string `xml:"newName,omitempty"`
}

type CustomFieldValueChangedEvent struct {
	*CustomFieldEvent

	entity   *ManagedEntityEventArgument `xml:"entity,omitempty"`
	fieldKey int32                       `xml:"fieldKey,omitempty"`
	name     string                      `xml:"name,omitempty"`
	value    string                      `xml:"value,omitempty"`
}

type AuthorizationEvent struct {
	*Event
}

type PermissionEvent struct {
	*AuthorizationEvent

	entity    *ManagedEntityEventArgument `xml:"entity,omitempty"`
	principal string                      `xml:"principal,omitempty"`
	group     bool                        `xml:"group,omitempty"`
}

type PermissionAddedEvent struct {
	*PermissionEvent

	role      *RoleEventArgument `xml:"role,omitempty"`
	propagate bool               `xml:"propagate,omitempty"`
}

type PermissionUpdatedEvent struct {
	*PermissionEvent

	role      *RoleEventArgument `xml:"role,omitempty"`
	propagate bool               `xml:"propagate,omitempty"`
}

type PermissionRemovedEvent struct {
	*PermissionEvent
}

type RoleEvent struct {
	*AuthorizationEvent

	role *RoleEventArgument `xml:"role,omitempty"`
}

type RoleAddedEvent struct {
	*RoleEvent

	privilegeList []string `xml:"privilegeList,omitempty"`
}

type RoleUpdatedEvent struct {
	*RoleEvent

	privilegeList []string `xml:"privilegeList,omitempty"`
}

type RoleRemovedEvent struct {
	*RoleEvent
}

type DatastoreEvent struct {
	*Event

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type DatastoreDestroyedEvent struct {
	*DatastoreEvent
}

type DatastoreRenamedEvent struct {
	*DatastoreEvent

	oldName string `xml:"oldName,omitempty"`
	newName string `xml:"newName,omitempty"`
}

type DatastoreCapacityIncreasedEvent struct {
	*DatastoreEvent

	oldCapacity int64 `xml:"oldCapacity,omitempty"`
	newCapacity int64 `xml:"newCapacity,omitempty"`
}

type DatastoreDuplicatedEvent struct {
	*DatastoreEvent
}

type DatastoreFileEvent struct {
	*DatastoreEvent

	targetFile string `xml:"targetFile,omitempty"`
}

type DatastoreFileCopiedEvent struct {
	*DatastoreFileEvent

	sourceDatastore *DatastoreEventArgument `xml:"sourceDatastore,omitempty"`
	sourceFile      string                  `xml:"sourceFile,omitempty"`
}

type DatastoreFileMovedEvent struct {
	*DatastoreFileEvent

	sourceDatastore *DatastoreEventArgument `xml:"sourceDatastore,omitempty"`
	sourceFile      string                  `xml:"sourceFile,omitempty"`
}

type DatastoreFileDeletedEvent struct {
	*DatastoreFileEvent
}

type NonVIWorkloadDetectedOnDatastoreEvent struct {
	*DatastoreEvent
}

type DatastoreIORMReconfiguredEvent struct {
	*DatastoreEvent
}

type TaskEvent struct {
	*Event

	info *TaskInfo `xml:"info,omitempty"`
}

type TaskTimeoutEvent struct {
	*TaskEvent
}

type LicenseEvent struct {
	*Event
}

type ServerLicenseExpiredEvent struct {
	*LicenseEvent

	product string `xml:"product,omitempty"`
}

type HostLicenseExpiredEvent struct {
	*LicenseEvent
}

type VMotionLicenseExpiredEvent struct {
	*LicenseEvent
}

type NoLicenseEvent struct {
	*LicenseEvent

	feature *LicenseFeatureInfo `xml:"feature,omitempty"`
}

type LicenseServerUnavailableEvent struct {
	*LicenseEvent

	licenseServer string `xml:"licenseServer,omitempty"`
}

type LicenseServerAvailableEvent struct {
	*LicenseEvent

	licenseServer string `xml:"licenseServer,omitempty"`
}

type LicenseExpiredEvent struct {
	*Event

	feature *LicenseFeatureInfo `xml:"feature,omitempty"`
}

type InvalidEditionEvent struct {
	*LicenseEvent

	feature string `xml:"feature,omitempty"`
}

type HostInventoryFullEvent struct {
	*LicenseEvent

	capacity int32 `xml:"capacity,omitempty"`
}

type LicenseRestrictedEvent struct {
	*LicenseEvent
}

type IncorrectHostInformationEvent struct {
	*LicenseEvent
}

type UnlicensedVirtualMachinesEvent struct {
	*LicenseEvent

	unlicensed int32 `xml:"unlicensed,omitempty"`
	available  int32 `xml:"available,omitempty"`
}

type UnlicensedVirtualMachinesFoundEvent struct {
	*LicenseEvent

	available int32 `xml:"available,omitempty"`
}

type AllVirtualMachinesLicensedEvent struct {
	*LicenseEvent
}

type LicenseNonComplianceEvent struct {
	*LicenseEvent

	url string `xml:"url,omitempty"`
}

type MigrationEvent struct {
	*VmEvent

	fault *LocalizedMethodFault `xml:"fault,omitempty"`
}

type MigrationWarningEvent struct {
	*MigrationEvent
}

type MigrationErrorEvent struct {
	*MigrationEvent
}

type MigrationHostWarningEvent struct {
	*MigrationEvent

	dstHost *HostEventArgument `xml:"dstHost,omitempty"`
}

type MigrationHostErrorEvent struct {
	*MigrationEvent

	dstHost *HostEventArgument `xml:"dstHost,omitempty"`
}

type MigrationResourceWarningEvent struct {
	*MigrationEvent

	dstPool *ResourcePoolEventArgument `xml:"dstPool,omitempty"`
	dstHost *HostEventArgument         `xml:"dstHost,omitempty"`
}

type MigrationResourceErrorEvent struct {
	*MigrationEvent

	dstPool *ResourcePoolEventArgument `xml:"dstPool,omitempty"`
	dstHost *HostEventArgument         `xml:"dstHost,omitempty"`
}

type ClusterEvent struct {
	*Event
}

type DasEnabledEvent struct {
	*ClusterEvent
}

type DasDisabledEvent struct {
	*ClusterEvent
}

type DasAdmissionControlDisabledEvent struct {
	*ClusterEvent
}

type DasAdmissionControlEnabledEvent struct {
	*ClusterEvent
}

type DasHostFailedEvent struct {
	*ClusterEvent

	failedHost *HostEventArgument `xml:"failedHost,omitempty"`
}

type DasHostIsolatedEvent struct {
	*ClusterEvent

	isolatedHost *HostEventArgument `xml:"isolatedHost,omitempty"`
}

type DasClusterIsolatedEvent struct {
	*ClusterEvent
}

type DasAgentUnavailableEvent struct {
	*ClusterEvent
}

type DasAgentFoundEvent struct {
	*ClusterEvent
}

type InsufficientFailoverResourcesEvent struct {
	*ClusterEvent
}

type FailoverLevelRestored struct {
	*ClusterEvent
}

type ClusterOvercommittedEvent struct {
	*ClusterEvent
}

type HostOvercommittedEvent struct {
	*ClusterOvercommittedEvent
}

type ClusterStatusChangedEvent struct {
	*ClusterEvent

	oldStatus string `xml:"oldStatus,omitempty"`
	newStatus string `xml:"newStatus,omitempty"`
}

type HostStatusChangedEvent struct {
	*ClusterStatusChangedEvent
}

type ClusterCreatedEvent struct {
	*ClusterEvent

	parent *FolderEventArgument `xml:"parent,omitempty"`
}

type ClusterDestroyedEvent struct {
	*ClusterEvent
}

type DrsEnabledEvent struct {
	*ClusterEvent

	behavior string `xml:"behavior,omitempty"`
}

type DrsDisabledEvent struct {
	*ClusterEvent
}

type ClusterReconfiguredEvent struct {
	*ClusterEvent
}

type HostMonitoringStateChangedEvent struct {
	*ClusterEvent

	state string `xml:"state,omitempty"`
}

type VmHealthMonitoringStateChangedEvent struct {
	*ClusterEvent

	state string `xml:"state,omitempty"`
}

type ResourcePoolEvent struct {
	*Event

	resourcePool *ResourcePoolEventArgument `xml:"resourcePool,omitempty"`
}

type ResourcePoolCreatedEvent struct {
	*ResourcePoolEvent

	parent *ResourcePoolEventArgument `xml:"parent,omitempty"`
}

type ResourcePoolDestroyedEvent struct {
	*ResourcePoolEvent
}

type ResourcePoolMovedEvent struct {
	*ResourcePoolEvent

	oldParent *ResourcePoolEventArgument `xml:"oldParent,omitempty"`
	newParent *ResourcePoolEventArgument `xml:"newParent,omitempty"`
}

type ResourcePoolReconfiguredEvent struct {
	*ResourcePoolEvent
}

type ResourceViolatedEvent struct {
	*ResourcePoolEvent
}

type VmResourcePoolMovedEvent struct {
	*VmEvent

	oldParent *ResourcePoolEventArgument `xml:"oldParent,omitempty"`
	newParent *ResourcePoolEventArgument `xml:"newParent,omitempty"`
}

type TemplateUpgradeEvent struct {
	*Event

	legacyTemplate string `xml:"legacyTemplate,omitempty"`
}

type TemplateBeingUpgradedEvent struct {
	*TemplateUpgradeEvent
}

type TemplateUpgradeFailedEvent struct {
	*TemplateUpgradeEvent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type TemplateUpgradedEvent struct {
	*TemplateUpgradeEvent
}

type CustomizationEvent struct {
	*VmEvent

	logLocation string `xml:"logLocation,omitempty"`
}

type CustomizationStartedEvent struct {
	*CustomizationEvent
}

type CustomizationSucceeded struct {
	*CustomizationEvent
}

type CustomizationFailed struct {
	*CustomizationEvent
}

type CustomizationUnknownFailure struct {
	*CustomizationFailed
}

type CustomizationSysprepFailed struct {
	*CustomizationFailed

	sysprepVersion string `xml:"sysprepVersion,omitempty"`
	systemVersion  string `xml:"systemVersion,omitempty"`
}

type CustomizationLinuxIdentityFailed struct {
	*CustomizationFailed
}

type CustomizationNetworkSetupFailed struct {
	*CustomizationFailed
}

type LockerMisconfiguredEvent struct {
	*Event

	datastore *DatastoreEventArgument `xml:"datastore,omitempty"`
}

type LockerReconfiguredEvent struct {
	*Event

	oldDatastore *DatastoreEventArgument `xml:"oldDatastore,omitempty"`
	newDatastore *DatastoreEventArgument `xml:"newDatastore,omitempty"`
}

type NoDatastoresConfiguredEvent struct {
	*HostEvent
}

type AdminPasswordNotChangedEvent struct {
	*HostEvent
}

type HostInAuditModeEvent struct {
	*HostEvent
}

type LocalTSMEnabledEvent struct {
	*HostEvent
}

type RemoteTSMEnabledEvent struct {
	*HostEvent
}

type VimAccountPasswordChangedEvent struct {
	*HostEvent
}

type IScsiBootFailureEvent struct {
	*HostEvent
}

type DvsHealthStatusChangeEvent struct {
	*HostEvent

	switchUuid   string                       `xml:"switchUuid,omitempty"`
	healthResult *HostMemberHealthCheckResult `xml:"healthResult,omitempty"`
}

type NetworkRollbackEvent struct {
	*Event

	methodName    string `xml:"methodName,omitempty"`
	transactionId string `xml:"transactionId,omitempty"`
}

type UplinkPortVlanTrunkedEvent struct {
	*DvsHealthStatusChangeEvent
}

type UplinkPortVlanUntrunkedEvent struct {
	*DvsHealthStatusChangeEvent
}

type MtuMatchEvent struct {
	*DvsHealthStatusChangeEvent
}

type MtuMismatchEvent struct {
	*DvsHealthStatusChangeEvent
}

type UplinkPortMtuNotSupportEvent struct {
	*DvsHealthStatusChangeEvent
}

type UplinkPortMtuSupportEvent struct {
	*DvsHealthStatusChangeEvent
}

type TeamingMatchEvent struct {
	*DvsHealthStatusChangeEvent
}

type TeamingMisMatchEvent struct {
	*DvsHealthStatusChangeEvent
}

type DvsEvent struct {
	*Event
}

type DvsCreatedEvent struct {
	*DvsEvent

	parent *FolderEventArgument `xml:"parent,omitempty"`
}

type DvsRenamedEvent struct {
	*DvsEvent

	oldName string `xml:"oldName,omitempty"`
	newName string `xml:"newName,omitempty"`
}

type DvsReconfiguredEvent struct {
	*DvsEvent

	configSpec *DVSConfigSpec `xml:"configSpec,omitempty"`
}

type DvsUpgradeAvailableEvent struct {
	*DvsEvent

	productInfo *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty"`
}

type DvsUpgradeInProgressEvent struct {
	*DvsEvent

	productInfo *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty"`
}

type DvsUpgradeRejectedEvent struct {
	*DvsEvent

	productInfo *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty"`
}

type DvsUpgradedEvent struct {
	*DvsEvent

	productInfo *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty"`
}

type DvsHostJoinedEvent struct {
	*DvsEvent

	hostJoined *HostEventArgument `xml:"hostJoined,omitempty"`
}

type DvsHostLeftEvent struct {
	*DvsEvent

	hostLeft *HostEventArgument `xml:"hostLeft,omitempty"`
}

type DvsOutOfSyncHostArgument struct {
	*DynamicData

	outOfSyncHost   *HostEventArgument `xml:"outOfSyncHost,omitempty"`
	configParamters []string           `xml:"configParamters,omitempty"`
}

type ArrayOfDvsOutOfSyncHostArgument struct {
	DvsOutOfSyncHostArgument []*DvsOutOfSyncHostArgument `xml:"DvsOutOfSyncHostArgument,omitempty"`
}

type OutOfSyncDvsHost struct {
	*DvsEvent

	hostOutOfSync []*DvsOutOfSyncHostArgument `xml:"hostOutOfSync,omitempty"`
}

type DvsHostWentOutOfSyncEvent struct {
	*DvsEvent

	hostOutOfSync *DvsOutOfSyncHostArgument `xml:"hostOutOfSync,omitempty"`
}

type DvsHostBackInSyncEvent struct {
	*DvsEvent

	hostBackInSync *HostEventArgument `xml:"hostBackInSync,omitempty"`
}

type DvsHostStatusUpdated struct {
	*DvsEvent

	hostMember      *HostEventArgument `xml:"hostMember,omitempty"`
	oldStatus       string             `xml:"oldStatus,omitempty"`
	newStatus       string             `xml:"newStatus,omitempty"`
	oldStatusDetail string             `xml:"oldStatusDetail,omitempty"`
	newStatusDetail string             `xml:"newStatusDetail,omitempty"`
}

type DvsPortCreatedEvent struct {
	*DvsEvent

	portKey []string `xml:"portKey,omitempty"`
}

type DvsPortReconfiguredEvent struct {
	*DvsEvent

	portKey []string `xml:"portKey,omitempty"`
}

type DvsPortDeletedEvent struct {
	*DvsEvent

	portKey []string `xml:"portKey,omitempty"`
}

type DvsPortConnectedEvent struct {
	*DvsEvent

	portKey   string                                 `xml:"portKey,omitempty"`
	connectee *DistributedVirtualSwitchPortConnectee `xml:"connectee,omitempty"`
}

type DvsPortDisconnectedEvent struct {
	*DvsEvent

	portKey   string                                 `xml:"portKey,omitempty"`
	connectee *DistributedVirtualSwitchPortConnectee `xml:"connectee,omitempty"`
}

type DvsPortVendorSpecificStateChangeEvent struct {
	*DvsEvent

	portKey string `xml:"portKey,omitempty"`
}

type DvsPortRuntimeChangeEvent struct {
	*DvsEvent

	portKey     string        `xml:"portKey,omitempty"`
	runtimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty"`
}

type DvsPortLinkUpEvent struct {
	*DvsEvent

	portKey     string        `xml:"portKey,omitempty"`
	runtimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty"`
}

type DvsPortLinkDownEvent struct {
	*DvsEvent

	portKey     string        `xml:"portKey,omitempty"`
	runtimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty"`
}

type DvsPortJoinPortgroupEvent struct {
	*DvsEvent

	portKey       string `xml:"portKey,omitempty"`
	portgroupKey  string `xml:"portgroupKey,omitempty"`
	portgroupName string `xml:"portgroupName,omitempty"`
}

type DvsPortLeavePortgroupEvent struct {
	*DvsEvent

	portKey       string `xml:"portKey,omitempty"`
	portgroupKey  string `xml:"portgroupKey,omitempty"`
	portgroupName string `xml:"portgroupName,omitempty"`
}

type DvsPortBlockedEvent struct {
	*DvsEvent

	portKey      string        `xml:"portKey,omitempty"`
	statusDetail string        `xml:"statusDetail,omitempty"`
	runtimeInfo  *DVPortStatus `xml:"runtimeInfo,omitempty"`
}

type DvsPortUnblockedEvent struct {
	*DvsEvent

	portKey     string        `xml:"portKey,omitempty"`
	runtimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty"`
}

type DvsPortEnteredPassthruEvent struct {
	*DvsEvent

	portKey     string        `xml:"portKey,omitempty"`
	runtimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty"`
}

type DvsPortExitedPassthruEvent struct {
	*DvsEvent

	portKey     string        `xml:"portKey,omitempty"`
	runtimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty"`
}

type DvsDestroyedEvent struct {
	*DvsEvent
}

type DvsMergedEvent struct {
	*DvsEvent

	sourceDvs      *DvsEventArgument `xml:"sourceDvs,omitempty"`
	destinationDvs *DvsEventArgument `xml:"destinationDvs,omitempty"`
}

type HostLocalPortCreatedEvent struct {
	*DvsEvent

	hostLocalPort *DVSHostLocalPortInfo `xml:"hostLocalPort,omitempty"`
}

type RollbackEvent struct {
	*DvsEvent

	hostName   string `xml:"hostName,omitempty"`
	methodName string `xml:"methodName,omitempty"`
}

type RecoveryEvent struct {
	*DvsEvent

	hostName string `xml:"hostName,omitempty"`
	portKey  string `xml:"portKey,omitempty"`
	dvsUuid  string `xml:"dvsUuid,omitempty"`
	vnic     string `xml:"vnic,omitempty"`
}

type DvsImportEvent struct {
	*DvsEvent

	importType string `xml:"importType,omitempty"`
}

type DvsRestoreEvent struct {
	*DvsEvent
}

type DVPortgroupEvent struct {
	*Event
}

type DVPortgroupCreatedEvent struct {
	*DVPortgroupEvent
}

type DVPortgroupRenamedEvent struct {
	*DVPortgroupEvent

	oldName string `xml:"oldName,omitempty"`
	newName string `xml:"newName,omitempty"`
}

type DVPortgroupReconfiguredEvent struct {
	*DVPortgroupEvent

	configSpec *DVPortgroupConfigSpec `xml:"configSpec,omitempty"`
}

type DVPortgroupDestroyedEvent struct {
	*DVPortgroupEvent
}

type DvpgImportEvent struct {
	*DVPortgroupEvent

	importType string `xml:"importType,omitempty"`
}

type DvpgRestoreEvent struct {
	*DVPortgroupEvent
}

type DrsInvocationFailedEvent struct {
	*ClusterEvent
}

type DrsRecoveredFromFailureEvent struct {
	*ClusterEvent
}

type VmReloadFromPathEvent struct {
	*VmEvent

	configPath string `xml:"configPath,omitempty"`
}

type VmReloadFromPathFailedEvent struct {
	*VmEvent

	configPath string `xml:"configPath,omitempty"`
}

type VmRequirementsExceedCurrentEVCModeEvent struct {
	*VmEvent
}

type EventArgument struct {
	*DynamicData
}

type RoleEventArgument struct {
	*EventArgument

	roleId int32  `xml:"roleId,omitempty"`
	name   string `xml:"name,omitempty"`
}

type EntityEventArgument struct {
	*EventArgument

	name string `xml:"name,omitempty"`
}

type ManagedEntityEventArgument struct {
	*EntityEventArgument

	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type FolderEventArgument struct {
	*EntityEventArgument

	folder *ManagedObjectReference `xml:"folder,omitempty"`
}

type DatacenterEventArgument struct {
	*EntityEventArgument

	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type ComputeResourceEventArgument struct {
	*EntityEventArgument

	computeResource *ManagedObjectReference `xml:"computeResource,omitempty"`
}

type ResourcePoolEventArgument struct {
	*EntityEventArgument

	resourcePool *ManagedObjectReference `xml:"resourcePool,omitempty"`
}

type HostEventArgument struct {
	*EntityEventArgument

	host *ManagedObjectReference `xml:"host,omitempty"`
}

type ArrayOfHostEventArgument struct {
	HostEventArgument []*HostEventArgument `xml:"HostEventArgument,omitempty"`
}

type VmEventArgument struct {
	*EntityEventArgument

	vm *ManagedObjectReference `xml:"vm,omitempty"`
}

type ArrayOfVmEventArgument struct {
	VmEventArgument []*VmEventArgument `xml:"VmEventArgument,omitempty"`
}

type DatastoreEventArgument struct {
	*EntityEventArgument

	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
}

type NetworkEventArgument struct {
	*EntityEventArgument

	network *ManagedObjectReference `xml:"network,omitempty"`
}

type AlarmEventArgument struct {
	*EntityEventArgument

	alarm *ManagedObjectReference `xml:"alarm,omitempty"`
}

type ScheduledTaskEventArgument struct {
	*EntityEventArgument

	scheduledTask *ManagedObjectReference `xml:"scheduledTask,omitempty"`
}

type ProfileEventArgument struct {
	*EventArgument

	profile *ManagedObjectReference `xml:"profile,omitempty"`
	name    string                  `xml:"name,omitempty"`
}

type DvsEventArgument struct {
	*EntityEventArgument

	dvs *ManagedObjectReference `xml:"dvs,omitempty"`
}

type EventArgDesc struct {
	*DynamicData

	name        string              `xml:"name,omitempty"`
	type_       string              `xml:"type,omitempty"`
	description *ElementDescription `xml:"description,omitempty"`
}

type ArrayOfEventArgDesc struct {
	EventArgDesc []*EventArgDesc `xml:"EventArgDesc,omitempty"`
}

type EventDescriptionEventDetail struct {
	*DynamicData

	key                     string `xml:"key,omitempty"`
	description             string `xml:"description,omitempty"`
	category                string `xml:"category,omitempty"`
	formatOnDatacenter      string `xml:"formatOnDatacenter,omitempty"`
	formatOnComputeResource string `xml:"formatOnComputeResource,omitempty"`
	formatOnHost            string `xml:"formatOnHost,omitempty"`
	formatOnVm              string `xml:"formatOnVm,omitempty"`
	fullFormat              string `xml:"fullFormat,omitempty"`
	longDescription         string `xml:"longDescription,omitempty"`
}

type ArrayOfEventDescriptionEventDetail struct {
	EventDescriptionEventDetail []*EventDescriptionEventDetail `xml:"EventDescriptionEventDetail,omitempty"`
}

type EventDescription struct {
	*DynamicData

	category        []*ElementDescription          `xml:"category,omitempty"`
	eventInfo       []*EventDescriptionEventDetail `xml:"eventInfo,omitempty"`
	enumeratedTypes []*EnumDescription             `xml:"enumeratedTypes,omitempty"`
}

type EventEx struct {
	*Event

	eventTypeId string                `xml:"eventTypeId,omitempty"`
	severity    string                `xml:"severity,omitempty"`
	message     string                `xml:"message,omitempty"`
	arguments   []*KeyAnyValue        `xml:"arguments,omitempty"`
	objectId    string                `xml:"objectId,omitempty"`
	objectType  string                `xml:"objectType,omitempty"`
	objectName  string                `xml:"objectName,omitempty"`
	fault       *LocalizedMethodFault `xml:"fault,omitempty"`
}

type EventFilterSpecByEntity struct {
	*DynamicData

	entity    *ManagedObjectReference         `xml:"entity,omitempty"`
	recursion *EventFilterSpecRecursionOption `xml:"recursion,omitempty"`
}

type EventFilterSpecByTime struct {
	*DynamicData

	beginTime time.Time `xml:"beginTime,omitempty"`
	endTime   time.Time `xml:"endTime,omitempty"`
}

type EventFilterSpecByUsername struct {
	*DynamicData

	systemUser bool     `xml:"systemUser,omitempty"`
	userList   []string `xml:"userList,omitempty"`
}

type EventFilterSpec struct {
	*DynamicData

	entity             *EventFilterSpecByEntity   `xml:"entity,omitempty"`
	time               *EventFilterSpecByTime     `xml:"time,omitempty"`
	userName           *EventFilterSpecByUsername `xml:"userName,omitempty"`
	eventChainId       int32                      `xml:"eventChainId,omitempty"`
	alarm              *ManagedObjectReference    `xml:"alarm,omitempty"`
	scheduledTask      *ManagedObjectReference    `xml:"scheduledTask,omitempty"`
	disableFullMessage bool                       `xml:"disableFullMessage,omitempty"`
	category           []string                   `xml:"category,omitempty"`
	type_              []string                   `xml:"type,omitempty"`
	tag                []string                   `xml:"tag,omitempty"`
	eventTypeId        []string                   `xml:"eventTypeId,omitempty"`
}

type ExtExtendedProductInfo struct {
	*DynamicData

	companyUrl    string                  `xml:"companyUrl,omitempty"`
	productUrl    string                  `xml:"productUrl,omitempty"`
	managementUrl string                  `xml:"managementUrl,omitempty"`
	self          *ManagedObjectReference `xml:"self,omitempty"`
}

type ManagedByInfo struct {
	*DynamicData

	extensionKey string `xml:"extensionKey,omitempty"`
	type_        string `xml:"type,omitempty"`
}

type ExtManagedEntityInfo struct {
	*DynamicData

	type_        string `xml:"type,omitempty"`
	smallIconUrl string `xml:"smallIconUrl,omitempty"`
	iconUrl      string `xml:"iconUrl,omitempty"`
	description  string `xml:"description,omitempty"`
}

type ArrayOfExtManagedEntityInfo struct {
	ExtManagedEntityInfo []*ExtManagedEntityInfo `xml:"ExtManagedEntityInfo,omitempty"`
}

type ExtSolutionManagerInfoTabInfo struct {
	*DynamicData

	label string `xml:"label,omitempty"`
	url   string `xml:"url,omitempty"`
}

type ArrayOfExtSolutionManagerInfoTabInfo struct {
	ExtSolutionManagerInfoTabInfo []*ExtSolutionManagerInfoTabInfo `xml:"ExtSolutionManagerInfoTabInfo,omitempty"`
}

type ExtSolutionManagerInfo struct {
	*DynamicData

	tab          []*ExtSolutionManagerInfoTabInfo `xml:"tab,omitempty"`
	smallIconUrl string                           `xml:"smallIconUrl,omitempty"`
}

type ActiveDirectoryFault struct {
	*VimFault

	errorCode int32 `xml:"errorCode,omitempty"`
}

type AdminDisabled struct {
	*HostConfigFault
}

type AdminNotDisabled struct {
	*HostConfigFault
}

type AffinityConfigured struct {
	*MigrationFault

	configuredAffinity []string `xml:"configuredAffinity,omitempty"`
}

type AgentInstallFailed struct {
	*HostConnectFault

	reason          string `xml:"reason,omitempty"`
	statusCode      int32  `xml:"statusCode,omitempty"`
	installerOutput string `xml:"installerOutput,omitempty"`
}

type AlreadyBeingManaged struct {
	*HostConnectFault

	ipAddress string `xml:"ipAddress,omitempty"`
}

type AlreadyConnected struct {
	*HostConnectFault

	name string `xml:"name,omitempty"`
}

type AlreadyExists struct {
	*VimFault

	name string `xml:"name,omitempty"`
}

type AlreadyUpgraded struct {
	*VimFault
}

type AnswerFileUpdateFailure struct {
	*DynamicData

	userInputPath *ProfilePropertyPath `xml:"userInputPath,omitempty"`
	errMsg        *LocalizableMessage  `xml:"errMsg,omitempty"`
}

type ArrayOfAnswerFileUpdateFailure struct {
	AnswerFileUpdateFailure []*AnswerFileUpdateFailure `xml:"AnswerFileUpdateFailure,omitempty"`
}

type AnswerFileUpdateFailed struct {
	*VimFault

	failure []*AnswerFileUpdateFailure `xml:"failure,omitempty"`
}

type ApplicationQuiesceFault struct {
	*SnapshotFault
}

type AuthMinimumAdminPermission struct {
	*VimFault
}

type BackupBlobReadFailure struct {
	*DvsFault

	entityName string                `xml:"entityName,omitempty"`
	entityType string                `xml:"entityType,omitempty"`
	fault      *LocalizedMethodFault `xml:"fault,omitempty"`
}

type BackupBlobWriteFailure struct {
	*DvsFault

	entityName string                `xml:"entityName,omitempty"`
	entityType string                `xml:"entityType,omitempty"`
	fault      *LocalizedMethodFault `xml:"fault,omitempty"`
}

type BlockedByFirewall struct {
	*HostConfigFault
}

type CAMServerRefusedConnection struct {
	*InvalidCAMServer
}

type CannotAccessFile struct {
	*FileFault
}

type CannotAccessLocalSource struct {
	*VimFault
}

type CannotAccessNetwork struct {
	*CannotAccessVmDevice
}

type CannotAccessVmComponent struct {
	*VmConfigFault
}

type CannotAccessVmConfig struct {
	*CannotAccessVmComponent

	reason *LocalizedMethodFault `xml:"reason,omitempty"`
}

type CannotAccessVmDevice struct {
	*CannotAccessVmComponent

	device    string `xml:"device,omitempty"`
	backing   string `xml:"backing,omitempty"`
	connected bool   `xml:"connected,omitempty"`
}

type CannotAccessVmDisk struct {
	*CannotAccessVmDevice

	fault *LocalizedMethodFault `xml:"fault,omitempty"`
}

type CannotAddHostWithFTVmAsStandalone struct {
	*HostConnectFault
}

type CannotAddHostWithFTVmToDifferentCluster struct {
	*HostConnectFault
}

type CannotAddHostWithFTVmToNonHACluster struct {
	*HostConnectFault
}

type CannotChangeDrsBehaviorForFtSecondary struct {
	*VmFaultToleranceIssue

	vm     *ManagedObjectReference `xml:"vm,omitempty"`
	vmName string                  `xml:"vmName,omitempty"`
}

type CannotChangeHaSettingsForFtSecondary struct {
	*VmFaultToleranceIssue

	vm     *ManagedObjectReference `xml:"vm,omitempty"`
	vmName string                  `xml:"vmName,omitempty"`
}

type CannotChangeVsanClusterUuid struct {
	*VsanFault
}

type CannotChangeVsanNodeUuid struct {
	*VsanFault
}

type CannotCreateFile struct {
	*FileFault
}

type CannotDecryptPasswords struct {
	*CustomizationFault
}

type CannotDeleteFile struct {
	*FileFault
}

type CannotDisableDrsOnClustersWithVApps struct {
	*RuntimeFault
}

type CannotDisableSnapshot struct {
	*VmConfigFault
}

type CannotDisconnectHostWithFaultToleranceVm struct {
	*VimFault

	hostName string `xml:"hostName,omitempty"`
}

type CannotModifyConfigCpuRequirements struct {
	*MigrationFault
}

type CannotMoveFaultToleranceVm struct {
	*VimFault

	moveType string `xml:"moveType,omitempty"`
	vmName   string `xml:"vmName,omitempty"`
}

type CannotMoveHostWithFaultToleranceVm struct {
	*VimFault
}

type CannotMoveVmWithDeltaDisk struct {
	*MigrationFault

	device string `xml:"device,omitempty"`
}

type CannotMoveVmWithNativeDeltaDisk struct {
	*MigrationFault
}

type CannotMoveVsanEnabledHost struct {
	*VsanFault
}

type CannotPlaceWithoutPrerequisiteMoves struct {
	*VimFault
}

type CannotPowerOffVmInCluster struct {
	*InvalidState

	operation string                  `xml:"operation,omitempty"`
	vm        *ManagedObjectReference `xml:"vm,omitempty"`
	vmName    string                  `xml:"vmName,omitempty"`
}

type CannotReconfigureVsanWhenHaEnabled struct {
	*VsanFault
}

type CannotUseNetwork struct {
	*VmConfigFault

	device    string `xml:"device,omitempty"`
	backing   string `xml:"backing,omitempty"`
	connected bool   `xml:"connected,omitempty"`
	reason    string `xml:"reason,omitempty"`
}

type ClockSkew struct {
	*HostConfigFault
}

type CloneFromSnapshotNotSupported struct {
	*MigrationFault
}

type CollectorAddressUnset struct {
	*DvsFault
}

type ConcurrentAccess struct {
	*VimFault
}

type ConflictingConfigurationConfig struct {
	*DynamicData

	entity       *ManagedObjectReference `xml:"entity,omitempty"`
	propertyPath string                  `xml:"propertyPath,omitempty"`
}

type ArrayOfConflictingConfigurationConfig struct {
	ConflictingConfigurationConfig []*ConflictingConfigurationConfig `xml:"ConflictingConfigurationConfig,omitempty"`
}

type ConflictingConfiguration struct {
	*DvsFault

	configInConflict []*ConflictingConfigurationConfig `xml:"configInConflict,omitempty"`
}

type ConflictingDatastoreFound struct {
	*RuntimeFault

	name string `xml:"name,omitempty"`
	url  string `xml:"url,omitempty"`
}

type ConnectedIso struct {
	*OvfExport

	cdrom    *VirtualCdrom `xml:"cdrom,omitempty"`
	filename string        `xml:"filename,omitempty"`
}

type CpuCompatibilityUnknown struct {
	*CpuIncompatible
}

type CpuHotPlugNotSupported struct {
	*VmConfigFault
}

type CpuIncompatible struct {
	*VirtualHardwareCompatibilityIssue

	level        int32                   `xml:"level,omitempty"`
	registerName string                  `xml:"registerName,omitempty"`
	registerBits string                  `xml:"registerBits,omitempty"`
	desiredBits  string                  `xml:"desiredBits,omitempty"`
	host         *ManagedObjectReference `xml:"host,omitempty"`
}

type CpuIncompatible1ECX struct {
	*CpuIncompatible

	sse3      bool `xml:"sse3,omitempty"`
	pclmulqdq bool `xml:"pclmulqdq,omitempty"`
	ssse3     bool `xml:"ssse3,omitempty"`
	sse41     bool `xml:"sse41,omitempty"`
	sse42     bool `xml:"sse42,omitempty"`
	aes       bool `xml:"aes,omitempty"`
	other     bool `xml:"other,omitempty"`
	otherOnly bool `xml:"otherOnly,omitempty"`
}

type CpuIncompatible81EDX struct {
	*CpuIncompatible

	nx        bool `xml:"nx,omitempty"`
	ffxsr     bool `xml:"ffxsr,omitempty"`
	rdtscp    bool `xml:"rdtscp,omitempty"`
	lm        bool `xml:"lm,omitempty"`
	other     bool `xml:"other,omitempty"`
	otherOnly bool `xml:"otherOnly,omitempty"`
}

type CustomizationFault struct {
	*VimFault
}

type CustomizationPending struct {
	*CustomizationFault
}

type DVPortNotSupported struct {
	*DeviceBackingNotSupported
}

type DasConfigFault struct {
	*VimFault

	reason string   `xml:"reason,omitempty"`
	output string   `xml:"output,omitempty"`
	event  []*Event `xml:"event,omitempty"`
}

type DatabaseError struct {
	*RuntimeFault
}

type DatacenterMismatchArgument struct {
	*DynamicData

	entity          *ManagedObjectReference `xml:"entity,omitempty"`
	inputDatacenter *ManagedObjectReference `xml:"inputDatacenter,omitempty"`
}

type ArrayOfDatacenterMismatchArgument struct {
	DatacenterMismatchArgument []*DatacenterMismatchArgument `xml:"DatacenterMismatchArgument,omitempty"`
}

type DatacenterMismatch struct {
	*MigrationFault

	invalidArgument    []*DatacenterMismatchArgument `xml:"invalidArgument,omitempty"`
	expectedDatacenter *ManagedObjectReference       `xml:"expectedDatacenter,omitempty"`
}

type DatastoreNotWritableOnHost struct {
	*InvalidDatastore

	host *ManagedObjectReference `xml:"host,omitempty"`
}

type DeltaDiskFormatNotSupported struct {
	*VmConfigFault

	datastore       []*ManagedObjectReference `xml:"datastore,omitempty"`
	deltaDiskFormat string                    `xml:"deltaDiskFormat,omitempty"`
}

type DestinationSwitchFull struct {
	*CannotAccessNetwork
}

type DestinationVsanDisabled struct {
	*CannotMoveVsanEnabledHost

	destinationCluster string `xml:"destinationCluster,omitempty"`
}

type DeviceBackingNotSupported struct {
	*DeviceNotSupported

	backing string `xml:"backing,omitempty"`
}

type DeviceControllerNotSupported struct {
	*DeviceNotSupported

	controller string `xml:"controller,omitempty"`
}

type DeviceHotPlugNotSupported struct {
	*InvalidDeviceSpec
}

type DeviceNotFound struct {
	*InvalidDeviceSpec
}

type DeviceNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	device string `xml:"device,omitempty"`
	reason string `xml:"reason,omitempty"`
}

type DeviceUnsupportedForVmPlatform struct {
	*InvalidDeviceSpec
}

type DeviceUnsupportedForVmVersion struct {
	*InvalidDeviceSpec

	currentVersion  string `xml:"currentVersion,omitempty"`
	expectedVersion string `xml:"expectedVersion,omitempty"`
}

type DirectoryNotEmpty struct {
	*FileFault
}

type DisableAdminNotSupported struct {
	*HostConfigFault
}

type DisallowedChangeByService struct {
	*RuntimeFault

	serviceName      string `xml:"serviceName,omitempty"`
	disallowedChange string `xml:"disallowedChange,omitempty"`
}

type DisallowedDiskModeChange struct {
	*InvalidDeviceSpec
}

type DisallowedMigrationDeviceAttached struct {
	*MigrationFault

	fault *LocalizedMethodFault `xml:"fault,omitempty"`
}

type DisallowedOperationOnFailoverHost struct {
	*RuntimeFault

	host     *ManagedObjectReference `xml:"host,omitempty"`
	hostname string                  `xml:"hostname,omitempty"`
}

type DiskHasPartitions struct {
	*VsanDiskFault
}

type DiskIsLastRemainingNonSSD struct {
	*VsanDiskFault
}

type DiskIsNonLocal struct {
	*VsanDiskFault
}

type DiskIsUSB struct {
	*VsanDiskFault
}

type DiskMoveTypeNotSupported struct {
	*MigrationFault
}

type DiskNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	disk int32 `xml:"disk,omitempty"`
}

type DiskTooSmall struct {
	*VsanDiskFault
}

type DomainNotFound struct {
	*ActiveDirectoryFault

	domainName string `xml:"domainName,omitempty"`
}

type DrsDisabledOnVm struct {
	*VimFault
}

type DrsVmotionIncompatibleFault struct {
	*VirtualHardwareCompatibilityIssue

	host *ManagedObjectReference `xml:"host,omitempty"`
}

type DuplicateDisks struct {
	*VsanDiskFault
}

type DuplicateName struct {
	*VimFault

	name   string                  `xml:"name,omitempty"`
	object *ManagedObjectReference `xml:"object,omitempty"`
}

type DuplicateVsanNetworkInterface struct {
	*VsanFault

	device string `xml:"device,omitempty"`
}

type DvsApplyOperationFaultFaultOnObject struct {
	*DynamicData

	objectId string                `xml:"objectId,omitempty"`
	type_    string                `xml:"type,omitempty"`
	fault    *LocalizedMethodFault `xml:"fault,omitempty"`
}

type ArrayOfDvsApplyOperationFaultFaultOnObject struct {
	DvsApplyOperationFaultFaultOnObject []*DvsApplyOperationFaultFaultOnObject `xml:"DvsApplyOperationFaultFaultOnObject,omitempty"`
}

type DvsApplyOperationFault struct {
	*DvsFault

	objectFault []*DvsApplyOperationFaultFaultOnObject `xml:"objectFault,omitempty"`
}

type DvsFault struct {
	*VimFault
}

type DvsNotAuthorized struct {
	*DvsFault

	sessionExtensionKey string `xml:"sessionExtensionKey,omitempty"`
	dvsExtensionKey     string `xml:"dvsExtensionKey,omitempty"`
}

type DvsOperationBulkFaultFaultOnHost struct {
	*DynamicData

	host  *ManagedObjectReference `xml:"host,omitempty"`
	fault *LocalizedMethodFault   `xml:"fault,omitempty"`
}

type ArrayOfDvsOperationBulkFaultFaultOnHost struct {
	DvsOperationBulkFaultFaultOnHost []*DvsOperationBulkFaultFaultOnHost `xml:"DvsOperationBulkFaultFaultOnHost,omitempty"`
}

type DvsOperationBulkFault struct {
	*DvsFault

	hostFault []*DvsOperationBulkFaultFaultOnHost `xml:"hostFault,omitempty"`
}

type DvsScopeViolated struct {
	*DvsFault

	scope  []*ManagedObjectReference `xml:"scope,omitempty"`
	entity *ManagedObjectReference   `xml:"entity,omitempty"`
}

type EVCAdmissionFailed struct {
	*NotSupportedHostInCluster

	faults []*LocalizedMethodFault `xml:"faults,omitempty"`
}

type EVCAdmissionFailedCPUFeaturesForMode struct {
	*EVCAdmissionFailed

	currentEVCModeKey string `xml:"currentEVCModeKey,omitempty"`
}

type EVCAdmissionFailedCPUModel struct {
	*EVCAdmissionFailed
}

type EVCAdmissionFailedCPUModelForMode struct {
	*EVCAdmissionFailed

	currentEVCModeKey string `xml:"currentEVCModeKey,omitempty"`
}

type EVCAdmissionFailedCPUVendor struct {
	*EVCAdmissionFailed

	clusterCPUVendor string `xml:"clusterCPUVendor,omitempty"`
	hostCPUVendor    string `xml:"hostCPUVendor,omitempty"`
}

type EVCAdmissionFailedCPUVendorUnknown struct {
	*EVCAdmissionFailed
}

type EVCAdmissionFailedHostDisconnected struct {
	*EVCAdmissionFailed
}

type EVCAdmissionFailedHostSoftware struct {
	*EVCAdmissionFailed
}

type EVCAdmissionFailedHostSoftwareForMode struct {
	*EVCAdmissionFailed
}

type EVCAdmissionFailedVmActive struct {
	*EVCAdmissionFailed
}

type EightHostLimitViolated struct {
	*VmConfigFault
}

type ExpiredAddonLicense struct {
	*ExpiredFeatureLicense
}

type ExpiredEditionLicense struct {
	*ExpiredFeatureLicense
}

type ExpiredFeatureLicense struct {
	*NotEnoughLicenses

	feature        string    `xml:"feature,omitempty"`
	count          int32     `xml:"count,omitempty"`
	expirationDate time.Time `xml:"expirationDate,omitempty"`
}

type ExtendedFault struct {
	*VimFault

	faultTypeId string      `xml:"faultTypeId,omitempty"`
	data        []*KeyValue `xml:"data,omitempty"`
}

type FailToEnableSPBM struct {
	*NotEnoughLicenses

	cs                *ManagedObjectReference               `xml:"cs,omitempty"`
	csName            string                                `xml:"csName,omitempty"`
	hostLicenseStates []*ComputeResourceHostSPBMLicenseInfo `xml:"hostLicenseStates,omitempty"`
}

type FailToLockFaultToleranceVMs struct {
	*RuntimeFault

	vmName          string                  `xml:"vmName,omitempty"`
	vm              *ManagedObjectReference `xml:"vm,omitempty"`
	alreadyLockedVm *ManagedObjectReference `xml:"alreadyLockedVm,omitempty"`
}

type FaultToleranceAntiAffinityViolated struct {
	*MigrationFault

	hostName string                  `xml:"hostName,omitempty"`
	host     *ManagedObjectReference `xml:"host,omitempty"`
}

type FaultToleranceCannotEditMem struct {
	*VmConfigFault

	vmName string                  `xml:"vmName,omitempty"`
	vm     *ManagedObjectReference `xml:"vm,omitempty"`
}

type FaultToleranceCpuIncompatible struct {
	*CpuIncompatible

	model    bool `xml:"model,omitempty"`
	family   bool `xml:"family,omitempty"`
	stepping bool `xml:"stepping,omitempty"`
}

type FaultToleranceNeedsThickDisk struct {
	*MigrationFault

	vmName string `xml:"vmName,omitempty"`
}

type FaultToleranceNotLicensed struct {
	*VmFaultToleranceIssue

	hostName string `xml:"hostName,omitempty"`
}

type FaultToleranceNotSameBuild struct {
	*MigrationFault

	build string `xml:"build,omitempty"`
}

type FaultTolerancePrimaryPowerOnNotAttempted struct {
	*VmFaultToleranceIssue

	secondaryVm *ManagedObjectReference `xml:"secondaryVm,omitempty"`
	primaryVm   *ManagedObjectReference `xml:"primaryVm,omitempty"`
}

type FaultToleranceVmNotDasProtected struct {
	*VimFault

	vm     *ManagedObjectReference `xml:"vm,omitempty"`
	vmName string                  `xml:"vmName,omitempty"`
}

type FcoeFault struct {
	*VimFault
}

type FcoeFaultPnicHasNoPortSet struct {
	*FcoeFault

	nicDevice string `xml:"nicDevice,omitempty"`
}

type FeatureRequirementsNotMet struct {
	*VirtualHardwareCompatibilityIssue

	featureRequirement []*VirtualMachineFeatureRequirement `xml:"featureRequirement,omitempty"`
	vm                 *ManagedObjectReference             `xml:"vm,omitempty"`
	host               *ManagedObjectReference             `xml:"host,omitempty"`
}

type FileAlreadyExists struct {
	*FileFault
}

type FileBackedPortNotSupported struct {
	*DeviceNotSupported
}

type FileFault struct {
	*VimFault

	file string `xml:"file,omitempty"`
}

type FileLocked struct {
	*FileFault
}

type FileNameTooLong struct {
	*FileFault
}

type FileNotFound struct {
	*FileFault
}

type FileNotWritable struct {
	*FileFault
}

type FileTooLarge struct {
	*FileFault

	datastore   string `xml:"datastore,omitempty"`
	fileSize    int64  `xml:"fileSize,omitempty"`
	maxFileSize int64  `xml:"maxFileSize,omitempty"`
}

type FilesystemQuiesceFault struct {
	*SnapshotFault
}

type FtIssuesOnHost struct {
	*VmFaultToleranceIssue

	host     *ManagedObjectReference `xml:"host,omitempty"`
	hostName string                  `xml:"hostName,omitempty"`
	errors   []*LocalizedMethodFault `xml:"errors,omitempty"`
}

type FullStorageVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

type GenericDrsFault struct {
	*VimFault

	hostFaults []*LocalizedMethodFault `xml:"hostFaults,omitempty"`
}

type GenericVmConfigFault struct {
	*VmConfigFault

	reason string `xml:"reason,omitempty"`
}

type GuestAuthenticationChallenge struct {
	*GuestOperationsFault

	serverChallenge *GuestAuthentication `xml:"serverChallenge,omitempty"`
	sessionID       int64                `xml:"sessionID,omitempty"`
}

type GuestComponentsOutOfDate struct {
	*GuestOperationsFault
}

type GuestOperationsFault struct {
	*VimFault
}

type GuestOperationsUnavailable struct {
	*GuestOperationsFault
}

type GuestPermissionDenied struct {
	*GuestOperationsFault
}

type GuestProcessNotFound struct {
	*GuestOperationsFault

	pid int64 `xml:"pid,omitempty"`
}

type HAErrorsAtDest struct {
	*MigrationFault
}

type HostAccessRestrictedToManagementServer struct {
	*NotSupported

	managementServer string `xml:"managementServer,omitempty"`
}

type HostConfigFailed struct {
	*HostConfigFault

	failure []*LocalizedMethodFault `xml:"failure,omitempty"`
}

type HostConfigFault struct {
	*VimFault
}

type HostConnectFault struct {
	*VimFault
}

type HostInDomain struct {
	*HostConfigFault
}

type HostIncompatibleForFaultTolerance struct {
	*VmFaultToleranceIssue

	hostName string `xml:"hostName,omitempty"`
	reason   string `xml:"reason,omitempty"`
}

type HostIncompatibleForRecordReplay struct {
	*VimFault

	hostName string `xml:"hostName,omitempty"`
	reason   string `xml:"reason,omitempty"`
}

type HostInventoryFull struct {
	*NotEnoughLicenses

	capacity int32 `xml:"capacity,omitempty"`
}

type HostPowerOpFailed struct {
	*VimFault
}

type HotSnapshotMoveNotSupported struct {
	*SnapshotCopyNotSupported
}

type IDEDiskNotSupported struct {
	*DiskNotSupported
}

type IORMNotSupportedHostOnDatastore struct {
	*VimFault

	datastore     *ManagedObjectReference   `xml:"datastore,omitempty"`
	datastoreName string                    `xml:"datastoreName,omitempty"`
	host          []*ManagedObjectReference `xml:"host,omitempty"`
}

type ImportHostAddFailure struct {
	*DvsFault

	hostIp []string `xml:"hostIp,omitempty"`
}

type ImportOperationBulkFaultFaultOnImport struct {
	*DynamicData

	entityType string                `xml:"entityType,omitempty"`
	key        string                `xml:"key,omitempty"`
	fault      *LocalizedMethodFault `xml:"fault,omitempty"`
}

type ArrayOfImportOperationBulkFaultFaultOnImport struct {
	ImportOperationBulkFaultFaultOnImport []*ImportOperationBulkFaultFaultOnImport `xml:"ImportOperationBulkFaultFaultOnImport,omitempty"`
}

type ImportOperationBulkFault struct {
	*DvsFault

	importFaults []*ImportOperationBulkFaultFaultOnImport `xml:"importFaults,omitempty"`
}

type InUseFeatureManipulationDisallowed struct {
	*NotEnoughLicenses
}

type InaccessibleDatastore struct {
	*InvalidDatastore

	detail string `xml:"detail,omitempty"`
}

type InaccessibleVFlashSource struct {
	*VimFault

	hostName string `xml:"hostName,omitempty"`
}

type IncompatibleDefaultDevice struct {
	*MigrationFault

	device string `xml:"device,omitempty"`
}

type IncompatibleHostForFtSecondary struct {
	*VmFaultToleranceIssue

	host  *ManagedObjectReference `xml:"host,omitempty"`
	error []*LocalizedMethodFault `xml:"error,omitempty"`
}

type IncompatibleSetting struct {
	*InvalidArgument

	conflictingProperty string `xml:"conflictingProperty,omitempty"`
}

type IncorrectFileType struct {
	*FileFault
}

type IncorrectHostInformation struct {
	*NotEnoughLicenses
}

type IndependentDiskVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

type InsufficientAgentVmsDeployed struct {
	*InsufficientResourcesFault

	hostName            string `xml:"hostName,omitempty"`
	requiredNumAgentVms int32  `xml:"requiredNumAgentVms,omitempty"`
	currentNumAgentVms  int32  `xml:"currentNumAgentVms,omitempty"`
}

type InsufficientCpuResourcesFault struct {
	*InsufficientResourcesFault

	unreserved int64 `xml:"unreserved,omitempty"`
	requested  int64 `xml:"requested,omitempty"`
}

type InsufficientDisks struct {
	*VsanDiskFault
}

type InsufficientFailoverResourcesFault struct {
	*InsufficientResourcesFault
}

type InsufficientHostCapacityFault struct {
	*InsufficientResourcesFault

	host *ManagedObjectReference `xml:"host,omitempty"`
}

type InsufficientHostCpuCapacityFault struct {
	*InsufficientHostCapacityFault

	unreserved int64 `xml:"unreserved,omitempty"`
	requested  int64 `xml:"requested,omitempty"`
}

type InsufficientHostMemoryCapacityFault struct {
	*InsufficientHostCapacityFault

	unreserved int64 `xml:"unreserved,omitempty"`
	requested  int64 `xml:"requested,omitempty"`
}

type InsufficientMemoryResourcesFault struct {
	*InsufficientResourcesFault

	unreserved int64 `xml:"unreserved,omitempty"`
	requested  int64 `xml:"requested,omitempty"`
}

type InsufficientPerCpuCapacity struct {
	*InsufficientHostCapacityFault
}

type InsufficientResourcesFault struct {
	*VimFault
}

type InsufficientStandbyCpuResource struct {
	*InsufficientStandbyResource

	available int64 `xml:"available,omitempty"`
	requested int64 `xml:"requested,omitempty"`
}

type InsufficientStandbyMemoryResource struct {
	*InsufficientStandbyResource

	available int64 `xml:"available,omitempty"`
	requested int64 `xml:"requested,omitempty"`
}

type InsufficientStandbyResource struct {
	*InsufficientResourcesFault
}

type InsufficientStorageSpace struct {
	*InsufficientResourcesFault
}

type InsufficientVFlashResourcesFault struct {
	*InsufficientResourcesFault

	freeSpace      int64 `xml:"freeSpace,omitempty"`
	requestedSpace int64 `xml:"requestedSpace,omitempty"`
}

type InvalidAffinitySettingFault struct {
	*VimFault
}

type InvalidBmcRole struct {
	*VimFault
}

type InvalidBundle struct {
	*PlatformConfigFault
}

type InvalidCAMCertificate struct {
	*InvalidCAMServer
}

type InvalidCAMServer struct {
	*ActiveDirectoryFault

	camServer string `xml:"camServer,omitempty"`
}

type InvalidClientCertificate struct {
	*InvalidLogin
}

type InvalidController struct {
	*InvalidDeviceSpec

	controllerKey int32 `xml:"controllerKey,omitempty"`
}

type InvalidDasConfigArgument struct {
	*InvalidArgument

	entry       string `xml:"entry,omitempty"`
	clusterName string `xml:"clusterName,omitempty"`
}

type InvalidDasRestartPriorityForFtVm struct {
	*InvalidArgument

	vm     *ManagedObjectReference `xml:"vm,omitempty"`
	vmName string                  `xml:"vmName,omitempty"`
}

type InvalidDatastore struct {
	*VimFault

	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
	name      string                  `xml:"name,omitempty"`
}

type InvalidDatastorePath struct {
	*InvalidDatastore

	datastorePath string `xml:"datastorePath,omitempty"`
}

type InvalidDatastoreState struct {
	*InvalidState

	datastoreName string `xml:"datastoreName,omitempty"`
}

type InvalidDeviceBacking struct {
	*InvalidDeviceSpec
}

type InvalidDeviceOperation struct {
	*InvalidDeviceSpec

	badOp     *VirtualDeviceConfigSpecOperation     `xml:"badOp,omitempty"`
	badFileOp *VirtualDeviceConfigSpecFileOperation `xml:"badFileOp,omitempty"`
}

type InvalidDeviceSpec struct {
	*InvalidVmConfig

	deviceIndex int32 `xml:"deviceIndex,omitempty"`
}

type InvalidDiskFormat struct {
	*InvalidFormat
}

type InvalidDrsBehaviorForFtVm struct {
	*InvalidArgument

	vm     *ManagedObjectReference `xml:"vm,omitempty"`
	vmName string                  `xml:"vmName,omitempty"`
}

type InvalidEditionLicense struct {
	*NotEnoughLicenses

	feature string `xml:"feature,omitempty"`
}

type InvalidEvent struct {
	*VimFault
}

type InvalidFolder struct {
	*VimFault

	target *ManagedObjectReference `xml:"target,omitempty"`
}

type InvalidFormat struct {
	*VmConfigFault
}

type InvalidGuestLogin struct {
	*GuestOperationsFault
}

type InvalidHostConnectionState struct {
	*InvalidHostState
}

type InvalidHostName struct {
	*HostConfigFault
}

type InvalidHostState struct {
	*InvalidState

	host *ManagedObjectReference `xml:"host,omitempty"`
}

type InvalidIndexArgument struct {
	*InvalidArgument

	key string `xml:"key,omitempty"`
}

type InvalidIpfixConfig struct {
	*DvsFault

	property string `xml:"property,omitempty"`
}

type InvalidIpmiLoginInfo struct {
	*VimFault
}

type InvalidIpmiMacAddress struct {
	*VimFault

	userProvidedMacAddress string `xml:"userProvidedMacAddress,omitempty"`
	observedMacAddress     string `xml:"observedMacAddress,omitempty"`
}

type InvalidLicense struct {
	*VimFault

	licenseContent string `xml:"licenseContent,omitempty"`
}

type InvalidLocale struct {
	*VimFault
}

type InvalidLogin struct {
	*VimFault
}

type InvalidName struct {
	*VimFault

	name   string                  `xml:"name,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type InvalidNasCredentials struct {
	*NasConfigFault

	userName string `xml:"userName,omitempty"`
}

type InvalidNetworkInType struct {
	*VAppPropertyFault
}

type InvalidNetworkResource struct {
	*NasConfigFault

	remoteHost string `xml:"remoteHost,omitempty"`
	remotePath string `xml:"remotePath,omitempty"`
}

type InvalidOperationOnSecondaryVm struct {
	*VmFaultToleranceIssue

	instanceUuid string `xml:"instanceUuid,omitempty"`
}

type InvalidPowerState struct {
	*InvalidState

	requestedState *VirtualMachinePowerState `xml:"requestedState,omitempty"`
	existingState  *VirtualMachinePowerState `xml:"existingState,omitempty"`
}

type InvalidPrivilege struct {
	*VimFault

	privilege string `xml:"privilege,omitempty"`
}

type InvalidProfileReferenceHost struct {
	*RuntimeFault

	reason  string                  `xml:"reason,omitempty"`
	host    *ManagedObjectReference `xml:"host,omitempty"`
	profile *ManagedObjectReference `xml:"profile,omitempty"`
}

type InvalidPropertyType struct {
	*VAppPropertyFault
}

type InvalidPropertyValue struct {
	*VAppPropertyFault
}

type InvalidResourcePoolStructureFault struct {
	*InsufficientResourcesFault
}

type InvalidSnapshotFormat struct {
	*InvalidFormat
}

type InvalidState struct {
	*VimFault
}

type InvalidVmConfig struct {
	*VmConfigFault

	property string `xml:"property,omitempty"`
}

type InventoryHasStandardAloneHosts struct {
	*NotEnoughLicenses

	hosts []string `xml:"hosts,omitempty"`
}

type IpHostnameGeneratorError struct {
	*CustomizationFault
}

type IscsiFault struct {
	*VimFault
}

type IscsiFaultInvalidVnic struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultPnicInUse struct {
	*IscsiFault

	pnicDevice string `xml:"pnicDevice,omitempty"`
}

type IscsiFaultVnicAlreadyBound struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultVnicHasActivePaths struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultVnicHasMultipleUplinks struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultVnicHasNoUplinks struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultVnicHasWrongUplink struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultVnicInUse struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultVnicIsLastPath struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultVnicNotBound struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type IscsiFaultVnicNotFound struct {
	*IscsiFault

	vnicDevice string `xml:"vnicDevice,omitempty"`
}

type LargeRDMConversionNotSupported struct {
	*MigrationFault

	device string `xml:"device,omitempty"`
}

type LargeRDMNotSupportedOnDatastore struct {
	*VmConfigFault

	device        string                  `xml:"device,omitempty"`
	datastore     *ManagedObjectReference `xml:"datastore,omitempty"`
	datastoreName string                  `xml:"datastoreName,omitempty"`
}

type LegacyNetworkInterfaceInUse struct {
	*CannotAccessNetwork
}

type LicenseAssignmentFailed struct {
	*RuntimeFault

	reason string `xml:"reason,omitempty"`
}

type LicenseDowngradeDisallowed struct {
	*NotEnoughLicenses

	edition  string         `xml:"edition,omitempty"`
	entityId string         `xml:"entityId,omitempty"`
	features []*KeyAnyValue `xml:"features,omitempty"`
}

type LicenseEntityNotFound struct {
	*VimFault

	entityId string `xml:"entityId,omitempty"`
}

type LicenseExpired struct {
	*NotEnoughLicenses

	licenseKey string `xml:"licenseKey,omitempty"`
}

type LicenseKeyEntityMismatch struct {
	*NotEnoughLicenses
}

type LicenseRestricted struct {
	*NotEnoughLicenses
}

type LicenseServerUnavailable struct {
	*VimFault

	licenseServer string `xml:"licenseServer,omitempty"`
}

type LicenseSourceUnavailable struct {
	*NotEnoughLicenses

	licenseSource *LicenseSource `xml:"licenseSource,omitempty"`
}

type LimitExceeded struct {
	*VimFault

	property string `xml:"property,omitempty"`
	limit    int32  `xml:"limit,omitempty"`
}

type LinuxVolumeNotClean struct {
	*CustomizationFault
}

type LogBundlingFailed struct {
	*VimFault
}

type MaintenanceModeFileMove struct {
	*MigrationFault
}

type MemoryHotPlugNotSupported struct {
	*VmConfigFault
}

type MemorySizeNotRecommended struct {
	*VirtualHardwareCompatibilityIssue

	memorySizeMB    int32 `xml:"memorySizeMB,omitempty"`
	minMemorySizeMB int32 `xml:"minMemorySizeMB,omitempty"`
	maxMemorySizeMB int32 `xml:"maxMemorySizeMB,omitempty"`
}

type MemorySizeNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	memorySizeMB    int32 `xml:"memorySizeMB,omitempty"`
	minMemorySizeMB int32 `xml:"minMemorySizeMB,omitempty"`
	maxMemorySizeMB int32 `xml:"maxMemorySizeMB,omitempty"`
}

type MemorySizeNotSupportedByDatastore struct {
	*VirtualHardwareCompatibilityIssue

	datastore       *ManagedObjectReference `xml:"datastore,omitempty"`
	memorySizeMB    int32                   `xml:"memorySizeMB,omitempty"`
	maxMemorySizeMB int32                   `xml:"maxMemorySizeMB,omitempty"`
}

type MemorySnapshotOnIndependentDisk struct {
	*SnapshotFault
}

type MethodAlreadyDisabledFault struct {
	*RuntimeFault

	sourceId string `xml:"sourceId,omitempty"`
}

type MethodDisabled struct {
	*RuntimeFault

	source string `xml:"source,omitempty"`
}

type MigrationDisabled struct {
	*MigrationFault
}

type MigrationFault struct {
	*VimFault
}

type MigrationFeatureNotSupported struct {
	*MigrationFault

	atSourceHost   bool                    `xml:"atSourceHost,omitempty"`
	failedHostName string                  `xml:"failedHostName,omitempty"`
	failedHost     *ManagedObjectReference `xml:"failedHost,omitempty"`
}

type MigrationNotReady struct {
	*MigrationFault

	reason string `xml:"reason,omitempty"`
}

type MismatchedBundle struct {
	*VimFault

	bundleUuid        string `xml:"bundleUuid,omitempty"`
	hostUuid          string `xml:"hostUuid,omitempty"`
	bundleBuildNumber int32  `xml:"bundleBuildNumber,omitempty"`
	hostBuildNumber   int32  `xml:"hostBuildNumber,omitempty"`
}

type MismatchedNetworkPolicies struct {
	*MigrationFault

	device    string `xml:"device,omitempty"`
	backing   string `xml:"backing,omitempty"`
	connected bool   `xml:"connected,omitempty"`
}

type MismatchedVMotionNetworkNames struct {
	*MigrationFault

	sourceNetwork string `xml:"sourceNetwork,omitempty"`
	destNetwork   string `xml:"destNetwork,omitempty"`
}

type MissingBmcSupport struct {
	*VimFault
}

type MissingController struct {
	*InvalidDeviceSpec
}

type MissingIpPool struct {
	*VAppPropertyFault
}

type MissingLinuxCustResources struct {
	*CustomizationFault
}

type MissingNetworkIpConfig struct {
	*VAppPropertyFault
}

type MissingPowerOffConfiguration struct {
	*VAppConfigFault
}

type MissingPowerOnConfiguration struct {
	*VAppConfigFault
}

type MissingWindowsCustResources struct {
	*CustomizationFault
}

type MksConnectionLimitReached struct {
	*InvalidState

	connectionLimit int32 `xml:"connectionLimit,omitempty"`
}

type MountError struct {
	*CustomizationFault

	vm        *ManagedObjectReference `xml:"vm,omitempty"`
	diskIndex int32                   `xml:"diskIndex,omitempty"`
}

type MultipleCertificatesVerifyFaultThumbprintData struct {
	*DynamicData

	port       int32  `xml:"port,omitempty"`
	thumbprint string `xml:"thumbprint,omitempty"`
}

type ArrayOfMultipleCertificatesVerifyFaultThumbprintData struct {
	MultipleCertificatesVerifyFaultThumbprintData []*MultipleCertificatesVerifyFaultThumbprintData `xml:"MultipleCertificatesVerifyFaultThumbprintData,omitempty"`
}

type MultipleCertificatesVerifyFault struct {
	*HostConnectFault

	thumbprintData []*MultipleCertificatesVerifyFaultThumbprintData `xml:"thumbprintData,omitempty"`
}

type MultipleSnapshotsNotSupported struct {
	*SnapshotFault
}

type NamespaceFull struct {
	*VimFault

	name           string `xml:"name,omitempty"`
	currentMaxSize int64  `xml:"currentMaxSize,omitempty"`
	requiredSize   int64  `xml:"requiredSize,omitempty"`
}

type NamespaceLimitReached struct {
	*VimFault

	limit int32 `xml:"limit,omitempty"`
}

type NamespaceWriteProtected struct {
	*VimFault

	name string `xml:"name,omitempty"`
}

type NasConfigFault struct {
	*HostConfigFault

	name string `xml:"name,omitempty"`
}

type NasConnectionLimitReached struct {
	*NasConfigFault

	remoteHost string `xml:"remoteHost,omitempty"`
	remotePath string `xml:"remotePath,omitempty"`
}

type NasSessionCredentialConflict struct {
	*NasConfigFault

	remoteHost string `xml:"remoteHost,omitempty"`
	remotePath string `xml:"remotePath,omitempty"`
	userName   string `xml:"userName,omitempty"`
}

type NasVolumeNotMounted struct {
	*NasConfigFault

	remoteHost string `xml:"remoteHost,omitempty"`
	remotePath string `xml:"remotePath,omitempty"`
}

type NetworkCopyFault struct {
	*FileFault
}

type NetworkDisruptedAndConfigRolledBack struct {
	*VimFault

	host string `xml:"host,omitempty"`
}

type NetworkInaccessible struct {
	*NasConfigFault
}

type NetworksMayNotBeTheSame struct {
	*MigrationFault

	name string `xml:"name,omitempty"`
}

type NicSettingMismatch struct {
	*CustomizationFault

	numberOfNicsInSpec int32 `xml:"numberOfNicsInSpec,omitempty"`
	numberOfNicsInVM   int32 `xml:"numberOfNicsInVM,omitempty"`
}

type NoActiveHostInCluster struct {
	*InvalidState

	computeResource *ManagedObjectReference `xml:"computeResource,omitempty"`
}

type NoAvailableIp struct {
	*VAppPropertyFault

	network *ManagedObjectReference `xml:"network,omitempty"`
}

type NoClientCertificate struct {
	*VimFault
}

type NoCompatibleDatastore struct {
	*VimFault
}

type NoCompatibleHardAffinityHost struct {
	*VmConfigFault

	vmName string `xml:"vmName,omitempty"`
}

type NoCompatibleHost struct {
	*VimFault

	host  []*ManagedObjectReference `xml:"host,omitempty"`
	error []*LocalizedMethodFault   `xml:"error,omitempty"`
}

type NoCompatibleHostWithAccessToDevice struct {
	*NoCompatibleHost
}

type NoCompatibleSoftAffinityHost struct {
	*VmConfigFault

	vmName string `xml:"vmName,omitempty"`
}

type NoConnectedDatastore struct {
	*VimFault
}

type NoDiskFound struct {
	*VimFault
}

type NoDiskSpace struct {
	*FileFault

	datastore string `xml:"datastore,omitempty"`
}

type NoDisksToCustomize struct {
	*CustomizationFault
}

type NoGateway struct {
	*HostConfigFault
}

type NoGuestHeartbeat struct {
	*MigrationFault
}

type NoHost struct {
	*HostConnectFault

	name string `xml:"name,omitempty"`
}

type NoHostSuitableForFtSecondary struct {
	*VmFaultToleranceIssue

	vm     *ManagedObjectReference `xml:"vm,omitempty"`
	vmName string                  `xml:"vmName,omitempty"`
}

type NoLicenseServerConfigured struct {
	*NotEnoughLicenses
}

type NoPeerHostFound struct {
	*HostPowerOpFailed
}

type NoPermission struct {
	*SecurityError

	object      *ManagedObjectReference `xml:"object,omitempty"`
	privilegeId string                  `xml:"privilegeId,omitempty"`
}

type NoPermissionOnAD struct {
	*ActiveDirectoryFault
}

type NoPermissionOnHost struct {
	*HostConnectFault
}

type NoPermissionOnNasVolume struct {
	*NasConfigFault

	userName string `xml:"userName,omitempty"`
}

type NoSubjectName struct {
	*VimFault
}

type NoVcManagedIpConfigured struct {
	*VAppPropertyFault
}

type NoVirtualNic struct {
	*HostConfigFault
}

type NoVmInVApp struct {
	*VAppConfigFault
}

type NonADUserRequired struct {
	*ActiveDirectoryFault
}

type NonHomeRDMVMotionNotSupported struct {
	*MigrationFeatureNotSupported

	device string `xml:"device,omitempty"`
}

type NonPersistentDisksNotSupported struct {
	*DeviceNotSupported
}

type NonVmwareOuiMacNotSupportedHost struct {
	*NotSupportedHost

	hostName string `xml:"hostName,omitempty"`
}

type NotADirectory struct {
	*FileFault
}

type NotAFile struct {
	*FileFault
}

type NotAuthenticated struct {
	*NoPermission
}

type NotEnoughCpus struct {
	*VirtualHardwareCompatibilityIssue

	numCpuDest int32 `xml:"numCpuDest,omitempty"`
	numCpuVm   int32 `xml:"numCpuVm,omitempty"`
}

type NotEnoughLogicalCpus struct {
	*NotEnoughCpus

	host *ManagedObjectReference `xml:"host,omitempty"`
}

type NotFound struct {
	*VimFault
}

type NotSupportedDeviceForFT struct {
	*VmFaultToleranceIssue

	host        *ManagedObjectReference `xml:"host,omitempty"`
	hostName    string                  `xml:"hostName,omitempty"`
	vm          *ManagedObjectReference `xml:"vm,omitempty"`
	vmName      string                  `xml:"vmName,omitempty"`
	deviceType  string                  `xml:"deviceType,omitempty"`
	deviceLabel string                  `xml:"deviceLabel,omitempty"`
}

type NotSupportedHost struct {
	*HostConnectFault

	productName    string `xml:"productName,omitempty"`
	productVersion string `xml:"productVersion,omitempty"`
}

type NotSupportedHostForVFlash struct {
	*NotSupportedHost

	hostName string `xml:"hostName,omitempty"`
}

type NotSupportedHostForVsan struct {
	*NotSupportedHost

	hostName string `xml:"hostName,omitempty"`
}

type NotSupportedHostInCluster struct {
	*NotSupportedHost
}

type NotSupportedHostInDvs struct {
	*NotSupportedHost

	switchProductSpec *DistributedVirtualSwitchProductSpec `xml:"switchProductSpec,omitempty"`
}

type NotSupportedHostInHACluster struct {
	*NotSupportedHost

	hostName string `xml:"hostName,omitempty"`
	build    string `xml:"build,omitempty"`
}

type NotUserConfigurableProperty struct {
	*VAppPropertyFault
}

type NumVirtualCoresPerSocketNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	maxSupportedCoresPerSocketDest int32 `xml:"maxSupportedCoresPerSocketDest,omitempty"`
	numCoresPerSocketVm            int32 `xml:"numCoresPerSocketVm,omitempty"`
}

type NumVirtualCpusExceedsLimit struct {
	*InsufficientResourcesFault

	maxSupportedVcpus int32 `xml:"maxSupportedVcpus,omitempty"`
}

type NumVirtualCpusIncompatible struct {
	*VmConfigFault

	reason string `xml:"reason,omitempty"`
	numCpu int32  `xml:"numCpu,omitempty"`
}

type NumVirtualCpusNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	maxSupportedVcpusDest int32 `xml:"maxSupportedVcpusDest,omitempty"`
	numCpuVm              int32 `xml:"numCpuVm,omitempty"`
}

type OperationDisabledByGuest struct {
	*GuestOperationsFault
}

type OperationDisallowedOnHost struct {
	*RuntimeFault
}

type OperationNotSupportedByGuest struct {
	*GuestOperationsFault
}

type OutOfBounds struct {
	*VimFault

	argumentName string `xml:"argumentName,omitempty"`
}

type OvfAttribute struct {
	*OvfInvalidPackage

	elementName   string `xml:"elementName,omitempty"`
	attributeName string `xml:"attributeName,omitempty"`
}

type OvfConnectedDevice struct {
	*OvfHardwareExport
}

type OvfConnectedDeviceFloppy struct {
	*OvfConnectedDevice

	filename string `xml:"filename,omitempty"`
}

type OvfConnectedDeviceIso struct {
	*OvfConnectedDevice

	filename string `xml:"filename,omitempty"`
}

type OvfConstraint struct {
	*OvfInvalidPackage

	name string `xml:"name,omitempty"`
}

type OvfConsumerCallbackFault struct {
	*OvfFault

	extensionKey  string `xml:"extensionKey,omitempty"`
	extensionName string `xml:"extensionName,omitempty"`
}

type OvfConsumerCommunicationError struct {
	*OvfConsumerCallbackFault

	description string `xml:"description,omitempty"`
}

type OvfConsumerFault struct {
	*OvfConsumerCallbackFault

	errorKey string      `xml:"errorKey,omitempty"`
	message  string      `xml:"message,omitempty"`
	params   []*KeyValue `xml:"params,omitempty"`
}

type OvfConsumerInvalidSection struct {
	*OvfConsumerCallbackFault

	lineNumber  int32  `xml:"lineNumber,omitempty"`
	description string `xml:"description,omitempty"`
}

type OvfConsumerPowerOnFault struct {
	*InvalidState

	extensionKey  string `xml:"extensionKey,omitempty"`
	extensionName string `xml:"extensionName,omitempty"`
	description   string `xml:"description,omitempty"`
}

type OvfConsumerUndeclaredSection struct {
	*OvfConsumerCallbackFault

	qualifiedSectionType string `xml:"qualifiedSectionType,omitempty"`
}

type OvfConsumerUndefinedPrefix struct {
	*OvfConsumerCallbackFault

	prefix string `xml:"prefix,omitempty"`
}

type OvfConsumerValidationFault struct {
	*VmConfigFault

	extensionKey  string `xml:"extensionKey,omitempty"`
	extensionName string `xml:"extensionName,omitempty"`
	message       string `xml:"message,omitempty"`
}

type OvfCpuCompatibility struct {
	*OvfImport

	registerName         string `xml:"registerName,omitempty"`
	level                int32  `xml:"level,omitempty"`
	registerValue        string `xml:"registerValue,omitempty"`
	desiredRegisterValue string `xml:"desiredRegisterValue,omitempty"`
}

type OvfCpuCompatibilityCheckNotSupported struct {
	*OvfImport
}

type OvfDiskMappingNotFound struct {
	*OvfSystemFault

	diskName string `xml:"diskName,omitempty"`
	vmName   string `xml:"vmName,omitempty"`
}

type OvfDiskOrderConstraint struct {
	*OvfConstraint
}

type OvfDuplicateElement struct {
	*OvfElement
}

type OvfDuplicatedElementBoundary struct {
	*OvfElement

	boundary string `xml:"boundary,omitempty"`
}

type OvfDuplicatedPropertyIdExport struct {
	*OvfExport

	fqid string `xml:"fqid,omitempty"`
}

type OvfDuplicatedPropertyIdImport struct {
	*OvfExport
}

type OvfElement struct {
	*OvfInvalidPackage

	name string `xml:"name,omitempty"`
}

type OvfElementInvalidValue struct {
	*OvfElement

	value string `xml:"value,omitempty"`
}

type OvfExport struct {
	*OvfFault
}

type OvfExportFailed struct {
	*OvfExport
}

type OvfFault struct {
	*VimFault
}

type OvfHardwareCheck struct {
	*OvfImport
}

type OvfHardwareExport struct {
	*OvfExport

	device *VirtualDevice `xml:"device,omitempty"`
	vmPath string         `xml:"vmPath,omitempty"`
}

type OvfHostResourceConstraint struct {
	*OvfConstraint

	value string `xml:"value,omitempty"`
}

type OvfHostValueNotParsed struct {
	*OvfSystemFault

	property string `xml:"property,omitempty"`
	value    string `xml:"value,omitempty"`
}

type OvfImport struct {
	*OvfFault
}

type OvfImportFailed struct {
	*OvfImport
}

type OvfInternalError struct {
	*OvfSystemFault
}

type OvfInvalidPackage struct {
	*OvfFault

	lineNumber int32 `xml:"lineNumber,omitempty"`
}

type OvfInvalidValue struct {
	*OvfAttribute

	value string `xml:"value,omitempty"`
}

type OvfInvalidValueConfiguration struct {
	*OvfInvalidValue
}

type OvfInvalidValueEmpty struct {
	*OvfInvalidValue
}

type OvfInvalidValueFormatMalformed struct {
	*OvfInvalidValue
}

type OvfInvalidValueReference struct {
	*OvfInvalidValue
}

type OvfInvalidVmName struct {
	*OvfUnsupportedPackage

	name string `xml:"name,omitempty"`
}

type OvfMappedOsId struct {
	*OvfImport

	ovfId             int32  `xml:"ovfId,omitempty"`
	ovfDescription    string `xml:"ovfDescription,omitempty"`
	targetDescription string `xml:"targetDescription,omitempty"`
}

type OvfMissingAttribute struct {
	*OvfAttribute
}

type OvfMissingElement struct {
	*OvfElement
}

type OvfMissingElementNormalBoundary struct {
	*OvfMissingElement

	boundary string `xml:"boundary,omitempty"`
}

type OvfMissingHardware struct {
	*OvfImport

	name         string `xml:"name,omitempty"`
	resourceType int32  `xml:"resourceType,omitempty"`
}

type OvfNetworkMappingNotSupported struct {
	*OvfImport
}

type OvfNoHostNic struct {
	*OvfUnsupportedPackage
}

type OvfNoSpaceOnController struct {
	*OvfUnsupportedElement

	parent string `xml:"parent,omitempty"`
}

type OvfNoSupportedHardwareFamily struct {
	*OvfUnsupportedPackage

	version string `xml:"version,omitempty"`
}

type OvfProperty struct {
	*OvfInvalidPackage

	type_ string `xml:"type,omitempty"`
	value string `xml:"value,omitempty"`
}

type OvfPropertyExport struct {
	*OvfExport

	type_ string `xml:"type,omitempty"`
	value string `xml:"value,omitempty"`
}

type OvfPropertyNetwork struct {
	*OvfProperty
}

type OvfPropertyNetworkExport struct {
	*OvfExport

	network string `xml:"network,omitempty"`
}

type OvfPropertyQualifier struct {
	*OvfProperty

	qualifier string `xml:"qualifier,omitempty"`
}

type OvfPropertyQualifierDuplicate struct {
	*OvfProperty

	qualifier string `xml:"qualifier,omitempty"`
}

type OvfPropertyQualifierIgnored struct {
	*OvfProperty

	qualifier string `xml:"qualifier,omitempty"`
}

type OvfPropertyType struct {
	*OvfProperty
}

type OvfPropertyValue struct {
	*OvfProperty
}

type OvfSystemFault struct {
	*OvfFault
}

type OvfToXmlUnsupportedElement struct {
	*OvfSystemFault

	name string `xml:"name,omitempty"`
}

type OvfUnableToExportDisk struct {
	*OvfHardwareExport

	diskName string `xml:"diskName,omitempty"`
}

type OvfUnexpectedElement struct {
	*OvfElement
}

type OvfUnknownDevice struct {
	*OvfSystemFault

	device *VirtualDevice `xml:"device,omitempty"`
	vmName string         `xml:"vmName,omitempty"`
}

type OvfUnknownDeviceBacking struct {
	*OvfHardwareExport

	backing *VirtualDeviceBackingInfo `xml:"backing,omitempty"`
}

type OvfUnknownEntity struct {
	*OvfSystemFault

	lineNumber int32 `xml:"lineNumber,omitempty"`
}

type OvfUnsupportedAttribute struct {
	*OvfUnsupportedPackage

	elementName   string `xml:"elementName,omitempty"`
	attributeName string `xml:"attributeName,omitempty"`
}

type OvfUnsupportedAttributeValue struct {
	*OvfUnsupportedAttribute

	value string `xml:"value,omitempty"`
}

type OvfUnsupportedDeviceBackingInfo struct {
	*OvfSystemFault

	elementName string `xml:"elementName,omitempty"`
	instanceId  string `xml:"instanceId,omitempty"`
	deviceName  string `xml:"deviceName,omitempty"`
	backingName string `xml:"backingName,omitempty"`
}

type OvfUnsupportedDeviceBackingOption struct {
	*OvfSystemFault

	elementName string `xml:"elementName,omitempty"`
	instanceId  string `xml:"instanceId,omitempty"`
	deviceName  string `xml:"deviceName,omitempty"`
	backingName string `xml:"backingName,omitempty"`
}

type OvfUnsupportedDeviceExport struct {
	*OvfHardwareExport
}

type OvfUnsupportedDiskProvisioning struct {
	*OvfImport

	diskProvisioning          string `xml:"diskProvisioning,omitempty"`
	supportedDiskProvisioning string `xml:"supportedDiskProvisioning,omitempty"`
}

type OvfUnsupportedElement struct {
	*OvfUnsupportedPackage

	name string `xml:"name,omitempty"`
}

type OvfUnsupportedElementValue struct {
	*OvfUnsupportedElement

	value string `xml:"value,omitempty"`
}

type OvfUnsupportedPackage struct {
	*OvfFault

	lineNumber int32 `xml:"lineNumber,omitempty"`
}

type OvfUnsupportedSection struct {
	*OvfUnsupportedElement

	info string `xml:"info,omitempty"`
}

type OvfUnsupportedSubType struct {
	*OvfUnsupportedPackage

	elementName   string `xml:"elementName,omitempty"`
	instanceId    string `xml:"instanceId,omitempty"`
	deviceType    int32  `xml:"deviceType,omitempty"`
	deviceSubType string `xml:"deviceSubType,omitempty"`
}

type OvfUnsupportedType struct {
	*OvfUnsupportedPackage

	name       string `xml:"name,omitempty"`
	instanceId string `xml:"instanceId,omitempty"`
	deviceType int32  `xml:"deviceType,omitempty"`
}

type OvfWrongElement struct {
	*OvfElement
}

type OvfWrongNamespace struct {
	*OvfInvalidPackage

	namespaceName string `xml:"namespaceName,omitempty"`
}

type OvfXmlFormat struct {
	*OvfInvalidPackage

	description string `xml:"description,omitempty"`
}

type PatchAlreadyInstalled struct {
	*PatchNotApplicable
}

type PatchBinariesNotFound struct {
	*VimFault

	patchID string   `xml:"patchID,omitempty"`
	binary  []string `xml:"binary,omitempty"`
}

type PatchInstallFailed struct {
	*PlatformConfigFault

	rolledBack bool `xml:"rolledBack,omitempty"`
}

type PatchIntegrityError struct {
	*PlatformConfigFault
}

type PatchMetadataCorrupted struct {
	*PatchMetadataInvalid
}

type PatchMetadataInvalid struct {
	*VimFault

	patchID  string   `xml:"patchID,omitempty"`
	metaData []string `xml:"metaData,omitempty"`
}

type PatchMetadataNotFound struct {
	*PatchMetadataInvalid
}

type PatchMissingDependencies struct {
	*PatchNotApplicable

	prerequisitePatch []string `xml:"prerequisitePatch,omitempty"`
	prerequisiteLib   []string `xml:"prerequisiteLib,omitempty"`
}

type PatchNotApplicable struct {
	*VimFault

	patchID string `xml:"patchID,omitempty"`
}

type PatchSuperseded struct {
	*PatchNotApplicable

	supersede []string `xml:"supersede,omitempty"`
}

type PhysCompatRDMNotSupported struct {
	*RDMNotSupported
}

type PlatformConfigFault struct {
	*HostConfigFault

	text string `xml:"text,omitempty"`
}

type PowerOnFtSecondaryFailed struct {
	*VmFaultToleranceIssue

	vm              *ManagedObjectReference          `xml:"vm,omitempty"`
	vmName          string                           `xml:"vmName,omitempty"`
	hostSelectionBy *FtIssuesOnHostHostSelectionType `xml:"hostSelectionBy,omitempty"`
	hostErrors      []*LocalizedMethodFault          `xml:"hostErrors,omitempty"`
	rootCause       *LocalizedMethodFault            `xml:"rootCause,omitempty"`
}

type PowerOnFtSecondaryTimedout struct {
	*Timedout

	vm      *ManagedObjectReference `xml:"vm,omitempty"`
	vmName  string                  `xml:"vmName,omitempty"`
	timeout int32                   `xml:"timeout,omitempty"`
}

type ProfileUpdateFailedUpdateFailure struct {
	*DynamicData

	profilePath *ProfilePropertyPath `xml:"profilePath,omitempty"`
	errMsg      *LocalizableMessage  `xml:"errMsg,omitempty"`
}

type ArrayOfProfileUpdateFailedUpdateFailure struct {
	ProfileUpdateFailedUpdateFailure []*ProfileUpdateFailedUpdateFailure `xml:"ProfileUpdateFailedUpdateFailure,omitempty"`
}

type ProfileUpdateFailed struct {
	*VimFault

	failure []*ProfileUpdateFailedUpdateFailure `xml:"failure,omitempty"`
}

type QuestionPending struct {
	*InvalidState

	text string `xml:"text,omitempty"`
}

type QuiesceDatastoreIOForHAFailed struct {
	*ResourceInUse

	host     *ManagedObjectReference `xml:"host,omitempty"`
	hostName string                  `xml:"hostName,omitempty"`
	ds       *ManagedObjectReference `xml:"ds,omitempty"`
	dsName   string                  `xml:"dsName,omitempty"`
}

type RDMConversionNotSupported struct {
	*MigrationFault

	device string `xml:"device,omitempty"`
}

type RDMNotPreserved struct {
	*MigrationFault

	device string `xml:"device,omitempty"`
}

type RDMNotSupported struct {
	*DeviceNotSupported
}

type RDMNotSupportedOnDatastore struct {
	*VmConfigFault

	device        string                  `xml:"device,omitempty"`
	datastore     *ManagedObjectReference `xml:"datastore,omitempty"`
	datastoreName string                  `xml:"datastoreName,omitempty"`
}

type RDMPointsToInaccessibleDisk struct {
	*CannotAccessVmDisk
}

type RawDiskNotSupported struct {
	*DeviceNotSupported
}

type ReadHostResourcePoolTreeFailed struct {
	*HostConnectFault
}

type ReadOnlyDisksWithLegacyDestination struct {
	*MigrationFault

	roDiskCount   int32 `xml:"roDiskCount,omitempty"`
	timeoutDanger bool  `xml:"timeoutDanger,omitempty"`
}

type RebootRequired struct {
	*VimFault

	patch string `xml:"patch,omitempty"`
}

type RecordReplayDisabled struct {
	*VimFault
}

type RemoteDeviceNotSupported struct {
	*DeviceNotSupported
}

type RemoveFailed struct {
	*VimFault
}

type ReplicationConfigFault struct {
	*ReplicationFault
}

type ReplicationDiskConfigFault struct {
	*ReplicationConfigFault

	reason string                  `xml:"reason,omitempty"`
	vmRef  *ManagedObjectReference `xml:"vmRef,omitempty"`
	key    int32                   `xml:"key,omitempty"`
}

type ReplicationFault struct {
	*VimFault
}

type ReplicationIncompatibleWithFT struct {
	*ReplicationFault
}

type ReplicationInvalidOptions struct {
	*ReplicationFault

	options string                  `xml:"options,omitempty"`
	entity  *ManagedObjectReference `xml:"entity,omitempty"`
}

type ReplicationNotSupportedOnHost struct {
	*ReplicationFault
}

type ReplicationVmConfigFault struct {
	*ReplicationConfigFault

	reason string                  `xml:"reason,omitempty"`
	vmRef  *ManagedObjectReference `xml:"vmRef,omitempty"`
}

type ReplicationVmFault struct {
	*ReplicationFault

	reason     string                  `xml:"reason,omitempty"`
	state      string                  `xml:"state,omitempty"`
	instanceId string                  `xml:"instanceId,omitempty"`
	vm         *ManagedObjectReference `xml:"vm,omitempty"`
}

type ResourceInUse struct {
	*VimFault

	type_ string `xml:"type,omitempty"`
	name  string `xml:"name,omitempty"`
}

type ResourceNotAvailable struct {
	*VimFault

	containerType string `xml:"containerType,omitempty"`
	containerName string `xml:"containerName,omitempty"`
	type_         string `xml:"type,omitempty"`
}

type RestrictedVersion struct {
	*SecurityError
}

type RollbackFailure struct {
	*DvsFault

	entityName string `xml:"entityName,omitempty"`
	entityType string `xml:"entityType,omitempty"`
}

type RuleViolation struct {
	*VmConfigFault

	host *ManagedObjectReference `xml:"host,omitempty"`
	rule *ClusterRuleInfo        `xml:"rule,omitempty"`
}

type SSLDisabledFault struct {
	*HostConnectFault
}

type SSLVerifyFault struct {
	*HostConnectFault

	selfSigned bool   `xml:"selfSigned,omitempty"`
	thumbprint string `xml:"thumbprint,omitempty"`
}

type SSPIChallenge struct {
	*VimFault

	base64Token string `xml:"base64Token,omitempty"`
}

type SecondaryVmAlreadyDisabled struct {
	*VmFaultToleranceIssue

	instanceUuid string `xml:"instanceUuid,omitempty"`
}

type SecondaryVmAlreadyEnabled struct {
	*VmFaultToleranceIssue

	instanceUuid string `xml:"instanceUuid,omitempty"`
}

type SecondaryVmAlreadyRegistered struct {
	*VmFaultToleranceIssue

	instanceUuid string `xml:"instanceUuid,omitempty"`
}

type SecondaryVmNotRegistered struct {
	*VmFaultToleranceIssue

	instanceUuid string `xml:"instanceUuid,omitempty"`
}

type SharedBusControllerNotSupported struct {
	*DeviceNotSupported
}

type ShrinkDiskFault struct {
	*VimFault

	diskId int32 `xml:"diskId,omitempty"`
}

type SnapshotCloneNotSupported struct {
	*SnapshotCopyNotSupported
}

type SnapshotCopyNotSupported struct {
	*MigrationFault
}

type SnapshotDisabled struct {
	*SnapshotFault
}

type SnapshotFault struct {
	*VimFault
}

type SnapshotIncompatibleDeviceInVm struct {
	*SnapshotFault

	fault *LocalizedMethodFault `xml:"fault,omitempty"`
}

type SnapshotLocked struct {
	*SnapshotFault
}

type SnapshotMoveFromNonHomeNotSupported struct {
	*SnapshotCopyNotSupported
}

type SnapshotMoveNotSupported struct {
	*SnapshotCopyNotSupported
}

type SnapshotMoveToNonHomeNotSupported struct {
	*SnapshotCopyNotSupported
}

type SnapshotNoChange struct {
	*SnapshotFault
}

type SnapshotRevertIssue struct {
	*MigrationFault

	snapshotName string   `xml:"snapshotName,omitempty"`
	event        []*Event `xml:"event,omitempty"`
	errors       bool     `xml:"errors,omitempty"`
}

type SoftRuleVioCorrectionDisallowed struct {
	*VmConfigFault

	vmName string `xml:"vmName,omitempty"`
}

type SoftRuleVioCorrectionImpact struct {
	*VmConfigFault

	vmName string `xml:"vmName,omitempty"`
}

type SsdDiskNotAvailable struct {
	*VimFault

	devicePath string `xml:"devicePath,omitempty"`
}

type StorageDrsCannotMoveDiskInMultiWriterMode struct {
	*VimFault
}

type StorageDrsCannotMoveFTVm struct {
	*VimFault
}

type StorageDrsCannotMoveIndependentDisk struct {
	*VimFault
}

type StorageDrsCannotMoveManuallyPlacedSwapFile struct {
	*VimFault
}

type StorageDrsCannotMoveManuallyPlacedVm struct {
	*VimFault
}

type StorageDrsCannotMoveSharedDisk struct {
	*VimFault
}

type StorageDrsCannotMoveTemplate struct {
	*VimFault
}

type StorageDrsCannotMoveVmInUserFolder struct {
	*VimFault
}

type StorageDrsCannotMoveVmWithMountedCDROM struct {
	*VimFault
}

type StorageDrsCannotMoveVmWithNoFilesInLayout struct {
	*VimFault
}

type StorageDrsDatacentersCannotShareDatastore struct {
	*VimFault
}

type StorageDrsDisabledOnVm struct {
	*VimFault
}

type StorageDrsIolbDisabledInternally struct {
	*VimFault
}

type StorageDrsUnableToMoveFiles struct {
	*VimFault
}

type StorageVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

type StorageVmotionIncompatible struct {
	*VirtualHardwareCompatibilityIssue

	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
}

type SuspendedRelocateNotSupported struct {
	*MigrationFault
}

type SwapDatastoreNotWritableOnHost struct {
	*DatastoreNotWritableOnHost
}

type SwapDatastoreUnset struct {
	*VimFault
}

type SwapPlacementOverrideNotSupported struct {
	*InvalidVmConfig
}

type SwitchIpUnset struct {
	*DvsFault
}

type SwitchNotInUpgradeMode struct {
	*DvsFault
}

type TaskInProgress struct {
	*VimFault

	task *ManagedObjectReference `xml:"task,omitempty"`
}

type ThirdPartyLicenseAssignmentFailed struct {
	*RuntimeFault

	host   *ManagedObjectReference `xml:"host,omitempty"`
	module string                  `xml:"module,omitempty"`
	reason string                  `xml:"reason,omitempty"`
}

type Timedout struct {
	*VimFault
}

type TooManyConcurrentNativeClones struct {
	*FileFault
}

type TooManyConsecutiveOverrides struct {
	*VimFault
}

type TooManyDevices struct {
	*InvalidVmConfig
}

type TooManyDisksOnLegacyHost struct {
	*MigrationFault

	diskCount     int32 `xml:"diskCount,omitempty"`
	timeoutDanger bool  `xml:"timeoutDanger,omitempty"`
}

type TooManyGuestLogons struct {
	*GuestOperationsFault
}

type TooManyHosts struct {
	*HostConnectFault
}

type TooManyNativeCloneLevels struct {
	*FileFault
}

type TooManyNativeClonesOnFile struct {
	*FileFault
}

type TooManySnapshotLevels struct {
	*SnapshotFault
}

type ToolsAlreadyUpgraded struct {
	*VmToolsUpgradeFault
}

type ToolsAutoUpgradeNotSupported struct {
	*VmToolsUpgradeFault
}

type ToolsImageCopyFailed struct {
	*VmToolsUpgradeFault
}

type ToolsImageNotAvailable struct {
	*VmToolsUpgradeFault
}

type ToolsImageSignatureCheckFailed struct {
	*VmToolsUpgradeFault
}

type ToolsInstallationInProgress struct {
	*MigrationFault
}

type ToolsUnavailable struct {
	*VimFault
}

type ToolsUpgradeCancelled struct {
	*VmToolsUpgradeFault
}

type UnSupportedDatastoreForVFlash struct {
	*UnsupportedDatastore

	datastoreName string `xml:"datastoreName,omitempty"`
	type_         string `xml:"type,omitempty"`
}

type UncommittedUndoableDisk struct {
	*MigrationFault
}

type UnconfiguredPropertyValue struct {
	*InvalidPropertyValue
}

type UncustomizableGuest struct {
	*CustomizationFault

	uncustomizableGuestOS string `xml:"uncustomizableGuestOS,omitempty"`
}

type UnexpectedCustomizationFault struct {
	*CustomizationFault
}

type UnrecognizedHost struct {
	*VimFault

	hostName string `xml:"hostName,omitempty"`
}

type UnsharedSwapVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

type UnsupportedDatastore struct {
	*VmConfigFault

	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
}

type UnsupportedGuest struct {
	*InvalidVmConfig

	unsupportedGuestOS string `xml:"unsupportedGuestOS,omitempty"`
}

type UnsupportedVimApiVersion struct {
	*VimFault

	version string `xml:"version,omitempty"`
}

type UnsupportedVmxLocation struct {
	*VmConfigFault
}

type UnusedVirtualDiskBlocksNotScrubbed struct {
	*DeviceBackingNotSupported
}

type UserNotFound struct {
	*VimFault

	principal  string `xml:"principal,omitempty"`
	unresolved bool   `xml:"unresolved,omitempty"`
}

type VAppConfigFault struct {
	*VimFault
}

type VAppNotRunning struct {
	*VmConfigFault
}

type VAppOperationInProgress struct {
	*RuntimeFault
}

type VAppPropertyFault struct {
	*VmConfigFault

	id       string `xml:"id,omitempty"`
	category string `xml:"category,omitempty"`
	label    string `xml:"label,omitempty"`
	type_    string `xml:"type,omitempty"`
	value    string `xml:"value,omitempty"`
}

type VAppTaskInProgress struct {
	*TaskInProgress
}

type VFlashModuleNotSupported struct {
	*VmConfigFault

	vmName     string `xml:"vmName,omitempty"`
	moduleName string `xml:"moduleName,omitempty"`
	reason     string `xml:"reason,omitempty"`
	hostName   string `xml:"hostName,omitempty"`
}

type VFlashModuleVersionIncompatible struct {
	*VimFault

	moduleName             string `xml:"moduleName,omitempty"`
	vmRequestModuleVersion string `xml:"vmRequestModuleVersion,omitempty"`
	hostMinSupportedVerson string `xml:"hostMinSupportedVerson,omitempty"`
	hostModuleVersion      string `xml:"hostModuleVersion,omitempty"`
}

type VMINotSupported struct {
	*DeviceNotSupported
}

type VMOnConflictDVPort struct {
	*CannotAccessNetwork
}

type VMOnVirtualIntranet struct {
	*CannotAccessNetwork
}

type VMotionAcrossNetworkNotSupported struct {
	*MigrationFeatureNotSupported
}

type VMotionInterfaceIssue struct {
	*MigrationFault

	atSourceHost     bool                    `xml:"atSourceHost,omitempty"`
	failedHost       string                  `xml:"failedHost,omitempty"`
	failedHostEntity *ManagedObjectReference `xml:"failedHostEntity,omitempty"`
}

type VMotionLinkCapacityLow struct {
	*VMotionInterfaceIssue

	network string `xml:"network,omitempty"`
}

type VMotionLinkDown struct {
	*VMotionInterfaceIssue

	network string `xml:"network,omitempty"`
}

type VMotionNotConfigured struct {
	*VMotionInterfaceIssue
}

type VMotionNotLicensed struct {
	*VMotionInterfaceIssue
}

type VMotionNotSupported struct {
	*VMotionInterfaceIssue
}

type VMotionProtocolIncompatible struct {
	*MigrationFault
}

type VimFault struct {
	*MethodFault
}

type VirtualDiskBlocksNotFullyProvisioned struct {
	*DeviceBackingNotSupported
}

type VirtualDiskModeNotSupported struct {
	*DeviceNotSupported

	mode string `xml:"mode,omitempty"`
}

type VirtualEthernetCardNotSupported struct {
	*DeviceNotSupported
}

type VirtualHardwareCompatibilityIssue struct {
	*VmConfigFault
}

type VirtualHardwareVersionNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	hostName string                  `xml:"hostName,omitempty"`
	host     *ManagedObjectReference `xml:"host,omitempty"`
}

type VmAlreadyExistsInDatacenter struct {
	*InvalidFolder

	host     *ManagedObjectReference   `xml:"host,omitempty"`
	hostname string                    `xml:"hostname,omitempty"`
	vm       []*ManagedObjectReference `xml:"vm,omitempty"`
}

type VmConfigFault struct {
	*VimFault
}

type VmConfigIncompatibleForFaultTolerance struct {
	*VmConfigFault

	fault *LocalizedMethodFault `xml:"fault,omitempty"`
}

type VmConfigIncompatibleForRecordReplay struct {
	*VmConfigFault

	fault *LocalizedMethodFault `xml:"fault,omitempty"`
}

type VmFaultToleranceConfigIssue struct {
	*VmFaultToleranceIssue

	reason     string                  `xml:"reason,omitempty"`
	entityName string                  `xml:"entityName,omitempty"`
	entity     *ManagedObjectReference `xml:"entity,omitempty"`
}

type VmFaultToleranceConfigIssueWrapper struct {
	*VmFaultToleranceIssue

	entityName string                  `xml:"entityName,omitempty"`
	entity     *ManagedObjectReference `xml:"entity,omitempty"`
	error      *LocalizedMethodFault   `xml:"error,omitempty"`
}

type VmFaultToleranceInvalidFileBacking struct {
	*VmFaultToleranceIssue

	backingType     string `xml:"backingType,omitempty"`
	backingFilename string `xml:"backingFilename,omitempty"`
}

type VmFaultToleranceIssue struct {
	*VimFault
}

type VmFaultToleranceOpIssuesList struct {
	*VmFaultToleranceIssue

	errors   []*LocalizedMethodFault `xml:"errors,omitempty"`
	warnings []*LocalizedMethodFault `xml:"warnings,omitempty"`
}

type VmFaultToleranceTooManyVMsOnHost struct {
	*InsufficientResourcesFault

	hostName    string `xml:"hostName,omitempty"`
	maxNumFtVms int32  `xml:"maxNumFtVms,omitempty"`
}

type VmHostAffinityRuleViolation struct {
	*VmConfigFault

	vmName   string `xml:"vmName,omitempty"`
	hostName string `xml:"hostName,omitempty"`
}

type VmLimitLicense struct {
	*NotEnoughLicenses

	limit int32 `xml:"limit,omitempty"`
}

type VmMetadataManagerFault struct {
	*VimFault
}

type VmMonitorIncompatibleForFaultTolerance struct {
	*VimFault
}

type VmPowerOnDisabled struct {
	*InvalidState
}

type VmToolsUpgradeFault struct {
	*VimFault
}

type VmValidateMaxDevice struct {
	*VimFault

	device string `xml:"device,omitempty"`
	max    int32  `xml:"max,omitempty"`
	count  int32  `xml:"count,omitempty"`
}

type VmWwnConflict struct {
	*InvalidVmConfig

	vm   *ManagedObjectReference `xml:"vm,omitempty"`
	host *ManagedObjectReference `xml:"host,omitempty"`
	name string                  `xml:"name,omitempty"`
	wwn  int64                   `xml:"wwn,omitempty"`
}

type VmfsAlreadyMounted struct {
	*VmfsMountFault
}

type VmfsAmbiguousMount struct {
	*VmfsMountFault
}

type VmfsMountFault struct {
	*HostConfigFault

	uuid string `xml:"uuid,omitempty"`
}

type VmotionInterfaceNotEnabled struct {
	*HostPowerOpFailed
}

type VolumeEditorError struct {
	*CustomizationFault
}

type VramLimitLicense struct {
	*NotEnoughLicenses

	limit int32 `xml:"limit,omitempty"`
}

type VsanClusterUuidMismatch struct {
	*CannotMoveVsanEnabledHost

	hostClusterUuid        string `xml:"hostClusterUuid,omitempty"`
	destinationClusterUuid string `xml:"destinationClusterUuid,omitempty"`
}

type VsanDiskFault struct {
	*VsanFault

	device string `xml:"device,omitempty"`
}

type VsanFault struct {
	*VimFault
}

type VspanDestPortConflict struct {
	*DvsFault

	vspanSessionKey1 string `xml:"vspanSessionKey1,omitempty"`
	vspanSessionKey2 string `xml:"vspanSessionKey2,omitempty"`
	portKey          string `xml:"portKey,omitempty"`
}

type VspanPortConflict struct {
	*DvsFault

	vspanSessionKey1 string `xml:"vspanSessionKey1,omitempty"`
	vspanSessionKey2 string `xml:"vspanSessionKey2,omitempty"`
	portKey          string `xml:"portKey,omitempty"`
}

type VspanPortMoveFault struct {
	*DvsFault

	srcPortgroupName  string `xml:"srcPortgroupName,omitempty"`
	destPortgroupName string `xml:"destPortgroupName,omitempty"`
	portKey           string `xml:"portKey,omitempty"`
}

type VspanPortPromiscChangeFault struct {
	*DvsFault

	portKey string `xml:"portKey,omitempty"`
}

type VspanPortgroupPromiscChangeFault struct {
	*DvsFault

	portgroupName string `xml:"portgroupName,omitempty"`
}

type VspanPortgroupTypeChangeFault struct {
	*DvsFault

	portgroupName string `xml:"portgroupName,omitempty"`
}

type VspanPromiscuousPortNotSupported struct {
	*DvsFault

	vspanSessionKey string `xml:"vspanSessionKey,omitempty"`
	portKey         string `xml:"portKey,omitempty"`
}

type VspanSameSessionPortConflict struct {
	*DvsFault

	vspanSessionKey string `xml:"vspanSessionKey,omitempty"`
	portKey         string `xml:"portKey,omitempty"`
}

type WakeOnLanNotSupported struct {
	*VirtualHardwareCompatibilityIssue
}

type WakeOnLanNotSupportedByVmotionNIC struct {
	*HostPowerOpFailed
}

type WillLoseHAProtection struct {
	*MigrationFault

	resolution string `xml:"resolution,omitempty"`
}

type WillModifyConfigCpuRequirements struct {
	*MigrationFault
}

type WillResetSnapshotDirectory struct {
	*MigrationFault
}

type WipeDiskFault struct {
	*VimFault
}

type HostActiveDirectoryInfo struct {
	*HostDirectoryStoreInfo

	joinedDomain           string   `xml:"joinedDomain,omitempty"`
	trustedDomain          []string `xml:"trustedDomain,omitempty"`
	domainMembershipStatus string   `xml:"domainMembershipStatus,omitempty"`
}

type HostActiveDirectorySpec struct {
	*DynamicData

	domainName string `xml:"domainName,omitempty"`
	userName   string `xml:"userName,omitempty"`
	password   string `xml:"password,omitempty"`
	camServer  string `xml:"camServer,omitempty"`
	thumbprint string `xml:"thumbprint,omitempty"`
}

type HostActiveDirectory struct {
	*DynamicData

	changeOperation string                   `xml:"changeOperation,omitempty"`
	spec            *HostActiveDirectorySpec `xml:"spec,omitempty"`
}

type ArrayOfHostActiveDirectory struct {
	HostActiveDirectory []*HostActiveDirectory `xml:"HostActiveDirectory,omitempty"`
}

type HostAuthenticationManagerInfo struct {
	*DynamicData

	authConfig []*HostAuthenticationStoreInfo `xml:"authConfig,omitempty"`
}

type HostAuthenticationStoreInfo struct {
	*DynamicData

	enabled bool `xml:"enabled,omitempty"`
}

type ArrayOfHostAuthenticationStoreInfo struct {
	HostAuthenticationStoreInfo []*HostAuthenticationStoreInfo `xml:"HostAuthenticationStoreInfo,omitempty"`
}

type AutoStartDefaults struct {
	*DynamicData

	enabled          bool   `xml:"enabled,omitempty"`
	startDelay       int32  `xml:"startDelay,omitempty"`
	stopDelay        int32  `xml:"stopDelay,omitempty"`
	waitForHeartbeat bool   `xml:"waitForHeartbeat,omitempty"`
	stopAction       string `xml:"stopAction,omitempty"`
}

type AutoStartPowerInfo struct {
	*DynamicData

	key              *ManagedObjectReference        `xml:"key,omitempty"`
	startOrder       int32                          `xml:"startOrder,omitempty"`
	startDelay       int32                          `xml:"startDelay,omitempty"`
	waitForHeartbeat *AutoStartWaitHeartbeatSetting `xml:"waitForHeartbeat,omitempty"`
	startAction      string                         `xml:"startAction,omitempty"`
	stopDelay        int32                          `xml:"stopDelay,omitempty"`
	stopAction       string                         `xml:"stopAction,omitempty"`
}

type ArrayOfAutoStartPowerInfo struct {
	AutoStartPowerInfo []*AutoStartPowerInfo `xml:"AutoStartPowerInfo,omitempty"`
}

type HostAutoStartManagerConfig struct {
	*DynamicData

	defaults  *AutoStartDefaults    `xml:"defaults,omitempty"`
	powerInfo []*AutoStartPowerInfo `xml:"powerInfo,omitempty"`
}

type HostBootDeviceInfo struct {
	*DynamicData

	bootDevices          []*HostBootDevice `xml:"bootDevices,omitempty"`
	currentBootDeviceKey string            `xml:"currentBootDeviceKey,omitempty"`
}

type HostBootDevice struct {
	*DynamicData

	key         string `xml:"key,omitempty"`
	description string `xml:"description,omitempty"`
}

type ArrayOfHostBootDevice struct {
	HostBootDevice []*HostBootDevice `xml:"HostBootDevice,omitempty"`
}

type HostCacheConfigurationSpec struct {
	*DynamicData

	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
	swapSize  int64                   `xml:"swapSize,omitempty"`
}

type HostCacheConfigurationInfo struct {
	*DynamicData

	key      *ManagedObjectReference `xml:"key,omitempty"`
	swapSize int64                   `xml:"swapSize,omitempty"`
}

type ArrayOfHostCacheConfigurationInfo struct {
	HostCacheConfigurationInfo []*HostCacheConfigurationInfo `xml:"HostCacheConfigurationInfo,omitempty"`
}

type HostCapability struct {
	*DynamicData

	recursiveResourcePoolsSupported           bool             `xml:"recursiveResourcePoolsSupported,omitempty"`
	cpuMemoryResourceConfigurationSupported   bool             `xml:"cpuMemoryResourceConfigurationSupported,omitempty"`
	rebootSupported                           bool             `xml:"rebootSupported,omitempty"`
	shutdownSupported                         bool             `xml:"shutdownSupported,omitempty"`
	vmotionSupported                          bool             `xml:"vmotionSupported,omitempty"`
	standbySupported                          bool             `xml:"standbySupported,omitempty"`
	ipmiSupported                             bool             `xml:"ipmiSupported,omitempty"`
	maxSupportedVMs                           int32            `xml:"maxSupportedVMs,omitempty"`
	maxRunningVMs                             int32            `xml:"maxRunningVMs,omitempty"`
	maxSupportedVcpus                         int32            `xml:"maxSupportedVcpus,omitempty"`
	maxRegisteredVMs                          int32            `xml:"maxRegisteredVMs,omitempty"`
	datastorePrincipalSupported               bool             `xml:"datastorePrincipalSupported,omitempty"`
	sanSupported                              bool             `xml:"sanSupported,omitempty"`
	nfsSupported                              bool             `xml:"nfsSupported,omitempty"`
	iscsiSupported                            bool             `xml:"iscsiSupported,omitempty"`
	vlanTaggingSupported                      bool             `xml:"vlanTaggingSupported,omitempty"`
	nicTeamingSupported                       bool             `xml:"nicTeamingSupported,omitempty"`
	highGuestMemSupported                     bool             `xml:"highGuestMemSupported,omitempty"`
	maintenanceModeSupported                  bool             `xml:"maintenanceModeSupported,omitempty"`
	suspendedRelocateSupported                bool             `xml:"suspendedRelocateSupported,omitempty"`
	restrictedSnapshotRelocateSupported       bool             `xml:"restrictedSnapshotRelocateSupported,omitempty"`
	perVmSwapFiles                            bool             `xml:"perVmSwapFiles,omitempty"`
	localSwapDatastoreSupported               bool             `xml:"localSwapDatastoreSupported,omitempty"`
	unsharedSwapVMotionSupported              bool             `xml:"unsharedSwapVMotionSupported,omitempty"`
	backgroundSnapshotsSupported              bool             `xml:"backgroundSnapshotsSupported,omitempty"`
	preAssignedPCIUnitNumbersSupported        bool             `xml:"preAssignedPCIUnitNumbersSupported,omitempty"`
	screenshotSupported                       bool             `xml:"screenshotSupported,omitempty"`
	scaledScreenshotSupported                 bool             `xml:"scaledScreenshotSupported,omitempty"`
	storageVMotionSupported                   bool             `xml:"storageVMotionSupported,omitempty"`
	vmotionWithStorageVMotionSupported        bool             `xml:"vmotionWithStorageVMotionSupported,omitempty"`
	vmotionAcrossNetworkSupported             bool             `xml:"vmotionAcrossNetworkSupported,omitempty"`
	hbrNicSelectionSupported                  bool             `xml:"hbrNicSelectionSupported,omitempty"`
	recordReplaySupported                     bool             `xml:"recordReplaySupported,omitempty"`
	ftSupported                               bool             `xml:"ftSupported,omitempty"`
	replayUnsupportedReason                   string           `xml:"replayUnsupportedReason,omitempty"`
	replayCompatibilityIssues                 []string         `xml:"replayCompatibilityIssues,omitempty"`
	ftCompatibilityIssues                     []string         `xml:"ftCompatibilityIssues,omitempty"`
	loginBySSLThumbprintSupported             bool             `xml:"loginBySSLThumbprintSupported,omitempty"`
	cloneFromSnapshotSupported                bool             `xml:"cloneFromSnapshotSupported,omitempty"`
	deltaDiskBackingsSupported                bool             `xml:"deltaDiskBackingsSupported,omitempty"`
	perVMNetworkTrafficShapingSupported       bool             `xml:"perVMNetworkTrafficShapingSupported,omitempty"`
	tpmSupported                              bool             `xml:"tpmSupported,omitempty"`
	supportedCpuFeature                       []*HostCpuIdInfo `xml:"supportedCpuFeature,omitempty"`
	virtualExecUsageSupported                 bool             `xml:"virtualExecUsageSupported,omitempty"`
	storageIORMSupported                      bool             `xml:"storageIORMSupported,omitempty"`
	vmDirectPathGen2Supported                 bool             `xml:"vmDirectPathGen2Supported,omitempty"`
	vmDirectPathGen2UnsupportedReason         []string         `xml:"vmDirectPathGen2UnsupportedReason,omitempty"`
	vmDirectPathGen2UnsupportedReasonExtended string           `xml:"vmDirectPathGen2UnsupportedReasonExtended,omitempty"`
	supportedVmfsMajorVersion                 []int32          `xml:"supportedVmfsMajorVersion,omitempty"`
	vStorageCapable                           bool             `xml:"vStorageCapable,omitempty"`
	snapshotRelayoutSupported                 bool             `xml:"snapshotRelayoutSupported,omitempty"`
	firewallIpRulesSupported                  bool             `xml:"firewallIpRulesSupported,omitempty"`
	servicePackageInfoSupported               bool             `xml:"servicePackageInfoSupported,omitempty"`
	maxHostRunningVms                         int32            `xml:"maxHostRunningVms,omitempty"`
	maxHostSupportedVcpus                     int32            `xml:"maxHostSupportedVcpus,omitempty"`
	vmfsDatastoreMountCapable                 bool             `xml:"vmfsDatastoreMountCapable,omitempty"`
	eightPlusHostVmfsSharedAccessSupported    bool             `xml:"eightPlusHostVmfsSharedAccessSupported,omitempty"`
	nestedHVSupported                         bool             `xml:"nestedHVSupported,omitempty"`
	vPMCSupported                             bool             `xml:"vPMCSupported,omitempty"`
	interVMCommunicationThroughVMCISupported  bool             `xml:"interVMCommunicationThroughVMCISupported,omitempty"`
	scheduledHardwareUpgradeSupported         bool             `xml:"scheduledHardwareUpgradeSupported,omitempty"`
	featureCapabilitiesSupported              bool             `xml:"featureCapabilitiesSupported,omitempty"`
	latencySensitivitySupported               bool             `xml:"latencySensitivitySupported,omitempty"`
	storagePolicySupported                    bool             `xml:"storagePolicySupported,omitempty"`
	accel3dSupported                          bool             `xml:"accel3dSupported,omitempty"`
	reliableMemoryAware                       bool             `xml:"reliableMemoryAware,omitempty"`
	multipleNetworkStackInstanceSupported     bool             `xml:"multipleNetworkStackInstanceSupported,omitempty"`
	vsanSupported                             bool             `xml:"vsanSupported,omitempty"`
	vFlashSupported                           bool             `xml:"vFlashSupported,omitempty"`
}

type HostConfigChange struct {
	*DynamicData
}

type HostConfigInfo struct {
	*DynamicData

	host                      *ManagedObjectReference              `xml:"host,omitempty"`
	product                   *AboutInfo                           `xml:"product,omitempty"`
	hyperThread               *HostHyperThreadScheduleInfo         `xml:"hyperThread,omitempty"`
	consoleReservation        *ServiceConsoleReservationInfo       `xml:"consoleReservation,omitempty"`
	virtualMachineReservation *VirtualMachineMemoryReservationInfo `xml:"virtualMachineReservation,omitempty"`
	storageDevice             *HostStorageDeviceInfo               `xml:"storageDevice,omitempty"`
	multipathState            *HostMultipathStateInfo              `xml:"multipathState,omitempty"`
	fileSystemVolume          *HostFileSystemVolumeInfo            `xml:"fileSystemVolume,omitempty"`
	systemFile                []string                             `xml:"systemFile,omitempty"`
	network                   *HostNetworkInfo                     `xml:"network,omitempty"`
	vmotion                   *HostVMotionInfo                     `xml:"vmotion,omitempty"`
	virtualNicManagerInfo     *HostVirtualNicManagerInfo           `xml:"virtualNicManagerInfo,omitempty"`
	capabilities              *HostNetCapabilities                 `xml:"capabilities,omitempty"`
	datastoreCapabilities     *HostDatastoreSystemCapabilities     `xml:"datastoreCapabilities,omitempty"`
	offloadCapabilities       *HostNetOffloadCapabilities          `xml:"offloadCapabilities,omitempty"`
	service                   *HostServiceInfo                     `xml:"service,omitempty"`
	firewall                  *HostFirewallInfo                    `xml:"firewall,omitempty"`
	autoStart                 *HostAutoStartManagerConfig          `xml:"autoStart,omitempty"`
	activeDiagnosticPartition *HostDiagnosticPartition             `xml:"activeDiagnosticPartition,omitempty"`
	option                    []*OptionValue                       `xml:"option,omitempty"`
	optionDef                 []*OptionDef                         `xml:"optionDef,omitempty"`
	datastorePrincipal        string                               `xml:"datastorePrincipal,omitempty"`
	localSwapDatastore        *ManagedObjectReference              `xml:"localSwapDatastore,omitempty"`
	systemSwapConfiguration   *HostSystemSwapConfiguration         `xml:"systemSwapConfiguration,omitempty"`
	systemResources           *HostSystemResourceInfo              `xml:"systemResources,omitempty"`
	dateTimeInfo              *HostDateTimeInfo                    `xml:"dateTimeInfo,omitempty"`
	flags                     *HostFlagInfo                        `xml:"flags,omitempty"`
	adminDisabled             bool                                 `xml:"adminDisabled,omitempty"`
	ipmi                      *HostIpmiInfo                        `xml:"ipmi,omitempty"`
	sslThumbprintInfo         *HostSslThumbprintInfo               `xml:"sslThumbprintInfo,omitempty"`
	sslThumbprintData         []*HostSslThumbprintInfo             `xml:"sslThumbprintData,omitempty"`
	certificate               []int8                               `xml:"certificate,omitempty"`
	pciPassthruInfo           []*HostPciPassthruInfo               `xml:"pciPassthruInfo,omitempty"`
	authenticationManagerInfo *HostAuthenticationManagerInfo       `xml:"authenticationManagerInfo,omitempty"`
	featureVersion            []*HostFeatureVersionInfo            `xml:"featureVersion,omitempty"`
	powerSystemCapability     *PowerSystemCapability               `xml:"powerSystemCapability,omitempty"`
	powerSystemInfo           *PowerSystemInfo                     `xml:"powerSystemInfo,omitempty"`
	cacheConfigurationInfo    []*HostCacheConfigurationInfo        `xml:"cacheConfigurationInfo,omitempty"`
	wakeOnLanCapable          bool                                 `xml:"wakeOnLanCapable,omitempty"`
	featureCapability         []*HostFeatureCapability             `xml:"featureCapability,omitempty"`
	maskedFeatureCapability   []*HostFeatureCapability             `xml:"maskedFeatureCapability,omitempty"`
	vFlashConfigInfo          *HostVFlashManagerVFlashConfigInfo   `xml:"vFlashConfigInfo,omitempty"`
	vsanHostConfig            *VsanHostConfigInfo                  `xml:"vsanHostConfig,omitempty"`
	graphicsInfo              []*HostGraphicsInfo                  `xml:"graphicsInfo,omitempty"`
}

type HostConfigManager struct {
	*DynamicData

	cpuScheduler              *ManagedObjectReference `xml:"cpuScheduler,omitempty"`
	datastoreSystem           *ManagedObjectReference `xml:"datastoreSystem,omitempty"`
	memoryManager             *ManagedObjectReference `xml:"memoryManager,omitempty"`
	storageSystem             *ManagedObjectReference `xml:"storageSystem,omitempty"`
	networkSystem             *ManagedObjectReference `xml:"networkSystem,omitempty"`
	vmotionSystem             *ManagedObjectReference `xml:"vmotionSystem,omitempty"`
	virtualNicManager         *ManagedObjectReference `xml:"virtualNicManager,omitempty"`
	serviceSystem             *ManagedObjectReference `xml:"serviceSystem,omitempty"`
	firewallSystem            *ManagedObjectReference `xml:"firewallSystem,omitempty"`
	advancedOption            *ManagedObjectReference `xml:"advancedOption,omitempty"`
	diagnosticSystem          *ManagedObjectReference `xml:"diagnosticSystem,omitempty"`
	autoStartManager          *ManagedObjectReference `xml:"autoStartManager,omitempty"`
	snmpSystem                *ManagedObjectReference `xml:"snmpSystem,omitempty"`
	dateTimeSystem            *ManagedObjectReference `xml:"dateTimeSystem,omitempty"`
	patchManager              *ManagedObjectReference `xml:"patchManager,omitempty"`
	imageConfigManager        *ManagedObjectReference `xml:"imageConfigManager,omitempty"`
	bootDeviceSystem          *ManagedObjectReference `xml:"bootDeviceSystem,omitempty"`
	firmwareSystem            *ManagedObjectReference `xml:"firmwareSystem,omitempty"`
	healthStatusSystem        *ManagedObjectReference `xml:"healthStatusSystem,omitempty"`
	pciPassthruSystem         *ManagedObjectReference `xml:"pciPassthruSystem,omitempty"`
	licenseManager            *ManagedObjectReference `xml:"licenseManager,omitempty"`
	kernelModuleSystem        *ManagedObjectReference `xml:"kernelModuleSystem,omitempty"`
	authenticationManager     *ManagedObjectReference `xml:"authenticationManager,omitempty"`
	powerSystem               *ManagedObjectReference `xml:"powerSystem,omitempty"`
	cacheConfigurationManager *ManagedObjectReference `xml:"cacheConfigurationManager,omitempty"`
	esxAgentHostManager       *ManagedObjectReference `xml:"esxAgentHostManager,omitempty"`
	iscsiManager              *ManagedObjectReference `xml:"iscsiManager,omitempty"`
	vFlashManager             *ManagedObjectReference `xml:"vFlashManager,omitempty"`
	vsanSystem                *ManagedObjectReference `xml:"vsanSystem,omitempty"`
	graphicsManager           *ManagedObjectReference `xml:"graphicsManager,omitempty"`
	vsanInternalSystem        *ManagedObjectReference `xml:"vsanInternalSystem,omitempty"`
}

type HostConfigSpec struct {
	*DynamicData

	nasDatastore             []*HostNasVolumeConfig                   `xml:"nasDatastore,omitempty"`
	network                  *HostNetworkConfig                       `xml:"network,omitempty"`
	nicTypeSelection         []*HostVirtualNicManagerNicTypeSelection `xml:"nicTypeSelection,omitempty"`
	service                  []*HostServiceConfig                     `xml:"service,omitempty"`
	firewall                 *HostFirewallConfig                      `xml:"firewall,omitempty"`
	option                   []*OptionValue                           `xml:"option,omitempty"`
	datastorePrincipal       string                                   `xml:"datastorePrincipal,omitempty"`
	datastorePrincipalPasswd string                                   `xml:"datastorePrincipalPasswd,omitempty"`
	datetime                 *HostDateTimeConfig                      `xml:"datetime,omitempty"`
	storageDevice            *HostStorageDeviceInfo                   `xml:"storageDevice,omitempty"`
	license                  *HostLicenseSpec                         `xml:"license,omitempty"`
	security                 *HostSecuritySpec                        `xml:"security,omitempty"`
	userAccount              []*HostAccountSpec                       `xml:"userAccount,omitempty"`
	usergroupAccount         []*HostAccountSpec                       `xml:"usergroupAccount,omitempty"`
	memory                   *HostMemorySpec                          `xml:"memory,omitempty"`
	activeDirectory          []*HostActiveDirectory                   `xml:"activeDirectory,omitempty"`
	genericConfig            []*KeyAnyValue                           `xml:"genericConfig,omitempty"`
}

type HostConnectInfoNetworkInfo struct {
	*DynamicData

	summary *NetworkSummary `xml:"summary,omitempty"`
}

type ArrayOfHostConnectInfoNetworkInfo struct {
	HostConnectInfoNetworkInfo []*HostConnectInfoNetworkInfo `xml:"HostConnectInfoNetworkInfo,omitempty"`
}

type HostNewNetworkConnectInfo struct {
	*HostConnectInfoNetworkInfo
}

type HostDatastoreConnectInfo struct {
	*DynamicData

	summary *DatastoreSummary `xml:"summary,omitempty"`
}

type ArrayOfHostDatastoreConnectInfo struct {
	HostDatastoreConnectInfo []*HostDatastoreConnectInfo `xml:"HostDatastoreConnectInfo,omitempty"`
}

type HostDatastoreExistsConnectInfo struct {
	*HostDatastoreConnectInfo

	newDatastoreName string `xml:"newDatastoreName,omitempty"`
}

type HostDatastoreNameConflictConnectInfo struct {
	*HostDatastoreConnectInfo

	newDatastoreName string `xml:"newDatastoreName,omitempty"`
}

type HostLicenseConnectInfo struct {
	*DynamicData

	license    *LicenseManagerLicenseInfo    `xml:"license,omitempty"`
	evaluation *LicenseManagerEvaluationInfo `xml:"evaluation,omitempty"`
	resource   *HostLicensableResourceInfo   `xml:"resource,omitempty"`
}

type HostConnectInfo struct {
	*DynamicData

	serverIp               string                        `xml:"serverIp,omitempty"`
	inDasCluster           bool                          `xml:"inDasCluster,omitempty"`
	host                   *HostListSummary              `xml:"host,omitempty"`
	vm                     []*VirtualMachineSummary      `xml:"vm,omitempty"`
	vimAccountNameRequired bool                          `xml:"vimAccountNameRequired,omitempty"`
	clusterSupported       bool                          `xml:"clusterSupported,omitempty"`
	network                []*HostConnectInfoNetworkInfo `xml:"network,omitempty"`
	datastore              []*HostDatastoreConnectInfo   `xml:"datastore,omitempty"`
	license                *HostLicenseConnectInfo       `xml:"license,omitempty"`
}

type HostConnectSpec struct {
	*DynamicData

	hostName           string                  `xml:"hostName,omitempty"`
	port               int32                   `xml:"port,omitempty"`
	sslThumbprint      string                  `xml:"sslThumbprint,omitempty"`
	userName           string                  `xml:"userName,omitempty"`
	password           string                  `xml:"password,omitempty"`
	vmFolder           *ManagedObjectReference `xml:"vmFolder,omitempty"`
	force              bool                    `xml:"force,omitempty"`
	vimAccountName     string                  `xml:"vimAccountName,omitempty"`
	vimAccountPassword string                  `xml:"vimAccountPassword,omitempty"`
	managementIp       string                  `xml:"managementIp,omitempty"`
}

type HostCpuIdInfo struct {
	*DynamicData

	level  int32  `xml:"level,omitempty"`
	vendor string `xml:"vendor,omitempty"`
	eax    string `xml:"eax,omitempty"`
	ebx    string `xml:"ebx,omitempty"`
	ecx    string `xml:"ecx,omitempty"`
	edx    string `xml:"edx,omitempty"`
}

type ArrayOfHostCpuIdInfo struct {
	HostCpuIdInfo []*HostCpuIdInfo `xml:"HostCpuIdInfo,omitempty"`
}

type HostHyperThreadScheduleInfo struct {
	*DynamicData

	available bool `xml:"available,omitempty"`
	active    bool `xml:"active,omitempty"`
	config    bool `xml:"config,omitempty"`
}

type FileQueryFlags struct {
	*DynamicData

	fileType     bool `xml:"fileType,omitempty"`
	fileSize     bool `xml:"fileSize,omitempty"`
	modification bool `xml:"modification,omitempty"`
	fileOwner    bool `xml:"fileOwner,omitempty"`
}

type FileInfo struct {
	*DynamicData

	path         string    `xml:"path,omitempty"`
	fileSize     int64     `xml:"fileSize,omitempty"`
	modification time.Time `xml:"modification,omitempty"`
	owner        string    `xml:"owner,omitempty"`
}

type ArrayOfFileInfo struct {
	FileInfo []*FileInfo `xml:"FileInfo,omitempty"`
}

type FileQuery struct {
	*DynamicData
}

type ArrayOfFileQuery struct {
	FileQuery []*FileQuery `xml:"FileQuery,omitempty"`
}

type VmConfigFileQueryFilter struct {
	*DynamicData

	matchConfigVersion []int32 `xml:"matchConfigVersion,omitempty"`
}

type VmConfigFileQueryFlags struct {
	*DynamicData

	configVersion bool `xml:"configVersion,omitempty"`
}

type VmConfigFileQuery struct {
	*FileQuery

	filter  *VmConfigFileQueryFilter `xml:"filter,omitempty"`
	details *VmConfigFileQueryFlags  `xml:"details,omitempty"`
}

type TemplateConfigFileQuery struct {
	*VmConfigFileQuery
}

type VmDiskFileQueryFilter struct {
	*DynamicData

	diskType             []string `xml:"diskType,omitempty"`
	matchHardwareVersion []int32  `xml:"matchHardwareVersion,omitempty"`
	controllerType       []string `xml:"controllerType,omitempty"`
	thin                 bool     `xml:"thin,omitempty"`
}

type VmDiskFileQueryFlags struct {
	*DynamicData

	diskType        bool `xml:"diskType,omitempty"`
	capacityKb      bool `xml:"capacityKb,omitempty"`
	hardwareVersion bool `xml:"hardwareVersion,omitempty"`
	controllerType  bool `xml:"controllerType,omitempty"`
	diskExtents     bool `xml:"diskExtents,omitempty"`
	thin            bool `xml:"thin,omitempty"`
}

type VmDiskFileQuery struct {
	*FileQuery

	filter  *VmDiskFileQueryFilter `xml:"filter,omitempty"`
	details *VmDiskFileQueryFlags  `xml:"details,omitempty"`
}

type FolderFileQuery struct {
	*FileQuery
}

type VmSnapshotFileQuery struct {
	*FileQuery
}

type IsoImageFileQuery struct {
	*FileQuery
}

type FloppyImageFileQuery struct {
	*FileQuery
}

type VmNvramFileQuery struct {
	*FileQuery
}

type VmLogFileQuery struct {
	*FileQuery
}

type VmConfigFileInfo struct {
	*FileInfo

	configVersion int32 `xml:"configVersion,omitempty"`
}

type TemplateConfigFileInfo struct {
	*VmConfigFileInfo
}

type VmDiskFileInfo struct {
	*FileInfo

	diskType        string   `xml:"diskType,omitempty"`
	capacityKb      int64    `xml:"capacityKb,omitempty"`
	hardwareVersion int32    `xml:"hardwareVersion,omitempty"`
	controllerType  string   `xml:"controllerType,omitempty"`
	diskExtents     []string `xml:"diskExtents,omitempty"`
	thin            bool     `xml:"thin,omitempty"`
}

type FolderFileInfo struct {
	*FileInfo
}

type VmSnapshotFileInfo struct {
	*FileInfo
}

type IsoImageFileInfo struct {
	*FileInfo
}

type FloppyImageFileInfo struct {
	*FileInfo
}

type VmNvramFileInfo struct {
	*FileInfo
}

type VmLogFileInfo struct {
	*FileInfo
}

type HostDatastoreBrowserSearchSpec struct {
	*DynamicData

	query                 []*FileQuery    `xml:"query,omitempty"`
	details               *FileQueryFlags `xml:"details,omitempty"`
	searchCaseInsensitive bool            `xml:"searchCaseInsensitive,omitempty"`
	matchPattern          []string        `xml:"matchPattern,omitempty"`
	sortFoldersFirst      bool            `xml:"sortFoldersFirst,omitempty"`
}

type HostDatastoreBrowserSearchResults struct {
	*DynamicData

	datastore  *ManagedObjectReference `xml:"datastore,omitempty"`
	folderPath string                  `xml:"folderPath,omitempty"`
	file       []*FileInfo             `xml:"file,omitempty"`
}

type ArrayOfHostDatastoreBrowserSearchResults struct {
	HostDatastoreBrowserSearchResults []*HostDatastoreBrowserSearchResults `xml:"HostDatastoreBrowserSearchResults,omitempty"`
}

type HostDatastoreSystemCapabilities struct {
	*DynamicData

	nfsMountCreationRequired     bool `xml:"nfsMountCreationRequired,omitempty"`
	nfsMountCreationSupported    bool `xml:"nfsMountCreationSupported,omitempty"`
	localDatastoreSupported      bool `xml:"localDatastoreSupported,omitempty"`
	vmfsExtentExpansionSupported bool `xml:"vmfsExtentExpansionSupported,omitempty"`
}

type VmfsDatastoreInfo struct {
	*DatastoreInfo

	maxPhysicalRDMFileSize int64           `xml:"maxPhysicalRDMFileSize,omitempty"`
	maxVirtualRDMFileSize  int64           `xml:"maxVirtualRDMFileSize,omitempty"`
	vmfs                   *HostVmfsVolume `xml:"vmfs,omitempty"`
}

type NasDatastoreInfo struct {
	*DatastoreInfo

	nas *HostNasVolume `xml:"nas,omitempty"`
}

type LocalDatastoreInfo struct {
	*DatastoreInfo

	path string `xml:"path,omitempty"`
}

type VmfsDatastoreSpec struct {
	*DynamicData

	diskUuid string `xml:"diskUuid,omitempty"`
}

type VmfsDatastoreCreateSpec struct {
	*VmfsDatastoreSpec

	partition *HostDiskPartitionSpec   `xml:"partition,omitempty"`
	vmfs      *HostVmfsSpec            `xml:"vmfs,omitempty"`
	extent    []*HostScsiDiskPartition `xml:"extent,omitempty"`
}

type VmfsDatastoreExtendSpec struct {
	*VmfsDatastoreSpec

	partition *HostDiskPartitionSpec   `xml:"partition,omitempty"`
	extent    []*HostScsiDiskPartition `xml:"extent,omitempty"`
}

type VmfsDatastoreExpandSpec struct {
	*VmfsDatastoreSpec

	partition *HostDiskPartitionSpec `xml:"partition,omitempty"`
	extent    *HostScsiDiskPartition `xml:"extent,omitempty"`
}

type VmfsDatastoreBaseOption struct {
	*DynamicData

	layout                *HostDiskPartitionLayout `xml:"layout,omitempty"`
	partitionFormatChange bool                     `xml:"partitionFormatChange,omitempty"`
}

type VmfsDatastoreSingleExtentOption struct {
	*VmfsDatastoreBaseOption

	vmfsExtent *HostDiskPartitionBlockRange `xml:"vmfsExtent,omitempty"`
}

type VmfsDatastoreAllExtentOption struct {
	*VmfsDatastoreSingleExtentOption
}

type VmfsDatastoreMultipleExtentOption struct {
	*VmfsDatastoreBaseOption

	vmfsExtent []*HostDiskPartitionBlockRange `xml:"vmfsExtent,omitempty"`
}

type VmfsDatastoreOption struct {
	*DynamicData

	info *VmfsDatastoreBaseOption `xml:"info,omitempty"`
	spec *VmfsDatastoreSpec       `xml:"spec,omitempty"`
}

type ArrayOfVmfsDatastoreOption struct {
	VmfsDatastoreOption []*VmfsDatastoreOption `xml:"VmfsDatastoreOption,omitempty"`
}

type HostDateTimeConfig struct {
	*DynamicData

	timeZone  string         `xml:"timeZone,omitempty"`
	ntpConfig *HostNtpConfig `xml:"ntpConfig,omitempty"`
}

type HostDateTimeInfo struct {
	*DynamicData

	timeZone  *HostDateTimeSystemTimeZone `xml:"timeZone,omitempty"`
	ntpConfig *HostNtpConfig              `xml:"ntpConfig,omitempty"`
}

type HostDateTimeSystemTimeZone struct {
	*DynamicData

	key         string `xml:"key,omitempty"`
	name        string `xml:"name,omitempty"`
	description string `xml:"description,omitempty"`
	gmtOffset   int32  `xml:"gmtOffset,omitempty"`
}

type ArrayOfHostDateTimeSystemTimeZone struct {
	HostDateTimeSystemTimeZone []*HostDateTimeSystemTimeZone `xml:"HostDateTimeSystemTimeZone,omitempty"`
}

type HostDevice struct {
	*DynamicData

	deviceName string `xml:"deviceName,omitempty"`
	deviceType string `xml:"deviceType,omitempty"`
}

type HostDhcpServiceSpec struct {
	*DynamicData

	virtualSwitch        string `xml:"virtualSwitch,omitempty"`
	defaultLeaseDuration int32  `xml:"defaultLeaseDuration,omitempty"`
	leaseBeginIp         string `xml:"leaseBeginIp,omitempty"`
	leaseEndIp           string `xml:"leaseEndIp,omitempty"`
	maxLeaseDuration     int32  `xml:"maxLeaseDuration,omitempty"`
	unlimitedLease       bool   `xml:"unlimitedLease,omitempty"`
	ipSubnetAddr         string `xml:"ipSubnetAddr,omitempty"`
	ipSubnetMask         string `xml:"ipSubnetMask,omitempty"`
}

type HostDhcpServiceConfig struct {
	*DynamicData

	changeOperation string               `xml:"changeOperation,omitempty"`
	key             string               `xml:"key,omitempty"`
	spec            *HostDhcpServiceSpec `xml:"spec,omitempty"`
}

type ArrayOfHostDhcpServiceConfig struct {
	HostDhcpServiceConfig []*HostDhcpServiceConfig `xml:"HostDhcpServiceConfig,omitempty"`
}

type HostDhcpService struct {
	*DynamicData

	key  string               `xml:"key,omitempty"`
	spec *HostDhcpServiceSpec `xml:"spec,omitempty"`
}

type ArrayOfHostDhcpService struct {
	HostDhcpService []*HostDhcpService `xml:"HostDhcpService,omitempty"`
}

type HostDiagnosticPartitionCreateOption struct {
	*DynamicData

	storageType    string        `xml:"storageType,omitempty"`
	diagnosticType string        `xml:"diagnosticType,omitempty"`
	disk           *HostScsiDisk `xml:"disk,omitempty"`
}

type ArrayOfHostDiagnosticPartitionCreateOption struct {
	HostDiagnosticPartitionCreateOption []*HostDiagnosticPartitionCreateOption `xml:"HostDiagnosticPartitionCreateOption,omitempty"`
}

type HostDiagnosticPartitionCreateSpec struct {
	*DynamicData

	storageType    string                 `xml:"storageType,omitempty"`
	diagnosticType string                 `xml:"diagnosticType,omitempty"`
	id             *HostScsiDiskPartition `xml:"id,omitempty"`
	partition      *HostDiskPartitionSpec `xml:"partition,omitempty"`
	active         bool                   `xml:"active,omitempty"`
}

type HostDiagnosticPartitionCreateDescription struct {
	*DynamicData

	layout   *HostDiskPartitionLayout           `xml:"layout,omitempty"`
	diskUuid string                             `xml:"diskUuid,omitempty"`
	spec     *HostDiagnosticPartitionCreateSpec `xml:"spec,omitempty"`
}

type HostDiagnosticPartition struct {
	*DynamicData

	storageType    string                 `xml:"storageType,omitempty"`
	diagnosticType string                 `xml:"diagnosticType,omitempty"`
	slots          int32                  `xml:"slots,omitempty"`
	id             *HostScsiDiskPartition `xml:"id,omitempty"`
}

type ArrayOfHostDiagnosticPartition struct {
	HostDiagnosticPartition []*HostDiagnosticPartition `xml:"HostDiagnosticPartition,omitempty"`
}

type HostDirectoryStoreInfo struct {
	*HostAuthenticationStoreInfo
}

type HostDiskConfigurationResult struct {
	*DynamicData

	devicePath string                `xml:"devicePath,omitempty"`
	success    bool                  `xml:"success,omitempty"`
	fault      *LocalizedMethodFault `xml:"fault,omitempty"`
}

type ArrayOfHostDiskConfigurationResult struct {
	HostDiskConfigurationResult []*HostDiskConfigurationResult `xml:"HostDiskConfigurationResult,omitempty"`
}

type HostDiskDimensionsChs struct {
	*DynamicData

	cylinder int64 `xml:"cylinder,omitempty"`
	head     int32 `xml:"head,omitempty"`
	sector   int32 `xml:"sector,omitempty"`
}

type HostDiskDimensionsLba struct {
	*DynamicData

	blockSize int32 `xml:"blockSize,omitempty"`
	block     int64 `xml:"block,omitempty"`
}

type HostDiskDimensions struct {
	*DynamicData
}

type HostDiskPartitionAttributes struct {
	*DynamicData

	partition          int32  `xml:"partition,omitempty"`
	startSector        int64  `xml:"startSector,omitempty"`
	endSector          int64  `xml:"endSector,omitempty"`
	type_              string `xml:"type,omitempty"`
	guid               string `xml:"guid,omitempty"`
	logical            bool   `xml:"logical,omitempty"`
	attributes         int8   `xml:"attributes,omitempty"`
	partitionAlignment int64  `xml:"partitionAlignment,omitempty"`
}

type ArrayOfHostDiskPartitionAttributes struct {
	HostDiskPartitionAttributes []*HostDiskPartitionAttributes `xml:"HostDiskPartitionAttributes,omitempty"`
}

type HostDiskPartitionBlockRange struct {
	*DynamicData

	partition int32                  `xml:"partition,omitempty"`
	type_     string                 `xml:"type,omitempty"`
	start     *HostDiskDimensionsLba `xml:"start,omitempty"`
	end       *HostDiskDimensionsLba `xml:"end,omitempty"`
}

type ArrayOfHostDiskPartitionBlockRange struct {
	HostDiskPartitionBlockRange []*HostDiskPartitionBlockRange `xml:"HostDiskPartitionBlockRange,omitempty"`
}

type HostDiskPartitionSpec struct {
	*DynamicData

	partitionFormat string                         `xml:"partitionFormat,omitempty"`
	chs             *HostDiskDimensionsChs         `xml:"chs,omitempty"`
	totalSectors    int64                          `xml:"totalSectors,omitempty"`
	partition       []*HostDiskPartitionAttributes `xml:"partition,omitempty"`
}

type HostDiskPartitionLayout struct {
	*DynamicData

	total     *HostDiskDimensionsLba         `xml:"total,omitempty"`
	partition []*HostDiskPartitionBlockRange `xml:"partition,omitempty"`
}

type HostDiskPartitionInfo struct {
	*DynamicData

	deviceName string                   `xml:"deviceName,omitempty"`
	spec       *HostDiskPartitionSpec   `xml:"spec,omitempty"`
	layout     *HostDiskPartitionLayout `xml:"layout,omitempty"`
}

type ArrayOfHostDiskPartitionInfo struct {
	HostDiskPartitionInfo []*HostDiskPartitionInfo `xml:"HostDiskPartitionInfo,omitempty"`
}

type HostDnsConfig struct {
	*DynamicData

	dhcp             bool     `xml:"dhcp,omitempty"`
	virtualNicDevice string   `xml:"virtualNicDevice,omitempty"`
	hostName         string   `xml:"hostName,omitempty"`
	domainName       string   `xml:"domainName,omitempty"`
	address          []string `xml:"address,omitempty"`
	searchDomain     []string `xml:"searchDomain,omitempty"`
}

type HostDnsConfigSpec struct {
	*HostDnsConfig

	virtualNicConnection *HostVirtualNicConnection `xml:"virtualNicConnection,omitempty"`
}

type HostEsxAgentHostManagerConfigInfo struct {
	*DynamicData

	agentVmDatastore *ManagedObjectReference `xml:"agentVmDatastore,omitempty"`
	agentVmNetwork   *ManagedObjectReference `xml:"agentVmNetwork,omitempty"`
}

type FcoeConfigVlanRange struct {
	*DynamicData

	vlanLow  int32 `xml:"vlanLow,omitempty"`
	vlanHigh int32 `xml:"vlanHigh,omitempty"`
}

type ArrayOfFcoeConfigVlanRange struct {
	FcoeConfigVlanRange []*FcoeConfigVlanRange `xml:"FcoeConfigVlanRange,omitempty"`
}

type FcoeConfigFcoeCapabilities struct {
	*DynamicData

	priorityClass    bool `xml:"priorityClass,omitempty"`
	sourceMacAddress bool `xml:"sourceMacAddress,omitempty"`
	vlanRange        bool `xml:"vlanRange,omitempty"`
}

type FcoeConfigFcoeSpecification struct {
	*DynamicData

	underlyingPnic string                 `xml:"underlyingPnic,omitempty"`
	priorityClass  int32                  `xml:"priorityClass,omitempty"`
	sourceMac      string                 `xml:"sourceMac,omitempty"`
	vlanRange      []*FcoeConfigVlanRange `xml:"vlanRange,omitempty"`
}

type FcoeConfig struct {
	*DynamicData

	priorityClass int32                       `xml:"priorityClass,omitempty"`
	sourceMac     string                      `xml:"sourceMac,omitempty"`
	vlanRange     []*FcoeConfigVlanRange      `xml:"vlanRange,omitempty"`
	capabilities  *FcoeConfigFcoeCapabilities `xml:"capabilities,omitempty"`
	fcoeActive    bool                        `xml:"fcoeActive,omitempty"`
}

type HostFeatureCapability struct {
	*DynamicData

	key         string `xml:"key,omitempty"`
	featureName string `xml:"featureName,omitempty"`
	value       string `xml:"value,omitempty"`
}

type ArrayOfHostFeatureCapability struct {
	HostFeatureCapability []*HostFeatureCapability `xml:"HostFeatureCapability,omitempty"`
}

type HostFeatureMask struct {
	*DynamicData

	key         string `xml:"key,omitempty"`
	featureName string `xml:"featureName,omitempty"`
	value       string `xml:"value,omitempty"`
}

type ArrayOfHostFeatureMask struct {
	HostFeatureMask []*HostFeatureMask `xml:"HostFeatureMask,omitempty"`
}

type HostFeatureVersionInfo struct {
	*DynamicData

	key   string `xml:"key,omitempty"`
	value string `xml:"value,omitempty"`
}

type ArrayOfHostFeatureVersionInfo struct {
	HostFeatureVersionInfo []*HostFeatureVersionInfo `xml:"HostFeatureVersionInfo,omitempty"`
}

type ModeInfo struct {
	*DynamicData

	browse string `xml:"browse,omitempty"`
	read   string `xml:"read,omitempty"`
	modify string `xml:"modify,omitempty"`
	use    string `xml:"use,omitempty"`
	admin  string `xml:"admin,omitempty"`
	full   string `xml:"full,omitempty"`
}

type HostFileAccess struct {
	*DynamicData

	who  string `xml:"who,omitempty"`
	what string `xml:"what,omitempty"`
}

type HostFileSystemVolumeInfo struct {
	*DynamicData

	volumeTypeList []string                   `xml:"volumeTypeList,omitempty"`
	mountInfo      []*HostFileSystemMountInfo `xml:"mountInfo,omitempty"`
}

type HostFileSystemMountInfo struct {
	*DynamicData

	mountInfo       *HostMountInfo        `xml:"mountInfo,omitempty"`
	volume          *HostFileSystemVolume `xml:"volume,omitempty"`
	vStorageSupport string                `xml:"vStorageSupport,omitempty"`
}

type ArrayOfHostFileSystemMountInfo struct {
	HostFileSystemMountInfo []*HostFileSystemMountInfo `xml:"HostFileSystemMountInfo,omitempty"`
}

type HostFileSystemVolume struct {
	*DynamicData

	type_    string `xml:"type,omitempty"`
	name     string `xml:"name,omitempty"`
	capacity int64  `xml:"capacity,omitempty"`
}

type HostNasVolumeSpec struct {
	*DynamicData

	remoteHost string `xml:"remoteHost,omitempty"`
	remotePath string `xml:"remotePath,omitempty"`
	localPath  string `xml:"localPath,omitempty"`
	accessMode string `xml:"accessMode,omitempty"`
	type_      string `xml:"type,omitempty"`
	userName   string `xml:"userName,omitempty"`
	password   string `xml:"password,omitempty"`
}

type HostNasVolumeConfig struct {
	*DynamicData

	changeOperation string             `xml:"changeOperation,omitempty"`
	spec            *HostNasVolumeSpec `xml:"spec,omitempty"`
}

type ArrayOfHostNasVolumeConfig struct {
	HostNasVolumeConfig []*HostNasVolumeConfig `xml:"HostNasVolumeConfig,omitempty"`
}

type HostNasVolume struct {
	*HostFileSystemVolume

	remoteHost string `xml:"remoteHost,omitempty"`
	remotePath string `xml:"remotePath,omitempty"`
	userName   string `xml:"userName,omitempty"`
}

type HostLocalFileSystemVolumeSpec struct {
	*DynamicData

	device    string `xml:"device,omitempty"`
	localPath string `xml:"localPath,omitempty"`
}

type HostLocalFileSystemVolume struct {
	*HostFileSystemVolume

	device string `xml:"device,omitempty"`
}

type HostVfatVolume struct {
	*HostFileSystemVolume
}

type HostFirewallConfigRuleSetConfig struct {
	*DynamicData

	rulesetId    string                     `xml:"rulesetId,omitempty"`
	enabled      bool                       `xml:"enabled,omitempty"`
	allowedHosts *HostFirewallRulesetIpList `xml:"allowedHosts,omitempty"`
}

type ArrayOfHostFirewallConfigRuleSetConfig struct {
	HostFirewallConfigRuleSetConfig []*HostFirewallConfigRuleSetConfig `xml:"HostFirewallConfigRuleSetConfig,omitempty"`
}

type HostFirewallConfig struct {
	*DynamicData

	rule                  []*HostFirewallConfigRuleSetConfig `xml:"rule,omitempty"`
	defaultBlockingPolicy *HostFirewallDefaultPolicy         `xml:"defaultBlockingPolicy,omitempty"`
}

type HostFirewallDefaultPolicy struct {
	*DynamicData

	incomingBlocked bool `xml:"incomingBlocked,omitempty"`
	outgoingBlocked bool `xml:"outgoingBlocked,omitempty"`
}

type HostFirewallInfo struct {
	*DynamicData

	defaultPolicy *HostFirewallDefaultPolicy `xml:"defaultPolicy,omitempty"`
	ruleset       []*HostFirewallRuleset     `xml:"ruleset,omitempty"`
}

type HostFlagInfo struct {
	*DynamicData

	backgroundSnapshotsEnabled bool `xml:"backgroundSnapshotsEnabled,omitempty"`
}

type HostForceMountedInfo struct {
	*DynamicData

	persist bool `xml:"persist,omitempty"`
	mounted bool `xml:"mounted,omitempty"`
}

type HostGraphicsInfo struct {
	*DynamicData

	deviceName     string                    `xml:"deviceName,omitempty"`
	vendorName     string                    `xml:"vendorName,omitempty"`
	pciId          string                    `xml:"pciId,omitempty"`
	graphicsType   string                    `xml:"graphicsType,omitempty"`
	memorySizeInKB int64                     `xml:"memorySizeInKB,omitempty"`
	vm             []*ManagedObjectReference `xml:"vm,omitempty"`
}

type ArrayOfHostGraphicsInfo struct {
	HostGraphicsInfo []*HostGraphicsInfo `xml:"HostGraphicsInfo,omitempty"`
}

type HostHardwareInfo struct {
	*DynamicData

	systemInfo             *HostSystemInfo             `xml:"systemInfo,omitempty"`
	cpuPowerManagementInfo *HostCpuPowerManagementInfo `xml:"cpuPowerManagementInfo,omitempty"`
	cpuInfo                *HostCpuInfo                `xml:"cpuInfo,omitempty"`
	cpuPkg                 []*HostCpuPackage           `xml:"cpuPkg,omitempty"`
	memorySize             int64                       `xml:"memorySize,omitempty"`
	numaInfo               *HostNumaInfo               `xml:"numaInfo,omitempty"`
	smcPresent             bool                        `xml:"smcPresent,omitempty"`
	pciDevice              []*HostPciDevice            `xml:"pciDevice,omitempty"`
	cpuFeature             []*HostCpuIdInfo            `xml:"cpuFeature,omitempty"`
	biosInfo               *HostBIOSInfo               `xml:"biosInfo,omitempty"`
	reliableMemoryInfo     *HostReliableMemoryInfo     `xml:"reliableMemoryInfo,omitempty"`
}

type HostSystemInfo struct {
	*DynamicData

	vendor               string                          `xml:"vendor,omitempty"`
	model                string                          `xml:"model,omitempty"`
	uuid                 string                          `xml:"uuid,omitempty"`
	otherIdentifyingInfo []*HostSystemIdentificationInfo `xml:"otherIdentifyingInfo,omitempty"`
}

type HostCpuPowerManagementInfo struct {
	*DynamicData

	currentPolicy   string `xml:"currentPolicy,omitempty"`
	hardwareSupport string `xml:"hardwareSupport,omitempty"`
}

type HostCpuInfo struct {
	*DynamicData

	numCpuPackages int16 `xml:"numCpuPackages,omitempty"`
	numCpuCores    int16 `xml:"numCpuCores,omitempty"`
	numCpuThreads  int16 `xml:"numCpuThreads,omitempty"`
	hz             int64 `xml:"hz,omitempty"`
}

type HostCpuPackage struct {
	*DynamicData

	index       int16            `xml:"index,omitempty"`
	vendor      string           `xml:"vendor,omitempty"`
	hz          int64            `xml:"hz,omitempty"`
	busHz       int64            `xml:"busHz,omitempty"`
	description string           `xml:"description,omitempty"`
	threadId    []int16          `xml:"threadId,omitempty"`
	cpuFeature  []*HostCpuIdInfo `xml:"cpuFeature,omitempty"`
}

type ArrayOfHostCpuPackage struct {
	HostCpuPackage []*HostCpuPackage `xml:"HostCpuPackage,omitempty"`
}

type HostNumaInfo struct {
	*DynamicData

	type_    string          `xml:"type,omitempty"`
	numNodes int32           `xml:"numNodes,omitempty"`
	numaNode []*HostNumaNode `xml:"numaNode,omitempty"`
}

type HostNumaNode struct {
	*DynamicData

	typeId            int8    `xml:"typeId,omitempty"`
	cpuID             []int16 `xml:"cpuID,omitempty"`
	memoryRangeBegin  int64   `xml:"memoryRangeBegin,omitempty"`
	memoryRangeLength int64   `xml:"memoryRangeLength,omitempty"`
}

type ArrayOfHostNumaNode struct {
	HostNumaNode []*HostNumaNode `xml:"HostNumaNode,omitempty"`
}

type HostBIOSInfo struct {
	*DynamicData

	biosVersion string    `xml:"biosVersion,omitempty"`
	releaseDate time.Time `xml:"releaseDate,omitempty"`
}

type HostReliableMemoryInfo struct {
	*DynamicData

	memorySize int64 `xml:"memorySize,omitempty"`
}

type HostHardwareElementInfo struct {
	*DynamicData

	name   string              `xml:"name,omitempty"`
	status *ElementDescription `xml:"status,omitempty"`
}

type ArrayOfHostHardwareElementInfo struct {
	HostHardwareElementInfo []*HostHardwareElementInfo `xml:"HostHardwareElementInfo,omitempty"`
}

type HostStorageOperationalInfo struct {
	*DynamicData

	property string `xml:"property,omitempty"`
	value    string `xml:"value,omitempty"`
}

type ArrayOfHostStorageOperationalInfo struct {
	HostStorageOperationalInfo []*HostStorageOperationalInfo `xml:"HostStorageOperationalInfo,omitempty"`
}

type HostStorageElementInfo struct {
	*HostHardwareElementInfo

	operationalInfo []*HostStorageOperationalInfo `xml:"operationalInfo,omitempty"`
}

type ArrayOfHostStorageElementInfo struct {
	HostStorageElementInfo []*HostStorageElementInfo `xml:"HostStorageElementInfo,omitempty"`
}

type HostHardwareStatusInfo struct {
	*DynamicData

	memoryStatusInfo  []*HostHardwareElementInfo `xml:"memoryStatusInfo,omitempty"`
	cpuStatusInfo     []*HostHardwareElementInfo `xml:"cpuStatusInfo,omitempty"`
	storageStatusInfo []*HostStorageElementInfo  `xml:"storageStatusInfo,omitempty"`
}

type HealthSystemRuntime struct {
	*DynamicData

	systemHealthInfo   *HostSystemHealthInfo   `xml:"systemHealthInfo,omitempty"`
	hardwareStatusInfo *HostHardwareStatusInfo `xml:"hardwareStatusInfo,omitempty"`
}

type HostHostBusAdapter struct {
	*DynamicData

	key    string `xml:"key,omitempty"`
	device string `xml:"device,omitempty"`
	bus    int32  `xml:"bus,omitempty"`
	status string `xml:"status,omitempty"`
	model  string `xml:"model,omitempty"`
	driver string `xml:"driver,omitempty"`
	pci    string `xml:"pci,omitempty"`
}

type ArrayOfHostHostBusAdapter struct {
	HostHostBusAdapter []*HostHostBusAdapter `xml:"HostHostBusAdapter,omitempty"`
}

type HostParallelScsiHba struct {
	*HostHostBusAdapter
}

type HostBlockHba struct {
	*HostHostBusAdapter
}

type HostFibreChannelHba struct {
	*HostHostBusAdapter

	portWorldWideName int64                 `xml:"portWorldWideName,omitempty"`
	nodeWorldWideName int64                 `xml:"nodeWorldWideName,omitempty"`
	portType          *FibreChannelPortType `xml:"portType,omitempty"`
	speed             int64                 `xml:"speed,omitempty"`
}

type HostInternetScsiHbaParamValue struct {
	*OptionValue

	isInherited bool `xml:"isInherited,omitempty"`
}

type ArrayOfHostInternetScsiHbaParamValue struct {
	HostInternetScsiHbaParamValue []*HostInternetScsiHbaParamValue `xml:"HostInternetScsiHbaParamValue,omitempty"`
}

type HostInternetScsiHbaDiscoveryCapabilities struct {
	*DynamicData

	iSnsDiscoverySettable         bool `xml:"iSnsDiscoverySettable,omitempty"`
	slpDiscoverySettable          bool `xml:"slpDiscoverySettable,omitempty"`
	staticTargetDiscoverySettable bool `xml:"staticTargetDiscoverySettable,omitempty"`
	sendTargetsDiscoverySettable  bool `xml:"sendTargetsDiscoverySettable,omitempty"`
}

type HostInternetScsiHbaDiscoveryProperties struct {
	*DynamicData

	iSnsDiscoveryEnabled         bool   `xml:"iSnsDiscoveryEnabled,omitempty"`
	iSnsDiscoveryMethod          string `xml:"iSnsDiscoveryMethod,omitempty"`
	iSnsHost                     string `xml:"iSnsHost,omitempty"`
	slpDiscoveryEnabled          bool   `xml:"slpDiscoveryEnabled,omitempty"`
	slpDiscoveryMethod           string `xml:"slpDiscoveryMethod,omitempty"`
	slpHost                      string `xml:"slpHost,omitempty"`
	staticTargetDiscoveryEnabled bool   `xml:"staticTargetDiscoveryEnabled,omitempty"`
	sendTargetsDiscoveryEnabled  bool   `xml:"sendTargetsDiscoveryEnabled,omitempty"`
}

type HostInternetScsiHbaAuthenticationCapabilities struct {
	*DynamicData

	chapAuthSettable         bool `xml:"chapAuthSettable,omitempty"`
	krb5AuthSettable         bool `xml:"krb5AuthSettable,omitempty"`
	srpAuthSettable          bool `xml:"srpAuthSettable,omitempty"`
	spkmAuthSettable         bool `xml:"spkmAuthSettable,omitempty"`
	mutualChapSettable       bool `xml:"mutualChapSettable,omitempty"`
	targetChapSettable       bool `xml:"targetChapSettable,omitempty"`
	targetMutualChapSettable bool `xml:"targetMutualChapSettable,omitempty"`
}

type HostInternetScsiHbaAuthenticationProperties struct {
	*DynamicData

	chapAuthEnabled              bool   `xml:"chapAuthEnabled,omitempty"`
	chapName                     string `xml:"chapName,omitempty"`
	chapSecret                   string `xml:"chapSecret,omitempty"`
	chapAuthenticationType       string `xml:"chapAuthenticationType,omitempty"`
	chapInherited                bool   `xml:"chapInherited,omitempty"`
	mutualChapName               string `xml:"mutualChapName,omitempty"`
	mutualChapSecret             string `xml:"mutualChapSecret,omitempty"`
	mutualChapAuthenticationType string `xml:"mutualChapAuthenticationType,omitempty"`
	mutualChapInherited          bool   `xml:"mutualChapInherited,omitempty"`
}

type HostInternetScsiHbaDigestCapabilities struct {
	*DynamicData

	headerDigestSettable       bool `xml:"headerDigestSettable,omitempty"`
	dataDigestSettable         bool `xml:"dataDigestSettable,omitempty"`
	targetHeaderDigestSettable bool `xml:"targetHeaderDigestSettable,omitempty"`
	targetDataDigestSettable   bool `xml:"targetDataDigestSettable,omitempty"`
}

type HostInternetScsiHbaDigestProperties struct {
	*DynamicData

	headerDigestType      string `xml:"headerDigestType,omitempty"`
	headerDigestInherited bool   `xml:"headerDigestInherited,omitempty"`
	dataDigestType        string `xml:"dataDigestType,omitempty"`
	dataDigestInherited   bool   `xml:"dataDigestInherited,omitempty"`
}

type HostInternetScsiHbaIPCapabilities struct {
	*DynamicData

	addressSettable                   bool `xml:"addressSettable,omitempty"`
	ipConfigurationMethodSettable     bool `xml:"ipConfigurationMethodSettable,omitempty"`
	subnetMaskSettable                bool `xml:"subnetMaskSettable,omitempty"`
	defaultGatewaySettable            bool `xml:"defaultGatewaySettable,omitempty"`
	primaryDnsServerAddressSettable   bool `xml:"primaryDnsServerAddressSettable,omitempty"`
	alternateDnsServerAddressSettable bool `xml:"alternateDnsServerAddressSettable,omitempty"`
	ipv6Supported                     bool `xml:"ipv6Supported,omitempty"`
	arpRedirectSettable               bool `xml:"arpRedirectSettable,omitempty"`
	mtuSettable                       bool `xml:"mtuSettable,omitempty"`
	hostNameAsTargetAddress           bool `xml:"hostNameAsTargetAddress,omitempty"`
	nameAliasSettable                 bool `xml:"nameAliasSettable,omitempty"`
}

type HostInternetScsiHbaIPProperties struct {
	*DynamicData

	mac                       string `xml:"mac,omitempty"`
	address                   string `xml:"address,omitempty"`
	dhcpConfigurationEnabled  bool   `xml:"dhcpConfigurationEnabled,omitempty"`
	subnetMask                string `xml:"subnetMask,omitempty"`
	defaultGateway            string `xml:"defaultGateway,omitempty"`
	primaryDnsServerAddress   string `xml:"primaryDnsServerAddress,omitempty"`
	alternateDnsServerAddress string `xml:"alternateDnsServerAddress,omitempty"`
	ipv6Address               string `xml:"ipv6Address,omitempty"`
	ipv6SubnetMask            string `xml:"ipv6SubnetMask,omitempty"`
	ipv6DefaultGateway        string `xml:"ipv6DefaultGateway,omitempty"`
	arpRedirectEnabled        bool   `xml:"arpRedirectEnabled,omitempty"`
	mtu                       int32  `xml:"mtu,omitempty"`
	jumboFramesEnabled        bool   `xml:"jumboFramesEnabled,omitempty"`
}

type HostInternetScsiHbaSendTarget struct {
	*DynamicData

	address                  string                                       `xml:"address,omitempty"`
	port                     int32                                        `xml:"port,omitempty"`
	authenticationProperties *HostInternetScsiHbaAuthenticationProperties `xml:"authenticationProperties,omitempty"`
	digestProperties         *HostInternetScsiHbaDigestProperties         `xml:"digestProperties,omitempty"`
	supportedAdvancedOptions []*OptionDef                                 `xml:"supportedAdvancedOptions,omitempty"`
	advancedOptions          []*HostInternetScsiHbaParamValue             `xml:"advancedOptions,omitempty"`
	parent                   string                                       `xml:"parent,omitempty"`
}

type ArrayOfHostInternetScsiHbaSendTarget struct {
	HostInternetScsiHbaSendTarget []*HostInternetScsiHbaSendTarget `xml:"HostInternetScsiHbaSendTarget,omitempty"`
}

type HostInternetScsiHbaStaticTarget struct {
	*DynamicData

	address                  string                                       `xml:"address,omitempty"`
	port                     int32                                        `xml:"port,omitempty"`
	iScsiName                string                                       `xml:"iScsiName,omitempty"`
	discoveryMethod          string                                       `xml:"discoveryMethod,omitempty"`
	authenticationProperties *HostInternetScsiHbaAuthenticationProperties `xml:"authenticationProperties,omitempty"`
	digestProperties         *HostInternetScsiHbaDigestProperties         `xml:"digestProperties,omitempty"`
	supportedAdvancedOptions []*OptionDef                                 `xml:"supportedAdvancedOptions,omitempty"`
	advancedOptions          []*HostInternetScsiHbaParamValue             `xml:"advancedOptions,omitempty"`
	parent                   string                                       `xml:"parent,omitempty"`
}

type ArrayOfHostInternetScsiHbaStaticTarget struct {
	HostInternetScsiHbaStaticTarget []*HostInternetScsiHbaStaticTarget `xml:"HostInternetScsiHbaStaticTarget,omitempty"`
}

type HostInternetScsiHbaTargetSet struct {
	*DynamicData

	staticTargets []*HostInternetScsiHbaStaticTarget `xml:"staticTargets,omitempty"`
	sendTargets   []*HostInternetScsiHbaSendTarget   `xml:"sendTargets,omitempty"`
}

type HostInternetScsiHba struct {
	*HostHostBusAdapter

	isSoftwareBased            bool                                           `xml:"isSoftwareBased,omitempty"`
	canBeDisabled              bool                                           `xml:"canBeDisabled,omitempty"`
	networkBindingSupport      *HostInternetScsiHbaNetworkBindingSupportType  `xml:"networkBindingSupport,omitempty"`
	discoveryCapabilities      *HostInternetScsiHbaDiscoveryCapabilities      `xml:"discoveryCapabilities,omitempty"`
	discoveryProperties        *HostInternetScsiHbaDiscoveryProperties        `xml:"discoveryProperties,omitempty"`
	authenticationCapabilities *HostInternetScsiHbaAuthenticationCapabilities `xml:"authenticationCapabilities,omitempty"`
	authenticationProperties   *HostInternetScsiHbaAuthenticationProperties   `xml:"authenticationProperties,omitempty"`
	digestCapabilities         *HostInternetScsiHbaDigestCapabilities         `xml:"digestCapabilities,omitempty"`
	digestProperties           *HostInternetScsiHbaDigestProperties           `xml:"digestProperties,omitempty"`
	ipCapabilities             *HostInternetScsiHbaIPCapabilities             `xml:"ipCapabilities,omitempty"`
	ipProperties               *HostInternetScsiHbaIPProperties               `xml:"ipProperties,omitempty"`
	supportedAdvancedOptions   []*OptionDef                                   `xml:"supportedAdvancedOptions,omitempty"`
	advancedOptions            []*HostInternetScsiHbaParamValue               `xml:"advancedOptions,omitempty"`
	iScsiName                  string                                         `xml:"iScsiName,omitempty"`
	iScsiAlias                 string                                         `xml:"iScsiAlias,omitempty"`
	configuredSendTarget       []*HostInternetScsiHbaSendTarget               `xml:"configuredSendTarget,omitempty"`
	configuredStaticTarget     []*HostInternetScsiHbaStaticTarget             `xml:"configuredStaticTarget,omitempty"`
	maxSpeedMb                 int32                                          `xml:"maxSpeedMb,omitempty"`
	currentSpeedMb             int32                                          `xml:"currentSpeedMb,omitempty"`
}

type HostFibreChannelOverEthernetHbaLinkInfo struct {
	*DynamicData

	vnportMac string `xml:"vnportMac,omitempty"`
	fcfMac    string `xml:"fcfMac,omitempty"`
	vlanId    int32  `xml:"vlanId,omitempty"`
}

type HostFibreChannelOverEthernetHba struct {
	*HostFibreChannelHba

	underlyingNic    string                                   `xml:"underlyingNic,omitempty"`
	linkInfo         *HostFibreChannelOverEthernetHbaLinkInfo `xml:"linkInfo,omitempty"`
	isSoftwareFcoe   bool                                     `xml:"isSoftwareFcoe,omitempty"`
	markedForRemoval bool                                     `xml:"markedForRemoval,omitempty"`
}

type HostProxySwitchSpec struct {
	*DynamicData

	backing *DistributedVirtualSwitchHostMemberBacking `xml:"backing,omitempty"`
}

type HostProxySwitchConfig struct {
	*DynamicData

	changeOperation string               `xml:"changeOperation,omitempty"`
	uuid            string               `xml:"uuid,omitempty"`
	spec            *HostProxySwitchSpec `xml:"spec,omitempty"`
}

type ArrayOfHostProxySwitchConfig struct {
	HostProxySwitchConfig []*HostProxySwitchConfig `xml:"HostProxySwitchConfig,omitempty"`
}

type HostProxySwitchHostLagConfig struct {
	*DynamicData

	lagKey     string      `xml:"lagKey,omitempty"`
	lagName    string      `xml:"lagName,omitempty"`
	uplinkPort []*KeyValue `xml:"uplinkPort,omitempty"`
}

type ArrayOfHostProxySwitchHostLagConfig struct {
	HostProxySwitchHostLagConfig []*HostProxySwitchHostLagConfig `xml:"HostProxySwitchHostLagConfig,omitempty"`
}

type HostProxySwitch struct {
	*DynamicData

	dvsUuid                     string                          `xml:"dvsUuid,omitempty"`
	dvsName                     string                          `xml:"dvsName,omitempty"`
	key                         string                          `xml:"key,omitempty"`
	numPorts                    int32                           `xml:"numPorts,omitempty"`
	configNumPorts              int32                           `xml:"configNumPorts,omitempty"`
	numPortsAvailable           int32                           `xml:"numPortsAvailable,omitempty"`
	uplinkPort                  []*KeyValue                     `xml:"uplinkPort,omitempty"`
	mtu                         int32                           `xml:"mtu,omitempty"`
	pnic                        []string                        `xml:"pnic,omitempty"`
	spec                        *HostProxySwitchSpec            `xml:"spec,omitempty"`
	hostLag                     []*HostProxySwitchHostLagConfig `xml:"hostLag,omitempty"`
	networkReservationSupported bool                            `xml:"networkReservationSupported,omitempty"`
}

type ArrayOfHostProxySwitch struct {
	HostProxySwitch []*HostProxySwitch `xml:"HostProxySwitch,omitempty"`
}

type HostImageProfileSummary struct {
	*DynamicData

	name   string `xml:"name,omitempty"`
	vendor string `xml:"vendor,omitempty"`
}

type HostIpConfigIpV6Address struct {
	*DynamicData

	ipAddress    string    `xml:"ipAddress,omitempty"`
	prefixLength int32     `xml:"prefixLength,omitempty"`
	origin       string    `xml:"origin,omitempty"`
	dadState     string    `xml:"dadState,omitempty"`
	lifetime     time.Time `xml:"lifetime,omitempty"`
	operation    string    `xml:"operation,omitempty"`
}

type ArrayOfHostIpConfigIpV6Address struct {
	HostIpConfigIpV6Address []*HostIpConfigIpV6Address `xml:"HostIpConfigIpV6Address,omitempty"`
}

type HostIpConfigIpV6AddressConfiguration struct {
	*DynamicData

	ipV6Address              []*HostIpConfigIpV6Address `xml:"ipV6Address,omitempty"`
	autoConfigurationEnabled bool                       `xml:"autoConfigurationEnabled,omitempty"`
	dhcpV6Enabled            bool                       `xml:"dhcpV6Enabled,omitempty"`
}

type HostIpConfig struct {
	*DynamicData

	dhcp       bool                                  `xml:"dhcp,omitempty"`
	ipAddress  string                                `xml:"ipAddress,omitempty"`
	subnetMask string                                `xml:"subnetMask,omitempty"`
	ipV6Config *HostIpConfigIpV6AddressConfiguration `xml:"ipV6Config,omitempty"`
}

type HostIpRouteConfig struct {
	*DynamicData

	defaultGateway     string `xml:"defaultGateway,omitempty"`
	gatewayDevice      string `xml:"gatewayDevice,omitempty"`
	ipV6DefaultGateway string `xml:"ipV6DefaultGateway,omitempty"`
	ipV6GatewayDevice  string `xml:"ipV6GatewayDevice,omitempty"`
}

type HostIpRouteConfigSpec struct {
	*HostIpRouteConfig

	gatewayDeviceConnection     *HostVirtualNicConnection `xml:"gatewayDeviceConnection,omitempty"`
	ipV6GatewayDeviceConnection *HostVirtualNicConnection `xml:"ipV6GatewayDeviceConnection,omitempty"`
}

type HostIpRouteEntry struct {
	*DynamicData

	network      string `xml:"network,omitempty"`
	prefixLength int32  `xml:"prefixLength,omitempty"`
	gateway      string `xml:"gateway,omitempty"`
	deviceName   string `xml:"deviceName,omitempty"`
}

type ArrayOfHostIpRouteEntry struct {
	HostIpRouteEntry []*HostIpRouteEntry `xml:"HostIpRouteEntry,omitempty"`
}

type HostIpRouteOp struct {
	*DynamicData

	changeOperation string            `xml:"changeOperation,omitempty"`
	route           *HostIpRouteEntry `xml:"route,omitempty"`
}

type ArrayOfHostIpRouteOp struct {
	HostIpRouteOp []*HostIpRouteOp `xml:"HostIpRouteOp,omitempty"`
}

type HostIpRouteTableConfig struct {
	*DynamicData

	ipRoute   []*HostIpRouteOp `xml:"ipRoute,omitempty"`
	ipv6Route []*HostIpRouteOp `xml:"ipv6Route,omitempty"`
}

type HostIpRouteTableInfo struct {
	*DynamicData

	ipRoute   []*HostIpRouteEntry `xml:"ipRoute,omitempty"`
	ipv6Route []*HostIpRouteEntry `xml:"ipv6Route,omitempty"`
}

type HostIpmiInfo struct {
	*DynamicData

	bmcIpAddress  string `xml:"bmcIpAddress,omitempty"`
	bmcMacAddress string `xml:"bmcMacAddress,omitempty"`
	login         string `xml:"login,omitempty"`
	password      string `xml:"password,omitempty"`
}

type IscsiStatus struct {
	*DynamicData

	reason []*LocalizedMethodFault `xml:"reason,omitempty"`
}

type IscsiPortInfo struct {
	*DynamicData

	vnicDevice       string          `xml:"vnicDevice,omitempty"`
	vnic             *HostVirtualNic `xml:"vnic,omitempty"`
	pnicDevice       string          `xml:"pnicDevice,omitempty"`
	pnic             *PhysicalNic    `xml:"pnic,omitempty"`
	switchName       string          `xml:"switchName,omitempty"`
	switchUuid       string          `xml:"switchUuid,omitempty"`
	portgroupName    string          `xml:"portgroupName,omitempty"`
	portgroupKey     string          `xml:"portgroupKey,omitempty"`
	portKey          string          `xml:"portKey,omitempty"`
	complianceStatus *IscsiStatus    `xml:"complianceStatus,omitempty"`
	pathStatus       string          `xml:"pathStatus,omitempty"`
}

type ArrayOfIscsiPortInfo struct {
	IscsiPortInfo []*IscsiPortInfo `xml:"IscsiPortInfo,omitempty"`
}

type IscsiDependencyEntity struct {
	*DynamicData

	pnicDevice string `xml:"pnicDevice,omitempty"`
	vnicDevice string `xml:"vnicDevice,omitempty"`
	vmhbaName  string `xml:"vmhbaName,omitempty"`
}

type ArrayOfIscsiDependencyEntity struct {
	IscsiDependencyEntity []*IscsiDependencyEntity `xml:"IscsiDependencyEntity,omitempty"`
}

type IscsiMigrationDependency struct {
	*DynamicData

	migrationAllowed bool                     `xml:"migrationAllowed,omitempty"`
	disallowReason   *IscsiStatus             `xml:"disallowReason,omitempty"`
	dependency       []*IscsiDependencyEntity `xml:"dependency,omitempty"`
}

type KernelModuleSectionInfo struct {
	*DynamicData

	address int64 `xml:"address,omitempty"`
	length  int32 `xml:"length,omitempty"`
}

type KernelModuleInfo struct {
	*DynamicData

	id              int32                    `xml:"id,omitempty"`
	name            string                   `xml:"name,omitempty"`
	version         string                   `xml:"version,omitempty"`
	filename        string                   `xml:"filename,omitempty"`
	optionString    string                   `xml:"optionString,omitempty"`
	loaded          bool                     `xml:"loaded,omitempty"`
	enabled         bool                     `xml:"enabled,omitempty"`
	useCount        int32                    `xml:"useCount,omitempty"`
	readOnlySection *KernelModuleSectionInfo `xml:"readOnlySection,omitempty"`
	writableSection *KernelModuleSectionInfo `xml:"writableSection,omitempty"`
	textSection     *KernelModuleSectionInfo `xml:"textSection,omitempty"`
	dataSection     *KernelModuleSectionInfo `xml:"dataSection,omitempty"`
	bssSection      *KernelModuleSectionInfo `xml:"bssSection,omitempty"`
}

type ArrayOfKernelModuleInfo struct {
	KernelModuleInfo []*KernelModuleInfo `xml:"KernelModuleInfo,omitempty"`
}

type HostLicenseSpec struct {
	*DynamicData

	source             *LicenseSource `xml:"source,omitempty"`
	editionKey         string         `xml:"editionKey,omitempty"`
	disabledFeatureKey []string       `xml:"disabledFeatureKey,omitempty"`
	enabledFeatureKey  []string       `xml:"enabledFeatureKey,omitempty"`
}

type LinkDiscoveryProtocolConfig struct {
	*DynamicData

	protocol  string `xml:"protocol,omitempty"`
	operation string `xml:"operation,omitempty"`
}

type HostAccountSpec struct {
	*DynamicData

	id          string `xml:"id,omitempty"`
	password    string `xml:"password,omitempty"`
	description string `xml:"description,omitempty"`
}

type ArrayOfHostAccountSpec struct {
	HostAccountSpec []*HostAccountSpec `xml:"HostAccountSpec,omitempty"`
}

type HostPosixAccountSpec struct {
	*HostAccountSpec

	posixId     int32 `xml:"posixId,omitempty"`
	shellAccess bool  `xml:"shellAccess,omitempty"`
}

type HostLocalAuthenticationInfo struct {
	*HostAuthenticationStoreInfo
}

type HostLowLevelProvisioningManagerVmRecoveryInfo struct {
	*DynamicData

	version      string                    `xml:"version,omitempty"`
	biosUUID     string                    `xml:"biosUUID,omitempty"`
	instanceUUID string                    `xml:"instanceUUID,omitempty"`
	ftInfo       *FaultToleranceConfigInfo `xml:"ftInfo,omitempty"`
}

type HostLowLevelProvisioningManagerVmMigrationStatus struct {
	*DynamicData

	migrationId          int64  `xml:"migrationId,omitempty"`
	type_                string `xml:"type,omitempty"`
	source               bool   `xml:"source,omitempty"`
	consideredSuccessful bool   `xml:"consideredSuccessful,omitempty"`
}

type HostLowLevelProvisioningManagerDiskLayoutSpec struct {
	*DynamicData

	controllerType string `xml:"controllerType,omitempty"`
	busNumber      int32  `xml:"busNumber,omitempty"`
	unitNumber     int32  `xml:"unitNumber,omitempty"`
	srcFilename    string `xml:"srcFilename,omitempty"`
	dstFilename    string `xml:"dstFilename,omitempty"`
}

type ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec struct {
	HostLowLevelProvisioningManagerDiskLayoutSpec []*HostLowLevelProvisioningManagerDiskLayoutSpec `xml:"HostLowLevelProvisioningManagerDiskLayoutSpec,omitempty"`
}

type HostLowLevelProvisioningManagerSnapshotLayoutSpec struct {
	*DynamicData

	id          int32                                            `xml:"id,omitempty"`
	srcFilename string                                           `xml:"srcFilename,omitempty"`
	dstFilename string                                           `xml:"dstFilename,omitempty"`
	disk        []*HostLowLevelProvisioningManagerDiskLayoutSpec `xml:"disk,omitempty"`
}

type ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec struct {
	HostLowLevelProvisioningManagerSnapshotLayoutSpec []*HostLowLevelProvisioningManagerSnapshotLayoutSpec `xml:"HostLowLevelProvisioningManagerSnapshotLayoutSpec,omitempty"`
}

type HostMaintenanceSpec struct {
	*DynamicData

	vsanMode *VsanHostDecommissionMode `xml:"vsanMode,omitempty"`
}

type ServiceConsoleReservationInfo struct {
	*DynamicData

	serviceConsoleReservedCfg int64 `xml:"serviceConsoleReservedCfg,omitempty"`
	serviceConsoleReserved    int64 `xml:"serviceConsoleReserved,omitempty"`
	unreserved                int64 `xml:"unreserved,omitempty"`
}

type VirtualMachineMemoryReservationInfo struct {
	*DynamicData

	virtualMachineMin      int64  `xml:"virtualMachineMin,omitempty"`
	virtualMachineMax      int64  `xml:"virtualMachineMax,omitempty"`
	virtualMachineReserved int64  `xml:"virtualMachineReserved,omitempty"`
	allocationPolicy       string `xml:"allocationPolicy,omitempty"`
}

type VirtualMachineMemoryReservationSpec struct {
	*DynamicData

	virtualMachineReserved int64  `xml:"virtualMachineReserved,omitempty"`
	allocationPolicy       string `xml:"allocationPolicy,omitempty"`
}

type HostMemorySpec struct {
	*DynamicData

	serviceConsoleReservation int64 `xml:"serviceConsoleReservation,omitempty"`
}

type HostMountInfo struct {
	*DynamicData

	path               string `xml:"path,omitempty"`
	accessMode         string `xml:"accessMode,omitempty"`
	mounted            bool   `xml:"mounted,omitempty"`
	accessible         bool   `xml:"accessible,omitempty"`
	inaccessibleReason string `xml:"inaccessibleReason,omitempty"`
}

type HostMultipathInfoLogicalUnitPolicy struct {
	*DynamicData

	policy string `xml:"policy,omitempty"`
}

type HostMultipathInfoLogicalUnitStorageArrayTypePolicy struct {
	*DynamicData

	policy string `xml:"policy,omitempty"`
}

type HostMultipathInfoFixedLogicalUnitPolicy struct {
	*HostMultipathInfoLogicalUnitPolicy

	prefer string `xml:"prefer,omitempty"`
}

type HostMultipathInfoLogicalUnit struct {
	*DynamicData

	key                    string                                              `xml:"key,omitempty"`
	id                     string                                              `xml:"id,omitempty"`
	lun                    string                                              `xml:"lun,omitempty"`
	path                   []*HostMultipathInfoPath                            `xml:"path,omitempty"`
	policy                 *HostMultipathInfoLogicalUnitPolicy                 `xml:"policy,omitempty"`
	storageArrayTypePolicy *HostMultipathInfoLogicalUnitStorageArrayTypePolicy `xml:"storageArrayTypePolicy,omitempty"`
}

type ArrayOfHostMultipathInfoLogicalUnit struct {
	HostMultipathInfoLogicalUnit []*HostMultipathInfoLogicalUnit `xml:"HostMultipathInfoLogicalUnit,omitempty"`
}

type HostMultipathInfoPath struct {
	*DynamicData

	key           string               `xml:"key,omitempty"`
	name          string               `xml:"name,omitempty"`
	pathState     string               `xml:"pathState,omitempty"`
	state         string               `xml:"state,omitempty"`
	isWorkingPath bool                 `xml:"isWorkingPath,omitempty"`
	adapter       string               `xml:"adapter,omitempty"`
	lun           string               `xml:"lun,omitempty"`
	transport     *HostTargetTransport `xml:"transport,omitempty"`
}

type ArrayOfHostMultipathInfoPath struct {
	HostMultipathInfoPath []*HostMultipathInfoPath `xml:"HostMultipathInfoPath,omitempty"`
}

type HostMultipathInfo struct {
	*DynamicData

	lun []*HostMultipathInfoLogicalUnit `xml:"lun,omitempty"`
}

type HostMultipathStateInfoPath struct {
	*DynamicData

	name      string `xml:"name,omitempty"`
	pathState string `xml:"pathState,omitempty"`
}

type ArrayOfHostMultipathStateInfoPath struct {
	HostMultipathStateInfoPath []*HostMultipathStateInfoPath `xml:"HostMultipathStateInfoPath,omitempty"`
}

type HostMultipathStateInfo struct {
	*DynamicData

	path []*HostMultipathStateInfoPath `xml:"path,omitempty"`
}

type HostNatServicePortForwardSpec struct {
	*DynamicData

	type_          string `xml:"type,omitempty"`
	name           string `xml:"name,omitempty"`
	hostPort       int32  `xml:"hostPort,omitempty"`
	guestPort      int32  `xml:"guestPort,omitempty"`
	guestIpAddress string `xml:"guestIpAddress,omitempty"`
}

type ArrayOfHostNatServicePortForwardSpec struct {
	HostNatServicePortForwardSpec []*HostNatServicePortForwardSpec `xml:"HostNatServicePortForwardSpec,omitempty"`
}

type HostNatServiceNameServiceSpec struct {
	*DynamicData

	dnsAutoDetect bool     `xml:"dnsAutoDetect,omitempty"`
	dnsPolicy     string   `xml:"dnsPolicy,omitempty"`
	dnsRetries    int32    `xml:"dnsRetries,omitempty"`
	dnsTimeout    int32    `xml:"dnsTimeout,omitempty"`
	dnsNameServer []string `xml:"dnsNameServer,omitempty"`
	nbdsTimeout   int32    `xml:"nbdsTimeout,omitempty"`
	nbnsRetries   int32    `xml:"nbnsRetries,omitempty"`
	nbnsTimeout   int32    `xml:"nbnsTimeout,omitempty"`
}

type HostNatServiceSpec struct {
	*DynamicData

	virtualSwitch    string                           `xml:"virtualSwitch,omitempty"`
	activeFtp        bool                             `xml:"activeFtp,omitempty"`
	allowAnyOui      bool                             `xml:"allowAnyOui,omitempty"`
	configPort       bool                             `xml:"configPort,omitempty"`
	ipGatewayAddress string                           `xml:"ipGatewayAddress,omitempty"`
	udpTimeout       int32                            `xml:"udpTimeout,omitempty"`
	portForward      []*HostNatServicePortForwardSpec `xml:"portForward,omitempty"`
	nameService      *HostNatServiceNameServiceSpec   `xml:"nameService,omitempty"`
}

type HostNatServiceConfig struct {
	*DynamicData

	changeOperation string              `xml:"changeOperation,omitempty"`
	key             string              `xml:"key,omitempty"`
	spec            *HostNatServiceSpec `xml:"spec,omitempty"`
}

type ArrayOfHostNatServiceConfig struct {
	HostNatServiceConfig []*HostNatServiceConfig `xml:"HostNatServiceConfig,omitempty"`
}

type HostNatService struct {
	*DynamicData

	key  string              `xml:"key,omitempty"`
	spec *HostNatServiceSpec `xml:"spec,omitempty"`
}

type ArrayOfHostNatService struct {
	HostNatService []*HostNatService `xml:"HostNatService,omitempty"`
}

type HostNetCapabilities struct {
	*DynamicData

	canSetPhysicalNicLinkSpeed bool     `xml:"canSetPhysicalNicLinkSpeed,omitempty"`
	supportsNicTeaming         bool     `xml:"supportsNicTeaming,omitempty"`
	nicTeamingPolicy           []string `xml:"nicTeamingPolicy,omitempty"`
	supportsVlan               bool     `xml:"supportsVlan,omitempty"`
	usesServiceConsoleNic      bool     `xml:"usesServiceConsoleNic,omitempty"`
	supportsNetworkHints       bool     `xml:"supportsNetworkHints,omitempty"`
	maxPortGroupsPerVswitch    int32    `xml:"maxPortGroupsPerVswitch,omitempty"`
	vswitchConfigSupported     bool     `xml:"vswitchConfigSupported,omitempty"`
	vnicConfigSupported        bool     `xml:"vnicConfigSupported,omitempty"`
	ipRouteConfigSupported     bool     `xml:"ipRouteConfigSupported,omitempty"`
	dnsConfigSupported         bool     `xml:"dnsConfigSupported,omitempty"`
	dhcpOnVnicSupported        bool     `xml:"dhcpOnVnicSupported,omitempty"`
	ipV6Supported              bool     `xml:"ipV6Supported,omitempty"`
}

type HostNetOffloadCapabilities struct {
	*DynamicData

	csumOffload     bool `xml:"csumOffload,omitempty"`
	tcpSegmentation bool `xml:"tcpSegmentation,omitempty"`
	zeroCopyXmit    bool `xml:"zeroCopyXmit,omitempty"`
}

type HostNetStackInstance struct {
	*DynamicData

	key                             string                  `xml:"key,omitempty"`
	name                            string                  `xml:"name,omitempty"`
	dnsConfig                       *HostDnsConfig          `xml:"dnsConfig,omitempty"`
	ipRouteConfig                   *HostIpRouteConfig      `xml:"ipRouteConfig,omitempty"`
	requestedMaxNumberOfConnections int32                   `xml:"requestedMaxNumberOfConnections,omitempty"`
	congestionControlAlgorithm      string                  `xml:"congestionControlAlgorithm,omitempty"`
	ipV6Enabled                     bool                    `xml:"ipV6Enabled,omitempty"`
	routeTableConfig                *HostIpRouteTableConfig `xml:"routeTableConfig,omitempty"`
}

type ArrayOfHostNetStackInstance struct {
	HostNetStackInstance []*HostNetStackInstance `xml:"HostNetStackInstance,omitempty"`
}

type HostNetworkConfigResult struct {
	*DynamicData

	vnicDevice        []string `xml:"vnicDevice,omitempty"`
	consoleVnicDevice []string `xml:"consoleVnicDevice,omitempty"`
}

type HostNetworkConfigNetStackSpec struct {
	*DynamicData

	netStackInstance *HostNetStackInstance `xml:"netStackInstance,omitempty"`
	operation        string                `xml:"operation,omitempty"`
}

type ArrayOfHostNetworkConfigNetStackSpec struct {
	HostNetworkConfigNetStackSpec []*HostNetworkConfigNetStackSpec `xml:"HostNetworkConfigNetStackSpec,omitempty"`
}

type HostNetworkConfig struct {
	*DynamicData

	vswitch              []*HostVirtualSwitchConfig       `xml:"vswitch,omitempty"`
	proxySwitch          []*HostProxySwitchConfig         `xml:"proxySwitch,omitempty"`
	portgroup            []*HostPortGroupConfig           `xml:"portgroup,omitempty"`
	pnic                 []*PhysicalNicConfig             `xml:"pnic,omitempty"`
	vnic                 []*HostVirtualNicConfig          `xml:"vnic,omitempty"`
	consoleVnic          []*HostVirtualNicConfig          `xml:"consoleVnic,omitempty"`
	dnsConfig            *HostDnsConfig                   `xml:"dnsConfig,omitempty"`
	ipRouteConfig        *HostIpRouteConfig               `xml:"ipRouteConfig,omitempty"`
	consoleIpRouteConfig *HostIpRouteConfig               `xml:"consoleIpRouteConfig,omitempty"`
	routeTableConfig     *HostIpRouteTableConfig          `xml:"routeTableConfig,omitempty"`
	dhcp                 []*HostDhcpServiceConfig         `xml:"dhcp,omitempty"`
	nat                  []*HostNatServiceConfig          `xml:"nat,omitempty"`
	ipV6Enabled          bool                             `xml:"ipV6Enabled,omitempty"`
	netStackSpec         []*HostNetworkConfigNetStackSpec `xml:"netStackSpec,omitempty"`
}

type HostNetworkInfo struct {
	*DynamicData

	vswitch              []*HostVirtualSwitch     `xml:"vswitch,omitempty"`
	proxySwitch          []*HostProxySwitch       `xml:"proxySwitch,omitempty"`
	portgroup            []*HostPortGroup         `xml:"portgroup,omitempty"`
	pnic                 []*PhysicalNic           `xml:"pnic,omitempty"`
	vnic                 []*HostVirtualNic        `xml:"vnic,omitempty"`
	consoleVnic          []*HostVirtualNic        `xml:"consoleVnic,omitempty"`
	dnsConfig            *HostDnsConfig           `xml:"dnsConfig,omitempty"`
	ipRouteConfig        *HostIpRouteConfig       `xml:"ipRouteConfig,omitempty"`
	consoleIpRouteConfig *HostIpRouteConfig       `xml:"consoleIpRouteConfig,omitempty"`
	routeTableInfo       *HostIpRouteTableInfo    `xml:"routeTableInfo,omitempty"`
	dhcp                 []*HostDhcpService       `xml:"dhcp,omitempty"`
	nat                  []*HostNatService        `xml:"nat,omitempty"`
	ipV6Enabled          bool                     `xml:"ipV6Enabled,omitempty"`
	atBootIpV6Enabled    bool                     `xml:"atBootIpV6Enabled,omitempty"`
	netStackInstance     []*HostNetStackInstance  `xml:"netStackInstance,omitempty"`
	opaqueSwitch         []*HostOpaqueSwitch      `xml:"opaqueSwitch,omitempty"`
	opaqueNetwork        []*HostOpaqueNetworkInfo `xml:"opaqueNetwork,omitempty"`
}

type HostNetworkSecurityPolicy struct {
	*DynamicData

	allowPromiscuous bool `xml:"allowPromiscuous,omitempty"`
	macChanges       bool `xml:"macChanges,omitempty"`
	forgedTransmits  bool `xml:"forgedTransmits,omitempty"`
}

type HostNetworkTrafficShapingPolicy struct {
	*DynamicData

	enabled          bool  `xml:"enabled,omitempty"`
	averageBandwidth int64 `xml:"averageBandwidth,omitempty"`
	peakBandwidth    int64 `xml:"peakBandwidth,omitempty"`
	burstSize        int64 `xml:"burstSize,omitempty"`
}

type HostNicFailureCriteria struct {
	*DynamicData

	checkSpeed        string `xml:"checkSpeed,omitempty"`
	speed             int32  `xml:"speed,omitempty"`
	checkDuplex       bool   `xml:"checkDuplex,omitempty"`
	fullDuplex        bool   `xml:"fullDuplex,omitempty"`
	checkErrorPercent bool   `xml:"checkErrorPercent,omitempty"`
	percentage        int32  `xml:"percentage,omitempty"`
	checkBeacon       bool   `xml:"checkBeacon,omitempty"`
}

type HostNicOrderPolicy struct {
	*DynamicData

	activeNic  []string `xml:"activeNic,omitempty"`
	standbyNic []string `xml:"standbyNic,omitempty"`
}

type HostNicTeamingPolicy struct {
	*DynamicData

	policy          string                  `xml:"policy,omitempty"`
	reversePolicy   bool                    `xml:"reversePolicy,omitempty"`
	notifySwitches  bool                    `xml:"notifySwitches,omitempty"`
	rollingOrder    bool                    `xml:"rollingOrder,omitempty"`
	failureCriteria *HostNicFailureCriteria `xml:"failureCriteria,omitempty"`
	nicOrder        *HostNicOrderPolicy     `xml:"nicOrder,omitempty"`
}

type HostNetworkPolicy struct {
	*DynamicData

	security      *HostNetworkSecurityPolicy       `xml:"security,omitempty"`
	nicTeaming    *HostNicTeamingPolicy            `xml:"nicTeaming,omitempty"`
	offloadPolicy *HostNetOffloadCapabilities      `xml:"offloadPolicy,omitempty"`
	shapingPolicy *HostNetworkTrafficShapingPolicy `xml:"shapingPolicy,omitempty"`
}

type HostNtpConfig struct {
	*DynamicData

	server []string `xml:"server,omitempty"`
}

type HostNumericSensorInfo struct {
	*DynamicData

	name           string              `xml:"name,omitempty"`
	healthState    *ElementDescription `xml:"healthState,omitempty"`
	currentReading int64               `xml:"currentReading,omitempty"`
	unitModifier   int32               `xml:"unitModifier,omitempty"`
	baseUnits      string              `xml:"baseUnits,omitempty"`
	rateUnits      string              `xml:"rateUnits,omitempty"`
	sensorType     string              `xml:"sensorType,omitempty"`
}

type ArrayOfHostNumericSensorInfo struct {
	HostNumericSensorInfo []*HostNumericSensorInfo `xml:"HostNumericSensorInfo,omitempty"`
}

type HostOpaqueNetworkInfo struct {
	*DynamicData

	opaqueNetworkId   string `xml:"opaqueNetworkId,omitempty"`
	opaqueNetworkName string `xml:"opaqueNetworkName,omitempty"`
	opaqueNetworkType string `xml:"opaqueNetworkType,omitempty"`
}

type ArrayOfHostOpaqueNetworkInfo struct {
	HostOpaqueNetworkInfo []*HostOpaqueNetworkInfo `xml:"HostOpaqueNetworkInfo,omitempty"`
}

type HostOpaqueSwitch struct {
	*DynamicData

	key  string   `xml:"key,omitempty"`
	name string   `xml:"name,omitempty"`
	pnic []string `xml:"pnic,omitempty"`
}

type ArrayOfHostOpaqueSwitch struct {
	HostOpaqueSwitch []*HostOpaqueSwitch `xml:"HostOpaqueSwitch,omitempty"`
}

type HostPatchManagerResult struct {
	*DynamicData

	version   string                    `xml:"version,omitempty"`
	status    []*HostPatchManagerStatus `xml:"status,omitempty"`
	xmlResult string                    `xml:"xmlResult,omitempty"`
}

type HostPatchManagerStatusPrerequisitePatch struct {
	*DynamicData

	id           string   `xml:"id,omitempty"`
	installState []string `xml:"installState,omitempty"`
}

type ArrayOfHostPatchManagerStatusPrerequisitePatch struct {
	HostPatchManagerStatusPrerequisitePatch []*HostPatchManagerStatusPrerequisitePatch `xml:"HostPatchManagerStatusPrerequisitePatch,omitempty"`
}

type HostPatchManagerStatus struct {
	*DynamicData

	id                 string                                     `xml:"id,omitempty"`
	applicable         bool                                       `xml:"applicable,omitempty"`
	reason             []string                                   `xml:"reason,omitempty"`
	integrity          string                                     `xml:"integrity,omitempty"`
	installed          bool                                       `xml:"installed,omitempty"`
	installState       []string                                   `xml:"installState,omitempty"`
	prerequisitePatch  []*HostPatchManagerStatusPrerequisitePatch `xml:"prerequisitePatch,omitempty"`
	restartRequired    bool                                       `xml:"restartRequired,omitempty"`
	reconnectRequired  bool                                       `xml:"reconnectRequired,omitempty"`
	vmOffRequired      bool                                       `xml:"vmOffRequired,omitempty"`
	supersededPatchIds []string                                   `xml:"supersededPatchIds,omitempty"`
}

type ArrayOfHostPatchManagerStatus struct {
	HostPatchManagerStatus []*HostPatchManagerStatus `xml:"HostPatchManagerStatus,omitempty"`
}

type HostPatchManagerLocator struct {
	*DynamicData

	url   string `xml:"url,omitempty"`
	proxy string `xml:"proxy,omitempty"`
}

type HostPatchManagerPatchManagerOperationSpec struct {
	*DynamicData

	proxy     string `xml:"proxy,omitempty"`
	port      int32  `xml:"port,omitempty"`
	userName  string `xml:"userName,omitempty"`
	password  string `xml:"password,omitempty"`
	cmdOption string `xml:"cmdOption,omitempty"`
}

type HostPathSelectionPolicyOption struct {
	*DynamicData

	policy *ElementDescription `xml:"policy,omitempty"`
}

type ArrayOfHostPathSelectionPolicyOption struct {
	HostPathSelectionPolicyOption []*HostPathSelectionPolicyOption `xml:"HostPathSelectionPolicyOption,omitempty"`
}

type HostPciDevice struct {
	*DynamicData

	id           string `xml:"id,omitempty"`
	classId      int16  `xml:"classId,omitempty"`
	bus          int8   `xml:"bus,omitempty"`
	slot         int8   `xml:"slot,omitempty"`
	function     int8   `xml:"function,omitempty"`
	vendorId     int16  `xml:"vendorId,omitempty"`
	subVendorId  int16  `xml:"subVendorId,omitempty"`
	vendorName   string `xml:"vendorName,omitempty"`
	deviceId     int16  `xml:"deviceId,omitempty"`
	subDeviceId  int16  `xml:"subDeviceId,omitempty"`
	parentBridge string `xml:"parentBridge,omitempty"`
	deviceName   string `xml:"deviceName,omitempty"`
}

type ArrayOfHostPciDevice struct {
	HostPciDevice []*HostPciDevice `xml:"HostPciDevice,omitempty"`
}

type HostPciPassthruConfig struct {
	*DynamicData

	id              string `xml:"id,omitempty"`
	passthruEnabled bool   `xml:"passthruEnabled,omitempty"`
}

type ArrayOfHostPciPassthruConfig struct {
	HostPciPassthruConfig []*HostPciPassthruConfig `xml:"HostPciPassthruConfig,omitempty"`
}

type HostPciPassthruInfo struct {
	*DynamicData

	id              string `xml:"id,omitempty"`
	dependentDevice string `xml:"dependentDevice,omitempty"`
	passthruEnabled bool   `xml:"passthruEnabled,omitempty"`
	passthruCapable bool   `xml:"passthruCapable,omitempty"`
	passthruActive  bool   `xml:"passthruActive,omitempty"`
}

type ArrayOfHostPciPassthruInfo struct {
	HostPciPassthruInfo []*HostPciPassthruInfo `xml:"HostPciPassthruInfo,omitempty"`
}

type PhysicalNicSpec struct {
	*DynamicData

	ip        *HostIpConfig        `xml:"ip,omitempty"`
	linkSpeed *PhysicalNicLinkInfo `xml:"linkSpeed,omitempty"`
}

type PhysicalNicConfig struct {
	*DynamicData

	device string           `xml:"device,omitempty"`
	spec   *PhysicalNicSpec `xml:"spec,omitempty"`
}

type ArrayOfPhysicalNicConfig struct {
	PhysicalNicConfig []*PhysicalNicConfig `xml:"PhysicalNicConfig,omitempty"`
}

type PhysicalNicLinkInfo struct {
	*DynamicData

	speedMb int32 `xml:"speedMb,omitempty"`
	duplex  bool  `xml:"duplex,omitempty"`
}

type ArrayOfPhysicalNicLinkInfo struct {
	PhysicalNicLinkInfo []*PhysicalNicLinkInfo `xml:"PhysicalNicLinkInfo,omitempty"`
}

type PhysicalNicHint struct {
	*DynamicData

	vlanId int32 `xml:"vlanId,omitempty"`
}

type PhysicalNicIpHint struct {
	*PhysicalNicHint

	ipSubnet string `xml:"ipSubnet,omitempty"`
}

type ArrayOfPhysicalNicIpHint struct {
	PhysicalNicIpHint []*PhysicalNicIpHint `xml:"PhysicalNicIpHint,omitempty"`
}

type PhysicalNicNameHint struct {
	*PhysicalNicHint

	network string `xml:"network,omitempty"`
}

type ArrayOfPhysicalNicNameHint struct {
	PhysicalNicNameHint []*PhysicalNicNameHint `xml:"PhysicalNicNameHint,omitempty"`
}

type PhysicalNicHintInfo struct {
	*DynamicData

	device              string                          `xml:"device,omitempty"`
	subnet              []*PhysicalNicIpHint            `xml:"subnet,omitempty"`
	network             []*PhysicalNicNameHint          `xml:"network,omitempty"`
	connectedSwitchPort *PhysicalNicCdpInfo             `xml:"connectedSwitchPort,omitempty"`
	lldpInfo            *LinkLayerDiscoveryProtocolInfo `xml:"lldpInfo,omitempty"`
}

type ArrayOfPhysicalNicHintInfo struct {
	PhysicalNicHintInfo []*PhysicalNicHintInfo `xml:"PhysicalNicHintInfo,omitempty"`
}

type PhysicalNicCdpDeviceCapability struct {
	*DynamicData

	router            bool `xml:"router,omitempty"`
	transparentBridge bool `xml:"transparentBridge,omitempty"`
	sourceRouteBridge bool `xml:"sourceRouteBridge,omitempty"`
	networkSwitch     bool `xml:"networkSwitch,omitempty"`
	host              bool `xml:"host,omitempty"`
	igmpEnabled       bool `xml:"igmpEnabled,omitempty"`
	repeater          bool `xml:"repeater,omitempty"`
}

type PhysicalNicCdpInfo struct {
	*DynamicData

	cdpVersion       int32                           `xml:"cdpVersion,omitempty"`
	timeout          int32                           `xml:"timeout,omitempty"`
	ttl              int32                           `xml:"ttl,omitempty"`
	samples          int32                           `xml:"samples,omitempty"`
	devId            string                          `xml:"devId,omitempty"`
	address          string                          `xml:"address,omitempty"`
	portId           string                          `xml:"portId,omitempty"`
	deviceCapability *PhysicalNicCdpDeviceCapability `xml:"deviceCapability,omitempty"`
	softwareVersion  string                          `xml:"softwareVersion,omitempty"`
	hardwarePlatform string                          `xml:"hardwarePlatform,omitempty"`
	ipPrefix         string                          `xml:"ipPrefix,omitempty"`
	ipPrefixLen      int32                           `xml:"ipPrefixLen,omitempty"`
	vlan             int32                           `xml:"vlan,omitempty"`
	fullDuplex       bool                            `xml:"fullDuplex,omitempty"`
	mtu              int32                           `xml:"mtu,omitempty"`
	systemName       string                          `xml:"systemName,omitempty"`
	systemOID        string                          `xml:"systemOID,omitempty"`
	mgmtAddr         string                          `xml:"mgmtAddr,omitempty"`
	location         string                          `xml:"location,omitempty"`
}

type LinkLayerDiscoveryProtocolInfo struct {
	*DynamicData

	chassisId  string         `xml:"chassisId,omitempty"`
	portId     string         `xml:"portId,omitempty"`
	timeToLive int32          `xml:"timeToLive,omitempty"`
	parameter  []*KeyAnyValue `xml:"parameter,omitempty"`
}

type PhysicalNic struct {
	*DynamicData

	key                                   string                 `xml:"key,omitempty"`
	device                                string                 `xml:"device,omitempty"`
	pci                                   string                 `xml:"pci,omitempty"`
	driver                                string                 `xml:"driver,omitempty"`
	linkSpeed                             *PhysicalNicLinkInfo   `xml:"linkSpeed,omitempty"`
	validLinkSpecification                []*PhysicalNicLinkInfo `xml:"validLinkSpecification,omitempty"`
	spec                                  *PhysicalNicSpec       `xml:"spec,omitempty"`
	wakeOnLanSupported                    bool                   `xml:"wakeOnLanSupported,omitempty"`
	mac                                   string                 `xml:"mac,omitempty"`
	fcoeConfiguration                     *FcoeConfig            `xml:"fcoeConfiguration,omitempty"`
	vmDirectPathGen2Supported             bool                   `xml:"vmDirectPathGen2Supported,omitempty"`
	vmDirectPathGen2SupportedMode         string                 `xml:"vmDirectPathGen2SupportedMode,omitempty"`
	resourcePoolSchedulerAllowed          bool                   `xml:"resourcePoolSchedulerAllowed,omitempty"`
	resourcePoolSchedulerDisallowedReason []string               `xml:"resourcePoolSchedulerDisallowedReason,omitempty"`
	autoNegotiateSupported                bool                   `xml:"autoNegotiateSupported,omitempty"`
}

type ArrayOfPhysicalNic struct {
	PhysicalNic []*PhysicalNic `xml:"PhysicalNic,omitempty"`
}

type HostPlugStoreTopologyAdapter struct {
	*DynamicData

	key     string   `xml:"key,omitempty"`
	adapter string   `xml:"adapter,omitempty"`
	path    []string `xml:"path,omitempty"`
}

type ArrayOfHostPlugStoreTopologyAdapter struct {
	HostPlugStoreTopologyAdapter []*HostPlugStoreTopologyAdapter `xml:"HostPlugStoreTopologyAdapter,omitempty"`
}

type HostPlugStoreTopologyPath struct {
	*DynamicData

	key           string `xml:"key,omitempty"`
	name          string `xml:"name,omitempty"`
	channelNumber int32  `xml:"channelNumber,omitempty"`
	targetNumber  int32  `xml:"targetNumber,omitempty"`
	lunNumber     int32  `xml:"lunNumber,omitempty"`
	adapter       string `xml:"adapter,omitempty"`
	target        string `xml:"target,omitempty"`
	device        string `xml:"device,omitempty"`
}

type ArrayOfHostPlugStoreTopologyPath struct {
	HostPlugStoreTopologyPath []*HostPlugStoreTopologyPath `xml:"HostPlugStoreTopologyPath,omitempty"`
}

type HostPlugStoreTopologyDevice struct {
	*DynamicData

	key  string   `xml:"key,omitempty"`
	lun  string   `xml:"lun,omitempty"`
	path []string `xml:"path,omitempty"`
}

type ArrayOfHostPlugStoreTopologyDevice struct {
	HostPlugStoreTopologyDevice []*HostPlugStoreTopologyDevice `xml:"HostPlugStoreTopologyDevice,omitempty"`
}

type HostPlugStoreTopologyPlugin struct {
	*DynamicData

	key         string   `xml:"key,omitempty"`
	name        string   `xml:"name,omitempty"`
	device      []string `xml:"device,omitempty"`
	claimedPath []string `xml:"claimedPath,omitempty"`
}

type ArrayOfHostPlugStoreTopologyPlugin struct {
	HostPlugStoreTopologyPlugin []*HostPlugStoreTopologyPlugin `xml:"HostPlugStoreTopologyPlugin,omitempty"`
}

type HostPlugStoreTopologyTarget struct {
	*DynamicData

	key       string               `xml:"key,omitempty"`
	transport *HostTargetTransport `xml:"transport,omitempty"`
}

type ArrayOfHostPlugStoreTopologyTarget struct {
	HostPlugStoreTopologyTarget []*HostPlugStoreTopologyTarget `xml:"HostPlugStoreTopologyTarget,omitempty"`
}

type HostPlugStoreTopology struct {
	*DynamicData

	adapter []*HostPlugStoreTopologyAdapter `xml:"adapter,omitempty"`
	path    []*HostPlugStoreTopologyPath    `xml:"path,omitempty"`
	target  []*HostPlugStoreTopologyTarget  `xml:"target,omitempty"`
	device  []*HostPlugStoreTopologyDevice  `xml:"device,omitempty"`
	plugin  []*HostPlugStoreTopologyPlugin  `xml:"plugin,omitempty"`
}

type HostPortGroupSpec struct {
	*DynamicData

	name        string             `xml:"name,omitempty"`
	vlanId      int32              `xml:"vlanId,omitempty"`
	vswitchName string             `xml:"vswitchName,omitempty"`
	policy      *HostNetworkPolicy `xml:"policy,omitempty"`
}

type HostPortGroupConfig struct {
	*DynamicData

	changeOperation string             `xml:"changeOperation,omitempty"`
	spec            *HostPortGroupSpec `xml:"spec,omitempty"`
}

type ArrayOfHostPortGroupConfig struct {
	HostPortGroupConfig []*HostPortGroupConfig `xml:"HostPortGroupConfig,omitempty"`
}

type HostPortGroupPort struct {
	*DynamicData

	key   string   `xml:"key,omitempty"`
	mac   []string `xml:"mac,omitempty"`
	type_ string   `xml:"type,omitempty"`
}

type ArrayOfHostPortGroupPort struct {
	HostPortGroupPort []*HostPortGroupPort `xml:"HostPortGroupPort,omitempty"`
}

type HostPortGroup struct {
	*DynamicData

	key            string               `xml:"key,omitempty"`
	port           []*HostPortGroupPort `xml:"port,omitempty"`
	vswitch        string               `xml:"vswitch,omitempty"`
	computedPolicy *HostNetworkPolicy   `xml:"computedPolicy,omitempty"`
	spec           *HostPortGroupSpec   `xml:"spec,omitempty"`
}

type ArrayOfHostPortGroup struct {
	HostPortGroup []*HostPortGroup `xml:"HostPortGroup,omitempty"`
}

type HostPowerPolicy struct {
	*DynamicData

	key         int32  `xml:"key,omitempty"`
	name        string `xml:"name,omitempty"`
	shortName   string `xml:"shortName,omitempty"`
	description string `xml:"description,omitempty"`
}

type ArrayOfHostPowerPolicy struct {
	HostPowerPolicy []*HostPowerPolicy `xml:"HostPowerPolicy,omitempty"`
}

type PowerSystemCapability struct {
	*DynamicData

	availablePolicy []*HostPowerPolicy `xml:"availablePolicy,omitempty"`
}

type PowerSystemInfo struct {
	*DynamicData

	currentPolicy *HostPowerPolicy `xml:"currentPolicy,omitempty"`
}

type HostResignatureRescanResult struct {
	*DynamicData

	rescan []*HostVmfsRescanResult `xml:"rescan,omitempty"`
	result *ManagedObjectReference `xml:"result,omitempty"`
}

type HostFirewallRulesetIpNetwork struct {
	*DynamicData

	network      string `xml:"network,omitempty"`
	prefixLength int32  `xml:"prefixLength,omitempty"`
}

type ArrayOfHostFirewallRulesetIpNetwork struct {
	HostFirewallRulesetIpNetwork []*HostFirewallRulesetIpNetwork `xml:"HostFirewallRulesetIpNetwork,omitempty"`
}

type HostFirewallRulesetIpList struct {
	*DynamicData

	ipAddress []string                        `xml:"ipAddress,omitempty"`
	ipNetwork []*HostFirewallRulesetIpNetwork `xml:"ipNetwork,omitempty"`
	allIp     bool                            `xml:"allIp,omitempty"`
}

type HostFirewallRulesetRulesetSpec struct {
	*DynamicData

	allowedHosts *HostFirewallRulesetIpList `xml:"allowedHosts,omitempty"`
}

type HostFirewallRule struct {
	*DynamicData

	port      int32                      `xml:"port,omitempty"`
	endPort   int32                      `xml:"endPort,omitempty"`
	direction *HostFirewallRuleDirection `xml:"direction,omitempty"`
	portType  *HostFirewallRulePortType  `xml:"portType,omitempty"`
	protocol  string                     `xml:"protocol,omitempty"`
}

type ArrayOfHostFirewallRule struct {
	HostFirewallRule []*HostFirewallRule `xml:"HostFirewallRule,omitempty"`
}

type HostFirewallRuleset struct {
	*DynamicData

	key          string                     `xml:"key,omitempty"`
	label        string                     `xml:"label,omitempty"`
	required     bool                       `xml:"required,omitempty"`
	rule         []*HostFirewallRule        `xml:"rule,omitempty"`
	service      string                     `xml:"service,omitempty"`
	enabled      bool                       `xml:"enabled,omitempty"`
	allowedHosts *HostFirewallRulesetIpList `xml:"allowedHosts,omitempty"`
}

type ArrayOfHostFirewallRuleset struct {
	HostFirewallRuleset []*HostFirewallRuleset `xml:"HostFirewallRuleset,omitempty"`
}

type HostRuntimeInfoNetStackInstanceRuntimeInfo struct {
	*DynamicData

	netStackInstanceKey    string   `xml:"netStackInstanceKey,omitempty"`
	state                  string   `xml:"state,omitempty"`
	vmknicKeys             []string `xml:"vmknicKeys,omitempty"`
	maxNumberOfConnections int32    `xml:"maxNumberOfConnections,omitempty"`
	currentIpV6Enabled     bool     `xml:"currentIpV6Enabled,omitempty"`
}

type ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo struct {
	HostRuntimeInfoNetStackInstanceRuntimeInfo []*HostRuntimeInfoNetStackInstanceRuntimeInfo `xml:"HostRuntimeInfoNetStackInstanceRuntimeInfo,omitempty"`
}

type HostRuntimeInfoNetworkRuntimeInfo struct {
	*DynamicData

	netStackInstanceRuntimeInfo []*HostRuntimeInfoNetStackInstanceRuntimeInfo `xml:"netStackInstanceRuntimeInfo,omitempty"`
}

type HostRuntimeInfo struct {
	*DynamicData

	connectionState            *HostSystemConnectionState                  `xml:"connectionState,omitempty"`
	powerState                 *HostSystemPowerState                       `xml:"powerState,omitempty"`
	standbyMode                string                                      `xml:"standbyMode,omitempty"`
	inMaintenanceMode          bool                                        `xml:"inMaintenanceMode,omitempty"`
	bootTime                   time.Time                                   `xml:"bootTime,omitempty"`
	healthSystemRuntime        *HealthSystemRuntime                        `xml:"healthSystemRuntime,omitempty"`
	dasHostState               *ClusterDasFdmHostState                     `xml:"dasHostState,omitempty"`
	tpmPcrValues               []*HostTpmDigestInfo                        `xml:"tpmPcrValues,omitempty"`
	vsanRuntimeInfo            *VsanHostRuntimeInfo                        `xml:"vsanRuntimeInfo,omitempty"`
	networkRuntimeInfo         *HostRuntimeInfoNetworkRuntimeInfo          `xml:"networkRuntimeInfo,omitempty"`
	vFlashResourceRuntimeInfo  *HostVFlashManagerVFlashResourceRunTimeInfo `xml:"vFlashResourceRuntimeInfo,omitempty"`
	hostMaxVirtualDiskCapacity int64                                       `xml:"hostMaxVirtualDiskCapacity,omitempty"`
}

type HostScsiDiskPartition struct {
	*DynamicData

	diskName  string `xml:"diskName,omitempty"`
	partition int32  `xml:"partition,omitempty"`
}

type ArrayOfHostScsiDiskPartition struct {
	HostScsiDiskPartition []*HostScsiDiskPartition `xml:"HostScsiDiskPartition,omitempty"`
}

type HostScsiDisk struct {
	*ScsiLun

	capacity   *HostDiskDimensionsLba `xml:"capacity,omitempty"`
	devicePath string                 `xml:"devicePath,omitempty"`
	ssd        bool                   `xml:"ssd,omitempty"`
}

type ArrayOfHostScsiDisk struct {
	HostScsiDisk []*HostScsiDisk `xml:"HostScsiDisk,omitempty"`
}

type ScsiLunCapabilities struct {
	*DynamicData

	updateDisplayNameSupported bool `xml:"updateDisplayNameSupported,omitempty"`
}

type ScsiLunDurableName struct {
	*DynamicData

	namespace   string `xml:"namespace,omitempty"`
	namespaceId int8   `xml:"namespaceId,omitempty"`
	data        []int8 `xml:"data,omitempty"`
}

type ArrayOfScsiLunDurableName struct {
	ScsiLunDurableName []*ScsiLunDurableName `xml:"ScsiLunDurableName,omitempty"`
}

type ScsiLunDescriptor struct {
	*DynamicData

	quality string `xml:"quality,omitempty"`
	id      string `xml:"id,omitempty"`
}

type ArrayOfScsiLunDescriptor struct {
	ScsiLunDescriptor []*ScsiLunDescriptor `xml:"ScsiLunDescriptor,omitempty"`
}

type ScsiLun struct {
	*HostDevice

	key              string                `xml:"key,omitempty"`
	uuid             string                `xml:"uuid,omitempty"`
	descriptor       []*ScsiLunDescriptor  `xml:"descriptor,omitempty"`
	canonicalName    string                `xml:"canonicalName,omitempty"`
	displayName      string                `xml:"displayName,omitempty"`
	lunType          string                `xml:"lunType,omitempty"`
	vendor           string                `xml:"vendor,omitempty"`
	model            string                `xml:"model,omitempty"`
	revision         string                `xml:"revision,omitempty"`
	scsiLevel        int32                 `xml:"scsiLevel,omitempty"`
	serialNumber     string                `xml:"serialNumber,omitempty"`
	durableName      *ScsiLunDurableName   `xml:"durableName,omitempty"`
	alternateName    []*ScsiLunDurableName `xml:"alternateName,omitempty"`
	standardInquiry  []int8                `xml:"standardInquiry,omitempty"`
	queueDepth       int32                 `xml:"queueDepth,omitempty"`
	operationalState []string              `xml:"operationalState,omitempty"`
	capabilities     *ScsiLunCapabilities  `xml:"capabilities,omitempty"`
	vStorageSupport  string                `xml:"vStorageSupport,omitempty"`
}

type ArrayOfScsiLun struct {
	ScsiLun []*ScsiLun `xml:"ScsiLun,omitempty"`
}

type HostScsiTopologyInterface struct {
	*DynamicData

	key     string                    `xml:"key,omitempty"`
	adapter string                    `xml:"adapter,omitempty"`
	target  []*HostScsiTopologyTarget `xml:"target,omitempty"`
}

type ArrayOfHostScsiTopologyInterface struct {
	HostScsiTopologyInterface []*HostScsiTopologyInterface `xml:"HostScsiTopologyInterface,omitempty"`
}

type HostScsiTopologyTarget struct {
	*DynamicData

	key       string                 `xml:"key,omitempty"`
	target    int32                  `xml:"target,omitempty"`
	lun       []*HostScsiTopologyLun `xml:"lun,omitempty"`
	transport *HostTargetTransport   `xml:"transport,omitempty"`
}

type ArrayOfHostScsiTopologyTarget struct {
	HostScsiTopologyTarget []*HostScsiTopologyTarget `xml:"HostScsiTopologyTarget,omitempty"`
}

type HostScsiTopologyLun struct {
	*DynamicData

	key     string `xml:"key,omitempty"`
	lun     int32  `xml:"lun,omitempty"`
	scsiLun string `xml:"scsiLun,omitempty"`
}

type ArrayOfHostScsiTopologyLun struct {
	HostScsiTopologyLun []*HostScsiTopologyLun `xml:"HostScsiTopologyLun,omitempty"`
}

type HostScsiTopology struct {
	*DynamicData

	adapter []*HostScsiTopologyInterface `xml:"adapter,omitempty"`
}

type HostSecuritySpec struct {
	*DynamicData

	adminPassword    string        `xml:"adminPassword,omitempty"`
	removePermission []*Permission `xml:"removePermission,omitempty"`
	addPermission    []*Permission `xml:"addPermission,omitempty"`
}

type HostServiceSourcePackage struct {
	*DynamicData

	sourcePackageName string `xml:"sourcePackageName,omitempty"`
	description       string `xml:"description,omitempty"`
}

type HostService struct {
	*DynamicData

	key           string                    `xml:"key,omitempty"`
	label         string                    `xml:"label,omitempty"`
	required      bool                      `xml:"required,omitempty"`
	uninstallable bool                      `xml:"uninstallable,omitempty"`
	running       bool                      `xml:"running,omitempty"`
	ruleset       []string                  `xml:"ruleset,omitempty"`
	policy        string                    `xml:"policy,omitempty"`
	sourcePackage *HostServiceSourcePackage `xml:"sourcePackage,omitempty"`
}

type ArrayOfHostService struct {
	HostService []*HostService `xml:"HostService,omitempty"`
}

type HostServiceConfig struct {
	*DynamicData

	serviceId     string `xml:"serviceId,omitempty"`
	startupPolicy string `xml:"startupPolicy,omitempty"`
}

type ArrayOfHostServiceConfig struct {
	HostServiceConfig []*HostServiceConfig `xml:"HostServiceConfig,omitempty"`
}

type HostServiceInfo struct {
	*DynamicData

	service []*HostService `xml:"service,omitempty"`
}

type HostSnmpDestination struct {
	*DynamicData

	hostName  string `xml:"hostName,omitempty"`
	port      int32  `xml:"port,omitempty"`
	community string `xml:"community,omitempty"`
}

type ArrayOfHostSnmpDestination struct {
	HostSnmpDestination []*HostSnmpDestination `xml:"HostSnmpDestination,omitempty"`
}

type HostSnmpConfigSpec struct {
	*DynamicData

	enabled             bool                   `xml:"enabled,omitempty"`
	port                int32                  `xml:"port,omitempty"`
	readOnlyCommunities []string               `xml:"readOnlyCommunities,omitempty"`
	trapTargets         []*HostSnmpDestination `xml:"trapTargets,omitempty"`
	option              []*KeyValue            `xml:"option,omitempty"`
}

type HostSnmpSystemAgentLimits struct {
	*DynamicData

	maxReadOnlyCommunities int32                    `xml:"maxReadOnlyCommunities,omitempty"`
	maxTrapDestinations    int32                    `xml:"maxTrapDestinations,omitempty"`
	maxCommunityLength     int32                    `xml:"maxCommunityLength,omitempty"`
	maxBufferSize          int32                    `xml:"maxBufferSize,omitempty"`
	capability             *HostSnmpAgentCapability `xml:"capability,omitempty"`
}

type HostSriovConfig struct {
	*HostPciPassthruConfig

	sriovEnabled       bool  `xml:"sriovEnabled,omitempty"`
	numVirtualFunction int32 `xml:"numVirtualFunction,omitempty"`
}

type HostSriovInfo struct {
	*HostPciPassthruInfo

	sriovEnabled                bool  `xml:"sriovEnabled,omitempty"`
	sriovCapable                bool  `xml:"sriovCapable,omitempty"`
	sriovActive                 bool  `xml:"sriovActive,omitempty"`
	numVirtualFunctionRequested int32 `xml:"numVirtualFunctionRequested,omitempty"`
	numVirtualFunction          int32 `xml:"numVirtualFunction,omitempty"`
	maxVirtualFunctionSupported int32 `xml:"maxVirtualFunctionSupported,omitempty"`
}

type HostSslThumbprintInfo struct {
	*DynamicData

	principal      string   `xml:"principal,omitempty"`
	ownerTag       string   `xml:"ownerTag,omitempty"`
	sslThumbprints []string `xml:"sslThumbprints,omitempty"`
}

type ArrayOfHostSslThumbprintInfo struct {
	HostSslThumbprintInfo []*HostSslThumbprintInfo `xml:"HostSslThumbprintInfo,omitempty"`
}

type HostStorageArrayTypePolicyOption struct {
	*DynamicData

	policy *ElementDescription `xml:"policy,omitempty"`
}

type ArrayOfHostStorageArrayTypePolicyOption struct {
	HostStorageArrayTypePolicyOption []*HostStorageArrayTypePolicyOption `xml:"HostStorageArrayTypePolicyOption,omitempty"`
}

type HostStorageDeviceInfo struct {
	*DynamicData

	hostBusAdapter              []*HostHostBusAdapter  `xml:"hostBusAdapter,omitempty"`
	scsiLun                     []*ScsiLun             `xml:"scsiLun,omitempty"`
	scsiTopology                *HostScsiTopology      `xml:"scsiTopology,omitempty"`
	multipathInfo               *HostMultipathInfo     `xml:"multipathInfo,omitempty"`
	plugStoreTopology           *HostPlugStoreTopology `xml:"plugStoreTopology,omitempty"`
	softwareInternetScsiEnabled bool                   `xml:"softwareInternetScsiEnabled,omitempty"`
}

type HostHardwareSummary struct {
	*DynamicData

	vendor               string                          `xml:"vendor,omitempty"`
	model                string                          `xml:"model,omitempty"`
	uuid                 string                          `xml:"uuid,omitempty"`
	otherIdentifyingInfo []*HostSystemIdentificationInfo `xml:"otherIdentifyingInfo,omitempty"`
	memorySize           int64                           `xml:"memorySize,omitempty"`
	cpuModel             string                          `xml:"cpuModel,omitempty"`
	cpuMhz               int32                           `xml:"cpuMhz,omitempty"`
	numCpuPkgs           int16                           `xml:"numCpuPkgs,omitempty"`
	numCpuCores          int16                           `xml:"numCpuCores,omitempty"`
	numCpuThreads        int16                           `xml:"numCpuThreads,omitempty"`
	numNics              int32                           `xml:"numNics,omitempty"`
	numHBAs              int32                           `xml:"numHBAs,omitempty"`
}

type HostListSummaryQuickStats struct {
	*DynamicData

	overallCpuUsage           int32 `xml:"overallCpuUsage,omitempty"`
	overallMemoryUsage        int32 `xml:"overallMemoryUsage,omitempty"`
	distributedCpuFairness    int32 `xml:"distributedCpuFairness,omitempty"`
	distributedMemoryFairness int32 `xml:"distributedMemoryFairness,omitempty"`
	uptime                    int32 `xml:"uptime,omitempty"`
}

type HostConfigSummary struct {
	*DynamicData

	name                  string                    `xml:"name,omitempty"`
	port                  int32                     `xml:"port,omitempty"`
	sslThumbprint         string                    `xml:"sslThumbprint,omitempty"`
	product               *AboutInfo                `xml:"product,omitempty"`
	vmotionEnabled        bool                      `xml:"vmotionEnabled,omitempty"`
	faultToleranceEnabled bool                      `xml:"faultToleranceEnabled,omitempty"`
	featureVersion        []*HostFeatureVersionInfo `xml:"featureVersion,omitempty"`
	agentVmDatastore      *ManagedObjectReference   `xml:"agentVmDatastore,omitempty"`
	agentVmNetwork        *ManagedObjectReference   `xml:"agentVmNetwork,omitempty"`
}

type HostListSummary struct {
	*DynamicData

	host               *ManagedObjectReference    `xml:"host,omitempty"`
	hardware           *HostHardwareSummary       `xml:"hardware,omitempty"`
	runtime            *HostRuntimeInfo           `xml:"runtime,omitempty"`
	config             *HostConfigSummary         `xml:"config,omitempty"`
	quickStats         *HostListSummaryQuickStats `xml:"quickStats,omitempty"`
	overallStatus      *ManagedEntityStatus       `xml:"overallStatus,omitempty"`
	rebootRequired     bool                       `xml:"rebootRequired,omitempty"`
	customValue        []*CustomFieldValue        `xml:"customValue,omitempty"`
	managementServerIp string                     `xml:"managementServerIp,omitempty"`
	maxEVCModeKey      string                     `xml:"maxEVCModeKey,omitempty"`
	currentEVCModeKey  string                     `xml:"currentEVCModeKey,omitempty"`
}

type HostSystemHealthInfo struct {
	*DynamicData

	numericSensorInfo []*HostNumericSensorInfo `xml:"numericSensorInfo,omitempty"`
}

type HostSystemIdentificationInfo struct {
	*DynamicData

	identifierValue string              `xml:"identifierValue,omitempty"`
	identifierType  *ElementDescription `xml:"identifierType,omitempty"`
}

type ArrayOfHostSystemIdentificationInfo struct {
	HostSystemIdentificationInfo []*HostSystemIdentificationInfo `xml:"HostSystemIdentificationInfo,omitempty"`
}

type HostSystemResourceInfo struct {
	*DynamicData

	key    string                    `xml:"key,omitempty"`
	config *ResourceConfigSpec       `xml:"config,omitempty"`
	child  []*HostSystemResourceInfo `xml:"child,omitempty"`
}

type ArrayOfHostSystemResourceInfo struct {
	HostSystemResourceInfo []*HostSystemResourceInfo `xml:"HostSystemResourceInfo,omitempty"`
}

type HostSystemSwapConfigurationSystemSwapOption struct {
	*DynamicData

	key int32 `xml:"key,omitempty"`
}

type ArrayOfHostSystemSwapConfigurationSystemSwapOption struct {
	HostSystemSwapConfigurationSystemSwapOption []*HostSystemSwapConfigurationSystemSwapOption `xml:"HostSystemSwapConfigurationSystemSwapOption,omitempty"`
}

type HostSystemSwapConfigurationDisabledOption struct {
	*HostSystemSwapConfigurationSystemSwapOption
}

type HostSystemSwapConfigurationHostCacheOption struct {
	*HostSystemSwapConfigurationSystemSwapOption
}

type HostSystemSwapConfigurationHostLocalSwapOption struct {
	*HostSystemSwapConfigurationSystemSwapOption
}

type HostSystemSwapConfigurationDatastoreOption struct {
	*HostSystemSwapConfigurationSystemSwapOption

	datastore string `xml:"datastore,omitempty"`
}

type HostSystemSwapConfiguration struct {
	*DynamicData

	option []*HostSystemSwapConfigurationSystemSwapOption `xml:"option,omitempty"`
}

type HostTargetTransport struct {
	*DynamicData
}

type HostParallelScsiTargetTransport struct {
	*HostTargetTransport
}

type HostBlockAdapterTargetTransport struct {
	*HostTargetTransport
}

type HostFibreChannelTargetTransport struct {
	*HostTargetTransport

	portWorldWideName int64 `xml:"portWorldWideName,omitempty"`
	nodeWorldWideName int64 `xml:"nodeWorldWideName,omitempty"`
}

type HostInternetScsiTargetTransport struct {
	*HostTargetTransport

	iScsiName  string   `xml:"iScsiName,omitempty"`
	iScsiAlias string   `xml:"iScsiAlias,omitempty"`
	address    []string `xml:"address,omitempty"`
}

type HostFibreChannelOverEthernetTargetTransport struct {
	*HostFibreChannelTargetTransport

	vnportMac string `xml:"vnportMac,omitempty"`
	fcfMac    string `xml:"fcfMac,omitempty"`
	vlanId    int32  `xml:"vlanId,omitempty"`
}

type HostTpmAttestationReport struct {
	*DynamicData

	tpmPcrValues   []*HostTpmDigestInfo    `xml:"tpmPcrValues,omitempty"`
	tpmEvents      []*HostTpmEventLogEntry `xml:"tpmEvents,omitempty"`
	tpmLogReliable bool                    `xml:"tpmLogReliable,omitempty"`
}

type HostTpmBootSecurityOptionEventDetails struct {
	*HostTpmEventDetails

	bootSecurityOption string `xml:"bootSecurityOption,omitempty"`
}

type HostTpmCommandEventDetails struct {
	*HostTpmEventDetails

	commandLine string `xml:"commandLine,omitempty"`
}

type HostDigestInfo struct {
	*DynamicData

	digestMethod string `xml:"digestMethod,omitempty"`
	digestValue  []int8 `xml:"digestValue,omitempty"`
	objectName   string `xml:"objectName,omitempty"`
}

type HostTpmDigestInfo struct {
	*HostDigestInfo

	pcrNumber int32 `xml:"pcrNumber,omitempty"`
}

type ArrayOfHostTpmDigestInfo struct {
	HostTpmDigestInfo []*HostTpmDigestInfo `xml:"HostTpmDigestInfo,omitempty"`
}

type HostTpmEventDetails struct {
	*DynamicData

	dataHash []int8 `xml:"dataHash,omitempty"`
}

type HostTpmEventLogEntry struct {
	*DynamicData

	pcrIndex     int32                `xml:"pcrIndex,omitempty"`
	eventDetails *HostTpmEventDetails `xml:"eventDetails,omitempty"`
}

type ArrayOfHostTpmEventLogEntry struct {
	HostTpmEventLogEntry []*HostTpmEventLogEntry `xml:"HostTpmEventLogEntry,omitempty"`
}

type HostTpmOptionEventDetails struct {
	*HostTpmEventDetails

	optionsFileName string `xml:"optionsFileName,omitempty"`
	bootOptions     []int8 `xml:"bootOptions,omitempty"`
}

type HostTpmSoftwareComponentEventDetails struct {
	*HostTpmEventDetails

	componentName string `xml:"componentName,omitempty"`
	vibName       string `xml:"vibName,omitempty"`
	vibVersion    string `xml:"vibVersion,omitempty"`
	vibVendor     string `xml:"vibVendor,omitempty"`
}

type HostUnresolvedVmfsExtent struct {
	*DynamicData

	device       *HostScsiDiskPartition `xml:"device,omitempty"`
	devicePath   string                 `xml:"devicePath,omitempty"`
	vmfsUuid     string                 `xml:"vmfsUuid,omitempty"`
	isHeadExtent bool                   `xml:"isHeadExtent,omitempty"`
	ordinal      int32                  `xml:"ordinal,omitempty"`
	startBlock   int32                  `xml:"startBlock,omitempty"`
	endBlock     int32                  `xml:"endBlock,omitempty"`
	reason       string                 `xml:"reason,omitempty"`
}

type ArrayOfHostUnresolvedVmfsExtent struct {
	HostUnresolvedVmfsExtent []*HostUnresolvedVmfsExtent `xml:"HostUnresolvedVmfsExtent,omitempty"`
}

type HostUnresolvedVmfsResignatureSpec struct {
	*DynamicData

	extentDevicePath []string `xml:"extentDevicePath,omitempty"`
}

type HostUnresolvedVmfsResolutionResult struct {
	*DynamicData

	spec  *HostUnresolvedVmfsResolutionSpec `xml:"spec,omitempty"`
	vmfs  *HostVmfsVolume                   `xml:"vmfs,omitempty"`
	fault *LocalizedMethodFault             `xml:"fault,omitempty"`
}

type ArrayOfHostUnresolvedVmfsResolutionResult struct {
	HostUnresolvedVmfsResolutionResult []*HostUnresolvedVmfsResolutionResult `xml:"HostUnresolvedVmfsResolutionResult,omitempty"`
}

type HostUnresolvedVmfsResolutionSpec struct {
	*DynamicData

	extentDevicePath []string `xml:"extentDevicePath,omitempty"`
	uuidResolution   string   `xml:"uuidResolution,omitempty"`
}

type ArrayOfHostUnresolvedVmfsResolutionSpec struct {
	HostUnresolvedVmfsResolutionSpec []*HostUnresolvedVmfsResolutionSpec `xml:"HostUnresolvedVmfsResolutionSpec,omitempty"`
}

type HostUnresolvedVmfsVolumeResolveStatus struct {
	*DynamicData

	resolvable        bool `xml:"resolvable,omitempty"`
	incompleteExtents bool `xml:"incompleteExtents,omitempty"`
	multipleCopies    bool `xml:"multipleCopies,omitempty"`
}

type HostUnresolvedVmfsVolume struct {
	*DynamicData

	extent        []*HostUnresolvedVmfsExtent            `xml:"extent,omitempty"`
	vmfsLabel     string                                 `xml:"vmfsLabel,omitempty"`
	vmfsUuid      string                                 `xml:"vmfsUuid,omitempty"`
	totalBlocks   int32                                  `xml:"totalBlocks,omitempty"`
	resolveStatus *HostUnresolvedVmfsVolumeResolveStatus `xml:"resolveStatus,omitempty"`
}

type ArrayOfHostUnresolvedVmfsVolume struct {
	HostUnresolvedVmfsVolume []*HostUnresolvedVmfsVolume `xml:"HostUnresolvedVmfsVolume,omitempty"`
}

type HostVFlashManagerVFlashResourceConfigSpec struct {
	*DynamicData

	vffsUuid string `xml:"vffsUuid,omitempty"`
}

type HostVFlashManagerVFlashResourceConfigInfo struct {
	*DynamicData

	vffs     *HostVffsVolume `xml:"vffs,omitempty"`
	capacity int64           `xml:"capacity,omitempty"`
}

type HostVFlashManagerVFlashResourceRunTimeInfo struct {
	*DynamicData

	usage              int64 `xml:"usage,omitempty"`
	capacity           int64 `xml:"capacity,omitempty"`
	accessible         bool  `xml:"accessible,omitempty"`
	capacityForVmCache int64 `xml:"capacityForVmCache,omitempty"`
	freeForVmCache     int64 `xml:"freeForVmCache,omitempty"`
}

type HostVFlashManagerVFlashCacheConfigSpec struct {
	*DynamicData

	defaultVFlashModule      string `xml:"defaultVFlashModule,omitempty"`
	swapCacheReservationInGB int64  `xml:"swapCacheReservationInGB,omitempty"`
}

type HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption struct {
	*DynamicData

	vFlashModule              string        `xml:"vFlashModule,omitempty"`
	vFlashModuleVersion       string        `xml:"vFlashModuleVersion,omitempty"`
	minSupportedModuleVersion string        `xml:"minSupportedModuleVersion,omitempty"`
	cacheConsistencyType      *ChoiceOption `xml:"cacheConsistencyType,omitempty"`
	cacheMode                 *ChoiceOption `xml:"cacheMode,omitempty"`
	blockSizeInKBOption       *LongOption   `xml:"blockSizeInKBOption,omitempty"`
	reservationInMBOption     *LongOption   `xml:"reservationInMBOption,omitempty"`
	maxDiskSizeInKB           int64         `xml:"maxDiskSizeInKB,omitempty"`
}

type ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption struct {
	HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption []*HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption `xml:"HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption,omitempty"`
}

type HostVFlashManagerVFlashCacheConfigInfo struct {
	*DynamicData

	vFlashModuleConfigOption []*HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption `xml:"vFlashModuleConfigOption,omitempty"`
	defaultVFlashModule      string                                                            `xml:"defaultVFlashModule,omitempty"`
	swapCacheReservationInGB int64                                                             `xml:"swapCacheReservationInGB,omitempty"`
}

type HostVFlashManagerVFlashConfigInfo struct {
	*DynamicData

	vFlashResourceConfigInfo *HostVFlashManagerVFlashResourceConfigInfo `xml:"vFlashResourceConfigInfo,omitempty"`
	vFlashCacheConfigInfo    *HostVFlashManagerVFlashCacheConfigInfo    `xml:"vFlashCacheConfigInfo,omitempty"`
}

type HostVFlashResourceConfigurationResult struct {
	*DynamicData

	devicePath              []string                       `xml:"devicePath,omitempty"`
	vffs                    *HostVffsVolume                `xml:"vffs,omitempty"`
	diskConfigurationResult []*HostDiskConfigurationResult `xml:"diskConfigurationResult,omitempty"`
}

type HostVMotionConfig struct {
	*DynamicData

	vmotionNicKey string `xml:"vmotionNicKey,omitempty"`
	enabled       bool   `xml:"enabled,omitempty"`
}

type HostVMotionInfo struct {
	*DynamicData

	netConfig *HostVMotionNetConfig `xml:"netConfig,omitempty"`
	ipConfig  *HostIpConfig         `xml:"ipConfig,omitempty"`
}

type HostVMotionNetConfig struct {
	*DynamicData

	candidateVnic []*HostVirtualNic `xml:"candidateVnic,omitempty"`
	selectedVnic  string            `xml:"selectedVnic,omitempty"`
}

type HostVffsSpec struct {
	*DynamicData

	devicePath   string                 `xml:"devicePath,omitempty"`
	partition    *HostDiskPartitionSpec `xml:"partition,omitempty"`
	majorVersion int32                  `xml:"majorVersion,omitempty"`
	volumeName   string                 `xml:"volumeName,omitempty"`
}

type HostVffsVolume struct {
	*HostFileSystemVolume

	majorVersion int32                    `xml:"majorVersion,omitempty"`
	version      string                   `xml:"version,omitempty"`
	uuid         string                   `xml:"uuid,omitempty"`
	extent       []*HostScsiDiskPartition `xml:"extent,omitempty"`
}

type HostVirtualNicSpec struct {
	*DynamicData

	ip                     *HostIpConfig                           `xml:"ip,omitempty"`
	mac                    string                                  `xml:"mac,omitempty"`
	distributedVirtualPort *DistributedVirtualSwitchPortConnection `xml:"distributedVirtualPort,omitempty"`
	portgroup              string                                  `xml:"portgroup,omitempty"`
	mtu                    int32                                   `xml:"mtu,omitempty"`
	tsoEnabled             bool                                    `xml:"tsoEnabled,omitempty"`
	netStackInstanceKey    string                                  `xml:"netStackInstanceKey,omitempty"`
}

type HostVirtualNicConfig struct {
	*DynamicData

	changeOperation string              `xml:"changeOperation,omitempty"`
	device          string              `xml:"device,omitempty"`
	portgroup       string              `xml:"portgroup,omitempty"`
	spec            *HostVirtualNicSpec `xml:"spec,omitempty"`
}

type ArrayOfHostVirtualNicConfig struct {
	HostVirtualNicConfig []*HostVirtualNicConfig `xml:"HostVirtualNicConfig,omitempty"`
}

type HostVirtualNic struct {
	*DynamicData

	device    string              `xml:"device,omitempty"`
	key       string              `xml:"key,omitempty"`
	portgroup string              `xml:"portgroup,omitempty"`
	spec      *HostVirtualNicSpec `xml:"spec,omitempty"`
	port      string              `xml:"port,omitempty"`
}

type ArrayOfHostVirtualNic struct {
	HostVirtualNic []*HostVirtualNic `xml:"HostVirtualNic,omitempty"`
}

type HostVirtualNicConnection struct {
	*DynamicData

	portgroup string                                  `xml:"portgroup,omitempty"`
	dvPort    *DistributedVirtualSwitchPortConnection `xml:"dvPort,omitempty"`
}

type HostVirtualNicManagerNicTypeSelection struct {
	*DynamicData

	vnic    *HostVirtualNicConnection `xml:"vnic,omitempty"`
	nicType []string                  `xml:"nicType,omitempty"`
}

type ArrayOfHostVirtualNicManagerNicTypeSelection struct {
	HostVirtualNicManagerNicTypeSelection []*HostVirtualNicManagerNicTypeSelection `xml:"HostVirtualNicManagerNicTypeSelection,omitempty"`
}

type VirtualNicManagerNetConfig struct {
	*DynamicData

	nicType            string            `xml:"nicType,omitempty"`
	multiSelectAllowed bool              `xml:"multiSelectAllowed,omitempty"`
	candidateVnic      []*HostVirtualNic `xml:"candidateVnic,omitempty"`
	selectedVnic       []string          `xml:"selectedVnic,omitempty"`
}

type ArrayOfVirtualNicManagerNetConfig struct {
	VirtualNicManagerNetConfig []*VirtualNicManagerNetConfig `xml:"VirtualNicManagerNetConfig,omitempty"`
}

type HostVirtualNicManagerInfo struct {
	*DynamicData

	netConfig []*VirtualNicManagerNetConfig `xml:"netConfig,omitempty"`
}

type HostVirtualSwitchBridge struct {
	*DynamicData
}

type HostVirtualSwitchAutoBridge struct {
	*HostVirtualSwitchBridge

	excludedNicDevice []string `xml:"excludedNicDevice,omitempty"`
}

type HostVirtualSwitchSimpleBridge struct {
	*HostVirtualSwitchBridge

	nicDevice string `xml:"nicDevice,omitempty"`
}

type HostVirtualSwitchBondBridge struct {
	*HostVirtualSwitchBridge

	nicDevice                   []string                       `xml:"nicDevice,omitempty"`
	beacon                      *HostVirtualSwitchBeaconConfig `xml:"beacon,omitempty"`
	linkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig   `xml:"linkDiscoveryProtocolConfig,omitempty"`
}

type HostVirtualSwitchBeaconConfig struct {
	*DynamicData

	interval int32 `xml:"interval,omitempty"`
}

type HostVirtualSwitchSpec struct {
	*DynamicData

	numPorts int32                    `xml:"numPorts,omitempty"`
	bridge   *HostVirtualSwitchBridge `xml:"bridge,omitempty"`
	policy   *HostNetworkPolicy       `xml:"policy,omitempty"`
	mtu      int32                    `xml:"mtu,omitempty"`
}

type HostVirtualSwitchConfig struct {
	*DynamicData

	changeOperation string                 `xml:"changeOperation,omitempty"`
	name            string                 `xml:"name,omitempty"`
	spec            *HostVirtualSwitchSpec `xml:"spec,omitempty"`
}

type ArrayOfHostVirtualSwitchConfig struct {
	HostVirtualSwitchConfig []*HostVirtualSwitchConfig `xml:"HostVirtualSwitchConfig,omitempty"`
}

type HostVirtualSwitch struct {
	*DynamicData

	name              string                 `xml:"name,omitempty"`
	key               string                 `xml:"key,omitempty"`
	numPorts          int32                  `xml:"numPorts,omitempty"`
	numPortsAvailable int32                  `xml:"numPortsAvailable,omitempty"`
	mtu               int32                  `xml:"mtu,omitempty"`
	portgroup         []string               `xml:"portgroup,omitempty"`
	pnic              []string               `xml:"pnic,omitempty"`
	spec              *HostVirtualSwitchSpec `xml:"spec,omitempty"`
}

type ArrayOfHostVirtualSwitch struct {
	HostVirtualSwitch []*HostVirtualSwitch `xml:"HostVirtualSwitch,omitempty"`
}

type HostVmciAccessManagerAccessSpec struct {
	*DynamicData

	vm       *ManagedObjectReference `xml:"vm,omitempty"`
	services []string                `xml:"services,omitempty"`
	mode     string                  `xml:"mode,omitempty"`
}

type ArrayOfHostVmciAccessManagerAccessSpec struct {
	HostVmciAccessManagerAccessSpec []*HostVmciAccessManagerAccessSpec `xml:"HostVmciAccessManagerAccessSpec,omitempty"`
}

type HostVmfsRescanResult struct {
	*DynamicData

	host  *ManagedObjectReference `xml:"host,omitempty"`
	fault *LocalizedMethodFault   `xml:"fault,omitempty"`
}

type ArrayOfHostVmfsRescanResult struct {
	HostVmfsRescanResult []*HostVmfsRescanResult `xml:"HostVmfsRescanResult,omitempty"`
}

type HostVmfsSpec struct {
	*DynamicData

	extent       *HostScsiDiskPartition `xml:"extent,omitempty"`
	blockSizeMb  int32                  `xml:"blockSizeMb,omitempty"`
	majorVersion int32                  `xml:"majorVersion,omitempty"`
	volumeName   string                 `xml:"volumeName,omitempty"`
}

type HostVmfsVolume struct {
	*HostFileSystemVolume

	blockSizeMb      int32                    `xml:"blockSizeMb,omitempty"`
	maxBlocks        int32                    `xml:"maxBlocks,omitempty"`
	majorVersion     int32                    `xml:"majorVersion,omitempty"`
	version          string                   `xml:"version,omitempty"`
	uuid             string                   `xml:"uuid,omitempty"`
	extent           []*HostScsiDiskPartition `xml:"extent,omitempty"`
	vmfsUpgradable   bool                     `xml:"vmfsUpgradable,omitempty"`
	forceMountedInfo *HostForceMountedInfo    `xml:"forceMountedInfo,omitempty"`
	ssd              bool                     `xml:"ssd,omitempty"`
	local            bool                     `xml:"local,omitempty"`
}

type HostVsanInternalSystemCmmdsQuery struct {
	*DynamicData

	type_ string `xml:"type,omitempty"`
	uuid  string `xml:"uuid,omitempty"`
	owner string `xml:"owner,omitempty"`
}

type ArrayOfHostVsanInternalSystemCmmdsQuery struct {
	HostVsanInternalSystemCmmdsQuery []*HostVsanInternalSystemCmmdsQuery `xml:"HostVsanInternalSystemCmmdsQuery,omitempty"`
}

type NetDhcpConfigInfoDhcpOptions struct {
	*DynamicData

	enable bool        `xml:"enable,omitempty"`
	config []*KeyValue `xml:"config,omitempty"`
}

type NetDhcpConfigInfo struct {
	*DynamicData

	ipv6 *NetDhcpConfigInfoDhcpOptions `xml:"ipv6,omitempty"`
	ipv4 *NetDhcpConfigInfoDhcpOptions `xml:"ipv4,omitempty"`
}

type NetDhcpConfigSpecDhcpOptionsSpec struct {
	*DynamicData

	enable    bool        `xml:"enable,omitempty"`
	config    []*KeyValue `xml:"config,omitempty"`
	operation string      `xml:"operation,omitempty"`
}

type NetDhcpConfigSpec struct {
	*DynamicData

	ipv6 *NetDhcpConfigSpecDhcpOptionsSpec `xml:"ipv6,omitempty"`
	ipv4 *NetDhcpConfigSpecDhcpOptionsSpec `xml:"ipv4,omitempty"`
}

type NetDnsConfigInfo struct {
	*DynamicData

	dhcp         bool     `xml:"dhcp,omitempty"`
	hostName     string   `xml:"hostName,omitempty"`
	domainName   string   `xml:"domainName,omitempty"`
	ipAddress    []string `xml:"ipAddress,omitempty"`
	searchDomain []string `xml:"searchDomain,omitempty"`
}

type NetDnsConfigSpec struct {
	*DynamicData

	dhcp         bool     `xml:"dhcp,omitempty"`
	hostName     string   `xml:"hostName,omitempty"`
	domainName   string   `xml:"domainName,omitempty"`
	ipAddress    []string `xml:"ipAddress,omitempty"`
	searchDomain []string `xml:"searchDomain,omitempty"`
}

type NetIpConfigInfoIpAddress struct {
	*DynamicData

	ipAddress    string    `xml:"ipAddress,omitempty"`
	prefixLength int32     `xml:"prefixLength,omitempty"`
	origin       string    `xml:"origin,omitempty"`
	state        string    `xml:"state,omitempty"`
	lifetime     time.Time `xml:"lifetime,omitempty"`
}

type ArrayOfNetIpConfigInfoIpAddress struct {
	NetIpConfigInfoIpAddress []*NetIpConfigInfoIpAddress `xml:"NetIpConfigInfoIpAddress,omitempty"`
}

type NetIpConfigInfo struct {
	*DynamicData

	ipAddress                []*NetIpConfigInfoIpAddress `xml:"ipAddress,omitempty"`
	dhcp                     *NetDhcpConfigInfo          `xml:"dhcp,omitempty"`
	autoConfigurationEnabled bool                        `xml:"autoConfigurationEnabled,omitempty"`
}

type NetIpConfigSpecIpAddressSpec struct {
	*DynamicData

	ipAddress    string `xml:"ipAddress,omitempty"`
	prefixLength int32  `xml:"prefixLength,omitempty"`
	operation    string `xml:"operation,omitempty"`
}

type ArrayOfNetIpConfigSpecIpAddressSpec struct {
	NetIpConfigSpecIpAddressSpec []*NetIpConfigSpecIpAddressSpec `xml:"NetIpConfigSpecIpAddressSpec,omitempty"`
}

type NetIpConfigSpec struct {
	*DynamicData

	ipAddress                []*NetIpConfigSpecIpAddressSpec `xml:"ipAddress,omitempty"`
	dhcp                     *NetDhcpConfigSpec              `xml:"dhcp,omitempty"`
	autoConfigurationEnabled bool                            `xml:"autoConfigurationEnabled,omitempty"`
}

type NetIpRouteConfigInfoGateway struct {
	*DynamicData

	ipAddress string `xml:"ipAddress,omitempty"`
	device    string `xml:"device,omitempty"`
}

type NetIpRouteConfigInfoIpRoute struct {
	*DynamicData

	network      string                       `xml:"network,omitempty"`
	prefixLength int32                        `xml:"prefixLength,omitempty"`
	gateway      *NetIpRouteConfigInfoGateway `xml:"gateway,omitempty"`
}

type ArrayOfNetIpRouteConfigInfoIpRoute struct {
	NetIpRouteConfigInfoIpRoute []*NetIpRouteConfigInfoIpRoute `xml:"NetIpRouteConfigInfoIpRoute,omitempty"`
}

type NetIpRouteConfigInfo struct {
	*DynamicData

	ipRoute []*NetIpRouteConfigInfoIpRoute `xml:"ipRoute,omitempty"`
}

type NetIpRouteConfigSpecGatewaySpec struct {
	*DynamicData

	ipAddress string `xml:"ipAddress,omitempty"`
	device    string `xml:"device,omitempty"`
}

type NetIpRouteConfigSpecIpRouteSpec struct {
	*DynamicData

	network      string                           `xml:"network,omitempty"`
	prefixLength int32                            `xml:"prefixLength,omitempty"`
	gateway      *NetIpRouteConfigSpecGatewaySpec `xml:"gateway,omitempty"`
	operation    string                           `xml:"operation,omitempty"`
}

type ArrayOfNetIpRouteConfigSpecIpRouteSpec struct {
	NetIpRouteConfigSpecIpRouteSpec []*NetIpRouteConfigSpecIpRouteSpec `xml:"NetIpRouteConfigSpecIpRouteSpec,omitempty"`
}

type NetIpRouteConfigSpec struct {
	*DynamicData

	ipRoute []*NetIpRouteConfigSpecIpRouteSpec `xml:"ipRoute,omitempty"`
}

type NetIpStackInfoNetToMedia struct {
	*DynamicData

	ipAddress       string `xml:"ipAddress,omitempty"`
	physicalAddress string `xml:"physicalAddress,omitempty"`
	device          string `xml:"device,omitempty"`
	type_           string `xml:"type,omitempty"`
}

type ArrayOfNetIpStackInfoNetToMedia struct {
	NetIpStackInfoNetToMedia []*NetIpStackInfoNetToMedia `xml:"NetIpStackInfoNetToMedia,omitempty"`
}

type NetIpStackInfoDefaultRouter struct {
	*DynamicData

	ipAddress  string    `xml:"ipAddress,omitempty"`
	device     string    `xml:"device,omitempty"`
	lifetime   time.Time `xml:"lifetime,omitempty"`
	preference string    `xml:"preference,omitempty"`
}

type ArrayOfNetIpStackInfoDefaultRouter struct {
	NetIpStackInfoDefaultRouter []*NetIpStackInfoDefaultRouter `xml:"NetIpStackInfoDefaultRouter,omitempty"`
}

type NetIpStackInfo struct {
	*DynamicData

	neighbor      []*NetIpStackInfoNetToMedia    `xml:"neighbor,omitempty"`
	defaultRouter []*NetIpStackInfoDefaultRouter `xml:"defaultRouter,omitempty"`
}

type NetBIOSConfigInfo struct {
	*DynamicData

	mode string `xml:"mode,omitempty"`
}

type WinNetBIOSConfigInfo struct {
	*NetBIOSConfigInfo

	primaryWINS   string `xml:"primaryWINS,omitempty"`
	secondaryWINS string `xml:"secondaryWINS,omitempty"`
}

type ArrayUpdateSpec struct {
	*DynamicData

	operation *ArrayUpdateOperation `xml:"operation,omitempty"`
	removeKey interface{}           `xml:"removeKey,omitempty"`
}

type BoolOption struct {
	*OptionType

	supported    bool `xml:"supported,omitempty"`
	defaultValue bool `xml:"defaultValue,omitempty"`
}

type ChoiceOption struct {
	*OptionType

	choiceInfo   []*ElementDescription `xml:"choiceInfo,omitempty"`
	defaultIndex int32                 `xml:"defaultIndex,omitempty"`
}

type FloatOption struct {
	*OptionType

	min          float32 `xml:"min,omitempty"`
	max          float32 `xml:"max,omitempty"`
	defaultValue float32 `xml:"defaultValue,omitempty"`
}

type IntOption struct {
	*OptionType

	min          int32 `xml:"min,omitempty"`
	max          int32 `xml:"max,omitempty"`
	defaultValue int32 `xml:"defaultValue,omitempty"`
}

type LongOption struct {
	*OptionType

	min          int64 `xml:"min,omitempty"`
	max          int64 `xml:"max,omitempty"`
	defaultValue int64 `xml:"defaultValue,omitempty"`
}

type OptionDef struct {
	*ElementDescription

	optionType *OptionType `xml:"optionType,omitempty"`
}

type ArrayOfOptionDef struct {
	OptionDef []*OptionDef `xml:"OptionDef,omitempty"`
}

type OptionType struct {
	*DynamicData

	valueIsReadonly bool `xml:"valueIsReadonly,omitempty"`
}

type OptionValue struct {
	*DynamicData

	key   string      `xml:"key,omitempty"`
	value interface{} `xml:"value,omitempty"`
}

type ArrayOfOptionValue struct {
	OptionValue []*OptionValue `xml:"OptionValue,omitempty"`
}

type StringOption struct {
	*OptionType

	defaultValue    string `xml:"defaultValue,omitempty"`
	validCharacters string `xml:"validCharacters,omitempty"`
}

type ApplyProfile struct {
	*DynamicData

	enabled         bool                           `xml:"enabled,omitempty"`
	policy          []*ProfilePolicy               `xml:"policy,omitempty"`
	profileTypeName string                         `xml:"profileTypeName,omitempty"`
	profileVersion  string                         `xml:"profileVersion,omitempty"`
	property        []*ProfileApplyProfileProperty `xml:"property,omitempty"`
}

type ArrayOfApplyProfile struct {
	ApplyProfile []*ApplyProfile `xml:"ApplyProfile,omitempty"`
}

type ProfileApplyProfileElement struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ProfileApplyProfileProperty struct {
	*DynamicData

	propertyName string          `xml:"propertyName,omitempty"`
	array        bool            `xml:"array,omitempty"`
	profile      []*ApplyProfile `xml:"profile,omitempty"`
}

type ArrayOfProfileApplyProfileProperty struct {
	ProfileApplyProfileProperty []*ProfileApplyProfileProperty `xml:"ProfileApplyProfileProperty,omitempty"`
}

type ComplianceLocator struct {
	*DynamicData

	expressionName string               `xml:"expressionName,omitempty"`
	applyPath      *ProfilePropertyPath `xml:"applyPath,omitempty"`
}

type ArrayOfComplianceLocator struct {
	ComplianceLocator []*ComplianceLocator `xml:"ComplianceLocator,omitempty"`
}

type ComplianceProfile struct {
	*DynamicData

	expression     []*ProfileExpression `xml:"expression,omitempty"`
	rootExpression string               `xml:"rootExpression,omitempty"`
}

type ComplianceFailure struct {
	*DynamicData

	failureType    string              `xml:"failureType,omitempty"`
	message        *LocalizableMessage `xml:"message,omitempty"`
	expressionName string              `xml:"expressionName,omitempty"`
}

type ArrayOfComplianceFailure struct {
	ComplianceFailure []*ComplianceFailure `xml:"ComplianceFailure,omitempty"`
}

type ComplianceResult struct {
	*DynamicData

	profile          *ManagedObjectReference `xml:"profile,omitempty"`
	complianceStatus string                  `xml:"complianceStatus,omitempty"`
	entity           *ManagedObjectReference `xml:"entity,omitempty"`
	checkTime        time.Time               `xml:"checkTime,omitempty"`
	failure          []*ComplianceFailure    `xml:"failure,omitempty"`
}

type ArrayOfComplianceResult struct {
	ComplianceResult []*ComplianceResult `xml:"ComplianceResult,omitempty"`
}

type ProfileDeferredPolicyOptionParameter struct {
	*DynamicData

	inputPath *ProfilePropertyPath `xml:"inputPath,omitempty"`
	parameter []*KeyAnyValue       `xml:"parameter,omitempty"`
}

type ArrayOfProfileDeferredPolicyOptionParameter struct {
	ProfileDeferredPolicyOptionParameter []*ProfileDeferredPolicyOptionParameter `xml:"ProfileDeferredPolicyOptionParameter,omitempty"`
}

type ProfileExpression struct {
	*DynamicData

	id          string `xml:"id,omitempty"`
	displayName string `xml:"displayName,omitempty"`
	negated     bool   `xml:"negated,omitempty"`
}

type ArrayOfProfileExpression struct {
	ProfileExpression []*ProfileExpression `xml:"ProfileExpression,omitempty"`
}

type ProfileSimpleExpression struct {
	*ProfileExpression

	expressionType string         `xml:"expressionType,omitempty"`
	parameter      []*KeyAnyValue `xml:"parameter,omitempty"`
}

type ProfileCompositeExpression struct {
	*ProfileExpression

	operator       string   `xml:"operator,omitempty"`
	expressionName []string `xml:"expressionName,omitempty"`
}

type ProfileExpressionMetadata struct {
	*DynamicData

	expressionId *ExtendedElementDescription `xml:"expressionId,omitempty"`
	parameter    []*ProfileParameterMetadata `xml:"parameter,omitempty"`
}

type ArrayOfProfileExpressionMetadata struct {
	ProfileExpressionMetadata []*ProfileExpressionMetadata `xml:"ProfileExpressionMetadata,omitempty"`
}

type ProfileParameterMetadata struct {
	*DynamicData

	id           *ExtendedElementDescription `xml:"id,omitempty"`
	type_        string                      `xml:"type,omitempty"`
	optional     bool                        `xml:"optional,omitempty"`
	defaultValue interface{}                 `xml:"defaultValue,omitempty"`
}

type ArrayOfProfileParameterMetadata struct {
	ProfileParameterMetadata []*ProfileParameterMetadata `xml:"ProfileParameterMetadata,omitempty"`
}

type ProfilePolicy struct {
	*DynamicData

	id           string        `xml:"id,omitempty"`
	policyOption *PolicyOption `xml:"policyOption,omitempty"`
}

type ArrayOfProfilePolicy struct {
	ProfilePolicy []*ProfilePolicy `xml:"ProfilePolicy,omitempty"`
}

type ProfilePolicyOptionMetadata struct {
	*DynamicData

	id        *ExtendedElementDescription `xml:"id,omitempty"`
	parameter []*ProfileParameterMetadata `xml:"parameter,omitempty"`
}

type ArrayOfProfilePolicyOptionMetadata struct {
	ProfilePolicyOptionMetadata []*ProfilePolicyOptionMetadata `xml:"ProfilePolicyOptionMetadata,omitempty"`
}

type ProfileCompositePolicyOptionMetadata struct {
	*ProfilePolicyOptionMetadata

	option []string `xml:"option,omitempty"`
}

type UserInputRequiredParameterMetadata struct {
	*ProfilePolicyOptionMetadata

	userInputParameter []*ProfileParameterMetadata `xml:"userInputParameter,omitempty"`
}

type ProfilePolicyMetadata struct {
	*DynamicData

	id             *ExtendedElementDescription    `xml:"id,omitempty"`
	possibleOption []*ProfilePolicyOptionMetadata `xml:"possibleOption,omitempty"`
}

type ArrayOfProfilePolicyMetadata struct {
	ProfilePolicyMetadata []*ProfilePolicyMetadata `xml:"ProfilePolicyMetadata,omitempty"`
}

type PolicyOption struct {
	*DynamicData

	id        string         `xml:"id,omitempty"`
	parameter []*KeyAnyValue `xml:"parameter,omitempty"`
}

type ArrayOfPolicyOption struct {
	PolicyOption []*PolicyOption `xml:"PolicyOption,omitempty"`
}

type CompositePolicyOption struct {
	*PolicyOption

	option []*PolicyOption `xml:"option,omitempty"`
}

type ProfileCreateSpec struct {
	*DynamicData

	name       string `xml:"name,omitempty"`
	annotation string `xml:"annotation,omitempty"`
	enabled    bool   `xml:"enabled,omitempty"`
}

type ProfileSerializedCreateSpec struct {
	*ProfileCreateSpec

	profileConfigString string `xml:"profileConfigString,omitempty"`
}

type ProfileConfigInfo struct {
	*DynamicData

	name       string `xml:"name,omitempty"`
	annotation string `xml:"annotation,omitempty"`
	enabled    bool   `xml:"enabled,omitempty"`
}

type ProfileDescriptionSection struct {
	*DynamicData

	description *ExtendedElementDescription `xml:"description,omitempty"`
	message     []*LocalizableMessage       `xml:"message,omitempty"`
}

type ArrayOfProfileDescriptionSection struct {
	ProfileDescriptionSection []*ProfileDescriptionSection `xml:"ProfileDescriptionSection,omitempty"`
}

type ProfileDescription struct {
	*DynamicData

	section []*ProfileDescriptionSection `xml:"section,omitempty"`
}

type ProfileMetadataProfileSortSpec struct {
	*DynamicData

	policyId  string `xml:"policyId,omitempty"`
	parameter string `xml:"parameter,omitempty"`
}

type ArrayOfProfileMetadataProfileSortSpec struct {
	ProfileMetadataProfileSortSpec []*ProfileMetadataProfileSortSpec `xml:"ProfileMetadataProfileSortSpec,omitempty"`
}

type ProfileMetadata struct {
	*DynamicData

	key              string                            `xml:"key,omitempty"`
	profileTypeName  string                            `xml:"profileTypeName,omitempty"`
	description      *ExtendedDescription              `xml:"description,omitempty"`
	sortSpec         []*ProfileMetadataProfileSortSpec `xml:"sortSpec,omitempty"`
	profileCategory  string                            `xml:"profileCategory,omitempty"`
	profileComponent string                            `xml:"profileComponent,omitempty"`
}

type ArrayOfProfileMetadata struct {
	ProfileMetadata []*ProfileMetadata `xml:"ProfileMetadata,omitempty"`
}

type ProfilePropertyPath struct {
	*DynamicData

	profilePath string `xml:"profilePath,omitempty"`
	policyId    string `xml:"policyId,omitempty"`
	parameterId string `xml:"parameterId,omitempty"`
}

type ArrayOfProfilePropertyPath struct {
	ProfilePropertyPath []*ProfilePropertyPath `xml:"ProfilePropertyPath,omitempty"`
}

type ProfileProfileStructure struct {
	*DynamicData

	profileTypeName string                             `xml:"profileTypeName,omitempty"`
	child           []*ProfileProfileStructureProperty `xml:"child,omitempty"`
}

type ProfileProfileStructureProperty struct {
	*DynamicData

	propertyName string                   `xml:"propertyName,omitempty"`
	array        bool                     `xml:"array,omitempty"`
	element      *ProfileProfileStructure `xml:"element,omitempty"`
}

type ArrayOfProfileProfileStructureProperty struct {
	ProfileProfileStructureProperty []*ProfileProfileStructureProperty `xml:"ProfileProfileStructureProperty,omitempty"`
}

type ClusterProfileConfigInfo struct {
	*ProfileConfigInfo

	complyProfile *ComplianceProfile `xml:"complyProfile,omitempty"`
}

type ClusterProfileCreateSpec struct {
	*ProfileCreateSpec
}

type ClusterProfileConfigSpec struct {
	*ClusterProfileCreateSpec
}

type ClusterProfileCompleteConfigSpec struct {
	*ClusterProfileConfigSpec

	complyProfile *ComplianceProfile `xml:"complyProfile,omitempty"`
}

type ClusterProfileConfigServiceCreateSpec struct {
	*ClusterProfileConfigSpec

	serviceType []string `xml:"serviceType,omitempty"`
}

type AnswerFile struct {
	*DynamicData

	userInput    []*ProfileDeferredPolicyOptionParameter `xml:"userInput,omitempty"`
	createdTime  time.Time                               `xml:"createdTime,omitempty"`
	modifiedTime time.Time                               `xml:"modifiedTime,omitempty"`
}

type AnswerFileStatusError struct {
	*DynamicData

	userInputPath *ProfilePropertyPath `xml:"userInputPath,omitempty"`
	errMsg        *LocalizableMessage  `xml:"errMsg,omitempty"`
}

type ArrayOfAnswerFileStatusError struct {
	AnswerFileStatusError []*AnswerFileStatusError `xml:"AnswerFileStatusError,omitempty"`
}

type AnswerFileStatusResult struct {
	*DynamicData

	checkedTime time.Time                `xml:"checkedTime,omitempty"`
	host        *ManagedObjectReference  `xml:"host,omitempty"`
	status      string                   `xml:"status,omitempty"`
	error       []*AnswerFileStatusError `xml:"error,omitempty"`
}

type ArrayOfAnswerFileStatusResult struct {
	AnswerFileStatusResult []*AnswerFileStatusResult `xml:"AnswerFileStatusResult,omitempty"`
}

type ProfileExecuteError struct {
	*DynamicData

	path    *ProfilePropertyPath `xml:"path,omitempty"`
	message *LocalizableMessage  `xml:"message,omitempty"`
}

type ArrayOfProfileExecuteError struct {
	ProfileExecuteError []*ProfileExecuteError `xml:"ProfileExecuteError,omitempty"`
}

type ProfileExecuteResult struct {
	*DynamicData

	status           string                                  `xml:"status,omitempty"`
	configSpec       *HostConfigSpec                         `xml:"configSpec,omitempty"`
	inapplicablePath []string                                `xml:"inapplicablePath,omitempty"`
	requireInput     []*ProfileDeferredPolicyOptionParameter `xml:"requireInput,omitempty"`
	error            []*ProfileExecuteError                  `xml:"error,omitempty"`
}

type HostApplyProfile struct {
	*ApplyProfile

	memory           *HostMemoryProfile     `xml:"memory,omitempty"`
	storage          *StorageProfile        `xml:"storage,omitempty"`
	network          *NetworkProfile        `xml:"network,omitempty"`
	datetime         *DateTimeProfile       `xml:"datetime,omitempty"`
	firewall         *FirewallProfile       `xml:"firewall,omitempty"`
	security         *SecurityProfile       `xml:"security,omitempty"`
	service          []*ServiceProfile      `xml:"service,omitempty"`
	option           []*OptionProfile       `xml:"option,omitempty"`
	userAccount      []*UserProfile         `xml:"userAccount,omitempty"`
	usergroupAccount []*UserGroupProfile    `xml:"usergroupAccount,omitempty"`
	authentication   *AuthenticationProfile `xml:"authentication,omitempty"`
}

type PhysicalNicProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfPhysicalNicProfile struct {
	PhysicalNicProfile []*PhysicalNicProfile `xml:"PhysicalNicProfile,omitempty"`
}

type HostMemoryProfile struct {
	*ApplyProfile
}

type UserProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfUserProfile struct {
	UserProfile []*UserProfile `xml:"UserProfile,omitempty"`
}

type UserGroupProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfUserGroupProfile struct {
	UserGroupProfile []*UserGroupProfile `xml:"UserGroupProfile,omitempty"`
}

type SecurityProfile struct {
	*ApplyProfile

	permission []*PermissionProfile `xml:"permission,omitempty"`
}

type OptionProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfOptionProfile struct {
	OptionProfile []*OptionProfile `xml:"OptionProfile,omitempty"`
}

type DateTimeProfile struct {
	*ApplyProfile
}

type ServiceProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfServiceProfile struct {
	ServiceProfile []*ServiceProfile `xml:"ServiceProfile,omitempty"`
}

type FirewallProfileRulesetProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfFirewallProfileRulesetProfile struct {
	FirewallProfileRulesetProfile []*FirewallProfileRulesetProfile `xml:"FirewallProfileRulesetProfile,omitempty"`
}

type FirewallProfile struct {
	*ApplyProfile

	ruleset []*FirewallProfileRulesetProfile `xml:"ruleset,omitempty"`
}

type NasStorageProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfNasStorageProfile struct {
	NasStorageProfile []*NasStorageProfile `xml:"NasStorageProfile,omitempty"`
}

type StorageProfile struct {
	*ApplyProfile

	nasStorage []*NasStorageProfile `xml:"nasStorage,omitempty"`
}

type NetworkProfileDnsConfigProfile struct {
	*ApplyProfile
}

type NetworkProfile struct {
	*ApplyProfile

	vswitch                 []*VirtualSwitchProfile           `xml:"vswitch,omitempty"`
	vmPortGroup             []*VmPortGroupProfile             `xml:"vmPortGroup,omitempty"`
	hostPortGroup           []*HostPortGroupProfile           `xml:"hostPortGroup,omitempty"`
	serviceConsolePortGroup []*ServiceConsolePortGroupProfile `xml:"serviceConsolePortGroup,omitempty"`
	dnsConfig               *NetworkProfileDnsConfigProfile   `xml:"dnsConfig,omitempty"`
	ipRouteConfig           *IpRouteProfile                   `xml:"ipRouteConfig,omitempty"`
	consoleIpRouteConfig    *IpRouteProfile                   `xml:"consoleIpRouteConfig,omitempty"`
	pnic                    []*PhysicalNicProfile             `xml:"pnic,omitempty"`
	dvswitch                []*DvsProfile                     `xml:"dvswitch,omitempty"`
	dvsServiceConsoleNic    []*DvsServiceConsoleVNicProfile   `xml:"dvsServiceConsoleNic,omitempty"`
	dvsHostNic              []*DvsHostVNicProfile             `xml:"dvsHostNic,omitempty"`
	netStackInstance        []*NetStackInstanceProfile        `xml:"netStackInstance,omitempty"`
}

type DvsVNicProfile struct {
	*ApplyProfile

	key      string            `xml:"key,omitempty"`
	ipConfig *IpAddressProfile `xml:"ipConfig,omitempty"`
}

type DvsServiceConsoleVNicProfile struct {
	*DvsVNicProfile
}

type ArrayOfDvsServiceConsoleVNicProfile struct {
	DvsServiceConsoleVNicProfile []*DvsServiceConsoleVNicProfile `xml:"DvsServiceConsoleVNicProfile,omitempty"`
}

type DvsHostVNicProfile struct {
	*DvsVNicProfile
}

type ArrayOfDvsHostVNicProfile struct {
	DvsHostVNicProfile []*DvsHostVNicProfile `xml:"DvsHostVNicProfile,omitempty"`
}

type DvsProfile struct {
	*ApplyProfile

	key    string               `xml:"key,omitempty"`
	name   string               `xml:"name,omitempty"`
	uplink []*PnicUplinkProfile `xml:"uplink,omitempty"`
}

type ArrayOfDvsProfile struct {
	DvsProfile []*DvsProfile `xml:"DvsProfile,omitempty"`
}

type PnicUplinkProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfPnicUplinkProfile struct {
	PnicUplinkProfile []*PnicUplinkProfile `xml:"PnicUplinkProfile,omitempty"`
}

type IpRouteProfile struct {
	*ApplyProfile

	staticRoute []*StaticRouteProfile `xml:"staticRoute,omitempty"`
}

type StaticRouteProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfStaticRouteProfile struct {
	StaticRouteProfile []*StaticRouteProfile `xml:"StaticRouteProfile,omitempty"`
}

type LinkProfile struct {
	*ApplyProfile
}

type NumPortsProfile struct {
	*ApplyProfile
}

type VirtualSwitchProfile struct {
	*ApplyProfile

	key           string                `xml:"key,omitempty"`
	name          string                `xml:"name,omitempty"`
	link          *LinkProfile          `xml:"link,omitempty"`
	numPorts      *NumPortsProfile      `xml:"numPorts,omitempty"`
	networkPolicy *NetworkPolicyProfile `xml:"networkPolicy,omitempty"`
}

type ArrayOfVirtualSwitchProfile struct {
	VirtualSwitchProfile []*VirtualSwitchProfile `xml:"VirtualSwitchProfile,omitempty"`
}

type NetStackInstanceProfile struct {
	*ApplyProfile

	key           string                          `xml:"key,omitempty"`
	dnsConfig     *NetworkProfileDnsConfigProfile `xml:"dnsConfig,omitempty"`
	ipRouteConfig *IpRouteProfile                 `xml:"ipRouteConfig,omitempty"`
}

type ArrayOfNetStackInstanceProfile struct {
	NetStackInstanceProfile []*NetStackInstanceProfile `xml:"NetStackInstanceProfile,omitempty"`
}

type VlanProfile struct {
	*ApplyProfile
}

type VirtualSwitchSelectionProfile struct {
	*ApplyProfile
}

type PortGroupProfile struct {
	*ApplyProfile

	key           string                         `xml:"key,omitempty"`
	name          string                         `xml:"name,omitempty"`
	vlan          *VlanProfile                   `xml:"vlan,omitempty"`
	vswitch       *VirtualSwitchSelectionProfile `xml:"vswitch,omitempty"`
	networkPolicy *NetworkPolicyProfile          `xml:"networkPolicy,omitempty"`
}

type VmPortGroupProfile struct {
	*PortGroupProfile
}

type ArrayOfVmPortGroupProfile struct {
	VmPortGroupProfile []*VmPortGroupProfile `xml:"VmPortGroupProfile,omitempty"`
}

type HostPortGroupProfile struct {
	*PortGroupProfile

	ipConfig *IpAddressProfile `xml:"ipConfig,omitempty"`
}

type ArrayOfHostPortGroupProfile struct {
	HostPortGroupProfile []*HostPortGroupProfile `xml:"HostPortGroupProfile,omitempty"`
}

type ServiceConsolePortGroupProfile struct {
	*PortGroupProfile

	ipConfig *IpAddressProfile `xml:"ipConfig,omitempty"`
}

type ArrayOfServiceConsolePortGroupProfile struct {
	ServiceConsolePortGroupProfile []*ServiceConsolePortGroupProfile `xml:"ServiceConsolePortGroupProfile,omitempty"`
}

type NetworkPolicyProfile struct {
	*ApplyProfile
}

type IpAddressProfile struct {
	*ApplyProfile
}

type AuthenticationProfile struct {
	*ApplyProfile

	activeDirectory *ActiveDirectoryProfile `xml:"activeDirectory,omitempty"`
}

type ActiveDirectoryProfile struct {
	*ApplyProfile
}

type PermissionProfile struct {
	*ApplyProfile

	key string `xml:"key,omitempty"`
}

type ArrayOfPermissionProfile struct {
	PermissionProfile []*PermissionProfile `xml:"PermissionProfile,omitempty"`
}

type HostProfileConfigInfo struct {
	*ProfileConfigInfo

	applyProfile           *HostApplyProfile    `xml:"applyProfile,omitempty"`
	defaultComplyProfile   *ComplianceProfile   `xml:"defaultComplyProfile,omitempty"`
	defaultComplyLocator   []*ComplianceLocator `xml:"defaultComplyLocator,omitempty"`
	customComplyProfile    *ComplianceProfile   `xml:"customComplyProfile,omitempty"`
	disabledExpressionList []string             `xml:"disabledExpressionList,omitempty"`
}

type HostProfileConfigSpec struct {
	*ProfileCreateSpec
}

type HostProfileSerializedHostProfileSpec struct {
	*ProfileSerializedCreateSpec

	validatorHost *ManagedObjectReference `xml:"validatorHost,omitempty"`
}

type HostProfileCompleteConfigSpec struct {
	*HostProfileConfigSpec

	applyProfile                  *HostApplyProfile       `xml:"applyProfile,omitempty"`
	customComplyProfile           *ComplianceProfile      `xml:"customComplyProfile,omitempty"`
	disabledExpressionListChanged bool                    `xml:"disabledExpressionListChanged,omitempty"`
	disabledExpressionList        []string                `xml:"disabledExpressionList,omitempty"`
	validatorHost                 *ManagedObjectReference `xml:"validatorHost,omitempty"`
}

type HostProfileHostBasedConfigSpec struct {
	*HostProfileConfigSpec

	host                 *ManagedObjectReference `xml:"host,omitempty"`
	useHostProfileEngine bool                    `xml:"useHostProfileEngine,omitempty"`
}

type HostProfileManagerConfigTaskList struct {
	*DynamicData

	configSpec      *HostConfigSpec       `xml:"configSpec,omitempty"`
	taskDescription []*LocalizableMessage `xml:"taskDescription,omitempty"`
}

type AnswerFileCreateSpec struct {
	*DynamicData
}

type AnswerFileOptionsCreateSpec struct {
	*AnswerFileCreateSpec

	userInput []*ProfileDeferredPolicyOptionParameter `xml:"userInput,omitempty"`
}

type AnswerFileSerializedCreateSpec struct {
	*AnswerFileCreateSpec

	answerFileConfigString string `xml:"answerFileConfigString,omitempty"`
}

type ScheduledTaskDetail struct {
	*TypeDescription

	frequency string `xml:"frequency,omitempty"`
}

type ArrayOfScheduledTaskDetail struct {
	ScheduledTaskDetail []*ScheduledTaskDetail `xml:"ScheduledTaskDetail,omitempty"`
}

type ScheduledTaskDescription struct {
	*DynamicData

	action        []*TypeDescription     `xml:"action,omitempty"`
	schedulerInfo []*ScheduledTaskDetail `xml:"schedulerInfo,omitempty"`
	state         []*ElementDescription  `xml:"state,omitempty"`
	dayOfWeek     []*ElementDescription  `xml:"dayOfWeek,omitempty"`
	weekOfMonth   []*ElementDescription  `xml:"weekOfMonth,omitempty"`
}

type ScheduledTaskInfo struct {
	*ScheduledTaskSpec

	scheduledTask    *ManagedObjectReference `xml:"scheduledTask,omitempty"`
	entity           *ManagedObjectReference `xml:"entity,omitempty"`
	lastModifiedTime time.Time               `xml:"lastModifiedTime,omitempty"`
	lastModifiedUser string                  `xml:"lastModifiedUser,omitempty"`
	nextRunTime      time.Time               `xml:"nextRunTime,omitempty"`
	prevRunTime      time.Time               `xml:"prevRunTime,omitempty"`
	state            *TaskInfoState          `xml:"state,omitempty"`
	error            *LocalizedMethodFault   `xml:"error,omitempty"`
	result           interface{}             `xml:"result,omitempty"`
	progress         int32                   `xml:"progress,omitempty"`
	activeTask       *ManagedObjectReference `xml:"activeTask,omitempty"`
	taskObject       *ManagedObjectReference `xml:"taskObject,omitempty"`
}

type TaskScheduler struct {
	*DynamicData

	activeTime time.Time `xml:"activeTime,omitempty"`
	expireTime time.Time `xml:"expireTime,omitempty"`
}

type AfterStartupTaskScheduler struct {
	*TaskScheduler

	minute int32 `xml:"minute,omitempty"`
}

type OnceTaskScheduler struct {
	*TaskScheduler

	runAt time.Time `xml:"runAt,omitempty"`
}

type RecurrentTaskScheduler struct {
	*TaskScheduler

	interval int32 `xml:"interval,omitempty"`
}

type HourlyTaskScheduler struct {
	*RecurrentTaskScheduler

	minute int32 `xml:"minute,omitempty"`
}

type DailyTaskScheduler struct {
	*HourlyTaskScheduler

	hour int32 `xml:"hour,omitempty"`
}

type WeeklyTaskScheduler struct {
	*DailyTaskScheduler

	sunday    bool `xml:"sunday,omitempty"`
	monday    bool `xml:"monday,omitempty"`
	tuesday   bool `xml:"tuesday,omitempty"`
	wednesday bool `xml:"wednesday,omitempty"`
	thursday  bool `xml:"thursday,omitempty"`
	friday    bool `xml:"friday,omitempty"`
	saturday  bool `xml:"saturday,omitempty"`
}

type MonthlyTaskScheduler struct {
	*DailyTaskScheduler
}

type MonthlyByDayTaskScheduler struct {
	*MonthlyTaskScheduler

	day int32 `xml:"day,omitempty"`
}

type MonthlyByWeekdayTaskScheduler struct {
	*MonthlyTaskScheduler

	offset  *WeekOfMonth `xml:"offset,omitempty"`
	weekday *DayOfWeek   `xml:"weekday,omitempty"`
}

type ScheduledTaskSpec struct {
	*DynamicData

	name         string         `xml:"name,omitempty"`
	description  string         `xml:"description,omitempty"`
	enabled      bool           `xml:"enabled,omitempty"`
	scheduler    *TaskScheduler `xml:"scheduler,omitempty"`
	action       *Action        `xml:"action,omitempty"`
	notification string         `xml:"notification,omitempty"`
}

type ApplyStorageRecommendationResult struct {
	*DynamicData

	vm *ManagedObjectReference `xml:"vm,omitempty"`
}

type StorageDrsConfigInfo struct {
	*DynamicData

	podConfig *StorageDrsPodConfigInfo  `xml:"podConfig,omitempty"`
	vmConfig  []*StorageDrsVmConfigInfo `xml:"vmConfig,omitempty"`
}

type StorageDrsConfigSpec struct {
	*DynamicData

	podConfigSpec *StorageDrsPodConfigSpec  `xml:"podConfigSpec,omitempty"`
	vmConfigSpec  []*StorageDrsVmConfigSpec `xml:"vmConfigSpec,omitempty"`
}

type StorageDrsVmConfigSpec struct {
	*ArrayUpdateSpec

	info *StorageDrsVmConfigInfo `xml:"info,omitempty"`
}

type ArrayOfStorageDrsVmConfigSpec struct {
	StorageDrsVmConfigSpec []*StorageDrsVmConfigSpec `xml:"StorageDrsVmConfigSpec,omitempty"`
}

type StorageDrsPodConfigInfo struct {
	*DynamicData

	enabled                bool                              `xml:"enabled,omitempty"`
	ioLoadBalanceEnabled   bool                              `xml:"ioLoadBalanceEnabled,omitempty"`
	defaultVmBehavior      string                            `xml:"defaultVmBehavior,omitempty"`
	loadBalanceInterval    int32                             `xml:"loadBalanceInterval,omitempty"`
	defaultIntraVmAffinity bool                              `xml:"defaultIntraVmAffinity,omitempty"`
	spaceLoadBalanceConfig *StorageDrsSpaceLoadBalanceConfig `xml:"spaceLoadBalanceConfig,omitempty"`
	ioLoadBalanceConfig    *StorageDrsIoLoadBalanceConfig    `xml:"ioLoadBalanceConfig,omitempty"`
	rule                   []*ClusterRuleInfo                `xml:"rule,omitempty"`
	option                 []*OptionValue                    `xml:"option,omitempty"`
}

type StorageDrsSpaceLoadBalanceConfig struct {
	*DynamicData

	spaceUtilizationThreshold     int32 `xml:"spaceUtilizationThreshold,omitempty"`
	minSpaceUtilizationDifference int32 `xml:"minSpaceUtilizationDifference,omitempty"`
}

type StorageDrsIoLoadBalanceConfig struct {
	*DynamicData

	ioLatencyThreshold       int32 `xml:"ioLatencyThreshold,omitempty"`
	ioLoadImbalanceThreshold int32 `xml:"ioLoadImbalanceThreshold,omitempty"`
}

type StorageDrsPodConfigSpec struct {
	*DynamicData

	enabled                bool                              `xml:"enabled,omitempty"`
	ioLoadBalanceEnabled   bool                              `xml:"ioLoadBalanceEnabled,omitempty"`
	defaultVmBehavior      string                            `xml:"defaultVmBehavior,omitempty"`
	loadBalanceInterval    int32                             `xml:"loadBalanceInterval,omitempty"`
	defaultIntraVmAffinity bool                              `xml:"defaultIntraVmAffinity,omitempty"`
	spaceLoadBalanceConfig *StorageDrsSpaceLoadBalanceConfig `xml:"spaceLoadBalanceConfig,omitempty"`
	ioLoadBalanceConfig    *StorageDrsIoLoadBalanceConfig    `xml:"ioLoadBalanceConfig,omitempty"`
	rule                   []*ClusterRuleSpec                `xml:"rule,omitempty"`
	option                 []*StorageDrsOptionSpec           `xml:"option,omitempty"`
}

type StorageDrsOptionSpec struct {
	*ArrayUpdateSpec

	option *OptionValue `xml:"option,omitempty"`
}

type ArrayOfStorageDrsOptionSpec struct {
	StorageDrsOptionSpec []*StorageDrsOptionSpec `xml:"StorageDrsOptionSpec,omitempty"`
}

type VmPodConfigForPlacement struct {
	*DynamicData

	storagePod  *ManagedObjectReference `xml:"storagePod,omitempty"`
	disk        []*PodDiskLocator       `xml:"disk,omitempty"`
	vmConfig    *StorageDrsVmConfigInfo `xml:"vmConfig,omitempty"`
	interVmRule []*ClusterRuleInfo      `xml:"interVmRule,omitempty"`
}

type ArrayOfVmPodConfigForPlacement struct {
	VmPodConfigForPlacement []*VmPodConfigForPlacement `xml:"VmPodConfigForPlacement,omitempty"`
}

type PodDiskLocator struct {
	*DynamicData

	diskId          int32                        `xml:"diskId,omitempty"`
	diskMoveType    string                       `xml:"diskMoveType,omitempty"`
	diskBackingInfo *VirtualDeviceBackingInfo    `xml:"diskBackingInfo,omitempty"`
	profile         []*VirtualMachineProfileSpec `xml:"profile,omitempty"`
}

type ArrayOfPodDiskLocator struct {
	PodDiskLocator []*PodDiskLocator `xml:"PodDiskLocator,omitempty"`
}

type StorageDrsPodSelectionSpec struct {
	*DynamicData

	initialVmConfig []*VmPodConfigForPlacement `xml:"initialVmConfig,omitempty"`
	storagePod      *ManagedObjectReference    `xml:"storagePod,omitempty"`
}

type StorageMigrationAction struct {
	*ClusterAction

	vm                 *ManagedObjectReference     `xml:"vm,omitempty"`
	relocateSpec       *VirtualMachineRelocateSpec `xml:"relocateSpec,omitempty"`
	source             *ManagedObjectReference     `xml:"source,omitempty"`
	destination        *ManagedObjectReference     `xml:"destination,omitempty"`
	sizeTransferred    int64                       `xml:"sizeTransferred,omitempty"`
	spaceUtilSrcBefore float32                     `xml:"spaceUtilSrcBefore,omitempty"`
	spaceUtilDstBefore float32                     `xml:"spaceUtilDstBefore,omitempty"`
	spaceUtilSrcAfter  float32                     `xml:"spaceUtilSrcAfter,omitempty"`
	spaceUtilDstAfter  float32                     `xml:"spaceUtilDstAfter,omitempty"`
	ioLatencySrcBefore float32                     `xml:"ioLatencySrcBefore,omitempty"`
	ioLatencyDstBefore float32                     `xml:"ioLatencyDstBefore,omitempty"`
}

type StoragePlacementAction struct {
	*ClusterAction

	vm              *ManagedObjectReference     `xml:"vm,omitempty"`
	relocateSpec    *VirtualMachineRelocateSpec `xml:"relocateSpec,omitempty"`
	destination     *ManagedObjectReference     `xml:"destination,omitempty"`
	spaceUtilBefore float32                     `xml:"spaceUtilBefore,omitempty"`
	spaceUtilAfter  float32                     `xml:"spaceUtilAfter,omitempty"`
	ioLatencyBefore float32                     `xml:"ioLatencyBefore,omitempty"`
}

type StoragePlacementResult struct {
	*DynamicData

	recommendations []*ClusterRecommendation `xml:"recommendations,omitempty"`
	drsFault        *ClusterDrsFaults        `xml:"drsFault,omitempty"`
	task            *ManagedObjectReference  `xml:"task,omitempty"`
}

type StoragePlacementSpec struct {
	*DynamicData

	type_                     string                      `xml:"type,omitempty"`
	priority                  *VirtualMachineMovePriority `xml:"priority,omitempty"`
	vm                        *ManagedObjectReference     `xml:"vm,omitempty"`
	podSelectionSpec          *StorageDrsPodSelectionSpec `xml:"podSelectionSpec,omitempty"`
	cloneSpec                 *VirtualMachineCloneSpec    `xml:"cloneSpec,omitempty"`
	cloneName                 string                      `xml:"cloneName,omitempty"`
	configSpec                *VirtualMachineConfigSpec   `xml:"configSpec,omitempty"`
	relocateSpec              *VirtualMachineRelocateSpec `xml:"relocateSpec,omitempty"`
	resourcePool              *ManagedObjectReference     `xml:"resourcePool,omitempty"`
	host                      *ManagedObjectReference     `xml:"host,omitempty"`
	folder                    *ManagedObjectReference     `xml:"folder,omitempty"`
	disallowPrerequisiteMoves bool                        `xml:"disallowPrerequisiteMoves,omitempty"`
	resourceLeaseDurationSec  int32                       `xml:"resourceLeaseDurationSec,omitempty"`
}

type VirtualDiskAntiAffinityRuleSpec struct {
	*ClusterRuleInfo

	diskId []int32 `xml:"diskId,omitempty"`
}

type StorageDrsVmConfigInfo struct {
	*DynamicData

	vm                  *ManagedObjectReference          `xml:"vm,omitempty"`
	enabled             bool                             `xml:"enabled,omitempty"`
	behavior            string                           `xml:"behavior,omitempty"`
	intraVmAffinity     bool                             `xml:"intraVmAffinity,omitempty"`
	intraVmAntiAffinity *VirtualDiskAntiAffinityRuleSpec `xml:"intraVmAntiAffinity,omitempty"`
}

type ArrayOfStorageDrsVmConfigInfo struct {
	StorageDrsVmConfigInfo []*StorageDrsVmConfigInfo `xml:"StorageDrsVmConfigInfo,omitempty"`
}

type VAppCloneSpecNetworkMappingPair struct {
	*DynamicData

	source      *ManagedObjectReference `xml:"source,omitempty"`
	destination *ManagedObjectReference `xml:"destination,omitempty"`
}

type ArrayOfVAppCloneSpecNetworkMappingPair struct {
	VAppCloneSpecNetworkMappingPair []*VAppCloneSpecNetworkMappingPair `xml:"VAppCloneSpecNetworkMappingPair,omitempty"`
}

type VAppCloneSpecResourceMap struct {
	*DynamicData

	source       *ManagedObjectReference `xml:"source,omitempty"`
	parent       *ManagedObjectReference `xml:"parent,omitempty"`
	resourceSpec *ResourceConfigSpec     `xml:"resourceSpec,omitempty"`
	location     *ManagedObjectReference `xml:"location,omitempty"`
}

type ArrayOfVAppCloneSpecResourceMap struct {
	VAppCloneSpecResourceMap []*VAppCloneSpecResourceMap `xml:"VAppCloneSpecResourceMap,omitempty"`
}

type VAppCloneSpec struct {
	*DynamicData

	location        *ManagedObjectReference            `xml:"location,omitempty"`
	host            *ManagedObjectReference            `xml:"host,omitempty"`
	resourceSpec    *ResourceConfigSpec                `xml:"resourceSpec,omitempty"`
	vmFolder        *ManagedObjectReference            `xml:"vmFolder,omitempty"`
	networkMapping  []*VAppCloneSpecNetworkMappingPair `xml:"networkMapping,omitempty"`
	property        []*KeyValue                        `xml:"property,omitempty"`
	resourceMapping []*VAppCloneSpecResourceMap        `xml:"resourceMapping,omitempty"`
	provisioning    string                             `xml:"provisioning,omitempty"`
}

type VAppEntityConfigInfo struct {
	*DynamicData

	key               *ManagedObjectReference `xml:"key,omitempty"`
	tag               string                  `xml:"tag,omitempty"`
	startOrder        int32                   `xml:"startOrder,omitempty"`
	startDelay        int32                   `xml:"startDelay,omitempty"`
	waitingForGuest   bool                    `xml:"waitingForGuest,omitempty"`
	startAction       string                  `xml:"startAction,omitempty"`
	stopDelay         int32                   `xml:"stopDelay,omitempty"`
	stopAction        string                  `xml:"stopAction,omitempty"`
	destroyWithParent bool                    `xml:"destroyWithParent,omitempty"`
}

type ArrayOfVAppEntityConfigInfo struct {
	VAppEntityConfigInfo []*VAppEntityConfigInfo `xml:"VAppEntityConfigInfo,omitempty"`
}

type VAppIPAssignmentInfo struct {
	*DynamicData

	supportedAllocationScheme []string `xml:"supportedAllocationScheme,omitempty"`
	ipAllocationPolicy        string   `xml:"ipAllocationPolicy,omitempty"`
	supportedIpProtocol       []string `xml:"supportedIpProtocol,omitempty"`
	ipProtocol                string   `xml:"ipProtocol,omitempty"`
}

type IpPoolIpPoolConfigInfo struct {
	*DynamicData

	subnetAddress       string   `xml:"subnetAddress,omitempty"`
	netmask             string   `xml:"netmask,omitempty"`
	gateway             string   `xml:"gateway,omitempty"`
	range_              string   `xml:"range,omitempty"`
	dns                 []string `xml:"dns,omitempty"`
	dhcpServerAvailable bool     `xml:"dhcpServerAvailable,omitempty"`
	ipPoolEnabled       bool     `xml:"ipPoolEnabled,omitempty"`
}

type IpPoolAssociation struct {
	*DynamicData

	network     *ManagedObjectReference `xml:"network,omitempty"`
	networkName string                  `xml:"networkName,omitempty"`
}

type ArrayOfIpPoolAssociation struct {
	IpPoolAssociation []*IpPoolAssociation `xml:"IpPoolAssociation,omitempty"`
}

type IpPool struct {
	*DynamicData

	id                     int32                   `xml:"id,omitempty"`
	name                   string                  `xml:"name,omitempty"`
	ipv4Config             *IpPoolIpPoolConfigInfo `xml:"ipv4Config,omitempty"`
	ipv6Config             *IpPoolIpPoolConfigInfo `xml:"ipv6Config,omitempty"`
	dnsDomain              string                  `xml:"dnsDomain,omitempty"`
	dnsSearchPath          string                  `xml:"dnsSearchPath,omitempty"`
	hostPrefix             string                  `xml:"hostPrefix,omitempty"`
	httpProxy              string                  `xml:"httpProxy,omitempty"`
	networkAssociation     []*IpPoolAssociation    `xml:"networkAssociation,omitempty"`
	availableIpv4Addresses int32                   `xml:"availableIpv4Addresses,omitempty"`
	availableIpv6Addresses int32                   `xml:"availableIpv6Addresses,omitempty"`
	allocatedIpv4Addresses int32                   `xml:"allocatedIpv4Addresses,omitempty"`
	allocatedIpv6Addresses int32                   `xml:"allocatedIpv6Addresses,omitempty"`
}

type ArrayOfIpPool struct {
	IpPool []*IpPool `xml:"IpPool,omitempty"`
}

type VAppOvfSectionInfo struct {
	*DynamicData

	key             int32  `xml:"key,omitempty"`
	namespace       string `xml:"namespace,omitempty"`
	type_           string `xml:"type,omitempty"`
	atEnvelopeLevel bool   `xml:"atEnvelopeLevel,omitempty"`
	contents        string `xml:"contents,omitempty"`
}

type ArrayOfVAppOvfSectionInfo struct {
	VAppOvfSectionInfo []*VAppOvfSectionInfo `xml:"VAppOvfSectionInfo,omitempty"`
}

type VAppProductInfo struct {
	*DynamicData

	key         int32  `xml:"key,omitempty"`
	classId     string `xml:"classId,omitempty"`
	instanceId  string `xml:"instanceId,omitempty"`
	name        string `xml:"name,omitempty"`
	vendor      string `xml:"vendor,omitempty"`
	version     string `xml:"version,omitempty"`
	fullVersion string `xml:"fullVersion,omitempty"`
	vendorUrl   string `xml:"vendorUrl,omitempty"`
	productUrl  string `xml:"productUrl,omitempty"`
	appUrl      string `xml:"appUrl,omitempty"`
}

type ArrayOfVAppProductInfo struct {
	VAppProductInfo []*VAppProductInfo `xml:"VAppProductInfo,omitempty"`
}

type VAppPropertyInfo struct {
	*DynamicData

	key              int32  `xml:"key,omitempty"`
	classId          string `xml:"classId,omitempty"`
	instanceId       string `xml:"instanceId,omitempty"`
	id               string `xml:"id,omitempty"`
	category         string `xml:"category,omitempty"`
	label            string `xml:"label,omitempty"`
	type_            string `xml:"type,omitempty"`
	typeReference    string `xml:"typeReference,omitempty"`
	userConfigurable bool   `xml:"userConfigurable,omitempty"`
	defaultValue     string `xml:"defaultValue,omitempty"`
	value            string `xml:"value,omitempty"`
	description      string `xml:"description,omitempty"`
}

type ArrayOfVAppPropertyInfo struct {
	VAppPropertyInfo []*VAppPropertyInfo `xml:"VAppPropertyInfo,omitempty"`
}

type VAppConfigInfo struct {
	*VmConfigInfo

	entityConfig []*VAppEntityConfigInfo `xml:"entityConfig,omitempty"`
	annotation   string                  `xml:"annotation,omitempty"`
	instanceUuid string                  `xml:"instanceUuid,omitempty"`
	managedBy    *ManagedByInfo          `xml:"managedBy,omitempty"`
}

type VAppConfigSpec struct {
	*VmConfigSpec

	entityConfig []*VAppEntityConfigInfo `xml:"entityConfig,omitempty"`
	annotation   string                  `xml:"annotation,omitempty"`
	instanceUuid string                  `xml:"instanceUuid,omitempty"`
	managedBy    *ManagedByInfo          `xml:"managedBy,omitempty"`
}

type VirtualAppImportSpec struct {
	*ImportSpec

	name             string              `xml:"name,omitempty"`
	vAppConfigSpec   *VAppConfigSpec     `xml:"vAppConfigSpec,omitempty"`
	resourcePoolSpec *ResourceConfigSpec `xml:"resourcePoolSpec,omitempty"`
	child            []*ImportSpec       `xml:"child,omitempty"`
}

type VmConfigInfo struct {
	*DynamicData

	product                 []*VAppProductInfo    `xml:"product,omitempty"`
	property                []*VAppPropertyInfo   `xml:"property,omitempty"`
	ipAssignment            *VAppIPAssignmentInfo `xml:"ipAssignment,omitempty"`
	eula                    []string              `xml:"eula,omitempty"`
	ovfSection              []*VAppOvfSectionInfo `xml:"ovfSection,omitempty"`
	ovfEnvironmentTransport []string              `xml:"ovfEnvironmentTransport,omitempty"`
	installBootRequired     bool                  `xml:"installBootRequired,omitempty"`
	installBootStopDelay    int32                 `xml:"installBootStopDelay,omitempty"`
}

type VmConfigSpec struct {
	*DynamicData

	product                 []*VAppProductSpec    `xml:"product,omitempty"`
	property                []*VAppPropertySpec   `xml:"property,omitempty"`
	ipAssignment            *VAppIPAssignmentInfo `xml:"ipAssignment,omitempty"`
	eula                    []string              `xml:"eula,omitempty"`
	ovfSection              []*VAppOvfSectionSpec `xml:"ovfSection,omitempty"`
	ovfEnvironmentTransport []string              `xml:"ovfEnvironmentTransport,omitempty"`
	installBootRequired     bool                  `xml:"installBootRequired,omitempty"`
	installBootStopDelay    int32                 `xml:"installBootStopDelay,omitempty"`
}

type VAppProductSpec struct {
	*ArrayUpdateSpec

	info *VAppProductInfo `xml:"info,omitempty"`
}

type ArrayOfVAppProductSpec struct {
	VAppProductSpec []*VAppProductSpec `xml:"VAppProductSpec,omitempty"`
}

type VAppPropertySpec struct {
	*ArrayUpdateSpec

	info *VAppPropertyInfo `xml:"info,omitempty"`
}

type ArrayOfVAppPropertySpec struct {
	VAppPropertySpec []*VAppPropertySpec `xml:"VAppPropertySpec,omitempty"`
}

type VAppOvfSectionSpec struct {
	*ArrayUpdateSpec

	info *VAppOvfSectionInfo `xml:"info,omitempty"`
}

type ArrayOfVAppOvfSectionSpec struct {
	VAppOvfSectionSpec []*VAppOvfSectionSpec `xml:"VAppOvfSectionSpec,omitempty"`
}

type VirtualMachineAffinityInfo struct {
	*DynamicData

	affinitySet []int32 `xml:"affinitySet,omitempty"`
}

type VirtualMachineBootOptionsBootableDevice struct {
	*DynamicData
}

type ArrayOfVirtualMachineBootOptionsBootableDevice struct {
	VirtualMachineBootOptionsBootableDevice []*VirtualMachineBootOptionsBootableDevice `xml:"VirtualMachineBootOptionsBootableDevice,omitempty"`
}

type VirtualMachineBootOptionsBootableDiskDevice struct {
	*VirtualMachineBootOptionsBootableDevice

	deviceKey int32 `xml:"deviceKey,omitempty"`
}

type VirtualMachineBootOptionsBootableEthernetDevice struct {
	*VirtualMachineBootOptionsBootableDevice

	deviceKey int32 `xml:"deviceKey,omitempty"`
}

type VirtualMachineBootOptionsBootableFloppyDevice struct {
	*VirtualMachineBootOptionsBootableDevice
}

type VirtualMachineBootOptionsBootableCdromDevice struct {
	*VirtualMachineBootOptionsBootableDevice
}

type VirtualMachineBootOptions struct {
	*DynamicData

	bootDelay        int64                                      `xml:"bootDelay,omitempty"`
	enterBIOSSetup   bool                                       `xml:"enterBIOSSetup,omitempty"`
	bootRetryEnabled bool                                       `xml:"bootRetryEnabled,omitempty"`
	bootRetryDelay   int64                                      `xml:"bootRetryDelay,omitempty"`
	bootOrder        []*VirtualMachineBootOptionsBootableDevice `xml:"bootOrder,omitempty"`
}

type VirtualMachineCapability struct {
	*DynamicData

	snapshotOperationsSupported         bool `xml:"snapshotOperationsSupported,omitempty"`
	multipleSnapshotsSupported          bool `xml:"multipleSnapshotsSupported,omitempty"`
	snapshotConfigSupported             bool `xml:"snapshotConfigSupported,omitempty"`
	poweredOffSnapshotsSupported        bool `xml:"poweredOffSnapshotsSupported,omitempty"`
	memorySnapshotsSupported            bool `xml:"memorySnapshotsSupported,omitempty"`
	revertToSnapshotSupported           bool `xml:"revertToSnapshotSupported,omitempty"`
	quiescedSnapshotsSupported          bool `xml:"quiescedSnapshotsSupported,omitempty"`
	disableSnapshotsSupported           bool `xml:"disableSnapshotsSupported,omitempty"`
	lockSnapshotsSupported              bool `xml:"lockSnapshotsSupported,omitempty"`
	consolePreferencesSupported         bool `xml:"consolePreferencesSupported,omitempty"`
	cpuFeatureMaskSupported             bool `xml:"cpuFeatureMaskSupported,omitempty"`
	s1AcpiManagementSupported           bool `xml:"s1AcpiManagementSupported,omitempty"`
	settingScreenResolutionSupported    bool `xml:"settingScreenResolutionSupported,omitempty"`
	toolsAutoUpdateSupported            bool `xml:"toolsAutoUpdateSupported,omitempty"`
	vmNpivWwnSupported                  bool `xml:"vmNpivWwnSupported,omitempty"`
	npivWwnOnNonRdmVmSupported          bool `xml:"npivWwnOnNonRdmVmSupported,omitempty"`
	vmNpivWwnDisableSupported           bool `xml:"vmNpivWwnDisableSupported,omitempty"`
	vmNpivWwnUpdateSupported            bool `xml:"vmNpivWwnUpdateSupported,omitempty"`
	swapPlacementSupported              bool `xml:"swapPlacementSupported,omitempty"`
	toolsSyncTimeSupported              bool `xml:"toolsSyncTimeSupported,omitempty"`
	virtualMmuUsageSupported            bool `xml:"virtualMmuUsageSupported,omitempty"`
	diskSharesSupported                 bool `xml:"diskSharesSupported,omitempty"`
	bootOptionsSupported                bool `xml:"bootOptionsSupported,omitempty"`
	bootRetryOptionsSupported           bool `xml:"bootRetryOptionsSupported,omitempty"`
	settingVideoRamSizeSupported        bool `xml:"settingVideoRamSizeSupported,omitempty"`
	settingDisplayTopologySupported     bool `xml:"settingDisplayTopologySupported,omitempty"`
	recordReplaySupported               bool `xml:"recordReplaySupported,omitempty"`
	changeTrackingSupported             bool `xml:"changeTrackingSupported,omitempty"`
	multipleCoresPerSocketSupported     bool `xml:"multipleCoresPerSocketSupported,omitempty"`
	hostBasedReplicationSupported       bool `xml:"hostBasedReplicationSupported,omitempty"`
	guestAutoLockSupported              bool `xml:"guestAutoLockSupported,omitempty"`
	memoryReservationLockSupported      bool `xml:"memoryReservationLockSupported,omitempty"`
	featureRequirementSupported         bool `xml:"featureRequirementSupported,omitempty"`
	poweredOnMonitorTypeChangeSupported bool `xml:"poweredOnMonitorTypeChangeSupported,omitempty"`
	seSparseDiskSupported               bool `xml:"seSparseDiskSupported,omitempty"`
	nestedHVSupported                   bool `xml:"nestedHVSupported,omitempty"`
	vPMCSupported                       bool `xml:"vPMCSupported,omitempty"`
}

type VirtualMachineCdromInfo struct {
	*VirtualMachineTargetInfo
}

type ArrayOfVirtualMachineCdromInfo struct {
	VirtualMachineCdromInfo []*VirtualMachineCdromInfo `xml:"VirtualMachineCdromInfo,omitempty"`
}

type VirtualMachineCloneSpec struct {
	*DynamicData

	location      *VirtualMachineRelocateSpec `xml:"location,omitempty"`
	template      bool                        `xml:"template,omitempty"`
	config        *VirtualMachineConfigSpec   `xml:"config,omitempty"`
	customization *CustomizationSpec          `xml:"customization,omitempty"`
	powerOn       bool                        `xml:"powerOn,omitempty"`
	snapshot      *ManagedObjectReference     `xml:"snapshot,omitempty"`
	memory        bool                        `xml:"memory,omitempty"`
}

type VirtualMachineConfigInfoDatastoreUrlPair struct {
	*DynamicData

	name string `xml:"name,omitempty"`
	url  string `xml:"url,omitempty"`
}

type ArrayOfVirtualMachineConfigInfoDatastoreUrlPair struct {
	VirtualMachineConfigInfoDatastoreUrlPair []*VirtualMachineConfigInfoDatastoreUrlPair `xml:"VirtualMachineConfigInfoDatastoreUrlPair,omitempty"`
}

type VirtualMachineConfigInfoOverheadInfo struct {
	*DynamicData

	initialMemoryReservation int64 `xml:"initialMemoryReservation,omitempty"`
	initialSwapReservation   int64 `xml:"initialSwapReservation,omitempty"`
}

type VirtualMachineConfigInfo struct {
	*DynamicData

	changeVersion                string                                      `xml:"changeVersion,omitempty"`
	modified                     time.Time                                   `xml:"modified,omitempty"`
	name                         string                                      `xml:"name,omitempty"`
	guestFullName                string                                      `xml:"guestFullName,omitempty"`
	version                      string                                      `xml:"version,omitempty"`
	uuid                         string                                      `xml:"uuid,omitempty"`
	instanceUuid                 string                                      `xml:"instanceUuid,omitempty"`
	npivNodeWorldWideName        []int64                                     `xml:"npivNodeWorldWideName,omitempty"`
	npivPortWorldWideName        []int64                                     `xml:"npivPortWorldWideName,omitempty"`
	npivWorldWideNameType        string                                      `xml:"npivWorldWideNameType,omitempty"`
	npivDesiredNodeWwns          int16                                       `xml:"npivDesiredNodeWwns,omitempty"`
	npivDesiredPortWwns          int16                                       `xml:"npivDesiredPortWwns,omitempty"`
	npivTemporaryDisabled        bool                                        `xml:"npivTemporaryDisabled,omitempty"`
	npivOnNonRdmDisks            bool                                        `xml:"npivOnNonRdmDisks,omitempty"`
	locationId                   string                                      `xml:"locationId,omitempty"`
	template                     bool                                        `xml:"template,omitempty"`
	guestId                      string                                      `xml:"guestId,omitempty"`
	alternateGuestName           string                                      `xml:"alternateGuestName,omitempty"`
	annotation                   string                                      `xml:"annotation,omitempty"`
	files                        *VirtualMachineFileInfo                     `xml:"files,omitempty"`
	tools                        *ToolsConfigInfo                            `xml:"tools,omitempty"`
	flags                        *VirtualMachineFlagInfo                     `xml:"flags,omitempty"`
	consolePreferences           *VirtualMachineConsolePreferences           `xml:"consolePreferences,omitempty"`
	defaultPowerOps              *VirtualMachineDefaultPowerOpInfo           `xml:"defaultPowerOps,omitempty"`
	hardware                     *VirtualHardware                            `xml:"hardware,omitempty"`
	cpuAllocation                *ResourceAllocationInfo                     `xml:"cpuAllocation,omitempty"`
	memoryAllocation             *ResourceAllocationInfo                     `xml:"memoryAllocation,omitempty"`
	latencySensitivity           *LatencySensitivity                         `xml:"latencySensitivity,omitempty"`
	memoryHotAddEnabled          bool                                        `xml:"memoryHotAddEnabled,omitempty"`
	cpuHotAddEnabled             bool                                        `xml:"cpuHotAddEnabled,omitempty"`
	cpuHotRemoveEnabled          bool                                        `xml:"cpuHotRemoveEnabled,omitempty"`
	hotPlugMemoryLimit           int64                                       `xml:"hotPlugMemoryLimit,omitempty"`
	hotPlugMemoryIncrementSize   int64                                       `xml:"hotPlugMemoryIncrementSize,omitempty"`
	cpuAffinity                  *VirtualMachineAffinityInfo                 `xml:"cpuAffinity,omitempty"`
	memoryAffinity               *VirtualMachineAffinityInfo                 `xml:"memoryAffinity,omitempty"`
	networkShaper                *VirtualMachineNetworkShaperInfo            `xml:"networkShaper,omitempty"`
	extraConfig                  []*OptionValue                              `xml:"extraConfig,omitempty"`
	cpuFeatureMask               []*HostCpuIdInfo                            `xml:"cpuFeatureMask,omitempty"`
	datastoreUrl                 []*VirtualMachineConfigInfoDatastoreUrlPair `xml:"datastoreUrl,omitempty"`
	swapPlacement                string                                      `xml:"swapPlacement,omitempty"`
	bootOptions                  *VirtualMachineBootOptions                  `xml:"bootOptions,omitempty"`
	ftInfo                       *FaultToleranceConfigInfo                   `xml:"ftInfo,omitempty"`
	vAppConfig                   *VmConfigInfo                               `xml:"vAppConfig,omitempty"`
	vAssertsEnabled              bool                                        `xml:"vAssertsEnabled,omitempty"`
	changeTrackingEnabled        bool                                        `xml:"changeTrackingEnabled,omitempty"`
	firmware                     string                                      `xml:"firmware,omitempty"`
	maxMksConnections            int32                                       `xml:"maxMksConnections,omitempty"`
	guestAutoLockEnabled         bool                                        `xml:"guestAutoLockEnabled,omitempty"`
	managedBy                    *ManagedByInfo                              `xml:"managedBy,omitempty"`
	memoryReservationLockedToMax bool                                        `xml:"memoryReservationLockedToMax,omitempty"`
	initialOverhead              *VirtualMachineConfigInfoOverheadInfo       `xml:"initialOverhead,omitempty"`
	nestedHVEnabled              bool                                        `xml:"nestedHVEnabled,omitempty"`
	vPMCEnabled                  bool                                        `xml:"vPMCEnabled,omitempty"`
	scheduledHardwareUpgradeInfo *ScheduledHardwareUpgradeInfo               `xml:"scheduledHardwareUpgradeInfo,omitempty"`
	vFlashCacheReservation       int64                                       `xml:"vFlashCacheReservation,omitempty"`
}

type VirtualMachineConfigOption struct {
	*DynamicData

	version                          string                    `xml:"version,omitempty"`
	description                      string                    `xml:"description,omitempty"`
	guestOSDescriptor                []*GuestOsDescriptor      `xml:"guestOSDescriptor,omitempty"`
	guestOSDefaultIndex              int32                     `xml:"guestOSDefaultIndex,omitempty"`
	hardwareOptions                  *VirtualHardwareOption    `xml:"hardwareOptions,omitempty"`
	capabilities                     *VirtualMachineCapability `xml:"capabilities,omitempty"`
	datastore                        *DatastoreOption          `xml:"datastore,omitempty"`
	defaultDevice                    []*VirtualDevice          `xml:"defaultDevice,omitempty"`
	supportedMonitorType             []string                  `xml:"supportedMonitorType,omitempty"`
	supportedOvfEnvironmentTransport []string                  `xml:"supportedOvfEnvironmentTransport,omitempty"`
	supportedOvfInstallTransport     []string                  `xml:"supportedOvfInstallTransport,omitempty"`
}

type VirtualMachineConfigOptionDescriptor struct {
	*DynamicData

	key                 string                    `xml:"key,omitempty"`
	description         string                    `xml:"description,omitempty"`
	host                []*ManagedObjectReference `xml:"host,omitempty"`
	createSupported     bool                      `xml:"createSupported,omitempty"`
	defaultConfigOption bool                      `xml:"defaultConfigOption,omitempty"`
	runSupported        bool                      `xml:"runSupported,omitempty"`
	upgradeSupported    bool                      `xml:"upgradeSupported,omitempty"`
}

type ArrayOfVirtualMachineConfigOptionDescriptor struct {
	VirtualMachineConfigOptionDescriptor []*VirtualMachineConfigOptionDescriptor `xml:"VirtualMachineConfigOptionDescriptor,omitempty"`
}

type VirtualMachineCpuIdInfoSpec struct {
	*ArrayUpdateSpec

	info *HostCpuIdInfo `xml:"info,omitempty"`
}

type ArrayOfVirtualMachineCpuIdInfoSpec struct {
	VirtualMachineCpuIdInfoSpec []*VirtualMachineCpuIdInfoSpec `xml:"VirtualMachineCpuIdInfoSpec,omitempty"`
}

type VirtualMachineConfigSpec struct {
	*DynamicData

	changeVersion                string                            `xml:"changeVersion,omitempty"`
	name                         string                            `xml:"name,omitempty"`
	version                      string                            `xml:"version,omitempty"`
	uuid                         string                            `xml:"uuid,omitempty"`
	instanceUuid                 string                            `xml:"instanceUuid,omitempty"`
	npivNodeWorldWideName        []int64                           `xml:"npivNodeWorldWideName,omitempty"`
	npivPortWorldWideName        []int64                           `xml:"npivPortWorldWideName,omitempty"`
	npivWorldWideNameType        string                            `xml:"npivWorldWideNameType,omitempty"`
	npivDesiredNodeWwns          int16                             `xml:"npivDesiredNodeWwns,omitempty"`
	npivDesiredPortWwns          int16                             `xml:"npivDesiredPortWwns,omitempty"`
	npivTemporaryDisabled        bool                              `xml:"npivTemporaryDisabled,omitempty"`
	npivOnNonRdmDisks            bool                              `xml:"npivOnNonRdmDisks,omitempty"`
	npivWorldWideNameOp          string                            `xml:"npivWorldWideNameOp,omitempty"`
	locationId                   string                            `xml:"locationId,omitempty"`
	guestId                      string                            `xml:"guestId,omitempty"`
	alternateGuestName           string                            `xml:"alternateGuestName,omitempty"`
	annotation                   string                            `xml:"annotation,omitempty"`
	files                        *VirtualMachineFileInfo           `xml:"files,omitempty"`
	tools                        *ToolsConfigInfo                  `xml:"tools,omitempty"`
	flags                        *VirtualMachineFlagInfo           `xml:"flags,omitempty"`
	consolePreferences           *VirtualMachineConsolePreferences `xml:"consolePreferences,omitempty"`
	powerOpInfo                  *VirtualMachineDefaultPowerOpInfo `xml:"powerOpInfo,omitempty"`
	numCPUs                      int32                             `xml:"numCPUs,omitempty"`
	numCoresPerSocket            int32                             `xml:"numCoresPerSocket,omitempty"`
	memoryMB                     int64                             `xml:"memoryMB,omitempty"`
	memoryHotAddEnabled          bool                              `xml:"memoryHotAddEnabled,omitempty"`
	cpuHotAddEnabled             bool                              `xml:"cpuHotAddEnabled,omitempty"`
	cpuHotRemoveEnabled          bool                              `xml:"cpuHotRemoveEnabled,omitempty"`
	virtualICH7MPresent          bool                              `xml:"virtualICH7MPresent,omitempty"`
	virtualSMCPresent            bool                              `xml:"virtualSMCPresent,omitempty"`
	deviceChange                 []*VirtualDeviceConfigSpec        `xml:"deviceChange,omitempty"`
	cpuAllocation                *ResourceAllocationInfo           `xml:"cpuAllocation,omitempty"`
	memoryAllocation             *ResourceAllocationInfo           `xml:"memoryAllocation,omitempty"`
	latencySensitivity           *LatencySensitivity               `xml:"latencySensitivity,omitempty"`
	cpuAffinity                  *VirtualMachineAffinityInfo       `xml:"cpuAffinity,omitempty"`
	memoryAffinity               *VirtualMachineAffinityInfo       `xml:"memoryAffinity,omitempty"`
	networkShaper                *VirtualMachineNetworkShaperInfo  `xml:"networkShaper,omitempty"`
	cpuFeatureMask               []*VirtualMachineCpuIdInfoSpec    `xml:"cpuFeatureMask,omitempty"`
	extraConfig                  []*OptionValue                    `xml:"extraConfig,omitempty"`
	swapPlacement                string                            `xml:"swapPlacement,omitempty"`
	bootOptions                  *VirtualMachineBootOptions        `xml:"bootOptions,omitempty"`
	vAppConfig                   *VmConfigSpec                     `xml:"vAppConfig,omitempty"`
	ftInfo                       *FaultToleranceConfigInfo         `xml:"ftInfo,omitempty"`
	vAppConfigRemoved            bool                              `xml:"vAppConfigRemoved,omitempty"`
	vAssertsEnabled              bool                              `xml:"vAssertsEnabled,omitempty"`
	changeTrackingEnabled        bool                              `xml:"changeTrackingEnabled,omitempty"`
	firmware                     string                            `xml:"firmware,omitempty"`
	maxMksConnections            int32                             `xml:"maxMksConnections,omitempty"`
	guestAutoLockEnabled         bool                              `xml:"guestAutoLockEnabled,omitempty"`
	managedBy                    *ManagedByInfo                    `xml:"managedBy,omitempty"`
	memoryReservationLockedToMax bool                              `xml:"memoryReservationLockedToMax,omitempty"`
	nestedHVEnabled              bool                              `xml:"nestedHVEnabled,omitempty"`
	vPMCEnabled                  bool                              `xml:"vPMCEnabled,omitempty"`
	scheduledHardwareUpgradeInfo *ScheduledHardwareUpgradeInfo     `xml:"scheduledHardwareUpgradeInfo,omitempty"`
	vmProfile                    []*VirtualMachineProfileSpec      `xml:"vmProfile,omitempty"`
}

type ConfigTarget struct {
	*DynamicData

	numCpus                     int32                                    `xml:"numCpus,omitempty"`
	numCpuCores                 int32                                    `xml:"numCpuCores,omitempty"`
	numNumaNodes                int32                                    `xml:"numNumaNodes,omitempty"`
	smcPresent                  bool                                     `xml:"smcPresent,omitempty"`
	datastore                   []*VirtualMachineDatastoreInfo           `xml:"datastore,omitempty"`
	network                     []*VirtualMachineNetworkInfo             `xml:"network,omitempty"`
	opaqueNetwork               []*OpaqueNetworkTargetInfo               `xml:"opaqueNetwork,omitempty"`
	distributedVirtualPortgroup []*DistributedVirtualPortgroupInfo       `xml:"distributedVirtualPortgroup,omitempty"`
	distributedVirtualSwitch    []*DistributedVirtualSwitchInfo          `xml:"distributedVirtualSwitch,omitempty"`
	cdRom                       []*VirtualMachineCdromInfo               `xml:"cdRom,omitempty"`
	serial                      []*VirtualMachineSerialInfo              `xml:"serial,omitempty"`
	parallel                    []*VirtualMachineParallelInfo            `xml:"parallel,omitempty"`
	sound                       []*VirtualMachineSoundInfo               `xml:"sound,omitempty"`
	usb                         []*VirtualMachineUsbInfo                 `xml:"usb,omitempty"`
	floppy                      []*VirtualMachineFloppyInfo              `xml:"floppy,omitempty"`
	legacyNetworkInfo           []*VirtualMachineLegacyNetworkSwitchInfo `xml:"legacyNetworkInfo,omitempty"`
	scsiPassthrough             []*VirtualMachineScsiPassthroughInfo     `xml:"scsiPassthrough,omitempty"`
	scsiDisk                    []*VirtualMachineScsiDiskDeviceInfo      `xml:"scsiDisk,omitempty"`
	ideDisk                     []*VirtualMachineIdeDiskDeviceInfo       `xml:"ideDisk,omitempty"`
	maxMemMBOptimalPerf         int32                                    `xml:"maxMemMBOptimalPerf,omitempty"`
	resourcePool                *ResourcePoolRuntimeInfo                 `xml:"resourcePool,omitempty"`
	autoVmotion                 bool                                     `xml:"autoVmotion,omitempty"`
	pciPassthrough              []*VirtualMachinePciPassthroughInfo      `xml:"pciPassthrough,omitempty"`
	sriov                       []*VirtualMachineSriovInfo               `xml:"sriov,omitempty"`
	vFlashModule                []*VirtualMachineVFlashModuleInfo        `xml:"vFlashModule,omitempty"`
}

type VirtualMachineConsolePreferences struct {
	*DynamicData

	powerOnWhenOpened        bool `xml:"powerOnWhenOpened,omitempty"`
	enterFullScreenOnPowerOn bool `xml:"enterFullScreenOnPowerOn,omitempty"`
	closeOnPowerOffOrSuspend bool `xml:"closeOnPowerOffOrSuspend,omitempty"`
}

type VirtualMachineDatastoreInfo struct {
	*VirtualMachineTargetInfo

	datastore              *DatastoreSummary    `xml:"datastore,omitempty"`
	capability             *DatastoreCapability `xml:"capability,omitempty"`
	maxFileSize            int64                `xml:"maxFileSize,omitempty"`
	maxVirtualDiskCapacity int64                `xml:"maxVirtualDiskCapacity,omitempty"`
	mode                   string               `xml:"mode,omitempty"`
	vStorageSupport        string               `xml:"vStorageSupport,omitempty"`
}

type ArrayOfVirtualMachineDatastoreInfo struct {
	VirtualMachineDatastoreInfo []*VirtualMachineDatastoreInfo `xml:"VirtualMachineDatastoreInfo,omitempty"`
}

type VirtualMachineDatastoreVolumeOption struct {
	*DynamicData

	fileSystemType string `xml:"fileSystemType,omitempty"`
	majorVersion   int32  `xml:"majorVersion,omitempty"`
}

type ArrayOfVirtualMachineDatastoreVolumeOption struct {
	VirtualMachineDatastoreVolumeOption []*VirtualMachineDatastoreVolumeOption `xml:"VirtualMachineDatastoreVolumeOption,omitempty"`
}

type DatastoreOption struct {
	*DynamicData

	unsupportedVolumes []*VirtualMachineDatastoreVolumeOption `xml:"unsupportedVolumes,omitempty"`
}

type VirtualMachineDefaultPowerOpInfo struct {
	*DynamicData

	powerOffType        string `xml:"powerOffType,omitempty"`
	suspendType         string `xml:"suspendType,omitempty"`
	resetType           string `xml:"resetType,omitempty"`
	defaultPowerOffType string `xml:"defaultPowerOffType,omitempty"`
	defaultSuspendType  string `xml:"defaultSuspendType,omitempty"`
	defaultResetType    string `xml:"defaultResetType,omitempty"`
	standbyAction       string `xml:"standbyAction,omitempty"`
}

type VirtualMachineDefinedProfileSpec struct {
	*VirtualMachineProfileSpec

	profileId   string                        `xml:"profileId,omitempty"`
	profileData *VirtualMachineProfileRawData `xml:"profileData,omitempty"`
}

type VirtualMachineDeviceRuntimeInfoDeviceRuntimeState struct {
	*DynamicData
}

type VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState struct {
	*VirtualMachineDeviceRuntimeInfoDeviceRuntimeState

	vmDirectPathGen2Active                 bool     `xml:"vmDirectPathGen2Active,omitempty"`
	vmDirectPathGen2InactiveReasonVm       []string `xml:"vmDirectPathGen2InactiveReasonVm,omitempty"`
	vmDirectPathGen2InactiveReasonOther    []string `xml:"vmDirectPathGen2InactiveReasonOther,omitempty"`
	vmDirectPathGen2InactiveReasonExtended string   `xml:"vmDirectPathGen2InactiveReasonExtended,omitempty"`
	reservationStatus                      string   `xml:"reservationStatus,omitempty"`
}

type VirtualMachineDeviceRuntimeInfo struct {
	*DynamicData

	runtimeState *VirtualMachineDeviceRuntimeInfoDeviceRuntimeState `xml:"runtimeState,omitempty"`
	key          int32                                              `xml:"key,omitempty"`
}

type ArrayOfVirtualMachineDeviceRuntimeInfo struct {
	VirtualMachineDeviceRuntimeInfo []*VirtualMachineDeviceRuntimeInfo `xml:"VirtualMachineDeviceRuntimeInfo,omitempty"`
}

type VirtualMachineDiskDeviceInfo struct {
	*VirtualMachineTargetInfo

	capacity int64                     `xml:"capacity,omitempty"`
	vm       []*ManagedObjectReference `xml:"vm,omitempty"`
}

type VirtualMachineEmptyProfileSpec struct {
	*VirtualMachineProfileSpec
}

type FaultToleranceConfigInfo struct {
	*DynamicData

	role          int32    `xml:"role,omitempty"`
	instanceUuids []string `xml:"instanceUuids,omitempty"`
	configPaths   []string `xml:"configPaths,omitempty"`
}

type FaultTolerancePrimaryConfigInfo struct {
	*FaultToleranceConfigInfo

	secondaries []*ManagedObjectReference `xml:"secondaries,omitempty"`
}

type FaultToleranceSecondaryConfigInfo struct {
	*FaultToleranceConfigInfo

	primaryVM *ManagedObjectReference `xml:"primaryVM,omitempty"`
}

type FaultToleranceSecondaryOpResult struct {
	*DynamicData

	vm               *ManagedObjectReference `xml:"vm,omitempty"`
	powerOnAttempted bool                    `xml:"powerOnAttempted,omitempty"`
	powerOnResult    *ClusterPowerOnVmResult `xml:"powerOnResult,omitempty"`
}

type VirtualMachineFeatureRequirement struct {
	*DynamicData

	key         string `xml:"key,omitempty"`
	featureName string `xml:"featureName,omitempty"`
	value       string `xml:"value,omitempty"`
}

type ArrayOfVirtualMachineFeatureRequirement struct {
	VirtualMachineFeatureRequirement []*VirtualMachineFeatureRequirement `xml:"VirtualMachineFeatureRequirement,omitempty"`
}

type VirtualMachineFileInfo struct {
	*DynamicData

	vmPathName        string `xml:"vmPathName,omitempty"`
	snapshotDirectory string `xml:"snapshotDirectory,omitempty"`
	suspendDirectory  string `xml:"suspendDirectory,omitempty"`
	logDirectory      string `xml:"logDirectory,omitempty"`
}

type VirtualMachineFileLayoutDiskLayout struct {
	*DynamicData

	key      int32    `xml:"key,omitempty"`
	diskFile []string `xml:"diskFile,omitempty"`
}

type ArrayOfVirtualMachineFileLayoutDiskLayout struct {
	VirtualMachineFileLayoutDiskLayout []*VirtualMachineFileLayoutDiskLayout `xml:"VirtualMachineFileLayoutDiskLayout,omitempty"`
}

type VirtualMachineFileLayoutSnapshotLayout struct {
	*DynamicData

	key          *ManagedObjectReference `xml:"key,omitempty"`
	snapshotFile []string                `xml:"snapshotFile,omitempty"`
}

type ArrayOfVirtualMachineFileLayoutSnapshotLayout struct {
	VirtualMachineFileLayoutSnapshotLayout []*VirtualMachineFileLayoutSnapshotLayout `xml:"VirtualMachineFileLayoutSnapshotLayout,omitempty"`
}

type VirtualMachineFileLayout struct {
	*DynamicData

	configFile []string                                  `xml:"configFile,omitempty"`
	logFile    []string                                  `xml:"logFile,omitempty"`
	disk       []*VirtualMachineFileLayoutDiskLayout     `xml:"disk,omitempty"`
	snapshot   []*VirtualMachineFileLayoutSnapshotLayout `xml:"snapshot,omitempty"`
	swapFile   string                                    `xml:"swapFile,omitempty"`
}

type VirtualMachineFileLayoutExFileInfo struct {
	*DynamicData

	key        int32  `xml:"key,omitempty"`
	name       string `xml:"name,omitempty"`
	type_      string `xml:"type,omitempty"`
	size       int64  `xml:"size,omitempty"`
	uniqueSize int64  `xml:"uniqueSize,omitempty"`
}

type ArrayOfVirtualMachineFileLayoutExFileInfo struct {
	VirtualMachineFileLayoutExFileInfo []*VirtualMachineFileLayoutExFileInfo `xml:"VirtualMachineFileLayoutExFileInfo,omitempty"`
}

type VirtualMachineFileLayoutExDiskUnit struct {
	*DynamicData

	fileKey []int32 `xml:"fileKey,omitempty"`
}

type ArrayOfVirtualMachineFileLayoutExDiskUnit struct {
	VirtualMachineFileLayoutExDiskUnit []*VirtualMachineFileLayoutExDiskUnit `xml:"VirtualMachineFileLayoutExDiskUnit,omitempty"`
}

type VirtualMachineFileLayoutExDiskLayout struct {
	*DynamicData

	key   int32                                 `xml:"key,omitempty"`
	chain []*VirtualMachineFileLayoutExDiskUnit `xml:"chain,omitempty"`
}

type ArrayOfVirtualMachineFileLayoutExDiskLayout struct {
	VirtualMachineFileLayoutExDiskLayout []*VirtualMachineFileLayoutExDiskLayout `xml:"VirtualMachineFileLayoutExDiskLayout,omitempty"`
}

type VirtualMachineFileLayoutExSnapshotLayout struct {
	*DynamicData

	key     *ManagedObjectReference                 `xml:"key,omitempty"`
	dataKey int32                                   `xml:"dataKey,omitempty"`
	disk    []*VirtualMachineFileLayoutExDiskLayout `xml:"disk,omitempty"`
}

type ArrayOfVirtualMachineFileLayoutExSnapshotLayout struct {
	VirtualMachineFileLayoutExSnapshotLayout []*VirtualMachineFileLayoutExSnapshotLayout `xml:"VirtualMachineFileLayoutExSnapshotLayout,omitempty"`
}

type VirtualMachineFileLayoutEx struct {
	*DynamicData

	file      []*VirtualMachineFileLayoutExFileInfo       `xml:"file,omitempty"`
	disk      []*VirtualMachineFileLayoutExDiskLayout     `xml:"disk,omitempty"`
	snapshot  []*VirtualMachineFileLayoutExSnapshotLayout `xml:"snapshot,omitempty"`
	timestamp time.Time                                   `xml:"timestamp,omitempty"`
}

type VirtualMachineFlagInfo struct {
	*DynamicData

	disableAcceleration      bool   `xml:"disableAcceleration,omitempty"`
	enableLogging            bool   `xml:"enableLogging,omitempty"`
	useToe                   bool   `xml:"useToe,omitempty"`
	runWithDebugInfo         bool   `xml:"runWithDebugInfo,omitempty"`
	monitorType              string `xml:"monitorType,omitempty"`
	htSharing                string `xml:"htSharing,omitempty"`
	snapshotDisabled         bool   `xml:"snapshotDisabled,omitempty"`
	snapshotLocked           bool   `xml:"snapshotLocked,omitempty"`
	diskUuidEnabled          bool   `xml:"diskUuidEnabled,omitempty"`
	virtualMmuUsage          string `xml:"virtualMmuUsage,omitempty"`
	virtualExecUsage         string `xml:"virtualExecUsage,omitempty"`
	snapshotPowerOffBehavior string `xml:"snapshotPowerOffBehavior,omitempty"`
	recordReplayEnabled      bool   `xml:"recordReplayEnabled,omitempty"`
}

type VirtualMachineFloppyInfo struct {
	*VirtualMachineTargetInfo
}

type ArrayOfVirtualMachineFloppyInfo struct {
	VirtualMachineFloppyInfo []*VirtualMachineFloppyInfo `xml:"VirtualMachineFloppyInfo,omitempty"`
}

type GuestDiskInfo struct {
	*DynamicData

	diskPath  string `xml:"diskPath,omitempty"`
	capacity  int64  `xml:"capacity,omitempty"`
	freeSpace int64  `xml:"freeSpace,omitempty"`
}

type ArrayOfGuestDiskInfo struct {
	GuestDiskInfo []*GuestDiskInfo `xml:"GuestDiskInfo,omitempty"`
}

type GuestNicInfo struct {
	*DynamicData

	network        string             `xml:"network,omitempty"`
	ipAddress      []string           `xml:"ipAddress,omitempty"`
	macAddress     string             `xml:"macAddress,omitempty"`
	connected      bool               `xml:"connected,omitempty"`
	deviceConfigId int32              `xml:"deviceConfigId,omitempty"`
	dnsConfig      *NetDnsConfigInfo  `xml:"dnsConfig,omitempty"`
	ipConfig       *NetIpConfigInfo   `xml:"ipConfig,omitempty"`
	netBIOSConfig  *NetBIOSConfigInfo `xml:"netBIOSConfig,omitempty"`
}

type ArrayOfGuestNicInfo struct {
	GuestNicInfo []*GuestNicInfo `xml:"GuestNicInfo,omitempty"`
}

type GuestStackInfo struct {
	*DynamicData

	dnsConfig     *NetDnsConfigInfo     `xml:"dnsConfig,omitempty"`
	ipRouteConfig *NetIpRouteConfigInfo `xml:"ipRouteConfig,omitempty"`
	ipStackConfig []*KeyValue           `xml:"ipStackConfig,omitempty"`
	dhcpConfig    *NetDhcpConfigInfo    `xml:"dhcpConfig,omitempty"`
}

type ArrayOfGuestStackInfo struct {
	GuestStackInfo []*GuestStackInfo `xml:"GuestStackInfo,omitempty"`
}

type GuestScreenInfo struct {
	*DynamicData

	width  int32 `xml:"width,omitempty"`
	height int32 `xml:"height,omitempty"`
}

type GuestInfoNamespaceGenerationInfo struct {
	*DynamicData

	key          string `xml:"key,omitempty"`
	generationNo int32  `xml:"generationNo,omitempty"`
}

type ArrayOfGuestInfoNamespaceGenerationInfo struct {
	GuestInfoNamespaceGenerationInfo []*GuestInfoNamespaceGenerationInfo `xml:"GuestInfoNamespaceGenerationInfo,omitempty"`
}

type GuestInfo struct {
	*DynamicData

	toolsStatus                     *VirtualMachineToolsStatus          `xml:"toolsStatus,omitempty"`
	toolsVersionStatus              string                              `xml:"toolsVersionStatus,omitempty"`
	toolsVersionStatus2             string                              `xml:"toolsVersionStatus2,omitempty"`
	toolsRunningStatus              string                              `xml:"toolsRunningStatus,omitempty"`
	toolsVersion                    string                              `xml:"toolsVersion,omitempty"`
	guestId                         string                              `xml:"guestId,omitempty"`
	guestFamily                     string                              `xml:"guestFamily,omitempty"`
	guestFullName                   string                              `xml:"guestFullName,omitempty"`
	hostName                        string                              `xml:"hostName,omitempty"`
	ipAddress                       string                              `xml:"ipAddress,omitempty"`
	net                             []*GuestNicInfo                     `xml:"net,omitempty"`
	ipStack                         []*GuestStackInfo                   `xml:"ipStack,omitempty"`
	disk                            []*GuestDiskInfo                    `xml:"disk,omitempty"`
	screen                          *GuestScreenInfo                    `xml:"screen,omitempty"`
	guestState                      string                              `xml:"guestState,omitempty"`
	appHeartbeatStatus              string                              `xml:"appHeartbeatStatus,omitempty"`
	appState                        string                              `xml:"appState,omitempty"`
	guestOperationsReady            bool                                `xml:"guestOperationsReady,omitempty"`
	interactiveGuestOperationsReady bool                                `xml:"interactiveGuestOperationsReady,omitempty"`
	generationInfo                  []*GuestInfoNamespaceGenerationInfo `xml:"generationInfo,omitempty"`
}

type GuestOsDescriptor struct {
	*DynamicData

	id                          string           `xml:"id,omitempty"`
	family                      string           `xml:"family,omitempty"`
	fullName                    string           `xml:"fullName,omitempty"`
	supportedMaxCPUs            int32            `xml:"supportedMaxCPUs,omitempty"`
	numSupportedPhysicalSockets int32            `xml:"numSupportedPhysicalSockets,omitempty"`
	numSupportedCoresPerSocket  int32            `xml:"numSupportedCoresPerSocket,omitempty"`
	supportedMinMemMB           int32            `xml:"supportedMinMemMB,omitempty"`
	supportedMaxMemMB           int32            `xml:"supportedMaxMemMB,omitempty"`
	recommendedMemMB            int32            `xml:"recommendedMemMB,omitempty"`
	recommendedColorDepth       int32            `xml:"recommendedColorDepth,omitempty"`
	supportedDiskControllerList []string         `xml:"supportedDiskControllerList,omitempty"`
	recommendedSCSIController   string           `xml:"recommendedSCSIController,omitempty"`
	recommendedDiskController   string           `xml:"recommendedDiskController,omitempty"`
	supportedNumDisks           int32            `xml:"supportedNumDisks,omitempty"`
	recommendedDiskSizeMB       int32            `xml:"recommendedDiskSizeMB,omitempty"`
	recommendedCdromController  string           `xml:"recommendedCdromController,omitempty"`
	supportedEthernetCard       []string         `xml:"supportedEthernetCard,omitempty"`
	recommendedEthernetCard     string           `xml:"recommendedEthernetCard,omitempty"`
	supportsSlaveDisk           bool             `xml:"supportsSlaveDisk,omitempty"`
	cpuFeatureMask              []*HostCpuIdInfo `xml:"cpuFeatureMask,omitempty"`
	smcRequired                 bool             `xml:"smcRequired,omitempty"`
	supportsWakeOnLan           bool             `xml:"supportsWakeOnLan,omitempty"`
	supportsVMI                 bool             `xml:"supportsVMI,omitempty"`
	supportsMemoryHotAdd        bool             `xml:"supportsMemoryHotAdd,omitempty"`
	supportsCpuHotAdd           bool             `xml:"supportsCpuHotAdd,omitempty"`
	supportsCpuHotRemove        bool             `xml:"supportsCpuHotRemove,omitempty"`
	supportedFirmware           []string         `xml:"supportedFirmware,omitempty"`
	recommendedFirmware         string           `xml:"recommendedFirmware,omitempty"`
	supportedUSBControllerList  []string         `xml:"supportedUSBControllerList,omitempty"`
	recommendedUSBController    string           `xml:"recommendedUSBController,omitempty"`
	supports3D                  bool             `xml:"supports3D,omitempty"`
	recommended3D               bool             `xml:"recommended3D,omitempty"`
	smcRecommended              bool             `xml:"smcRecommended,omitempty"`
	ich7mRecommended            bool             `xml:"ich7mRecommended,omitempty"`
	usbRecommended              bool             `xml:"usbRecommended,omitempty"`
	supportLevel                string           `xml:"supportLevel,omitempty"`
	supportedForCreate          bool             `xml:"supportedForCreate,omitempty"`
	vRAMSizeInKB                *IntOption       `xml:"vRAMSizeInKB,omitempty"`
}

type ArrayOfGuestOsDescriptor struct {
	GuestOsDescriptor []*GuestOsDescriptor `xml:"GuestOsDescriptor,omitempty"`
}

type VirtualMachineIdeDiskDevicePartitionInfo struct {
	*DynamicData

	id       int32 `xml:"id,omitempty"`
	capacity int32 `xml:"capacity,omitempty"`
}

type ArrayOfVirtualMachineIdeDiskDevicePartitionInfo struct {
	VirtualMachineIdeDiskDevicePartitionInfo []*VirtualMachineIdeDiskDevicePartitionInfo `xml:"VirtualMachineIdeDiskDevicePartitionInfo,omitempty"`
}

type VirtualMachineIdeDiskDeviceInfo struct {
	*VirtualMachineDiskDeviceInfo

	partitionTable []*VirtualMachineIdeDiskDevicePartitionInfo `xml:"partitionTable,omitempty"`
}

type ArrayOfVirtualMachineIdeDiskDeviceInfo struct {
	VirtualMachineIdeDiskDeviceInfo []*VirtualMachineIdeDiskDeviceInfo `xml:"VirtualMachineIdeDiskDeviceInfo,omitempty"`
}

type VirtualMachineLegacyNetworkSwitchInfo struct {
	*DynamicData

	name string `xml:"name,omitempty"`
}

type ArrayOfVirtualMachineLegacyNetworkSwitchInfo struct {
	VirtualMachineLegacyNetworkSwitchInfo []*VirtualMachineLegacyNetworkSwitchInfo `xml:"VirtualMachineLegacyNetworkSwitchInfo,omitempty"`
}

type VirtualMachineMessage struct {
	*DynamicData

	id       string        `xml:"id,omitempty"`
	argument []interface{} `xml:"argument,omitempty"`
	text     string        `xml:"text,omitempty"`
}

type ArrayOfVirtualMachineMessage struct {
	VirtualMachineMessage []*VirtualMachineMessage `xml:"VirtualMachineMessage,omitempty"`
}

type VirtualMachineMetadataManagerVmMetadataOwner struct {
	*DynamicData

	name string `xml:"name,omitempty"`
}

type VirtualMachineMetadataManagerVmMetadata struct {
	*DynamicData

	vmId     string `xml:"vmId,omitempty"`
	metadata string `xml:"metadata,omitempty"`
}

type VirtualMachineMetadataManagerVmMetadataInput struct {
	*DynamicData

	operation  string                                   `xml:"operation,omitempty"`
	vmMetadata *VirtualMachineMetadataManagerVmMetadata `xml:"vmMetadata,omitempty"`
}

type ArrayOfVirtualMachineMetadataManagerVmMetadataInput struct {
	VirtualMachineMetadataManagerVmMetadataInput []*VirtualMachineMetadataManagerVmMetadataInput `xml:"VirtualMachineMetadataManagerVmMetadataInput,omitempty"`
}

type VirtualMachineMetadataManagerVmMetadataResult struct {
	*DynamicData

	vmMetadata *VirtualMachineMetadataManagerVmMetadata `xml:"vmMetadata,omitempty"`
	error      *LocalizedMethodFault                    `xml:"error,omitempty"`
}

type ArrayOfVirtualMachineMetadataManagerVmMetadataResult struct {
	VirtualMachineMetadataManagerVmMetadataResult []*VirtualMachineMetadataManagerVmMetadataResult `xml:"VirtualMachineMetadataManagerVmMetadataResult,omitempty"`
}

type VirtualMachineNetworkInfo struct {
	*VirtualMachineTargetInfo

	network *NetworkSummary `xml:"network,omitempty"`
}

type ArrayOfVirtualMachineNetworkInfo struct {
	VirtualMachineNetworkInfo []*VirtualMachineNetworkInfo `xml:"VirtualMachineNetworkInfo,omitempty"`
}

type VirtualMachineNetworkShaperInfo struct {
	*DynamicData

	enabled    bool  `xml:"enabled,omitempty"`
	peakBps    int64 `xml:"peakBps,omitempty"`
	averageBps int64 `xml:"averageBps,omitempty"`
	burstSize  int64 `xml:"burstSize,omitempty"`
}

type OpaqueNetworkTargetInfo struct {
	*VirtualMachineTargetInfo

	network *OpaqueNetworkSummary `xml:"network,omitempty"`
}

type ArrayOfOpaqueNetworkTargetInfo struct {
	OpaqueNetworkTargetInfo []*OpaqueNetworkTargetInfo `xml:"OpaqueNetworkTargetInfo,omitempty"`
}

type VirtualMachineParallelInfo struct {
	*VirtualMachineTargetInfo
}

type ArrayOfVirtualMachineParallelInfo struct {
	VirtualMachineParallelInfo []*VirtualMachineParallelInfo `xml:"VirtualMachineParallelInfo,omitempty"`
}

type VirtualMachinePciPassthroughInfo struct {
	*VirtualMachineTargetInfo

	pciDevice *HostPciDevice `xml:"pciDevice,omitempty"`
	systemId  string         `xml:"systemId,omitempty"`
}

type ArrayOfVirtualMachinePciPassthroughInfo struct {
	VirtualMachinePciPassthroughInfo []*VirtualMachinePciPassthroughInfo `xml:"VirtualMachinePciPassthroughInfo,omitempty"`
}

type VirtualMachineProfileRawData struct {
	*DynamicData

	extensionKey string `xml:"extensionKey,omitempty"`
	objectData   string `xml:"objectData,omitempty"`
}

type VirtualMachineProfileSpec struct {
	*DynamicData
}

type ArrayOfVirtualMachineProfileSpec struct {
	VirtualMachineProfileSpec []*VirtualMachineProfileSpec `xml:"VirtualMachineProfileSpec,omitempty"`
}

type VirtualMachineQuestionInfo struct {
	*DynamicData

	id      string                   `xml:"id,omitempty"`
	text    string                   `xml:"text,omitempty"`
	choice  *ChoiceOption            `xml:"choice,omitempty"`
	message []*VirtualMachineMessage `xml:"message,omitempty"`
}

type VirtualMachineRelocateSpecDiskLocator struct {
	*DynamicData

	diskId          int32                        `xml:"diskId,omitempty"`
	datastore       *ManagedObjectReference      `xml:"datastore,omitempty"`
	diskMoveType    string                       `xml:"diskMoveType,omitempty"`
	diskBackingInfo *VirtualDeviceBackingInfo    `xml:"diskBackingInfo,omitempty"`
	profile         []*VirtualMachineProfileSpec `xml:"profile,omitempty"`
}

type ArrayOfVirtualMachineRelocateSpecDiskLocator struct {
	VirtualMachineRelocateSpecDiskLocator []*VirtualMachineRelocateSpecDiskLocator `xml:"VirtualMachineRelocateSpecDiskLocator,omitempty"`
}

type VirtualMachineRelocateSpec struct {
	*DynamicData

	datastore    *ManagedObjectReference                  `xml:"datastore,omitempty"`
	diskMoveType string                                   `xml:"diskMoveType,omitempty"`
	pool         *ManagedObjectReference                  `xml:"pool,omitempty"`
	host         *ManagedObjectReference                  `xml:"host,omitempty"`
	disk         []*VirtualMachineRelocateSpecDiskLocator `xml:"disk,omitempty"`
	transform    *VirtualMachineRelocateTransformation    `xml:"transform,omitempty"`
	deviceChange []*VirtualDeviceConfigSpec               `xml:"deviceChange,omitempty"`
	profile      []*VirtualMachineProfileSpec             `xml:"profile,omitempty"`
}

type ReplicationInfoDiskSettings struct {
	*DynamicData

	key               int32  `xml:"key,omitempty"`
	diskReplicationId string `xml:"diskReplicationId,omitempty"`
}

type ArrayOfReplicationInfoDiskSettings struct {
	ReplicationInfoDiskSettings []*ReplicationInfoDiskSettings `xml:"ReplicationInfoDiskSettings,omitempty"`
}

type VirtualMachineRuntimeInfoDasProtectionState struct {
	*DynamicData

	dasProtected bool `xml:"dasProtected,omitempty"`
}

type VirtualMachineRuntimeInfo struct {
	*DynamicData

	device                    []*VirtualMachineDeviceRuntimeInfo           `xml:"device,omitempty"`
	host                      *ManagedObjectReference                      `xml:"host,omitempty"`
	connectionState           *VirtualMachineConnectionState               `xml:"connectionState,omitempty"`
	powerState                *VirtualMachinePowerState                    `xml:"powerState,omitempty"`
	faultToleranceState       *VirtualMachineFaultToleranceState           `xml:"faultToleranceState,omitempty"`
	dasVmProtection           *VirtualMachineRuntimeInfoDasProtectionState `xml:"dasVmProtection,omitempty"`
	toolsInstallerMounted     bool                                         `xml:"toolsInstallerMounted,omitempty"`
	suspendTime               time.Time                                    `xml:"suspendTime,omitempty"`
	bootTime                  time.Time                                    `xml:"bootTime,omitempty"`
	suspendInterval           int64                                        `xml:"suspendInterval,omitempty"`
	question                  *VirtualMachineQuestionInfo                  `xml:"question,omitempty"`
	memoryOverhead            int64                                        `xml:"memoryOverhead,omitempty"`
	maxCpuUsage               int32                                        `xml:"maxCpuUsage,omitempty"`
	maxMemoryUsage            int32                                        `xml:"maxMemoryUsage,omitempty"`
	numMksConnections         int32                                        `xml:"numMksConnections,omitempty"`
	recordReplayState         *VirtualMachineRecordReplayState             `xml:"recordReplayState,omitempty"`
	cleanPowerOff             bool                                         `xml:"cleanPowerOff,omitempty"`
	needSecondaryReason       string                                       `xml:"needSecondaryReason,omitempty"`
	onlineStandby             bool                                         `xml:"onlineStandby,omitempty"`
	minRequiredEVCModeKey     string                                       `xml:"minRequiredEVCModeKey,omitempty"`
	consolidationNeeded       bool                                         `xml:"consolidationNeeded,omitempty"`
	offlineFeatureRequirement []*VirtualMachineFeatureRequirement          `xml:"offlineFeatureRequirement,omitempty"`
	featureRequirement        []*VirtualMachineFeatureRequirement          `xml:"featureRequirement,omitempty"`
	featureMask               []*HostFeatureMask                           `xml:"featureMask,omitempty"`
	vFlashCacheAllocation     int64                                        `xml:"vFlashCacheAllocation,omitempty"`
}

type ScheduledHardwareUpgradeInfo struct {
	*DynamicData

	upgradePolicy                  string                `xml:"upgradePolicy,omitempty"`
	versionKey                     string                `xml:"versionKey,omitempty"`
	scheduledHardwareUpgradeStatus string                `xml:"scheduledHardwareUpgradeStatus,omitempty"`
	fault                          *LocalizedMethodFault `xml:"fault,omitempty"`
}

type VirtualMachineScsiDiskDeviceInfo struct {
	*VirtualMachineDiskDeviceInfo

	disk          *HostScsiDisk `xml:"disk,omitempty"`
	transportHint string        `xml:"transportHint,omitempty"`
	lunNumber     int32         `xml:"lunNumber,omitempty"`
}

type ArrayOfVirtualMachineScsiDiskDeviceInfo struct {
	VirtualMachineScsiDiskDeviceInfo []*VirtualMachineScsiDiskDeviceInfo `xml:"VirtualMachineScsiDiskDeviceInfo,omitempty"`
}

type VirtualMachineScsiPassthroughInfo struct {
	*VirtualMachineTargetInfo

	scsiClass          string `xml:"scsiClass,omitempty"`
	vendor             string `xml:"vendor,omitempty"`
	physicalUnitNumber int32  `xml:"physicalUnitNumber,omitempty"`
}

type ArrayOfVirtualMachineScsiPassthroughInfo struct {
	VirtualMachineScsiPassthroughInfo []*VirtualMachineScsiPassthroughInfo `xml:"VirtualMachineScsiPassthroughInfo,omitempty"`
}

type VirtualMachineSerialInfo struct {
	*VirtualMachineTargetInfo
}

type ArrayOfVirtualMachineSerialInfo struct {
	VirtualMachineSerialInfo []*VirtualMachineSerialInfo `xml:"VirtualMachineSerialInfo,omitempty"`
}

type VirtualMachineSnapshotInfo struct {
	*DynamicData

	currentSnapshot  *ManagedObjectReference       `xml:"currentSnapshot,omitempty"`
	rootSnapshotList []*VirtualMachineSnapshotTree `xml:"rootSnapshotList,omitempty"`
}

type VirtualMachineSnapshotTree struct {
	*DynamicData

	snapshot          *ManagedObjectReference       `xml:"snapshot,omitempty"`
	vm                *ManagedObjectReference       `xml:"vm,omitempty"`
	name              string                        `xml:"name,omitempty"`
	description       string                        `xml:"description,omitempty"`
	id                int32                         `xml:"id,omitempty"`
	createTime        time.Time                     `xml:"createTime,omitempty"`
	state             *VirtualMachinePowerState     `xml:"state,omitempty"`
	quiesced          bool                          `xml:"quiesced,omitempty"`
	backupManifest    string                        `xml:"backupManifest,omitempty"`
	childSnapshotList []*VirtualMachineSnapshotTree `xml:"childSnapshotList,omitempty"`
	replaySupported   bool                          `xml:"replaySupported,omitempty"`
}

type ArrayOfVirtualMachineSnapshotTree struct {
	VirtualMachineSnapshotTree []*VirtualMachineSnapshotTree `xml:"VirtualMachineSnapshotTree,omitempty"`
}

type VirtualMachineSoundInfo struct {
	*VirtualMachineTargetInfo
}

type ArrayOfVirtualMachineSoundInfo struct {
	VirtualMachineSoundInfo []*VirtualMachineSoundInfo `xml:"VirtualMachineSoundInfo,omitempty"`
}

type VirtualMachineSriovInfo struct {
	*VirtualMachinePciPassthroughInfo

	virtualFunction bool   `xml:"virtualFunction,omitempty"`
	pnic            string `xml:"pnic,omitempty"`
}

type ArrayOfVirtualMachineSriovInfo struct {
	VirtualMachineSriovInfo []*VirtualMachineSriovInfo `xml:"VirtualMachineSriovInfo,omitempty"`
}

type VirtualMachineUsageOnDatastore struct {
	*DynamicData

	datastore   *ManagedObjectReference `xml:"datastore,omitempty"`
	committed   int64                   `xml:"committed,omitempty"`
	uncommitted int64                   `xml:"uncommitted,omitempty"`
	unshared    int64                   `xml:"unshared,omitempty"`
}

type ArrayOfVirtualMachineUsageOnDatastore struct {
	VirtualMachineUsageOnDatastore []*VirtualMachineUsageOnDatastore `xml:"VirtualMachineUsageOnDatastore,omitempty"`
}

type VirtualMachineStorageInfo struct {
	*DynamicData

	perDatastoreUsage []*VirtualMachineUsageOnDatastore `xml:"perDatastoreUsage,omitempty"`
	timestamp         time.Time                         `xml:"timestamp,omitempty"`
}

type VirtualMachineConfigSummary struct {
	*DynamicData

	name                string                    `xml:"name,omitempty"`
	template            bool                      `xml:"template,omitempty"`
	vmPathName          string                    `xml:"vmPathName,omitempty"`
	memorySizeMB        int32                     `xml:"memorySizeMB,omitempty"`
	cpuReservation      int32                     `xml:"cpuReservation,omitempty"`
	memoryReservation   int32                     `xml:"memoryReservation,omitempty"`
	numCpu              int32                     `xml:"numCpu,omitempty"`
	numEthernetCards    int32                     `xml:"numEthernetCards,omitempty"`
	numVirtualDisks     int32                     `xml:"numVirtualDisks,omitempty"`
	uuid                string                    `xml:"uuid,omitempty"`
	instanceUuid        string                    `xml:"instanceUuid,omitempty"`
	guestId             string                    `xml:"guestId,omitempty"`
	guestFullName       string                    `xml:"guestFullName,omitempty"`
	annotation          string                    `xml:"annotation,omitempty"`
	product             *VAppProductInfo          `xml:"product,omitempty"`
	installBootRequired bool                      `xml:"installBootRequired,omitempty"`
	ftInfo              *FaultToleranceConfigInfo `xml:"ftInfo,omitempty"`
	managedBy           *ManagedByInfo            `xml:"managedBy,omitempty"`
}

type VirtualMachineQuickStats struct {
	*DynamicData

	overallCpuUsage              int32                `xml:"overallCpuUsage,omitempty"`
	overallCpuDemand             int32                `xml:"overallCpuDemand,omitempty"`
	guestMemoryUsage             int32                `xml:"guestMemoryUsage,omitempty"`
	hostMemoryUsage              int32                `xml:"hostMemoryUsage,omitempty"`
	guestHeartbeatStatus         *ManagedEntityStatus `xml:"guestHeartbeatStatus,omitempty"`
	distributedCpuEntitlement    int32                `xml:"distributedCpuEntitlement,omitempty"`
	distributedMemoryEntitlement int32                `xml:"distributedMemoryEntitlement,omitempty"`
	staticCpuEntitlement         int32                `xml:"staticCpuEntitlement,omitempty"`
	staticMemoryEntitlement      int32                `xml:"staticMemoryEntitlement,omitempty"`
	privateMemory                int32                `xml:"privateMemory,omitempty"`
	sharedMemory                 int32                `xml:"sharedMemory,omitempty"`
	swappedMemory                int32                `xml:"swappedMemory,omitempty"`
	balloonedMemory              int32                `xml:"balloonedMemory,omitempty"`
	consumedOverheadMemory       int32                `xml:"consumedOverheadMemory,omitempty"`
	ftLogBandwidth               int32                `xml:"ftLogBandwidth,omitempty"`
	ftSecondaryLatency           int32                `xml:"ftSecondaryLatency,omitempty"`
	ftLatencyStatus              *ManagedEntityStatus `xml:"ftLatencyStatus,omitempty"`
	compressedMemory             int64                `xml:"compressedMemory,omitempty"`
	uptimeSeconds                int32                `xml:"uptimeSeconds,omitempty"`
	ssdSwappedMemory             int64                `xml:"ssdSwappedMemory,omitempty"`
}

type VirtualMachineGuestSummary struct {
	*DynamicData

	guestId             string                     `xml:"guestId,omitempty"`
	guestFullName       string                     `xml:"guestFullName,omitempty"`
	toolsStatus         *VirtualMachineToolsStatus `xml:"toolsStatus,omitempty"`
	toolsVersionStatus  string                     `xml:"toolsVersionStatus,omitempty"`
	toolsVersionStatus2 string                     `xml:"toolsVersionStatus2,omitempty"`
	toolsRunningStatus  string                     `xml:"toolsRunningStatus,omitempty"`
	hostName            string                     `xml:"hostName,omitempty"`
	ipAddress           string                     `xml:"ipAddress,omitempty"`
}

type VirtualMachineStorageSummary struct {
	*DynamicData

	committed   int64     `xml:"committed,omitempty"`
	uncommitted int64     `xml:"uncommitted,omitempty"`
	unshared    int64     `xml:"unshared,omitempty"`
	timestamp   time.Time `xml:"timestamp,omitempty"`
}

type VirtualMachineSummary struct {
	*DynamicData

	vm            *ManagedObjectReference       `xml:"vm,omitempty"`
	runtime       *VirtualMachineRuntimeInfo    `xml:"runtime,omitempty"`
	guest         *VirtualMachineGuestSummary   `xml:"guest,omitempty"`
	config        *VirtualMachineConfigSummary  `xml:"config,omitempty"`
	storage       *VirtualMachineStorageSummary `xml:"storage,omitempty"`
	quickStats    *VirtualMachineQuickStats     `xml:"quickStats,omitempty"`
	overallStatus *ManagedEntityStatus          `xml:"overallStatus,omitempty"`
	customValue   []*CustomFieldValue           `xml:"customValue,omitempty"`
}

type ArrayOfVirtualMachineSummary struct {
	VirtualMachineSummary []*VirtualMachineSummary `xml:"VirtualMachineSummary,omitempty"`
}

type VirtualMachineTargetInfo struct {
	*DynamicData

	name             string   `xml:"name,omitempty"`
	configurationTag []string `xml:"configurationTag,omitempty"`
}

type ToolsConfigInfoToolsLastInstallInfo struct {
	*DynamicData

	counter int32                 `xml:"counter,omitempty"`
	fault   *LocalizedMethodFault `xml:"fault,omitempty"`
}

type ToolsConfigInfo struct {
	*DynamicData

	toolsVersion         int32                                `xml:"toolsVersion,omitempty"`
	afterPowerOn         bool                                 `xml:"afterPowerOn,omitempty"`
	afterResume          bool                                 `xml:"afterResume,omitempty"`
	beforeGuestStandby   bool                                 `xml:"beforeGuestStandby,omitempty"`
	beforeGuestShutdown  bool                                 `xml:"beforeGuestShutdown,omitempty"`
	beforeGuestReboot    bool                                 `xml:"beforeGuestReboot,omitempty"`
	toolsUpgradePolicy   string                               `xml:"toolsUpgradePolicy,omitempty"`
	pendingCustomization string                               `xml:"pendingCustomization,omitempty"`
	syncTimeWithHost     bool                                 `xml:"syncTimeWithHost,omitempty"`
	lastInstallInfo      *ToolsConfigInfoToolsLastInstallInfo `xml:"lastInstallInfo,omitempty"`
}

type VirtualMachineUsbInfo struct {
	*VirtualMachineTargetInfo

	description  string                 `xml:"description,omitempty"`
	vendor       int32                  `xml:"vendor,omitempty"`
	product      int32                  `xml:"product,omitempty"`
	physicalPath string                 `xml:"physicalPath,omitempty"`
	family       []string               `xml:"family,omitempty"`
	speed        []string               `xml:"speed,omitempty"`
	summary      *VirtualMachineSummary `xml:"summary,omitempty"`
}

type ArrayOfVirtualMachineUsbInfo struct {
	VirtualMachineUsbInfo []*VirtualMachineUsbInfo `xml:"VirtualMachineUsbInfo,omitempty"`
}

type VirtualMachineVFlashModuleInfo struct {
	*VirtualMachineTargetInfo

	vFlashModule *HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption `xml:"vFlashModule,omitempty"`
}

type ArrayOfVirtualMachineVFlashModuleInfo struct {
	VirtualMachineVFlashModuleInfo []*VirtualMachineVFlashModuleInfo `xml:"VirtualMachineVFlashModuleInfo,omitempty"`
}

type VirtualHardware struct {
	*DynamicData

	numCPU              int32            `xml:"numCPU,omitempty"`
	numCoresPerSocket   int32            `xml:"numCoresPerSocket,omitempty"`
	memoryMB            int32            `xml:"memoryMB,omitempty"`
	virtualICH7MPresent bool             `xml:"virtualICH7MPresent,omitempty"`
	virtualSMCPresent   bool             `xml:"virtualSMCPresent,omitempty"`
	device              []*VirtualDevice `xml:"device,omitempty"`
}

type VirtualHardwareOption struct {
	*DynamicData

	hwVersion             int32                  `xml:"hwVersion,omitempty"`
	virtualDeviceOption   []*VirtualDeviceOption `xml:"virtualDeviceOption,omitempty"`
	deviceListReadonly    bool                   `xml:"deviceListReadonly,omitempty"`
	numCPU                []int32                `xml:"numCPU,omitempty"`
	numCoresPerSocket     *IntOption             `xml:"numCoresPerSocket,omitempty"`
	numCpuReadonly        bool                   `xml:"numCpuReadonly,omitempty"`
	memoryMB              *LongOption            `xml:"memoryMB,omitempty"`
	numPCIControllers     *IntOption             `xml:"numPCIControllers,omitempty"`
	numIDEControllers     *IntOption             `xml:"numIDEControllers,omitempty"`
	numUSBControllers     *IntOption             `xml:"numUSBControllers,omitempty"`
	numUSBXHCIControllers *IntOption             `xml:"numUSBXHCIControllers,omitempty"`
	numSIOControllers     *IntOption             `xml:"numSIOControllers,omitempty"`
	numPS2Controllers     *IntOption             `xml:"numPS2Controllers,omitempty"`
	licensingLimit        []string               `xml:"licensingLimit,omitempty"`
	numSupportedWwnPorts  *IntOption             `xml:"numSupportedWwnPorts,omitempty"`
	numSupportedWwnNodes  *IntOption             `xml:"numSupportedWwnNodes,omitempty"`
	resourceConfigOption  *ResourceConfigOption  `xml:"resourceConfigOption,omitempty"`
}

type VirtualMachineImportSpec struct {
	*ImportSpec

	configSpec    *VirtualMachineConfigSpec `xml:"configSpec,omitempty"`
	resPoolEntity *ManagedObjectReference   `xml:"resPoolEntity,omitempty"`
}

type CheckResult struct {
	*DynamicData

	vm      *ManagedObjectReference `xml:"vm,omitempty"`
	host    *ManagedObjectReference `xml:"host,omitempty"`
	warning []*LocalizedMethodFault `xml:"warning,omitempty"`
	error   []*LocalizedMethodFault `xml:"error,omitempty"`
}

type ArrayOfCheckResult struct {
	CheckResult []*CheckResult `xml:"CheckResult,omitempty"`
}

type CustomizationIPSettingsIpV6AddressSpec struct {
	*DynamicData

	ip      []*CustomizationIpV6Generator `xml:"ip,omitempty"`
	gateway []string                      `xml:"gateway,omitempty"`
}

type CustomizationIPSettings struct {
	*DynamicData

	ip            *CustomizationIpGenerator               `xml:"ip,omitempty"`
	subnetMask    string                                  `xml:"subnetMask,omitempty"`
	gateway       []string                                `xml:"gateway,omitempty"`
	ipV6Spec      *CustomizationIPSettingsIpV6AddressSpec `xml:"ipV6Spec,omitempty"`
	dnsServerList []string                                `xml:"dnsServerList,omitempty"`
	dnsDomain     string                                  `xml:"dnsDomain,omitempty"`
	primaryWINS   string                                  `xml:"primaryWINS,omitempty"`
	secondaryWINS string                                  `xml:"secondaryWINS,omitempty"`
	netBIOS       *CustomizationNetBIOSMode               `xml:"netBIOS,omitempty"`
}

type CustomizationSpec struct {
	*DynamicData

	options          *CustomizationOptions          `xml:"options,omitempty"`
	identity         *CustomizationIdentitySettings `xml:"identity,omitempty"`
	globalIPSettings *CustomizationGlobalIPSettings `xml:"globalIPSettings,omitempty"`
	nicSettingMap    []*CustomizationAdapterMapping `xml:"nicSettingMap,omitempty"`
	encryptionKey    []int8                         `xml:"encryptionKey,omitempty"`
}

type CustomizationName struct {
	*DynamicData
}

type CustomizationFixedName struct {
	*CustomizationName

	name string `xml:"name,omitempty"`
}

type CustomizationPrefixName struct {
	*CustomizationName

	base string `xml:"base,omitempty"`
}

type CustomizationVirtualMachineName struct {
	*CustomizationName
}

type CustomizationUnknownName struct {
	*CustomizationName
}

type CustomizationCustomName struct {
	*CustomizationName

	argument string `xml:"argument,omitempty"`
}

type CustomizationPassword struct {
	*DynamicData

	value     string `xml:"value,omitempty"`
	plainText bool   `xml:"plainText,omitempty"`
}

type CustomizationOptions struct {
	*DynamicData
}

type CustomizationWinOptions struct {
	*CustomizationOptions

	changeSID      bool                              `xml:"changeSID,omitempty"`
	deleteAccounts bool                              `xml:"deleteAccounts,omitempty"`
	reboot         *CustomizationSysprepRebootOption `xml:"reboot,omitempty"`
}

type CustomizationLinuxOptions struct {
	*CustomizationOptions
}

type CustomizationGuiUnattended struct {
	*DynamicData

	password       *CustomizationPassword `xml:"password,omitempty"`
	timeZone       int32                  `xml:"timeZone,omitempty"`
	autoLogon      bool                   `xml:"autoLogon,omitempty"`
	autoLogonCount int32                  `xml:"autoLogonCount,omitempty"`
}

type CustomizationUserData struct {
	*DynamicData

	fullName     string             `xml:"fullName,omitempty"`
	orgName      string             `xml:"orgName,omitempty"`
	computerName *CustomizationName `xml:"computerName,omitempty"`
	productId    string             `xml:"productId,omitempty"`
}

type CustomizationGuiRunOnce struct {
	*DynamicData

	commandList []string `xml:"commandList,omitempty"`
}

type CustomizationIdentification struct {
	*DynamicData

	joinWorkgroup       string                 `xml:"joinWorkgroup,omitempty"`
	joinDomain          string                 `xml:"joinDomain,omitempty"`
	domainAdmin         string                 `xml:"domainAdmin,omitempty"`
	domainAdminPassword *CustomizationPassword `xml:"domainAdminPassword,omitempty"`
}

type CustomizationLicenseFilePrintData struct {
	*DynamicData

	autoMode  *CustomizationLicenseDataMode `xml:"autoMode,omitempty"`
	autoUsers int32                         `xml:"autoUsers,omitempty"`
}

type CustomizationIdentitySettings struct {
	*DynamicData
}

type CustomizationSysprepText struct {
	*CustomizationIdentitySettings

	value string `xml:"value,omitempty"`
}

type CustomizationSysprep struct {
	*CustomizationIdentitySettings

	guiUnattended        *CustomizationGuiUnattended        `xml:"guiUnattended,omitempty"`
	userData             *CustomizationUserData             `xml:"userData,omitempty"`
	guiRunOnce           *CustomizationGuiRunOnce           `xml:"guiRunOnce,omitempty"`
	identification       *CustomizationIdentification       `xml:"identification,omitempty"`
	licenseFilePrintData *CustomizationLicenseFilePrintData `xml:"licenseFilePrintData,omitempty"`
}

type CustomizationLinuxPrep struct {
	*CustomizationIdentitySettings

	hostName   *CustomizationName `xml:"hostName,omitempty"`
	domain     string             `xml:"domain,omitempty"`
	timeZone   string             `xml:"timeZone,omitempty"`
	hwClockUTC bool               `xml:"hwClockUTC,omitempty"`
}

type CustomizationGlobalIPSettings struct {
	*DynamicData

	dnsSuffixList []string `xml:"dnsSuffixList,omitempty"`
	dnsServerList []string `xml:"dnsServerList,omitempty"`
}

type CustomizationIpGenerator struct {
	*DynamicData
}

type CustomizationDhcpIpGenerator struct {
	*CustomizationIpGenerator
}

type CustomizationFixedIp struct {
	*CustomizationIpGenerator

	ipAddress string `xml:"ipAddress,omitempty"`
}

type CustomizationUnknownIpGenerator struct {
	*CustomizationIpGenerator
}

type CustomizationCustomIpGenerator struct {
	*CustomizationIpGenerator

	argument string `xml:"argument,omitempty"`
}

type CustomizationIpV6Generator struct {
	*DynamicData
}

type ArrayOfCustomizationIpV6Generator struct {
	CustomizationIpV6Generator []*CustomizationIpV6Generator `xml:"CustomizationIpV6Generator,omitempty"`
}

type CustomizationDhcpIpV6Generator struct {
	*CustomizationIpV6Generator
}

type CustomizationStatelessIpV6Generator struct {
	*CustomizationIpV6Generator
}

type CustomizationFixedIpV6 struct {
	*CustomizationIpV6Generator

	ipAddress  string `xml:"ipAddress,omitempty"`
	subnetMask int32  `xml:"subnetMask,omitempty"`
}

type CustomizationAutoIpV6Generator struct {
	*CustomizationIpV6Generator
}

type CustomizationUnknownIpV6Generator struct {
	*CustomizationIpV6Generator
}

type CustomizationCustomIpV6Generator struct {
	*CustomizationIpV6Generator

	argument string `xml:"argument,omitempty"`
}

type CustomizationAdapterMapping struct {
	*DynamicData

	macAddress string                   `xml:"macAddress,omitempty"`
	adapter    *CustomizationIPSettings `xml:"adapter,omitempty"`
}

type ArrayOfCustomizationAdapterMapping struct {
	CustomizationAdapterMapping []*CustomizationAdapterMapping `xml:"CustomizationAdapterMapping,omitempty"`
}

type HostDiskMappingPartitionInfo struct {
	*DynamicData

	name         string `xml:"name,omitempty"`
	fileSystem   string `xml:"fileSystem,omitempty"`
	capacityInKb int64  `xml:"capacityInKb,omitempty"`
}

type HostDiskMappingInfo struct {
	*DynamicData

	physicalPartition *HostDiskMappingPartitionInfo `xml:"physicalPartition,omitempty"`
	name              string                        `xml:"name,omitempty"`
	exclusive         bool                          `xml:"exclusive,omitempty"`
}

type HostDiskMappingPartitionOption struct {
	*DynamicData

	name         string `xml:"name,omitempty"`
	fileSystem   string `xml:"fileSystem,omitempty"`
	capacityInKb int64  `xml:"capacityInKb,omitempty"`
}

type ArrayOfHostDiskMappingPartitionOption struct {
	HostDiskMappingPartitionOption []*HostDiskMappingPartitionOption `xml:"HostDiskMappingPartitionOption,omitempty"`
}

type HostDiskMappingOption struct {
	*DynamicData

	physicalPartition []*HostDiskMappingPartitionOption `xml:"physicalPartition,omitempty"`
	name              string                            `xml:"name,omitempty"`
}

type ParaVirtualSCSIController struct {
	*VirtualSCSIController
}

type ParaVirtualSCSIControllerOption struct {
	*VirtualSCSIControllerOption
}

type VirtualAHCIController struct {
	*VirtualSATAController
}

type VirtualAHCIControllerOption struct {
	*VirtualSATAControllerOption
}

type VirtualBusLogicController struct {
	*VirtualSCSIController
}

type VirtualBusLogicControllerOption struct {
	*VirtualSCSIControllerOption
}

type VirtualCdromIsoBackingInfo struct {
	*VirtualDeviceFileBackingInfo
}

type VirtualCdromPassthroughBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	exclusive bool `xml:"exclusive,omitempty"`
}

type VirtualCdromRemotePassthroughBackingInfo struct {
	*VirtualDeviceRemoteDeviceBackingInfo

	exclusive bool `xml:"exclusive,omitempty"`
}

type VirtualCdromAtapiBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

type VirtualCdromRemoteAtapiBackingInfo struct {
	*VirtualDeviceRemoteDeviceBackingInfo
}

type VirtualCdrom struct {
	*VirtualDevice
}

type VirtualCdromIsoBackingOption struct {
	*VirtualDeviceFileBackingOption
}

type VirtualCdromPassthroughBackingOption struct {
	*VirtualDeviceDeviceBackingOption

	exclusive *BoolOption `xml:"exclusive,omitempty"`
}

type VirtualCdromRemotePassthroughBackingOption struct {
	*VirtualDeviceRemoteDeviceBackingOption

	exclusive *BoolOption `xml:"exclusive,omitempty"`
}

type VirtualCdromAtapiBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualCdromRemoteAtapiBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualCdromOption struct {
	*VirtualDeviceOption
}

type VirtualController struct {
	*VirtualDevice

	busNumber int32   `xml:"busNumber,omitempty"`
	device    []int32 `xml:"device,omitempty"`
}

type VirtualControllerOption struct {
	*VirtualDeviceOption

	devices         *IntOption `xml:"devices,omitempty"`
	supportedDevice []string   `xml:"supportedDevice,omitempty"`
}

type VirtualDeviceBackingInfo struct {
	*DynamicData
}

type VirtualDeviceFileBackingInfo struct {
	*VirtualDeviceBackingInfo

	fileName        string                  `xml:"fileName,omitempty"`
	datastore       *ManagedObjectReference `xml:"datastore,omitempty"`
	backingObjectId string                  `xml:"backingObjectId,omitempty"`
}

type VirtualDeviceDeviceBackingInfo struct {
	*VirtualDeviceBackingInfo

	deviceName    string `xml:"deviceName,omitempty"`
	useAutoDetect bool   `xml:"useAutoDetect,omitempty"`
}

type VirtualDeviceRemoteDeviceBackingInfo struct {
	*VirtualDeviceBackingInfo

	deviceName    string `xml:"deviceName,omitempty"`
	useAutoDetect bool   `xml:"useAutoDetect,omitempty"`
}

type VirtualDevicePipeBackingInfo struct {
	*VirtualDeviceBackingInfo

	pipeName string `xml:"pipeName,omitempty"`
}

type VirtualDeviceURIBackingInfo struct {
	*VirtualDeviceBackingInfo

	serviceURI string `xml:"serviceURI,omitempty"`
	direction  string `xml:"direction,omitempty"`
	proxyURI   string `xml:"proxyURI,omitempty"`
}

type VirtualDeviceConnectInfo struct {
	*DynamicData

	startConnected    bool   `xml:"startConnected,omitempty"`
	allowGuestControl bool   `xml:"allowGuestControl,omitempty"`
	connected         bool   `xml:"connected,omitempty"`
	status            string `xml:"status,omitempty"`
}

type VirtualDeviceBusSlotInfo struct {
	*DynamicData
}

type VirtualDevicePciBusSlotInfo struct {
	*VirtualDeviceBusSlotInfo

	pciSlotNumber int32 `xml:"pciSlotNumber,omitempty"`
}

type VirtualDevice struct {
	*DynamicData

	key           int32                     `xml:"key,omitempty"`
	deviceInfo    *Description              `xml:"deviceInfo,omitempty"`
	backing       *VirtualDeviceBackingInfo `xml:"backing,omitempty"`
	connectable   *VirtualDeviceConnectInfo `xml:"connectable,omitempty"`
	slotInfo      *VirtualDeviceBusSlotInfo `xml:"slotInfo,omitempty"`
	controllerKey int32                     `xml:"controllerKey,omitempty"`
	unitNumber    int32                     `xml:"unitNumber,omitempty"`
}

type ArrayOfVirtualDevice struct {
	VirtualDevice []*VirtualDevice `xml:"VirtualDevice,omitempty"`
}

type VirtualDeviceBackingOption struct {
	*DynamicData

	type_ string `xml:"type,omitempty"`
}

type ArrayOfVirtualDeviceBackingOption struct {
	VirtualDeviceBackingOption []*VirtualDeviceBackingOption `xml:"VirtualDeviceBackingOption,omitempty"`
}

type VirtualDeviceFileBackingOption struct {
	*VirtualDeviceBackingOption

	fileNameExtensions *ChoiceOption `xml:"fileNameExtensions,omitempty"`
}

type VirtualDeviceDeviceBackingOption struct {
	*VirtualDeviceBackingOption

	autoDetectAvailable *BoolOption `xml:"autoDetectAvailable,omitempty"`
}

type VirtualDeviceRemoteDeviceBackingOption struct {
	*VirtualDeviceBackingOption

	autoDetectAvailable *BoolOption `xml:"autoDetectAvailable,omitempty"`
}

type VirtualDevicePipeBackingOption struct {
	*VirtualDeviceBackingOption
}

type VirtualDeviceURIBackingOption struct {
	*VirtualDeviceBackingOption

	directions *ChoiceOption `xml:"directions,omitempty"`
}

type VirtualDeviceConnectOption struct {
	*DynamicData

	startConnected    *BoolOption `xml:"startConnected,omitempty"`
	allowGuestControl *BoolOption `xml:"allowGuestControl,omitempty"`
}

type VirtualDeviceBusSlotOption struct {
	*DynamicData

	type_ string `xml:"type,omitempty"`
}

type VirtualDeviceOption struct {
	*DynamicData

	type_                     string                        `xml:"type,omitempty"`
	connectOption             *VirtualDeviceConnectOption   `xml:"connectOption,omitempty"`
	busSlotOption             *VirtualDeviceBusSlotOption   `xml:"busSlotOption,omitempty"`
	controllerType            string                        `xml:"controllerType,omitempty"`
	autoAssignController      *BoolOption                   `xml:"autoAssignController,omitempty"`
	backingOption             []*VirtualDeviceBackingOption `xml:"backingOption,omitempty"`
	defaultBackingOptionIndex int32                         `xml:"defaultBackingOptionIndex,omitempty"`
	licensingLimit            []string                      `xml:"licensingLimit,omitempty"`
	deprecated                bool                          `xml:"deprecated,omitempty"`
	plugAndPlay               bool                          `xml:"plugAndPlay,omitempty"`
	hotRemoveSupported        bool                          `xml:"hotRemoveSupported,omitempty"`
}

type ArrayOfVirtualDeviceOption struct {
	VirtualDeviceOption []*VirtualDeviceOption `xml:"VirtualDeviceOption,omitempty"`
}

type VirtualDeviceConfigSpec struct {
	*DynamicData

	operation     *VirtualDeviceConfigSpecOperation     `xml:"operation,omitempty"`
	fileOperation *VirtualDeviceConfigSpecFileOperation `xml:"fileOperation,omitempty"`
	device        *VirtualDevice                        `xml:"device,omitempty"`
	profile       []*VirtualMachineProfileSpec          `xml:"profile,omitempty"`
}

type ArrayOfVirtualDeviceConfigSpec struct {
	VirtualDeviceConfigSpec []*VirtualDeviceConfigSpec `xml:"VirtualDeviceConfigSpec,omitempty"`
}

type VirtualDiskSparseVer1BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	diskMode      string                            `xml:"diskMode,omitempty"`
	split         bool                              `xml:"split,omitempty"`
	writeThrough  bool                              `xml:"writeThrough,omitempty"`
	spaceUsedInKB int64                             `xml:"spaceUsedInKB,omitempty"`
	contentId     string                            `xml:"contentId,omitempty"`
	parent        *VirtualDiskSparseVer1BackingInfo `xml:"parent,omitempty"`
}

type VirtualDiskSparseVer2BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	diskMode      string                            `xml:"diskMode,omitempty"`
	split         bool                              `xml:"split,omitempty"`
	writeThrough  bool                              `xml:"writeThrough,omitempty"`
	spaceUsedInKB int64                             `xml:"spaceUsedInKB,omitempty"`
	uuid          string                            `xml:"uuid,omitempty"`
	contentId     string                            `xml:"contentId,omitempty"`
	changeId      string                            `xml:"changeId,omitempty"`
	parent        *VirtualDiskSparseVer2BackingInfo `xml:"parent,omitempty"`
}

type VirtualDiskFlatVer1BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	diskMode     string                          `xml:"diskMode,omitempty"`
	split        bool                            `xml:"split,omitempty"`
	writeThrough bool                            `xml:"writeThrough,omitempty"`
	contentId    string                          `xml:"contentId,omitempty"`
	parent       *VirtualDiskFlatVer1BackingInfo `xml:"parent,omitempty"`
}

type VirtualDiskFlatVer2BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	diskMode        string                          `xml:"diskMode,omitempty"`
	split           bool                            `xml:"split,omitempty"`
	writeThrough    bool                            `xml:"writeThrough,omitempty"`
	thinProvisioned bool                            `xml:"thinProvisioned,omitempty"`
	eagerlyScrub    bool                            `xml:"eagerlyScrub,omitempty"`
	uuid            string                          `xml:"uuid,omitempty"`
	contentId       string                          `xml:"contentId,omitempty"`
	changeId        string                          `xml:"changeId,omitempty"`
	parent          *VirtualDiskFlatVer2BackingInfo `xml:"parent,omitempty"`
	deltaDiskFormat string                          `xml:"deltaDiskFormat,omitempty"`
	digestEnabled   bool                            `xml:"digestEnabled,omitempty"`
	deltaGrainSize  int32                           `xml:"deltaGrainSize,omitempty"`
}

type VirtualDiskSeSparseBackingInfo struct {
	*VirtualDeviceFileBackingInfo

	diskMode        string                          `xml:"diskMode,omitempty"`
	writeThrough    bool                            `xml:"writeThrough,omitempty"`
	uuid            string                          `xml:"uuid,omitempty"`
	contentId       string                          `xml:"contentId,omitempty"`
	changeId        string                          `xml:"changeId,omitempty"`
	parent          *VirtualDiskSeSparseBackingInfo `xml:"parent,omitempty"`
	deltaDiskFormat string                          `xml:"deltaDiskFormat,omitempty"`
	digestEnabled   bool                            `xml:"digestEnabled,omitempty"`
	grainSize       int32                           `xml:"grainSize,omitempty"`
}

type VirtualDiskRawDiskVer2BackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	descriptorFileName string `xml:"descriptorFileName,omitempty"`
	uuid               string `xml:"uuid,omitempty"`
	changeId           string `xml:"changeId,omitempty"`
}

type VirtualDiskPartitionedRawDiskVer2BackingInfo struct {
	*VirtualDiskRawDiskVer2BackingInfo

	partition []int32 `xml:"partition,omitempty"`
}

type VirtualDiskRawDiskMappingVer1BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	lunUuid           string                                    `xml:"lunUuid,omitempty"`
	deviceName        string                                    `xml:"deviceName,omitempty"`
	compatibilityMode string                                    `xml:"compatibilityMode,omitempty"`
	diskMode          string                                    `xml:"diskMode,omitempty"`
	uuid              string                                    `xml:"uuid,omitempty"`
	contentId         string                                    `xml:"contentId,omitempty"`
	changeId          string                                    `xml:"changeId,omitempty"`
	parent            *VirtualDiskRawDiskMappingVer1BackingInfo `xml:"parent,omitempty"`
}

type VirtualDiskVFlashCacheConfigInfo struct {
	*DynamicData

	vFlashModule         string `xml:"vFlashModule,omitempty"`
	reservationInMB      int64  `xml:"reservationInMB,omitempty"`
	cacheConsistencyType string `xml:"cacheConsistencyType,omitempty"`
	cacheMode            string `xml:"cacheMode,omitempty"`
	blockSizeInKB        int64  `xml:"blockSizeInKB,omitempty"`
}

type VirtualDisk struct {
	*VirtualDevice

	capacityInKB          int64                             `xml:"capacityInKB,omitempty"`
	capacityInBytes       int64                             `xml:"capacityInBytes,omitempty"`
	shares                *SharesInfo                       `xml:"shares,omitempty"`
	storageIOAllocation   *StorageIOAllocationInfo          `xml:"storageIOAllocation,omitempty"`
	diskObjectId          string                            `xml:"diskObjectId,omitempty"`
	vFlashCacheConfigInfo *VirtualDiskVFlashCacheConfigInfo `xml:"vFlashCacheConfigInfo,omitempty"`
}

type ArrayOfVirtualDisk struct {
	VirtualDisk []*VirtualDisk `xml:"VirtualDisk,omitempty"`
}

type VirtualDiskId struct {
	*DynamicData

	vm     *ManagedObjectReference `xml:"vm,omitempty"`
	diskId int32                   `xml:"diskId,omitempty"`
}

type VirtualDiskSparseVer1BackingOption struct {
	*VirtualDeviceFileBackingOption

	diskModes    *ChoiceOption `xml:"diskModes,omitempty"`
	split        *BoolOption   `xml:"split,omitempty"`
	writeThrough *BoolOption   `xml:"writeThrough,omitempty"`
	growable     bool          `xml:"growable,omitempty"`
}

type VirtualDiskSparseVer2BackingOption struct {
	*VirtualDeviceFileBackingOption

	diskMode     *ChoiceOption `xml:"diskMode,omitempty"`
	split        *BoolOption   `xml:"split,omitempty"`
	writeThrough *BoolOption   `xml:"writeThrough,omitempty"`
	growable     bool          `xml:"growable,omitempty"`
	hotGrowable  bool          `xml:"hotGrowable,omitempty"`
	uuid         bool          `xml:"uuid,omitempty"`
}

type VirtualDiskFlatVer1BackingOption struct {
	*VirtualDeviceFileBackingOption

	diskMode     *ChoiceOption `xml:"diskMode,omitempty"`
	split        *BoolOption   `xml:"split,omitempty"`
	writeThrough *BoolOption   `xml:"writeThrough,omitempty"`
	growable     bool          `xml:"growable,omitempty"`
}

type VirtualDiskDeltaDiskFormatsSupported struct {
	*DynamicData

	datastoreType   string        `xml:"datastoreType,omitempty"`
	deltaDiskFormat *ChoiceOption `xml:"deltaDiskFormat,omitempty"`
}

type ArrayOfVirtualDiskDeltaDiskFormatsSupported struct {
	VirtualDiskDeltaDiskFormatsSupported []*VirtualDiskDeltaDiskFormatsSupported `xml:"VirtualDiskDeltaDiskFormatsSupported,omitempty"`
}

type VirtualDiskFlatVer2BackingOption struct {
	*VirtualDeviceFileBackingOption

	diskMode                  *ChoiceOption                           `xml:"diskMode,omitempty"`
	split                     *BoolOption                             `xml:"split,omitempty"`
	writeThrough              *BoolOption                             `xml:"writeThrough,omitempty"`
	growable                  bool                                    `xml:"growable,omitempty"`
	hotGrowable               bool                                    `xml:"hotGrowable,omitempty"`
	uuid                      bool                                    `xml:"uuid,omitempty"`
	thinProvisioned           *BoolOption                             `xml:"thinProvisioned,omitempty"`
	eagerlyScrub              *BoolOption                             `xml:"eagerlyScrub,omitempty"`
	deltaDiskFormat           *ChoiceOption                           `xml:"deltaDiskFormat,omitempty"`
	deltaDiskFormatsSupported []*VirtualDiskDeltaDiskFormatsSupported `xml:"deltaDiskFormatsSupported,omitempty"`
}

type VirtualDiskSeSparseBackingOption struct {
	*VirtualDeviceFileBackingOption

	diskMode                  *ChoiceOption                           `xml:"diskMode,omitempty"`
	writeThrough              *BoolOption                             `xml:"writeThrough,omitempty"`
	growable                  bool                                    `xml:"growable,omitempty"`
	hotGrowable               bool                                    `xml:"hotGrowable,omitempty"`
	uuid                      bool                                    `xml:"uuid,omitempty"`
	deltaDiskFormatsSupported []*VirtualDiskDeltaDiskFormatsSupported `xml:"deltaDiskFormatsSupported,omitempty"`
}

type VirtualDiskRawDiskVer2BackingOption struct {
	*VirtualDeviceDeviceBackingOption

	descriptorFileNameExtensions *ChoiceOption `xml:"descriptorFileNameExtensions,omitempty"`
	uuid                         bool          `xml:"uuid,omitempty"`
}

type VirtualDiskPartitionedRawDiskVer2BackingOption struct {
	*VirtualDiskRawDiskVer2BackingOption
}

type VirtualDiskRawDiskMappingVer1BackingOption struct {
	*VirtualDeviceDeviceBackingOption

	descriptorFileNameExtensions *ChoiceOption `xml:"descriptorFileNameExtensions,omitempty"`
	compatibilityMode            *ChoiceOption `xml:"compatibilityMode,omitempty"`
	diskMode                     *ChoiceOption `xml:"diskMode,omitempty"`
	uuid                         bool          `xml:"uuid,omitempty"`
}

type VirtualDiskOptionVFlashCacheConfigOption struct {
	*DynamicData

	cacheConsistencyType *ChoiceOption `xml:"cacheConsistencyType,omitempty"`
	cacheMode            *ChoiceOption `xml:"cacheMode,omitempty"`
	reservationInMB      *LongOption   `xml:"reservationInMB,omitempty"`
	blockSizeInKB        *LongOption   `xml:"blockSizeInKB,omitempty"`
}

type VirtualDiskOption struct {
	*VirtualDeviceOption

	capacityInKB            *LongOption                               `xml:"capacityInKB,omitempty"`
	ioAllocationOption      *StorageIOAllocationOption                `xml:"ioAllocationOption,omitempty"`
	vFlashCacheConfigOption *VirtualDiskOptionVFlashCacheConfigOption `xml:"vFlashCacheConfigOption,omitempty"`
}

type VirtualDiskConfigSpec struct {
	*VirtualDeviceConfigSpec

	migrateCache bool `xml:"migrateCache,omitempty"`
}

type VirtualE1000 struct {
	*VirtualEthernetCard
}

type VirtualE1000Option struct {
	*VirtualEthernetCardOption
}

type VirtualE1000e struct {
	*VirtualEthernetCard
}

type VirtualE1000eOption struct {
	*VirtualEthernetCardOption
}

type VirtualEnsoniq1371 struct {
	*VirtualSoundCard
}

type VirtualEnsoniq1371Option struct {
	*VirtualSoundCardOption
}

type VirtualEthernetCardNetworkBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	network           *ManagedObjectReference `xml:"network,omitempty"`
	inPassthroughMode bool                    `xml:"inPassthroughMode,omitempty"`
}

type VirtualEthernetCardLegacyNetworkBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

type VirtualEthernetCardDistributedVirtualPortBackingInfo struct {
	*VirtualDeviceBackingInfo

	port *DistributedVirtualSwitchPortConnection `xml:"port,omitempty"`
}

type VirtualEthernetCardOpaqueNetworkBackingInfo struct {
	*VirtualDeviceBackingInfo

	opaqueNetworkId   string `xml:"opaqueNetworkId,omitempty"`
	opaqueNetworkType string `xml:"opaqueNetworkType,omitempty"`
}

type VirtualEthernetCard struct {
	*VirtualDevice

	addressType      string `xml:"addressType,omitempty"`
	macAddress       string `xml:"macAddress,omitempty"`
	wakeOnLanEnabled bool   `xml:"wakeOnLanEnabled,omitempty"`
}

type VirtualEthernetCardNetworkBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualEthernetCardOpaqueNetworkBackingOption struct {
	*VirtualDeviceBackingOption
}

type VirtualEthernetCardLegacyNetworkBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualEthernetCardDVPortBackingOption struct {
	*VirtualDeviceBackingOption
}

type VirtualEthernetCardOption struct {
	*VirtualDeviceOption

	supportedOUI              *ChoiceOption `xml:"supportedOUI,omitempty"`
	macType                   *ChoiceOption `xml:"macType,omitempty"`
	wakeOnLanEnabled          *BoolOption   `xml:"wakeOnLanEnabled,omitempty"`
	vmDirectPathGen2Supported bool          `xml:"vmDirectPathGen2Supported,omitempty"`
}

type VirtualFloppyImageBackingInfo struct {
	*VirtualDeviceFileBackingInfo
}

type VirtualFloppyDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

type VirtualFloppyRemoteDeviceBackingInfo struct {
	*VirtualDeviceRemoteDeviceBackingInfo
}

type VirtualFloppy struct {
	*VirtualDevice
}

type VirtualFloppyImageBackingOption struct {
	*VirtualDeviceFileBackingOption
}

type VirtualFloppyDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualFloppyRemoteDeviceBackingOption struct {
	*VirtualDeviceRemoteDeviceBackingOption
}

type VirtualFloppyOption struct {
	*VirtualDeviceOption
}

type VirtualHdAudioCard struct {
	*VirtualSoundCard
}

type VirtualHdAudioCardOption struct {
	*VirtualSoundCardOption
}

type VirtualIDEController struct {
	*VirtualController
}

type VirtualIDEControllerOption struct {
	*VirtualControllerOption

	numIDEDisks  *IntOption `xml:"numIDEDisks,omitempty"`
	numIDECdroms *IntOption `xml:"numIDECdroms,omitempty"`
}

type VirtualKeyboard struct {
	*VirtualDevice
}

type VirtualKeyboardOption struct {
	*VirtualDeviceOption
}

type VirtualLsiLogicController struct {
	*VirtualSCSIController
}

type VirtualLsiLogicControllerOption struct {
	*VirtualSCSIControllerOption
}

type VirtualLsiLogicSASController struct {
	*VirtualSCSIController
}

type VirtualLsiLogicSASControllerOption struct {
	*VirtualSCSIControllerOption
}

type VirtualPCIController struct {
	*VirtualController
}

type VirtualPCIControllerOption struct {
	*VirtualControllerOption

	numSCSIControllers            *IntOption `xml:"numSCSIControllers,omitempty"`
	numEthernetCards              *IntOption `xml:"numEthernetCards,omitempty"`
	numVideoCards                 *IntOption `xml:"numVideoCards,omitempty"`
	numSoundCards                 *IntOption `xml:"numSoundCards,omitempty"`
	numVmiRoms                    *IntOption `xml:"numVmiRoms,omitempty"`
	numVmciDevices                *IntOption `xml:"numVmciDevices,omitempty"`
	numPCIPassthroughDevices      *IntOption `xml:"numPCIPassthroughDevices,omitempty"`
	numSasSCSIControllers         *IntOption `xml:"numSasSCSIControllers,omitempty"`
	numVmxnet3EthernetCards       *IntOption `xml:"numVmxnet3EthernetCards,omitempty"`
	numParaVirtualSCSIControllers *IntOption `xml:"numParaVirtualSCSIControllers,omitempty"`
	numSATAControllers            *IntOption `xml:"numSATAControllers,omitempty"`
}

type VirtualPCIPassthroughDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	id       string `xml:"id,omitempty"`
	deviceId string `xml:"deviceId,omitempty"`
	systemId string `xml:"systemId,omitempty"`
	vendorId int16  `xml:"vendorId,omitempty"`
}

type VirtualPCIPassthrough struct {
	*VirtualDevice
}

type VirtualPCIPassthroughDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualPCIPassthroughOption struct {
	*VirtualDeviceOption
}

type VirtualPCNet32 struct {
	*VirtualEthernetCard
}

type VirtualPCNet32Option struct {
	*VirtualEthernetCardOption

	supportsMorphing bool `xml:"supportsMorphing,omitempty"`
}

type VirtualPS2Controller struct {
	*VirtualController
}

type VirtualPS2ControllerOption struct {
	*VirtualControllerOption

	numKeyboards       *IntOption `xml:"numKeyboards,omitempty"`
	numPointingDevices *IntOption `xml:"numPointingDevices,omitempty"`
}

type VirtualParallelPortFileBackingInfo struct {
	*VirtualDeviceFileBackingInfo
}

type VirtualParallelPortDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

type VirtualParallelPort struct {
	*VirtualDevice
}

type VirtualParallelPortFileBackingOption struct {
	*VirtualDeviceFileBackingOption
}

type VirtualParallelPortDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualParallelPortOption struct {
	*VirtualDeviceOption
}

type VirtualPointingDeviceDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	hostPointingDevice string `xml:"hostPointingDevice,omitempty"`
}

type VirtualPointingDevice struct {
	*VirtualDevice
}

type VirtualPointingDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption

	hostPointingDevice *ChoiceOption `xml:"hostPointingDevice,omitempty"`
}

type VirtualPointingDeviceOption struct {
	*VirtualDeviceOption
}

type VirtualSATAController struct {
	*VirtualController
}

type VirtualSATAControllerOption struct {
	*VirtualControllerOption

	numSATADisks  *IntOption `xml:"numSATADisks,omitempty"`
	numSATACdroms *IntOption `xml:"numSATACdroms,omitempty"`
}

type ArrayOfVirtualSCSISharing struct {
	VirtualSCSISharing []*VirtualSCSISharing `xml:"VirtualSCSISharing,omitempty"`
}

type VirtualSCSIController struct {
	*VirtualController

	hotAddRemove       bool                `xml:"hotAddRemove,omitempty"`
	sharedBus          *VirtualSCSISharing `xml:"sharedBus,omitempty"`
	scsiCtlrUnitNumber int32               `xml:"scsiCtlrUnitNumber,omitempty"`
}

type VirtualSCSIControllerOption struct {
	*VirtualControllerOption

	numSCSIDisks       *IntOption            `xml:"numSCSIDisks,omitempty"`
	numSCSICdroms      *IntOption            `xml:"numSCSICdroms,omitempty"`
	numSCSIPassthrough *IntOption            `xml:"numSCSIPassthrough,omitempty"`
	sharing            []*VirtualSCSISharing `xml:"sharing,omitempty"`
	defaultSharedIndex int32                 `xml:"defaultSharedIndex,omitempty"`
	hotAddRemove       *BoolOption           `xml:"hotAddRemove,omitempty"`
	scsiCtlrUnitNumber int32                 `xml:"scsiCtlrUnitNumber,omitempty"`
}

type VirtualSCSIPassthroughDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

type VirtualSCSIPassthrough struct {
	*VirtualDevice
}

type VirtualSCSIPassthroughDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualSCSIPassthroughOption struct {
	*VirtualDeviceOption
}

type VirtualSIOController struct {
	*VirtualController
}

type VirtualSIOControllerOption struct {
	*VirtualControllerOption

	numFloppyDrives  *IntOption `xml:"numFloppyDrives,omitempty"`
	numSerialPorts   *IntOption `xml:"numSerialPorts,omitempty"`
	numParallelPorts *IntOption `xml:"numParallelPorts,omitempty"`
}

type VirtualSerialPortFileBackingInfo struct {
	*VirtualDeviceFileBackingInfo
}

type VirtualSerialPortDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

type VirtualSerialPortPipeBackingInfo struct {
	*VirtualDevicePipeBackingInfo

	endpoint string `xml:"endpoint,omitempty"`
	noRxLoss bool   `xml:"noRxLoss,omitempty"`
}

type VirtualSerialPortURIBackingInfo struct {
	*VirtualDeviceURIBackingInfo
}

type VirtualSerialPortThinPrintBackingInfo struct {
	*VirtualDeviceBackingInfo
}

type VirtualSerialPort struct {
	*VirtualDevice

	yieldOnPoll bool `xml:"yieldOnPoll,omitempty"`
}

type VirtualSerialPortFileBackingOption struct {
	*VirtualDeviceFileBackingOption
}

type VirtualSerialPortDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualSerialPortPipeBackingOption struct {
	*VirtualDevicePipeBackingOption

	endpoint *ChoiceOption `xml:"endpoint,omitempty"`
	noRxLoss *BoolOption   `xml:"noRxLoss,omitempty"`
}

type VirtualSerialPortURIBackingOption struct {
	*VirtualDeviceURIBackingOption
}

type VirtualSerialPortThinPrintBackingOption struct {
	*VirtualDeviceBackingOption
}

type VirtualSerialPortOption struct {
	*VirtualDeviceOption

	yieldOnPoll *BoolOption `xml:"yieldOnPoll,omitempty"`
}

type VirtualSoundBlaster16 struct {
	*VirtualSoundCard
}

type VirtualSoundBlaster16Option struct {
	*VirtualSoundCardOption
}

type VirtualSoundCardDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

type VirtualSoundCard struct {
	*VirtualDevice
}

type VirtualSoundCardDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualSoundCardOption struct {
	*VirtualDeviceOption
}

type VirtualSriovEthernetCardSriovBackingInfo struct {
	*VirtualDeviceBackingInfo

	physicalFunctionBacking *VirtualPCIPassthroughDeviceBackingInfo `xml:"physicalFunctionBacking,omitempty"`
	virtualFunctionBacking  *VirtualPCIPassthroughDeviceBackingInfo `xml:"virtualFunctionBacking,omitempty"`
	virtualFunctionIndex    int32                                   `xml:"virtualFunctionIndex,omitempty"`
}

type VirtualSriovEthernetCard struct {
	*VirtualEthernetCard

	allowGuestOSMtuChange bool                                      `xml:"allowGuestOSMtuChange,omitempty"`
	sriovBacking          *VirtualSriovEthernetCardSriovBackingInfo `xml:"sriovBacking,omitempty"`
}

type VirtualSriovEthernetCardSriovBackingOption struct {
	*VirtualDeviceBackingOption
}

type VirtualSriovEthernetCardOption struct {
	*VirtualEthernetCardOption
}

type VirtualUSBUSBBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

type VirtualUSBRemoteHostBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	hostname string `xml:"hostname,omitempty"`
}

type VirtualUSBRemoteClientBackingInfo struct {
	*VirtualDeviceRemoteDeviceBackingInfo

	hostname string `xml:"hostname,omitempty"`
}

type VirtualUSB struct {
	*VirtualDevice

	connected bool     `xml:"connected,omitempty"`
	vendor    int32    `xml:"vendor,omitempty"`
	product   int32    `xml:"product,omitempty"`
	family    []string `xml:"family,omitempty"`
	speed     []string `xml:"speed,omitempty"`
}

type VirtualUSBControllerPciBusSlotInfo struct {
	*VirtualDevicePciBusSlotInfo

	ehciPciSlotNumber int32 `xml:"ehciPciSlotNumber,omitempty"`
}

type VirtualUSBController struct {
	*VirtualController

	autoConnectDevices bool `xml:"autoConnectDevices,omitempty"`
	ehciEnabled        bool `xml:"ehciEnabled,omitempty"`
}

type VirtualUSBControllerOption struct {
	*VirtualControllerOption

	autoConnectDevices *BoolOption `xml:"autoConnectDevices,omitempty"`
	ehciSupported      *BoolOption `xml:"ehciSupported,omitempty"`
	supportedSpeeds    []string    `xml:"supportedSpeeds,omitempty"`
}

type VirtualUSBUSBBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualUSBRemoteHostBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

type VirtualUSBRemoteClientBackingOption struct {
	*VirtualDeviceRemoteDeviceBackingOption
}

type VirtualUSBOption struct {
	*VirtualDeviceOption
}

type VirtualUSBXHCIController struct {
	*VirtualController

	autoConnectDevices bool `xml:"autoConnectDevices,omitempty"`
}

type VirtualUSBXHCIControllerOption struct {
	*VirtualControllerOption

	autoConnectDevices *BoolOption `xml:"autoConnectDevices,omitempty"`
	supportedSpeeds    []string    `xml:"supportedSpeeds,omitempty"`
}

type VirtualMachineVMCIDevice struct {
	*VirtualDevice

	id                             int64 `xml:"id,omitempty"`
	allowUnrestrictedCommunication bool  `xml:"allowUnrestrictedCommunication,omitempty"`
}

type VirtualMachineVMCIDeviceOption struct {
	*VirtualDeviceOption

	allowUnrestrictedCommunication *BoolOption `xml:"allowUnrestrictedCommunication,omitempty"`
}

type VirtualMachineVMIROM struct {
	*VirtualDevice
}

type VirtualVMIROMOption struct {
	*VirtualDeviceOption
}

type VirtualMachineVideoCard struct {
	*VirtualDevice

	videoRamSizeInKB int64  `xml:"videoRamSizeInKB,omitempty"`
	numDisplays      int32  `xml:"numDisplays,omitempty"`
	useAutoDetect    bool   `xml:"useAutoDetect,omitempty"`
	enable3DSupport  bool   `xml:"enable3DSupport,omitempty"`
	use3dRenderer    string `xml:"use3dRenderer,omitempty"`
}

type VirtualVideoCardOption struct {
	*VirtualDeviceOption

	videoRamSizeInKB       *LongOption `xml:"videoRamSizeInKB,omitempty"`
	numDisplays            *IntOption  `xml:"numDisplays,omitempty"`
	useAutoDetect          *BoolOption `xml:"useAutoDetect,omitempty"`
	support3D              *BoolOption `xml:"support3D,omitempty"`
	use3dRendererSupported *BoolOption `xml:"use3dRendererSupported,omitempty"`
}

type VirtualVmxnet struct {
	*VirtualEthernetCard
}

type VirtualVmxnet2 struct {
	*VirtualVmxnet
}

type VirtualVmxnet2Option struct {
	*VirtualVmxnetOption
}

type VirtualVmxnet3 struct {
	*VirtualVmxnet
}

type VirtualVmxnet3Option struct {
	*VirtualVmxnetOption
}

type VirtualVmxnetOption struct {
	*VirtualEthernetCardOption
}

type GuestFileAttributes struct {
	*DynamicData

	modificationTime time.Time `xml:"modificationTime,omitempty"`
	accessTime       time.Time `xml:"accessTime,omitempty"`
	symlinkTarget    string    `xml:"symlinkTarget,omitempty"`
}

type GuestPosixFileAttributes struct {
	*GuestFileAttributes

	ownerId     int32 `xml:"ownerId,omitempty"`
	groupId     int32 `xml:"groupId,omitempty"`
	permissions int64 `xml:"permissions,omitempty"`
}

type GuestWindowsFileAttributes struct {
	*GuestFileAttributes

	hidden     bool      `xml:"hidden,omitempty"`
	readOnly   bool      `xml:"readOnly,omitempty"`
	createTime time.Time `xml:"createTime,omitempty"`
}

type GuestFileInfo struct {
	*DynamicData

	path       string               `xml:"path,omitempty"`
	type_      string               `xml:"type,omitempty"`
	size       int64                `xml:"size,omitempty"`
	attributes *GuestFileAttributes `xml:"attributes,omitempty"`
}

type ArrayOfGuestFileInfo struct {
	GuestFileInfo []*GuestFileInfo `xml:"GuestFileInfo,omitempty"`
}

type GuestListFileInfo struct {
	*DynamicData

	files     []*GuestFileInfo `xml:"files,omitempty"`
	remaining int32            `xml:"remaining,omitempty"`
}

type FileTransferInformation struct {
	*DynamicData

	attributes *GuestFileAttributes `xml:"attributes,omitempty"`
	size       int64                `xml:"size,omitempty"`
	url        string               `xml:"url,omitempty"`
}

type GuestAuthentication struct {
	*DynamicData

	interactiveSession bool `xml:"interactiveSession,omitempty"`
}

type NamePasswordAuthentication struct {
	*GuestAuthentication

	username string `xml:"username,omitempty"`
	password string `xml:"password,omitempty"`
}

type GuestProgramSpec struct {
	*DynamicData

	programPath      string   `xml:"programPath,omitempty"`
	arguments        string   `xml:"arguments,omitempty"`
	workingDirectory string   `xml:"workingDirectory,omitempty"`
	envVariables     []string `xml:"envVariables,omitempty"`
}

type GuestWindowsProgramSpec struct {
	*GuestProgramSpec

	startMinimized bool `xml:"startMinimized,omitempty"`
}

type GuestProcessInfo struct {
	*DynamicData

	name      string    `xml:"name,omitempty"`
	pid       int64     `xml:"pid,omitempty"`
	owner     string    `xml:"owner,omitempty"`
	cmdLine   string    `xml:"cmdLine,omitempty"`
	startTime time.Time `xml:"startTime,omitempty"`
	endTime   time.Time `xml:"endTime,omitempty"`
	exitCode  int32     `xml:"exitCode,omitempty"`
}

type ArrayOfGuestProcessInfo struct {
	GuestProcessInfo []*GuestProcessInfo `xml:"GuestProcessInfo,omitempty"`
}

type SSPIAuthentication struct {
	*GuestAuthentication

	sspiToken string `xml:"sspiToken,omitempty"`
}

type TicketedSessionAuthentication struct {
	*GuestAuthentication

	ticket string `xml:"ticket,omitempty"`
}

type VsanClusterConfigInfoHostDefaultInfo struct {
	*DynamicData

	uuid             string `xml:"uuid,omitempty"`
	autoClaimStorage bool   `xml:"autoClaimStorage,omitempty"`
}

type VsanClusterConfigInfo struct {
	*DynamicData

	enabled       bool                                  `xml:"enabled,omitempty"`
	defaultConfig *VsanClusterConfigInfoHostDefaultInfo `xml:"defaultConfig,omitempty"`
}

type VsanHostClusterStatusStateCompletionEstimate struct {
	*DynamicData

	completeTime    time.Time `xml:"completeTime,omitempty"`
	percentComplete int32     `xml:"percentComplete,omitempty"`
}

type VsanHostClusterStatusState struct {
	*DynamicData

	state      string                                        `xml:"state,omitempty"`
	completion *VsanHostClusterStatusStateCompletionEstimate `xml:"completion,omitempty"`
}

type VsanHostClusterStatus struct {
	*DynamicData

	uuid       string                      `xml:"uuid,omitempty"`
	nodeUuid   string                      `xml:"nodeUuid,omitempty"`
	health     string                      `xml:"health,omitempty"`
	nodeState  *VsanHostClusterStatusState `xml:"nodeState,omitempty"`
	memberUuid []string                    `xml:"memberUuid,omitempty"`
}

type VsanHostConfigInfoStorageInfo struct {
	*DynamicData

	autoClaimStorage bool                   `xml:"autoClaimStorage,omitempty"`
	diskMapping      []*VsanHostDiskMapping `xml:"diskMapping,omitempty"`
}

type VsanHostConfigInfoClusterInfo struct {
	*DynamicData

	uuid     string `xml:"uuid,omitempty"`
	nodeUuid string `xml:"nodeUuid,omitempty"`
}

type VsanHostConfigInfoNetworkInfoPortConfig struct {
	*DynamicData

	ipConfig *VsanHostIpConfig `xml:"ipConfig,omitempty"`
	device   string            `xml:"device,omitempty"`
}

type ArrayOfVsanHostConfigInfoNetworkInfoPortConfig struct {
	VsanHostConfigInfoNetworkInfoPortConfig []*VsanHostConfigInfoNetworkInfoPortConfig `xml:"VsanHostConfigInfoNetworkInfoPortConfig,omitempty"`
}

type VsanHostConfigInfoNetworkInfo struct {
	*DynamicData

	port []*VsanHostConfigInfoNetworkInfoPortConfig `xml:"port,omitempty"`
}

type VsanHostConfigInfo struct {
	*DynamicData

	enabled     bool                           `xml:"enabled,omitempty"`
	hostSystem  *ManagedObjectReference        `xml:"hostSystem,omitempty"`
	clusterInfo *VsanHostConfigInfoClusterInfo `xml:"clusterInfo,omitempty"`
	storageInfo *VsanHostConfigInfoStorageInfo `xml:"storageInfo,omitempty"`
	networkInfo *VsanHostConfigInfoNetworkInfo `xml:"networkInfo,omitempty"`
}

type ArrayOfVsanHostConfigInfo struct {
	VsanHostConfigInfo []*VsanHostConfigInfo `xml:"VsanHostConfigInfo,omitempty"`
}

type VsanHostDecommissionMode struct {
	*DynamicData

	objectAction string `xml:"objectAction,omitempty"`
}

type VsanHostDiskMapResult struct {
	*DynamicData

	mapping    *VsanHostDiskMapping  `xml:"mapping,omitempty"`
	diskResult []*VsanHostDiskResult `xml:"diskResult,omitempty"`
	error      *LocalizedMethodFault `xml:"error,omitempty"`
}

type ArrayOfVsanHostDiskMapResult struct {
	VsanHostDiskMapResult []*VsanHostDiskMapResult `xml:"VsanHostDiskMapResult,omitempty"`
}

type VsanHostDiskMapping struct {
	*DynamicData

	ssd    *HostScsiDisk   `xml:"ssd,omitempty"`
	nonSsd []*HostScsiDisk `xml:"nonSsd,omitempty"`
}

type ArrayOfVsanHostDiskMapping struct {
	VsanHostDiskMapping []*VsanHostDiskMapping `xml:"VsanHostDiskMapping,omitempty"`
}

type VsanHostDiskResult struct {
	*DynamicData

	disk     *HostScsiDisk         `xml:"disk,omitempty"`
	state    string                `xml:"state,omitempty"`
	vsanUuid string                `xml:"vsanUuid,omitempty"`
	error    *LocalizedMethodFault `xml:"error,omitempty"`
}

type ArrayOfVsanHostDiskResult struct {
	VsanHostDiskResult []*VsanHostDiskResult `xml:"VsanHostDiskResult,omitempty"`
}

type VsanHostIpConfig struct {
	*DynamicData

	upstreamIpAddress   string `xml:"upstreamIpAddress,omitempty"`
	downstreamIpAddress string `xml:"downstreamIpAddress,omitempty"`
}

type VsanHostMembershipInfo struct {
	*DynamicData

	nodeUuid string `xml:"nodeUuid,omitempty"`
	hostname string `xml:"hostname,omitempty"`
}

type ArrayOfVsanHostMembershipInfo struct {
	VsanHostMembershipInfo []*VsanHostMembershipInfo `xml:"VsanHostMembershipInfo,omitempty"`
}

type VsanHostRuntimeInfoDiskIssue struct {
	*DynamicData

	diskId string `xml:"diskId,omitempty"`
	issue  string `xml:"issue,omitempty"`
}

type ArrayOfVsanHostRuntimeInfoDiskIssue struct {
	VsanHostRuntimeInfoDiskIssue []*VsanHostRuntimeInfoDiskIssue `xml:"VsanHostRuntimeInfoDiskIssue,omitempty"`
}

type VsanHostRuntimeInfo struct {
	*DynamicData

	membershipList []*VsanHostMembershipInfo       `xml:"membershipList,omitempty"`
	diskIssues     []*VsanHostRuntimeInfoDiskIssue `xml:"diskIssues,omitempty"`
	accessGenNo    int32                           `xml:"accessGenNo,omitempty"`
}

type AddAuthorizationRoleRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	name    string                  `xml:"name,omitempty"`
	privIds []string                `xml:"privIds,omitempty"`
}

type RemoveAuthorizationRoleRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	roleId     int32                   `xml:"roleId,omitempty"`
	failIfUsed bool                    `xml:"failIfUsed,omitempty"`
}

type UpdateAuthorizationRoleRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	roleId  int32                   `xml:"roleId,omitempty"`
	newName string                  `xml:"newName,omitempty"`
	privIds []string                `xml:"privIds,omitempty"`
}

type MergePermissionsRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	srcRoleId int32                   `xml:"srcRoleId,omitempty"`
	dstRoleId int32                   `xml:"dstRoleId,omitempty"`
}

type RetrieveRolePermissionsRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	roleId int32                   `xml:"roleId,omitempty"`
}

type RetrieveEntityPermissionsRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	entity    *ManagedObjectReference `xml:"entity,omitempty"`
	inherited bool                    `xml:"inherited,omitempty"`
}

type RetrieveAllPermissionsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type SetEntityPermissionsRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	entity     *ManagedObjectReference `xml:"entity,omitempty"`
	permission []*Permission           `xml:"permission,omitempty"`
}

type ResetEntityPermissionsRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	entity     *ManagedObjectReference `xml:"entity,omitempty"`
	permission []*Permission           `xml:"permission,omitempty"`
}

type RemoveEntityPermissionRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	entity  *ManagedObjectReference `xml:"entity,omitempty"`
	user    string                  `xml:"user,omitempty"`
	isGroup bool                    `xml:"isGroup,omitempty"`
}

type HasPrivilegeOnEntityRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	entity    *ManagedObjectReference `xml:"entity,omitempty"`
	sessionId string                  `xml:"sessionId,omitempty"`
	privId    []string                `xml:"privId,omitempty"`
}

type HasPrivilegeOnEntitiesRequestType struct {
	_this     *ManagedObjectReference   `xml:"_this,omitempty"`
	entity    []*ManagedObjectReference `xml:"entity,omitempty"`
	sessionId string                    `xml:"sessionId,omitempty"`
	privId    []string                  `xml:"privId,omitempty"`
}

type ReconfigureClusterRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	spec   *ClusterConfigSpec      `xml:"spec,omitempty"`
	modify bool                    `xml:"modify,omitempty"`
}

type ApplyRecommendationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   string                  `xml:"key,omitempty"`
}

type CancelRecommendationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   string                  `xml:"key,omitempty"`
}

type RecommendHostsForVmRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	pool  *ManagedObjectReference `xml:"pool,omitempty"`
}

type AddHostRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	spec         *HostConnectSpec        `xml:"spec,omitempty"`
	asConnected  bool                    `xml:"asConnected,omitempty"`
	resourcePool *ManagedObjectReference `xml:"resourcePool,omitempty"`
	license      string                  `xml:"license,omitempty"`
}

type MoveIntoRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	host  []*ManagedObjectReference `xml:"host,omitempty"`
}

type MoveHostIntoRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	host         *ManagedObjectReference `xml:"host,omitempty"`
	resourcePool *ManagedObjectReference `xml:"resourcePool,omitempty"`
}

type RefreshRecommendationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RetrieveDasAdvancedRuntimeInfoRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ClusterEnterMaintenanceModeRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	host   []*ManagedObjectReference `xml:"host,omitempty"`
	option []*OptionValue            `xml:"option,omitempty"`
}

type ReconfigureComputeResourceRequestType struct {
	_this  *ManagedObjectReference    `xml:"_this,omitempty"`
	spec   *ComputeResourceConfigSpec `xml:"spec,omitempty"`
	modify bool                       `xml:"modify,omitempty"`
}

type AddCustomFieldDefRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	name           string                  `xml:"name,omitempty"`
	moType         string                  `xml:"moType,omitempty"`
	fieldDefPolicy *PrivilegePolicyDef     `xml:"fieldDefPolicy,omitempty"`
	fieldPolicy    *PrivilegePolicyDef     `xml:"fieldPolicy,omitempty"`
}

type RemoveCustomFieldDefRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   int32                   `xml:"key,omitempty"`
}

type RenameCustomFieldDefRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   int32                   `xml:"key,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type SetFieldRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
	key    int32                   `xml:"key,omitempty"`
	value  string                  `xml:"value,omitempty"`
}

type DoesCustomizationSpecExistRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type GetCustomizationSpecRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type CreateCustomizationSpecRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	item  *CustomizationSpecItem  `xml:"item,omitempty"`
}

type OverwriteCustomizationSpecRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	item  *CustomizationSpecItem  `xml:"item,omitempty"`
}

type DeleteCustomizationSpecRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type DuplicateCustomizationSpecRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	name    string                  `xml:"name,omitempty"`
	newName string                  `xml:"newName,omitempty"`
}

type RenameCustomizationSpecRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	name    string                  `xml:"name,omitempty"`
	newName string                  `xml:"newName,omitempty"`
}

type CustomizationSpecItemToXmlRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	item  *CustomizationSpecItem  `xml:"item,omitempty"`
}

type XmlToCustomizationSpecItemRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	specItemXml string                  `xml:"specItemXml,omitempty"`
}

type CheckCustomizationResourcesRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	guestOs string                  `xml:"guestOs,omitempty"`
}

type QueryConnectionInfoRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	hostname      string                  `xml:"hostname,omitempty"`
	port          int32                   `xml:"port,omitempty"`
	username      string                  `xml:"username,omitempty"`
	password      string                  `xml:"password,omitempty"`
	sslThumbprint string                  `xml:"sslThumbprint,omitempty"`
}

type PowerOnMultiVMRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	vm     []*ManagedObjectReference `xml:"vm,omitempty"`
	option []*OptionValue            `xml:"option,omitempty"`
}

type queryDatacenterConfigOptionDescriptorRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ReconfigureDatacenterRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	spec   *DatacenterConfigSpec   `xml:"spec,omitempty"`
	modify bool                    `xml:"modify,omitempty"`
}

type RefreshDatastoreRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RefreshDatastoreStorageInfoRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateVirtualMachineFilesRequestType struct {
	_this                     *ManagedObjectReference            `xml:"_this,omitempty"`
	mountPathDatastoreMapping []*DatastoreMountPathDatastorePair `xml:"mountPathDatastoreMapping,omitempty"`
}

type RenameDatastoreRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	newName string                  `xml:"newName,omitempty"`
}

type DestroyDatastoreRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type DatastoreEnterMaintenanceModeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type DatastoreExitMaintenanceModeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateDirectoryRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	datastore   *ManagedObjectReference `xml:"datastore,omitempty"`
	displayName string                  `xml:"displayName,omitempty"`
	policy      string                  `xml:"policy,omitempty"`
}

type DeleteDirectoryRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	datacenter    *ManagedObjectReference `xml:"datacenter,omitempty"`
	datastorePath string                  `xml:"datastorePath,omitempty"`
}

type QueryDescriptionsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type BrowseDiagnosticLogRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
	key   string                  `xml:"key,omitempty"`
	start int32                   `xml:"start,omitempty"`
	lines int32                   `xml:"lines,omitempty"`
}

type GenerateLogBundlesRequestType struct {
	_this          *ManagedObjectReference   `xml:"_this,omitempty"`
	includeDefault bool                      `xml:"includeDefault,omitempty"`
	host           []*ManagedObjectReference `xml:"host,omitempty"`
}

type FetchDVPortKeysRequestType struct {
	_this    *ManagedObjectReference               `xml:"_this,omitempty"`
	criteria *DistributedVirtualSwitchPortCriteria `xml:"criteria,omitempty"`
}

type FetchDVPortsRequestType struct {
	_this    *ManagedObjectReference               `xml:"_this,omitempty"`
	criteria *DistributedVirtualSwitchPortCriteria `xml:"criteria,omitempty"`
}

type QueryUsedVlanIdInDvsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ReconfigureDvsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *DVSConfigSpec          `xml:"spec,omitempty"`
}

type PerformDvsProductSpecOperationRequestType struct {
	_this       *ManagedObjectReference              `xml:"_this,omitempty"`
	operation   string                               `xml:"operation,omitempty"`
	productSpec *DistributedVirtualSwitchProductSpec `xml:"productSpec,omitempty"`
}

type MergeDvsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	dvs   *ManagedObjectReference `xml:"dvs,omitempty"`
}

type AddDVPortgroupRequestType struct {
	_this *ManagedObjectReference  `xml:"_this,omitempty"`
	spec  []*DVPortgroupConfigSpec `xml:"spec,omitempty"`
}

type MoveDVPortRequestType struct {
	_this                   *ManagedObjectReference `xml:"_this,omitempty"`
	portKey                 []string                `xml:"portKey,omitempty"`
	destinationPortgroupKey string                  `xml:"destinationPortgroupKey,omitempty"`
}

type UpdateDvsCapabilityRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	capability *DVSCapability          `xml:"capability,omitempty"`
}

type ReconfigureDVPortRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	port  []*DVPortConfigSpec     `xml:"port,omitempty"`
}

type RefreshDVPortStateRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	portKeys []string                `xml:"portKeys,omitempty"`
}

type RectifyDvsHostRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	hosts []*ManagedObjectReference `xml:"hosts,omitempty"`
}

type UpdateNetworkResourcePoolRequestType struct {
	_this      *ManagedObjectReference             `xml:"_this,omitempty"`
	configSpec []*DVSNetworkResourcePoolConfigSpec `xml:"configSpec,omitempty"`
}

type AddNetworkResourcePoolRequestType struct {
	_this      *ManagedObjectReference             `xml:"_this,omitempty"`
	configSpec []*DVSNetworkResourcePoolConfigSpec `xml:"configSpec,omitempty"`
}

type RemoveNetworkResourcePoolRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   []string                `xml:"key,omitempty"`
}

type EnableNetworkResourceManagementRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	enable bool                    `xml:"enable,omitempty"`
}

type DVSRollbackRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	entityBackup *EntityBackupConfig     `xml:"entityBackup,omitempty"`
}

type CreateDVPortgroupRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *DVPortgroupConfigSpec  `xml:"spec,omitempty"`
}

type UpdateDVSHealthCheckConfigRequestType struct {
	_this             *ManagedObjectReference `xml:"_this,omitempty"`
	healthCheckConfig []*DVSHealthCheckConfig `xml:"healthCheckConfig,omitempty"`
}

type LookupDvPortGroupRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	portgroupKey string                  `xml:"portgroupKey,omitempty"`
}

type QueryConfigOptionDescriptorRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryConfigOptionRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   string                  `xml:"key,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type QueryConfigTargetRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type QueryTargetCapabilitiesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type setCustomValueRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   string                  `xml:"key,omitempty"`
	value string                  `xml:"value,omitempty"`
}

type UnregisterExtensionRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	extensionKey string                  `xml:"extensionKey,omitempty"`
}

type FindExtensionRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	extensionKey string                  `xml:"extensionKey,omitempty"`
}

type RegisterExtensionRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	extension *Extension              `xml:"extension,omitempty"`
}

type UpdateExtensionRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	extension *Extension              `xml:"extension,omitempty"`
}

type GetPublicKeyRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type SetPublicKeyRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	extensionKey string                  `xml:"extensionKey,omitempty"`
	publicKey    string                  `xml:"publicKey,omitempty"`
}

type SetExtensionCertificateRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	extensionKey   string                  `xml:"extensionKey,omitempty"`
	certificatePem string                  `xml:"certificatePem,omitempty"`
}

type QueryManagedByRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	extensionKey string                  `xml:"extensionKey,omitempty"`
}

type QueryExtensionIpAllocationUsageRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	extensionKeys []string                `xml:"extensionKeys,omitempty"`
}

type MoveDatastoreFileRequestType struct {
	_this                 *ManagedObjectReference `xml:"_this,omitempty"`
	sourceName            string                  `xml:"sourceName,omitempty"`
	sourceDatacenter      *ManagedObjectReference `xml:"sourceDatacenter,omitempty"`
	destinationName       string                  `xml:"destinationName,omitempty"`
	destinationDatacenter *ManagedObjectReference `xml:"destinationDatacenter,omitempty"`
	force                 bool                    `xml:"force,omitempty"`
}

type CopyDatastoreFileRequestType struct {
	_this                 *ManagedObjectReference `xml:"_this,omitempty"`
	sourceName            string                  `xml:"sourceName,omitempty"`
	sourceDatacenter      *ManagedObjectReference `xml:"sourceDatacenter,omitempty"`
	destinationName       string                  `xml:"destinationName,omitempty"`
	destinationDatacenter *ManagedObjectReference `xml:"destinationDatacenter,omitempty"`
	force                 bool                    `xml:"force,omitempty"`
}

type DeleteDatastoreFileRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type MakeDirectoryRequestType struct {
	_this                   *ManagedObjectReference `xml:"_this,omitempty"`
	name                    string                  `xml:"name,omitempty"`
	datacenter              *ManagedObjectReference `xml:"datacenter,omitempty"`
	createParentDirectories bool                    `xml:"createParentDirectories,omitempty"`
}

type ChangeOwnerRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	owner      string                  `xml:"owner,omitempty"`
}

type CreateFolderRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type MoveIntoFolderRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	list  []*ManagedObjectReference `xml:"list,omitempty"`
}

type CreateVMRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	config *VirtualMachineConfigSpec `xml:"config,omitempty"`
	pool   *ManagedObjectReference   `xml:"pool,omitempty"`
	host   *ManagedObjectReference   `xml:"host,omitempty"`
}

type RegisterVMRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	path       string                  `xml:"path,omitempty"`
	name       string                  `xml:"name,omitempty"`
	asTemplate bool                    `xml:"asTemplate,omitempty"`
	pool       *ManagedObjectReference `xml:"pool,omitempty"`
	host       *ManagedObjectReference `xml:"host,omitempty"`
}

type CreateClusterRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
	spec  *ClusterConfigSpec      `xml:"spec,omitempty"`
}

type CreateClusterExRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
	spec  *ClusterConfigSpecEx    `xml:"spec,omitempty"`
}

type AddStandaloneHostRequestType struct {
	_this        *ManagedObjectReference    `xml:"_this,omitempty"`
	spec         *HostConnectSpec           `xml:"spec,omitempty"`
	compResSpec  *ComputeResourceConfigSpec `xml:"compResSpec,omitempty"`
	addConnected bool                       `xml:"addConnected,omitempty"`
	license      string                     `xml:"license,omitempty"`
}

type CreateDatacenterRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type UnregisterAndDestroyRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateDVSRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *DVSCreateSpec          `xml:"spec,omitempty"`
}

type CreateStoragePodRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type SetCollectorPageSizeRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	maxCount int32                   `xml:"maxCount,omitempty"`
}

type RewindCollectorRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ResetCollectorRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type DestroyCollectorRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryTpmAttestationReportRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryHostConnectionInfoRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateSystemResourcesRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	resourceInfo *HostSystemResourceInfo `xml:"resourceInfo,omitempty"`
}

type UpdateSystemSwapConfigurationRequestType struct {
	_this         *ManagedObjectReference      `xml:"_this,omitempty"`
	sysSwapConfig *HostSystemSwapConfiguration `xml:"sysSwapConfig,omitempty"`
}

type ReconnectHostRequestType struct {
	_this         *ManagedObjectReference  `xml:"_this,omitempty"`
	cnxSpec       *HostConnectSpec         `xml:"cnxSpec,omitempty"`
	reconnectSpec *HostSystemReconnectSpec `xml:"reconnectSpec,omitempty"`
}

type DisconnectHostRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type EnterMaintenanceModeRequestType struct {
	_this                 *ManagedObjectReference `xml:"_this,omitempty"`
	timeout               int32                   `xml:"timeout,omitempty"`
	evacuatePoweredOffVms bool                    `xml:"evacuatePoweredOffVms,omitempty"`
	maintenanceSpec       *HostMaintenanceSpec    `xml:"maintenanceSpec,omitempty"`
}

type ExitMaintenanceModeRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	timeout int32                   `xml:"timeout,omitempty"`
}

type RebootHostRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	force bool                    `xml:"force,omitempty"`
}

type ShutdownHostRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	force bool                    `xml:"force,omitempty"`
}

type PowerDownHostToStandByRequestType struct {
	_this                 *ManagedObjectReference `xml:"_this,omitempty"`
	timeoutSec            int32                   `xml:"timeoutSec,omitempty"`
	evacuatePoweredOffVms bool                    `xml:"evacuatePoweredOffVms,omitempty"`
}

type PowerUpHostFromStandByRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	timeoutSec int32                   `xml:"timeoutSec,omitempty"`
}

type QueryMemoryOverheadRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	memorySize   int64                   `xml:"memorySize,omitempty"`
	videoRamSize int32                   `xml:"videoRamSize,omitempty"`
	numVcpus     int32                   `xml:"numVcpus,omitempty"`
}

type QueryMemoryOverheadExRequestType struct {
	_this        *ManagedObjectReference   `xml:"_this,omitempty"`
	vmConfigInfo *VirtualMachineConfigInfo `xml:"vmConfigInfo,omitempty"`
}

type ReconfigureHostForDASRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateFlagsRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	flagInfo *HostFlagInfo           `xml:"flagInfo,omitempty"`
}

type EnterLockdownModeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ExitLockdownModeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type AcquireCimServicesTicketRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateIpmiRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	ipmiInfo *HostIpmiInfo           `xml:"ipmiInfo,omitempty"`
}

type RetrieveHardwareUptimeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type HttpNfcLeaseGetManifestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type HttpNfcLeaseCompleteRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type HttpNfcLeaseAbortRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	fault *LocalizedMethodFault   `xml:"fault,omitempty"`
}

type HttpNfcLeaseProgressRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	percent int32                   `xml:"percent,omitempty"`
}

type QueryIpPoolsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	dc    *ManagedObjectReference `xml:"dc,omitempty"`
}

type CreateIpPoolRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	dc    *ManagedObjectReference `xml:"dc,omitempty"`
	pool  *IpPool                 `xml:"pool,omitempty"`
}

type UpdateIpPoolRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	dc    *ManagedObjectReference `xml:"dc,omitempty"`
	pool  *IpPool                 `xml:"pool,omitempty"`
}

type DestroyIpPoolRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	dc    *ManagedObjectReference `xml:"dc,omitempty"`
	id    int32                   `xml:"id,omitempty"`
	force bool                    `xml:"force,omitempty"`
}

type AllocateIpv4AddressRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	dc           *ManagedObjectReference `xml:"dc,omitempty"`
	poolId       int32                   `xml:"poolId,omitempty"`
	allocationId string                  `xml:"allocationId,omitempty"`
}

type AllocateIpv6AddressRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	dc           *ManagedObjectReference `xml:"dc,omitempty"`
	poolId       int32                   `xml:"poolId,omitempty"`
	allocationId string                  `xml:"allocationId,omitempty"`
}

type ReleaseIpAllocationRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	dc           *ManagedObjectReference `xml:"dc,omitempty"`
	poolId       int32                   `xml:"poolId,omitempty"`
	allocationId string                  `xml:"allocationId,omitempty"`
}

type QueryIPAllocationsRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	dc           *ManagedObjectReference `xml:"dc,omitempty"`
	poolId       int32                   `xml:"poolId,omitempty"`
	extensionKey string                  `xml:"extensionKey,omitempty"`
}

type UpdateAssignedLicenseRequestType struct {
	_this             *ManagedObjectReference `xml:"_this,omitempty"`
	entity            string                  `xml:"entity,omitempty"`
	licenseKey        string                  `xml:"licenseKey,omitempty"`
	entityDisplayName string                  `xml:"entityDisplayName,omitempty"`
}

type RemoveAssignedLicenseRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	entityId string                  `xml:"entityId,omitempty"`
}

type QueryAssignedLicensesRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	entityId string                  `xml:"entityId,omitempty"`
}

type QuerySupportedFeaturesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type QueryLicenseSourceAvailabilityRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type QueryLicenseUsageRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type SetLicenseEditionRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	host       *ManagedObjectReference `xml:"host,omitempty"`
	featureKey string                  `xml:"featureKey,omitempty"`
}

type CheckLicenseFeatureRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	host       *ManagedObjectReference `xml:"host,omitempty"`
	featureKey string                  `xml:"featureKey,omitempty"`
}

type EnableFeatureRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	host       *ManagedObjectReference `xml:"host,omitempty"`
	featureKey string                  `xml:"featureKey,omitempty"`
}

type DisableFeatureRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	host       *ManagedObjectReference `xml:"host,omitempty"`
	featureKey string                  `xml:"featureKey,omitempty"`
}

type ConfigureLicenseSourceRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	host          *ManagedObjectReference `xml:"host,omitempty"`
	licenseSource *LicenseSource          `xml:"licenseSource,omitempty"`
}

type UpdateLicenseRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	licenseKey string                  `xml:"licenseKey,omitempty"`
	labels     []*KeyValue             `xml:"labels,omitempty"`
}

type AddLicenseRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	licenseKey string                  `xml:"licenseKey,omitempty"`
	labels     []*KeyValue             `xml:"labels,omitempty"`
}

type RemoveLicenseRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	licenseKey string                  `xml:"licenseKey,omitempty"`
}

type DecodeLicenseRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	licenseKey string                  `xml:"licenseKey,omitempty"`
}

type UpdateLicenseLabelRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	licenseKey string                  `xml:"licenseKey,omitempty"`
	labelKey   string                  `xml:"labelKey,omitempty"`
	labelValue string                  `xml:"labelValue,omitempty"`
}

type RemoveLicenseLabelRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	licenseKey string                  `xml:"licenseKey,omitempty"`
	labelKey   string                  `xml:"labelKey,omitempty"`
}

type ReloadRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RenameRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	newName string                  `xml:"newName,omitempty"`
}

type DestroyRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type DestroyNetworkRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ValidateHostRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	ovfDescriptor string                  `xml:"ovfDescriptor,omitempty"`
	host          *ManagedObjectReference `xml:"host,omitempty"`
	vhp           *OvfValidateHostParams  `xml:"vhp,omitempty"`
}

type ParseDescriptorRequestType struct {
	_this         *ManagedObjectReference   `xml:"_this,omitempty"`
	ovfDescriptor string                    `xml:"ovfDescriptor,omitempty"`
	pdp           *OvfParseDescriptorParams `xml:"pdp,omitempty"`
}

type CreateImportSpecRequestType struct {
	_this         *ManagedObjectReference    `xml:"_this,omitempty"`
	ovfDescriptor string                     `xml:"ovfDescriptor,omitempty"`
	resourcePool  *ManagedObjectReference    `xml:"resourcePool,omitempty"`
	datastore     *ManagedObjectReference    `xml:"datastore,omitempty"`
	cisp          *OvfCreateImportSpecParams `xml:"cisp,omitempty"`
}

type CreateDescriptorRequestType struct {
	_this *ManagedObjectReference    `xml:"_this,omitempty"`
	obj   *ManagedObjectReference    `xml:"obj,omitempty"`
	cdp   *OvfCreateDescriptorParams `xml:"cdp,omitempty"`
}

type QueryPerfProviderSummaryRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type QueryAvailablePerfMetricRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	entity     *ManagedObjectReference `xml:"entity,omitempty"`
	beginTime  time.Time               `xml:"beginTime,omitempty"`
	endTime    time.Time               `xml:"endTime,omitempty"`
	intervalId int32                   `xml:"intervalId,omitempty"`
}

type QueryPerfCounterRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	counterId []int32                 `xml:"counterId,omitempty"`
}

type QueryPerfCounterByLevelRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	level int32                   `xml:"level,omitempty"`
}

type QueryPerfRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	querySpec []*PerfQuerySpec        `xml:"querySpec,omitempty"`
}

type QueryPerfCompositeRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	querySpec *PerfQuerySpec          `xml:"querySpec,omitempty"`
}

type CreatePerfIntervalRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	intervalId *PerfInterval           `xml:"intervalId,omitempty"`
}

type RemovePerfIntervalRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	samplePeriod int32                   `xml:"samplePeriod,omitempty"`
}

type UpdatePerfIntervalRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	interval *PerfInterval           `xml:"interval,omitempty"`
}

type UpdateCounterLevelMappingRequestType struct {
	_this           *ManagedObjectReference                  `xml:"_this,omitempty"`
	counterLevelMap []*PerformanceManagerCounterLevelMapping `xml:"counterLevelMap,omitempty"`
}

type ResetCounterLevelMappingRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	counters []int32                 `xml:"counters,omitempty"`
}

type EstimateDatabaseSizeRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	dbSizeParam *DatabaseSizeParam      `xml:"dbSizeParam,omitempty"`
}

type UpdateConfigRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	name   string                  `xml:"name,omitempty"`
	config *ResourceConfigSpec     `xml:"config,omitempty"`
}

type MoveIntoResourcePoolRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	list  []*ManagedObjectReference `xml:"list,omitempty"`
}

type UpdateChildResourceConfigurationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  []*ResourceConfigSpec   `xml:"spec,omitempty"`
}

type CreateResourcePoolRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
	spec  *ResourceConfigSpec     `xml:"spec,omitempty"`
}

type DestroyChildrenRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateVAppRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	resSpec    *ResourceConfigSpec     `xml:"resSpec,omitempty"`
	configSpec *VAppConfigSpec         `xml:"configSpec,omitempty"`
	vmFolder   *ManagedObjectReference `xml:"vmFolder,omitempty"`
}

type CreateChildVMRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	config *VirtualMachineConfigSpec `xml:"config,omitempty"`
	host   *ManagedObjectReference   `xml:"host,omitempty"`
}

type RegisterChildVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	path  string                  `xml:"path,omitempty"`
	name  string                  `xml:"name,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type ImportVAppRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	spec   *ImportSpec             `xml:"spec,omitempty"`
	folder *ManagedObjectReference `xml:"folder,omitempty"`
	host   *ManagedObjectReference `xml:"host,omitempty"`
}

type QueryResourceConfigOptionRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RefreshRuntimeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type FindByUuidRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	datacenter   *ManagedObjectReference `xml:"datacenter,omitempty"`
	uuid         string                  `xml:"uuid,omitempty"`
	vmSearch     bool                    `xml:"vmSearch,omitempty"`
	instanceUuid bool                    `xml:"instanceUuid,omitempty"`
}

type FindByDatastorePathRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	path       string                  `xml:"path,omitempty"`
}

type FindByDnsNameRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	dnsName    string                  `xml:"dnsName,omitempty"`
	vmSearch   bool                    `xml:"vmSearch,omitempty"`
}

type FindByIpRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	ip         string                  `xml:"ip,omitempty"`
	vmSearch   bool                    `xml:"vmSearch,omitempty"`
}

type FindByInventoryPathRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	inventoryPath string                  `xml:"inventoryPath,omitempty"`
}

type FindChildRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
	name   string                  `xml:"name,omitempty"`
}

type FindAllByUuidRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	datacenter   *ManagedObjectReference `xml:"datacenter,omitempty"`
	uuid         string                  `xml:"uuid,omitempty"`
	vmSearch     bool                    `xml:"vmSearch,omitempty"`
	instanceUuid bool                    `xml:"instanceUuid,omitempty"`
}

type FindAllByDnsNameRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	dnsName    string                  `xml:"dnsName,omitempty"`
	vmSearch   bool                    `xml:"vmSearch,omitempty"`
}

type FindAllByIpRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	ip         string                  `xml:"ip,omitempty"`
	vmSearch   bool                    `xml:"vmSearch,omitempty"`
}

type CurrentTimeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RetrieveServiceContentRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ValidateMigrationRequestType struct {
	_this    *ManagedObjectReference   `xml:"_this,omitempty"`
	vm       []*ManagedObjectReference `xml:"vm,omitempty"`
	state    *VirtualMachinePowerState `xml:"state,omitempty"`
	testType []string                  `xml:"testType,omitempty"`
	pool     *ManagedObjectReference   `xml:"pool,omitempty"`
	host     *ManagedObjectReference   `xml:"host,omitempty"`
}

type QueryVMotionCompatibilityRequestType struct {
	_this         *ManagedObjectReference   `xml:"_this,omitempty"`
	vm            *ManagedObjectReference   `xml:"vm,omitempty"`
	host          []*ManagedObjectReference `xml:"host,omitempty"`
	compatibility []string                  `xml:"compatibility,omitempty"`
}

type RetrieveProductComponentsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryServiceListRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	serviceName string                  `xml:"serviceName,omitempty"`
	location    []string                `xml:"location,omitempty"`
}

type UpdateServiceMessageRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	message string                  `xml:"message,omitempty"`
}

type LoginByTokenRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	locale string                  `xml:"locale,omitempty"`
}

type LoginRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	userName string                  `xml:"userName,omitempty"`
	password string                  `xml:"password,omitempty"`
	locale   string                  `xml:"locale,omitempty"`
}

type LoginBySSPIRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	base64Token string                  `xml:"base64Token,omitempty"`
	locale      string                  `xml:"locale,omitempty"`
}

type LogoutRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type AcquireLocalTicketRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	userName string                  `xml:"userName,omitempty"`
}

type AcquireGenericServiceTicketRequestType struct {
	_this *ManagedObjectReference           `xml:"_this,omitempty"`
	spec  *SessionManagerServiceRequestSpec `xml:"spec,omitempty"`
}

type TerminateSessionRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	sessionId []string                `xml:"sessionId,omitempty"`
}

type SetLocaleRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	locale string                  `xml:"locale,omitempty"`
}

type LoginExtensionBySubjectNameRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	extensionKey string                  `xml:"extensionKey,omitempty"`
	locale       string                  `xml:"locale,omitempty"`
}

type LoginExtensionByCertificateRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	extensionKey string                  `xml:"extensionKey,omitempty"`
	locale       string                  `xml:"locale,omitempty"`
}

type ImpersonateUserRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	userName string                  `xml:"userName,omitempty"`
	locale   string                  `xml:"locale,omitempty"`
}

type SessionIsActiveRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	sessionID string                  `xml:"sessionID,omitempty"`
	userName  string                  `xml:"userName,omitempty"`
}

type AcquireCloneTicketRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CloneSessionRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	cloneTicket string                  `xml:"cloneTicket,omitempty"`
}

type ExecuteSimpleCommandRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	arguments []string                `xml:"arguments,omitempty"`
}

type ConfigureDatastoreIORMRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
	spec      *StorageIORMConfigSpec  `xml:"spec,omitempty"`
}

type QueryIORMConfigOptionRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type QueryDatastorePerformanceSummaryRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
}

type ApplyStorageDrsRecommendationToPodRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	pod   *ManagedObjectReference `xml:"pod,omitempty"`
	key   string                  `xml:"key,omitempty"`
}

type ApplyStorageDrsRecommendationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   []string                `xml:"key,omitempty"`
}

type CancelStorageDrsRecommendationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   []string                `xml:"key,omitempty"`
}

type RefreshStorageDrsRecommendationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	pod   *ManagedObjectReference `xml:"pod,omitempty"`
}

type ConfigureStorageDrsForPodRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	pod    *ManagedObjectReference `xml:"pod,omitempty"`
	spec   *StorageDrsConfigSpec   `xml:"spec,omitempty"`
	modify bool                    `xml:"modify,omitempty"`
}

type RecommendDatastoresRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	storageSpec *StoragePlacementSpec   `xml:"storageSpec,omitempty"`
}

type CancelTaskRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateProgressRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	percentDone int32                   `xml:"percentDone,omitempty"`
}

type SetTaskStateRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	state  *TaskInfoState          `xml:"state,omitempty"`
	result interface{}             `xml:"result,omitempty"`
	fault  *LocalizedMethodFault   `xml:"fault,omitempty"`
}

type SetTaskDescriptionRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	description *LocalizableMessage     `xml:"description,omitempty"`
}

type ReadNextTasksRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	maxCount int32                   `xml:"maxCount,omitempty"`
}

type ReadPreviousTasksRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	maxCount int32                   `xml:"maxCount,omitempty"`
}

type CreateCollectorForTasksRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	filter *TaskFilterSpec         `xml:"filter,omitempty"`
}

type CreateTaskRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	obj           *ManagedObjectReference `xml:"obj,omitempty"`
	taskTypeId    string                  `xml:"taskTypeId,omitempty"`
	initiatedBy   string                  `xml:"initiatedBy,omitempty"`
	cancelable    bool                    `xml:"cancelable,omitempty"`
	parentTaskKey string                  `xml:"parentTaskKey,omitempty"`
}

type RetrieveUserGroupsRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	domain         string                  `xml:"domain,omitempty"`
	searchStr      string                  `xml:"searchStr,omitempty"`
	belongsToGroup string                  `xml:"belongsToGroup,omitempty"`
	belongsToUser  string                  `xml:"belongsToUser,omitempty"`
	exactMatch     bool                    `xml:"exactMatch,omitempty"`
	findUsers      bool                    `xml:"findUsers,omitempty"`
	findGroups     bool                    `xml:"findGroups,omitempty"`
}

type UpdateVAppConfigRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *VAppConfigSpec         `xml:"spec,omitempty"`
}

type UpdateLinkedChildrenRequestType struct {
	_this        *ManagedObjectReference   `xml:"_this,omitempty"`
	addChangeSet []*VirtualAppLinkInfo     `xml:"addChangeSet,omitempty"`
	removeSet    []*ManagedObjectReference `xml:"removeSet,omitempty"`
}

type CloneVAppRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	name   string                  `xml:"name,omitempty"`
	target *ManagedObjectReference `xml:"target,omitempty"`
	spec   *VAppCloneSpec          `xml:"spec,omitempty"`
}

type ExportVAppRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type PowerOnVAppRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type PowerOffVAppRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	force bool                    `xml:"force,omitempty"`
}

type SuspendVAppRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type unregisterVAppRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateVirtualDiskRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	spec       *VirtualDiskSpec        `xml:"spec,omitempty"`
}

type DeleteVirtualDiskRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type MoveVirtualDiskRequestType struct {
	_this            *ManagedObjectReference      `xml:"_this,omitempty"`
	sourceName       string                       `xml:"sourceName,omitempty"`
	sourceDatacenter *ManagedObjectReference      `xml:"sourceDatacenter,omitempty"`
	destName         string                       `xml:"destName,omitempty"`
	destDatacenter   *ManagedObjectReference      `xml:"destDatacenter,omitempty"`
	force            bool                         `xml:"force,omitempty"`
	profile          []*VirtualMachineProfileSpec `xml:"profile,omitempty"`
}

type CopyVirtualDiskRequestType struct {
	_this            *ManagedObjectReference `xml:"_this,omitempty"`
	sourceName       string                  `xml:"sourceName,omitempty"`
	sourceDatacenter *ManagedObjectReference `xml:"sourceDatacenter,omitempty"`
	destName         string                  `xml:"destName,omitempty"`
	destDatacenter   *ManagedObjectReference `xml:"destDatacenter,omitempty"`
	destSpec         *VirtualDiskSpec        `xml:"destSpec,omitempty"`
	force            bool                    `xml:"force,omitempty"`
}

type ExtendVirtualDiskRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	name          string                  `xml:"name,omitempty"`
	datacenter    *ManagedObjectReference `xml:"datacenter,omitempty"`
	newCapacityKb int64                   `xml:"newCapacityKb,omitempty"`
	eagerZero     bool                    `xml:"eagerZero,omitempty"`
}

type QueryVirtualDiskFragmentationRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type DefragmentVirtualDiskRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type ShrinkVirtualDiskRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	copy       bool                    `xml:"copy,omitempty"`
}

type InflateVirtualDiskRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type EagerZeroVirtualDiskRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type ZeroFillVirtualDiskRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type SetVirtualDiskUuidRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
	uuid       string                  `xml:"uuid,omitempty"`
}

type QueryVirtualDiskUuidRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type QueryVirtualDiskGeometryRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	name       string                  `xml:"name,omitempty"`
	datacenter *ManagedObjectReference `xml:"datacenter,omitempty"`
}

type RefreshStorageInfoRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateSnapshotRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	name        string                  `xml:"name,omitempty"`
	description string                  `xml:"description,omitempty"`
	memory      bool                    `xml:"memory,omitempty"`
	quiesce     bool                    `xml:"quiesce,omitempty"`
}

type RevertToCurrentSnapshotRequestType struct {
	_this           *ManagedObjectReference `xml:"_this,omitempty"`
	host            *ManagedObjectReference `xml:"host,omitempty"`
	suppressPowerOn bool                    `xml:"suppressPowerOn,omitempty"`
}

type RemoveAllSnapshotsRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	consolidate bool                    `xml:"consolidate,omitempty"`
}

type ConsolidateVMDisksRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type EstimateStorageForConsolidateSnapshotsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ReconfigVMRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	spec  *VirtualMachineConfigSpec `xml:"spec,omitempty"`
}

type UpgradeVMRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	version string                  `xml:"version,omitempty"`
}

type ExtractOvfEnvironmentRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type PowerOnVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type PowerOffVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type SuspendVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ResetVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ShutdownGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RebootGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type StandbyGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type AnswerVMRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	questionId   string                  `xml:"questionId,omitempty"`
	answerChoice string                  `xml:"answerChoice,omitempty"`
}

type CustomizeVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *CustomizationSpec      `xml:"spec,omitempty"`
}

type CheckCustomizationSpecRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *CustomizationSpec      `xml:"spec,omitempty"`
}

type MigrateVMRequestType struct {
	_this    *ManagedObjectReference     `xml:"_this,omitempty"`
	pool     *ManagedObjectReference     `xml:"pool,omitempty"`
	host     *ManagedObjectReference     `xml:"host,omitempty"`
	priority *VirtualMachineMovePriority `xml:"priority,omitempty"`
	state    *VirtualMachinePowerState   `xml:"state,omitempty"`
}

type RelocateVMRequestType struct {
	_this    *ManagedObjectReference     `xml:"_this,omitempty"`
	spec     *VirtualMachineRelocateSpec `xml:"spec,omitempty"`
	priority *VirtualMachineMovePriority `xml:"priority,omitempty"`
}

type CloneVMRequestType struct {
	_this  *ManagedObjectReference  `xml:"_this,omitempty"`
	folder *ManagedObjectReference  `xml:"folder,omitempty"`
	name   string                   `xml:"name,omitempty"`
	spec   *VirtualMachineCloneSpec `xml:"spec,omitempty"`
}

type ExportVmRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type MarkAsTemplateRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type MarkAsVirtualMachineRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	pool  *ManagedObjectReference `xml:"pool,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type UnregisterVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ResetGuestInformationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type MountToolsInstallerRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UnmountToolsInstallerRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpgradeToolsRequestType struct {
	_this            *ManagedObjectReference `xml:"_this,omitempty"`
	installerOptions string                  `xml:"installerOptions,omitempty"`
}

type AcquireMksTicketRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type AcquireTicketRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	ticketType string                  `xml:"ticketType,omitempty"`
}

type SetScreenResolutionRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	width  int32                   `xml:"width,omitempty"`
	height int32                   `xml:"height,omitempty"`
}

type DefragmentAllDisksRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateSecondaryVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type TurnOffFaultToleranceForVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type MakePrimaryVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
}

type TerminateFaultTolerantVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
}

type DisableSecondaryVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
}

type EnableSecondaryVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type SetDisplayTopologyRequestType struct {
	_this    *ManagedObjectReference          `xml:"_this,omitempty"`
	displays []*VirtualMachineDisplayTopology `xml:"displays,omitempty"`
}

type StartRecordingRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	name        string                  `xml:"name,omitempty"`
	description string                  `xml:"description,omitempty"`
}

type StopRecordingRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type StartReplayingRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	replaySnapshot *ManagedObjectReference `xml:"replaySnapshot,omitempty"`
}

type StopReplayingRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type PromoteDisksRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	unlink bool                    `xml:"unlink,omitempty"`
	disks  []*VirtualDisk          `xml:"disks,omitempty"`
}

type CreateScreenshotRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryChangedDiskAreasRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	snapshot    *ManagedObjectReference `xml:"snapshot,omitempty"`
	deviceKey   int32                   `xml:"deviceKey,omitempty"`
	startOffset int64                   `xml:"startOffset,omitempty"`
	changeId    string                  `xml:"changeId,omitempty"`
}

type QueryUnownedFilesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type reloadVirtualMachineFromPathRequestType struct {
	_this             *ManagedObjectReference `xml:"_this,omitempty"`
	configurationPath string                  `xml:"configurationPath,omitempty"`
}

type QueryFaultToleranceCompatibilityRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type TerminateVMRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RemoveAlarmRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ReconfigureAlarmRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *AlarmSpec              `xml:"spec,omitempty"`
}

type CreateAlarmRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
	spec   *AlarmSpec              `xml:"spec,omitempty"`
}

type GetAlarmRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type AreAlarmActionsEnabledRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type EnableAlarmActionsRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	entity  *ManagedObjectReference `xml:"entity,omitempty"`
	enabled bool                    `xml:"enabled,omitempty"`
}

type GetAlarmStateRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type AcknowledgeAlarmRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	alarm  *ManagedObjectReference `xml:"alarm,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type ReconfigureDVPortgroupRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *DVPortgroupConfigSpec  `xml:"spec,omitempty"`
}

type DVPortgroupRollbackRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	entityBackup *EntityBackupConfig     `xml:"entityBackup,omitempty"`
}

type QueryAvailableDvsSpecRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryCompatibleHostForNewDvsRequestType struct {
	_this             *ManagedObjectReference              `xml:"_this,omitempty"`
	container         *ManagedObjectReference              `xml:"container,omitempty"`
	recursive         bool                                 `xml:"recursive,omitempty"`
	switchProductSpec *DistributedVirtualSwitchProductSpec `xml:"switchProductSpec,omitempty"`
}

type QueryCompatibleHostForExistingDvsRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	container *ManagedObjectReference `xml:"container,omitempty"`
	recursive bool                    `xml:"recursive,omitempty"`
	dvs       *ManagedObjectReference `xml:"dvs,omitempty"`
}

type QueryDvsCompatibleHostSpecRequestType struct {
	_this             *ManagedObjectReference              `xml:"_this,omitempty"`
	switchProductSpec *DistributedVirtualSwitchProductSpec `xml:"switchProductSpec,omitempty"`
}

type QueryDvsFeatureCapabilityRequestType struct {
	_this             *ManagedObjectReference              `xml:"_this,omitempty"`
	switchProductSpec *DistributedVirtualSwitchProductSpec `xml:"switchProductSpec,omitempty"`
}

type QueryDvsByUuidRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	uuid  string                  `xml:"uuid,omitempty"`
}

type QueryDvsConfigTargetRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
	dvs   *ManagedObjectReference `xml:"dvs,omitempty"`
}

type QueryDvsCheckCompatibilityRequestType struct {
	_this          *ManagedObjectReference                             `xml:"_this,omitempty"`
	hostContainer  *DistributedVirtualSwitchManagerHostContainer       `xml:"hostContainer,omitempty"`
	dvsProductSpec *DistributedVirtualSwitchManagerDvsProductSpec      `xml:"dvsProductSpec,omitempty"`
	hostFilterSpec []*DistributedVirtualSwitchManagerHostDvsFilterSpec `xml:"hostFilterSpec,omitempty"`
}

type RectifyDvsOnHostRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	hosts []*ManagedObjectReference `xml:"hosts,omitempty"`
}

type DVSManagerExportEntityRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	selectionSet []*SelectionSet         `xml:"selectionSet,omitempty"`
}

type DVSManagerImportEntityRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	entityBackup []*EntityBackupConfig   `xml:"entityBackup,omitempty"`
	importType   string                  `xml:"importType,omitempty"`
}

type DVSManagerLookupDvPortGroupRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	switchUuid   string                  `xml:"switchUuid,omitempty"`
	portgroupKey string                  `xml:"portgroupKey,omitempty"`
}

type UpdateDVSLacpGroupConfigRequestType struct {
	_this         *ManagedObjectReference   `xml:"_this,omitempty"`
	lacpGroupSpec []*VMwareDvsLacpGroupSpec `xml:"lacpGroupSpec,omitempty"`
}

type ReadNextEventsRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	maxCount int32                   `xml:"maxCount,omitempty"`
}

type ReadPreviousEventsRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	maxCount int32                   `xml:"maxCount,omitempty"`
}

type RetrieveArgumentDescriptionRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	eventTypeId string                  `xml:"eventTypeId,omitempty"`
}

type CreateCollectorForEventsRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	filter *EventFilterSpec        `xml:"filter,omitempty"`
}

type LogUserEventRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
	msg    string                  `xml:"msg,omitempty"`
}

type QueryEventsRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	filter *EventFilterSpec        `xml:"filter,omitempty"`
}

type PostEventRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	eventToPost *Event                  `xml:"eventToPost,omitempty"`
	taskInfo    *TaskInfo               `xml:"taskInfo,omitempty"`
}

type JoinDomainRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	domainName string                  `xml:"domainName,omitempty"`
	userName   string                  `xml:"userName,omitempty"`
	password   string                  `xml:"password,omitempty"`
}

type JoinDomainWithCAMRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	domainName string                  `xml:"domainName,omitempty"`
	camServer  string                  `xml:"camServer,omitempty"`
}

type ImportCertificateForCAMRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	certPath  string                  `xml:"certPath,omitempty"`
	camServer string                  `xml:"camServer,omitempty"`
}

type LeaveCurrentDomainRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	force bool                    `xml:"force,omitempty"`
}

type ReconfigureAutostartRequestType struct {
	_this *ManagedObjectReference     `xml:"_this,omitempty"`
	spec  *HostAutoStartManagerConfig `xml:"spec,omitempty"`
}

type AutoStartPowerOnRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type AutoStartPowerOffRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryBootDevicesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateBootDeviceRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   string                  `xml:"key,omitempty"`
}

type ConfigureHostCacheRequestType struct {
	_this *ManagedObjectReference     `xml:"_this,omitempty"`
	spec  *HostCacheConfigurationSpec `xml:"spec,omitempty"`
}

type EnableHyperThreadingRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type DisableHyperThreadingRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type SearchDatastoreRequestType struct {
	_this         *ManagedObjectReference         `xml:"_this,omitempty"`
	datastorePath string                          `xml:"datastorePath,omitempty"`
	searchSpec    *HostDatastoreBrowserSearchSpec `xml:"searchSpec,omitempty"`
}

type SearchDatastoreSubFoldersRequestType struct {
	_this         *ManagedObjectReference         `xml:"_this,omitempty"`
	datastorePath string                          `xml:"datastorePath,omitempty"`
	searchSpec    *HostDatastoreBrowserSearchSpec `xml:"searchSpec,omitempty"`
}

type DeleteFileRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	datastorePath string                  `xml:"datastorePath,omitempty"`
}

type UpdateLocalSwapDatastoreRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
}

type QueryAvailableDisksForVmfsRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
}

type QueryVmfsDatastoreCreateOptionsRequestType struct {
	_this            *ManagedObjectReference `xml:"_this,omitempty"`
	devicePath       string                  `xml:"devicePath,omitempty"`
	vmfsMajorVersion int32                   `xml:"vmfsMajorVersion,omitempty"`
}

type CreateVmfsDatastoreRequestType struct {
	_this *ManagedObjectReference  `xml:"_this,omitempty"`
	spec  *VmfsDatastoreCreateSpec `xml:"spec,omitempty"`
}

type QueryVmfsDatastoreExtendOptionsRequestType struct {
	_this                    *ManagedObjectReference `xml:"_this,omitempty"`
	datastore                *ManagedObjectReference `xml:"datastore,omitempty"`
	devicePath               string                  `xml:"devicePath,omitempty"`
	suppressExpandCandidates bool                    `xml:"suppressExpandCandidates,omitempty"`
}

type QueryVmfsDatastoreExpandOptionsRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
}

type ExtendVmfsDatastoreRequestType struct {
	_this     *ManagedObjectReference  `xml:"_this,omitempty"`
	datastore *ManagedObjectReference  `xml:"datastore,omitempty"`
	spec      *VmfsDatastoreExtendSpec `xml:"spec,omitempty"`
}

type ExpandVmfsDatastoreRequestType struct {
	_this     *ManagedObjectReference  `xml:"_this,omitempty"`
	datastore *ManagedObjectReference  `xml:"datastore,omitempty"`
	spec      *VmfsDatastoreExpandSpec `xml:"spec,omitempty"`
}

type CreateNasDatastoreRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *HostNasVolumeSpec      `xml:"spec,omitempty"`
}

type CreateLocalDatastoreRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
	path  string                  `xml:"path,omitempty"`
}

type RemoveDatastoreRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	datastore *ManagedObjectReference `xml:"datastore,omitempty"`
}

type ConfigureDatastorePrincipalRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	userName string                  `xml:"userName,omitempty"`
	password string                  `xml:"password,omitempty"`
}

type QueryUnresolvedVmfsVolumesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ResignatureUnresolvedVmfsVolumeRequestType struct {
	_this          *ManagedObjectReference            `xml:"_this,omitempty"`
	resolutionSpec *HostUnresolvedVmfsResignatureSpec `xml:"resolutionSpec,omitempty"`
}

type UpdateDateTimeConfigRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	config *HostDateTimeConfig     `xml:"config,omitempty"`
}

type QueryAvailableTimeZonesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryDateTimeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateDateTimeRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	dateTime time.Time               `xml:"dateTime,omitempty"`
}

type RefreshDateTimeSystemRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryAvailablePartitionRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type SelectActivePartitionRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	partition *HostScsiDiskPartition  `xml:"partition,omitempty"`
}

type QueryPartitionCreateOptionsRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	storageType    string                  `xml:"storageType,omitempty"`
	diagnosticType string                  `xml:"diagnosticType,omitempty"`
}

type QueryPartitionCreateDescRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	diskUuid       string                  `xml:"diskUuid,omitempty"`
	diagnosticType string                  `xml:"diagnosticType,omitempty"`
}

type CreateDiagnosticPartitionRequestType struct {
	_this *ManagedObjectReference            `xml:"_this,omitempty"`
	spec  *HostDiagnosticPartitionCreateSpec `xml:"spec,omitempty"`
}

type EsxAgentHostManagerUpdateConfigRequestType struct {
	_this      *ManagedObjectReference            `xml:"_this,omitempty"`
	configInfo *HostEsxAgentHostManagerConfigInfo `xml:"configInfo,omitempty"`
}

type UpdateDefaultPolicyRequestType struct {
	_this         *ManagedObjectReference    `xml:"_this,omitempty"`
	defaultPolicy *HostFirewallDefaultPolicy `xml:"defaultPolicy,omitempty"`
}

type EnableRulesetRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	id    string                  `xml:"id,omitempty"`
}

type DisableRulesetRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	id    string                  `xml:"id,omitempty"`
}

type UpdateRulesetRequestType struct {
	_this *ManagedObjectReference         `xml:"_this,omitempty"`
	id    string                          `xml:"id,omitempty"`
	spec  *HostFirewallRulesetRulesetSpec `xml:"spec,omitempty"`
}

type RefreshFirewallRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ResetFirmwareToFactoryDefaultsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type BackupFirmwareConfigurationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryFirmwareConfigUploadURLRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RestoreFirmwareConfigurationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	force bool                    `xml:"force,omitempty"`
}

type RefreshGraphicsManagerRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type IsSharedGraphicsActiveRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RefreshHealthStatusSystemRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ResetSystemHealthInfoRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type HostImageConfigGetAcceptanceRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type HostImageConfigGetProfileRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateHostImageAcceptanceLevelRequestType struct {
	_this              *ManagedObjectReference `xml:"_this,omitempty"`
	newAcceptanceLevel string                  `xml:"newAcceptanceLevel,omitempty"`
}

type QueryVnicStatusRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	vnicDevice string                  `xml:"vnicDevice,omitempty"`
}

type QueryPnicStatusRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	pnicDevice string                  `xml:"pnicDevice,omitempty"`
}

type QueryBoundVnicsRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	iScsiHbaName string                  `xml:"iScsiHbaName,omitempty"`
}

type QueryCandidateNicsRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	iScsiHbaName string                  `xml:"iScsiHbaName,omitempty"`
}

type BindVnicRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	iScsiHbaName string                  `xml:"iScsiHbaName,omitempty"`
	vnicDevice   string                  `xml:"vnicDevice,omitempty"`
}

type UnbindVnicRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	iScsiHbaName string                  `xml:"iScsiHbaName,omitempty"`
	vnicDevice   string                  `xml:"vnicDevice,omitempty"`
	force        bool                    `xml:"force,omitempty"`
}

type QueryMigrationDependenciesRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	pnicDevice []string                `xml:"pnicDevice,omitempty"`
}

type QueryModulesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateModuleOptionStringRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	name    string                  `xml:"name,omitempty"`
	options string                  `xml:"options,omitempty"`
}

type QueryConfiguredModuleOptionStringRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type CreateUserRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	user  *HostAccountSpec        `xml:"user,omitempty"`
}

type UpdateUserRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	user  *HostAccountSpec        `xml:"user,omitempty"`
}

type CreateGroupRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	group *HostAccountSpec        `xml:"group,omitempty"`
}

type RemoveUserRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	userName string                  `xml:"userName,omitempty"`
}

type RemoveGroupRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	groupName string                  `xml:"groupName,omitempty"`
}

type AssignUserToGroupRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	user  string                  `xml:"user,omitempty"`
	group string                  `xml:"group,omitempty"`
}

type UnassignUserFromGroupRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	user  string                  `xml:"user,omitempty"`
	group string                  `xml:"group,omitempty"`
}

type ReconfigureServiceConsoleReservationRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	cfgBytes int64                   `xml:"cfgBytes,omitempty"`
}

type ReconfigureVirtualMachineReservationRequestType struct {
	_this *ManagedObjectReference              `xml:"_this,omitempty"`
	spec  *VirtualMachineMemoryReservationSpec `xml:"spec,omitempty"`
}

type UpdateNetworkConfigRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	config     *HostNetworkConfig      `xml:"config,omitempty"`
	changeMode string                  `xml:"changeMode,omitempty"`
}

type UpdateDnsConfigRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	config *HostDnsConfig          `xml:"config,omitempty"`
}

type UpdateIpRouteConfigRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	config *HostIpRouteConfig      `xml:"config,omitempty"`
}

type UpdateConsoleIpRouteConfigRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	config *HostIpRouteConfig      `xml:"config,omitempty"`
}

type UpdateIpRouteTableConfigRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	config *HostIpRouteTableConfig `xml:"config,omitempty"`
}

type AddVirtualSwitchRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	vswitchName string                  `xml:"vswitchName,omitempty"`
	spec        *HostVirtualSwitchSpec  `xml:"spec,omitempty"`
}

type RemoveVirtualSwitchRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	vswitchName string                  `xml:"vswitchName,omitempty"`
}

type UpdateVirtualSwitchRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	vswitchName string                  `xml:"vswitchName,omitempty"`
	spec        *HostVirtualSwitchSpec  `xml:"spec,omitempty"`
}

type AddPortGroupRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	portgrp *HostPortGroupSpec      `xml:"portgrp,omitempty"`
}

type RemovePortGroupRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	pgName string                  `xml:"pgName,omitempty"`
}

type UpdatePortGroupRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	pgName  string                  `xml:"pgName,omitempty"`
	portgrp *HostPortGroupSpec      `xml:"portgrp,omitempty"`
}

type UpdatePhysicalNicLinkSpeedRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	device    string                  `xml:"device,omitempty"`
	linkSpeed *PhysicalNicLinkInfo    `xml:"linkSpeed,omitempty"`
}

type QueryNetworkHintRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	device []string                `xml:"device,omitempty"`
}

type AddVirtualNicRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	portgroup string                  `xml:"portgroup,omitempty"`
	nic       *HostVirtualNicSpec     `xml:"nic,omitempty"`
}

type RemoveVirtualNicRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	device string                  `xml:"device,omitempty"`
}

type UpdateVirtualNicRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	device string                  `xml:"device,omitempty"`
	nic    *HostVirtualNicSpec     `xml:"nic,omitempty"`
}

type AddServiceConsoleVirtualNicRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	portgroup string                  `xml:"portgroup,omitempty"`
	nic       *HostVirtualNicSpec     `xml:"nic,omitempty"`
}

type RemoveServiceConsoleVirtualNicRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	device string                  `xml:"device,omitempty"`
}

type UpdateServiceConsoleVirtualNicRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	device string                  `xml:"device,omitempty"`
	nic    *HostVirtualNicSpec     `xml:"nic,omitempty"`
}

type RestartServiceConsoleVirtualNicRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	device string                  `xml:"device,omitempty"`
}

type RefreshNetworkSystemRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CheckHostPatchRequestType struct {
	_this      *ManagedObjectReference                    `xml:"_this,omitempty"`
	metaUrls   []string                                   `xml:"metaUrls,omitempty"`
	bundleUrls []string                                   `xml:"bundleUrls,omitempty"`
	spec       *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty"`
}

type ScanHostPatchRequestType struct {
	_this      *ManagedObjectReference  `xml:"_this,omitempty"`
	repository *HostPatchManagerLocator `xml:"repository,omitempty"`
	updateID   []string                 `xml:"updateID,omitempty"`
}

type ScanHostPatchV2RequestType struct {
	_this      *ManagedObjectReference                    `xml:"_this,omitempty"`
	metaUrls   []string                                   `xml:"metaUrls,omitempty"`
	bundleUrls []string                                   `xml:"bundleUrls,omitempty"`
	spec       *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty"`
}

type StageHostPatchRequestType struct {
	_this      *ManagedObjectReference                    `xml:"_this,omitempty"`
	metaUrls   []string                                   `xml:"metaUrls,omitempty"`
	bundleUrls []string                                   `xml:"bundleUrls,omitempty"`
	vibUrls    []string                                   `xml:"vibUrls,omitempty"`
	spec       *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty"`
}

type InstallHostPatchRequestType struct {
	_this      *ManagedObjectReference  `xml:"_this,omitempty"`
	repository *HostPatchManagerLocator `xml:"repository,omitempty"`
	updateID   string                   `xml:"updateID,omitempty"`
	force      bool                     `xml:"force,omitempty"`
}

type InstallHostPatchV2RequestType struct {
	_this      *ManagedObjectReference                    `xml:"_this,omitempty"`
	metaUrls   []string                                   `xml:"metaUrls,omitempty"`
	bundleUrls []string                                   `xml:"bundleUrls,omitempty"`
	vibUrls    []string                                   `xml:"vibUrls,omitempty"`
	spec       *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty"`
}

type UninstallHostPatchRequestType struct {
	_this       *ManagedObjectReference                    `xml:"_this,omitempty"`
	bulletinIds []string                                   `xml:"bulletinIds,omitempty"`
	spec        *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty"`
}

type QueryHostPatchRequestType struct {
	_this *ManagedObjectReference                    `xml:"_this,omitempty"`
	spec  *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty"`
}

type RefreshRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdatePassthruConfigRequestType struct {
	_this  *ManagedObjectReference  `xml:"_this,omitempty"`
	config []*HostPciPassthruConfig `xml:"config,omitempty"`
}

type ConfigurePowerPolicyRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	key   int32                   `xml:"key,omitempty"`
}

type UpdateServicePolicyRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	id     string                  `xml:"id,omitempty"`
	policy string                  `xml:"policy,omitempty"`
}

type StartServiceRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	id    string                  `xml:"id,omitempty"`
}

type StopServiceRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	id    string                  `xml:"id,omitempty"`
}

type RestartServiceRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	id    string                  `xml:"id,omitempty"`
}

type UninstallServiceRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	id    string                  `xml:"id,omitempty"`
}

type RefreshServicesRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ReconfigureSnmpAgentRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *HostSnmpConfigSpec     `xml:"spec,omitempty"`
}

type SendTestNotificationRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type RetrieveDiskPartitionInfoRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	devicePath []string                `xml:"devicePath,omitempty"`
}

type ComputeDiskPartitionInfoRequestType struct {
	_this           *ManagedObjectReference  `xml:"_this,omitempty"`
	devicePath      string                   `xml:"devicePath,omitempty"`
	layout          *HostDiskPartitionLayout `xml:"layout,omitempty"`
	partitionFormat string                   `xml:"partitionFormat,omitempty"`
}

type ComputeDiskPartitionInfoForResizeRequestType struct {
	_this           *ManagedObjectReference      `xml:"_this,omitempty"`
	partition       *HostScsiDiskPartition       `xml:"partition,omitempty"`
	blockRange      *HostDiskPartitionBlockRange `xml:"blockRange,omitempty"`
	partitionFormat string                       `xml:"partitionFormat,omitempty"`
}

type UpdateDiskPartitionsRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	devicePath string                  `xml:"devicePath,omitempty"`
	spec       *HostDiskPartitionSpec  `xml:"spec,omitempty"`
}

type FormatVmfsRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	createSpec *HostVmfsSpec           `xml:"createSpec,omitempty"`
}

type MountVmfsVolumeRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vmfsUuid string                  `xml:"vmfsUuid,omitempty"`
}

type UnmountVmfsVolumeRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vmfsUuid string                  `xml:"vmfsUuid,omitempty"`
}

type DeleteVmfsVolumeStateRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vmfsUuid string                  `xml:"vmfsUuid,omitempty"`
}

type RescanVmfsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type AttachVmfsExtentRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vmfsPath string                  `xml:"vmfsPath,omitempty"`
	extent   *HostScsiDiskPartition  `xml:"extent,omitempty"`
}

type ExpandVmfsExtentRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vmfsPath string                  `xml:"vmfsPath,omitempty"`
	extent   *HostScsiDiskPartition  `xml:"extent,omitempty"`
}

type UpgradeVmfsRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vmfsPath string                  `xml:"vmfsPath,omitempty"`
}

type UpgradeVmLayoutRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryUnresolvedVmfsVolumeRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ResolveMultipleUnresolvedVmfsVolumesRequestType struct {
	_this          *ManagedObjectReference             `xml:"_this,omitempty"`
	resolutionSpec []*HostUnresolvedVmfsResolutionSpec `xml:"resolutionSpec,omitempty"`
}

type ResolveMultipleUnresolvedVmfsVolumesExRequestType struct {
	_this          *ManagedObjectReference             `xml:"_this,omitempty"`
	resolutionSpec []*HostUnresolvedVmfsResolutionSpec `xml:"resolutionSpec,omitempty"`
}

type UnmountForceMountedVmfsVolumeRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vmfsUuid string                  `xml:"vmfsUuid,omitempty"`
}

type RescanHbaRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	hbaDevice string                  `xml:"hbaDevice,omitempty"`
}

type RescanAllHbaRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateSoftwareInternetScsiEnabledRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	enabled bool                    `xml:"enabled,omitempty"`
}

type UpdateInternetScsiDiscoveryPropertiesRequestType struct {
	_this               *ManagedObjectReference                 `xml:"_this,omitempty"`
	iScsiHbaDevice      string                                  `xml:"iScsiHbaDevice,omitempty"`
	discoveryProperties *HostInternetScsiHbaDiscoveryProperties `xml:"discoveryProperties,omitempty"`
}

type UpdateInternetScsiAuthenticationPropertiesRequestType struct {
	_this                    *ManagedObjectReference                      `xml:"_this,omitempty"`
	iScsiHbaDevice           string                                       `xml:"iScsiHbaDevice,omitempty"`
	authenticationProperties *HostInternetScsiHbaAuthenticationProperties `xml:"authenticationProperties,omitempty"`
	targetSet                *HostInternetScsiHbaTargetSet                `xml:"targetSet,omitempty"`
}

type UpdateInternetScsiDigestPropertiesRequestType struct {
	_this            *ManagedObjectReference              `xml:"_this,omitempty"`
	iScsiHbaDevice   string                               `xml:"iScsiHbaDevice,omitempty"`
	targetSet        *HostInternetScsiHbaTargetSet        `xml:"targetSet,omitempty"`
	digestProperties *HostInternetScsiHbaDigestProperties `xml:"digestProperties,omitempty"`
}

type UpdateInternetScsiAdvancedOptionsRequestType struct {
	_this          *ManagedObjectReference          `xml:"_this,omitempty"`
	iScsiHbaDevice string                           `xml:"iScsiHbaDevice,omitempty"`
	targetSet      *HostInternetScsiHbaTargetSet    `xml:"targetSet,omitempty"`
	options        []*HostInternetScsiHbaParamValue `xml:"options,omitempty"`
}

type UpdateInternetScsiIPPropertiesRequestType struct {
	_this          *ManagedObjectReference          `xml:"_this,omitempty"`
	iScsiHbaDevice string                           `xml:"iScsiHbaDevice,omitempty"`
	ipProperties   *HostInternetScsiHbaIPProperties `xml:"ipProperties,omitempty"`
}

type UpdateInternetScsiNameRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	iScsiHbaDevice string                  `xml:"iScsiHbaDevice,omitempty"`
	iScsiName      string                  `xml:"iScsiName,omitempty"`
}

type UpdateInternetScsiAliasRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	iScsiHbaDevice string                  `xml:"iScsiHbaDevice,omitempty"`
	iScsiAlias     string                  `xml:"iScsiAlias,omitempty"`
}

type AddInternetScsiSendTargetsRequestType struct {
	_this          *ManagedObjectReference          `xml:"_this,omitempty"`
	iScsiHbaDevice string                           `xml:"iScsiHbaDevice,omitempty"`
	targets        []*HostInternetScsiHbaSendTarget `xml:"targets,omitempty"`
}

type RemoveInternetScsiSendTargetsRequestType struct {
	_this          *ManagedObjectReference          `xml:"_this,omitempty"`
	iScsiHbaDevice string                           `xml:"iScsiHbaDevice,omitempty"`
	targets        []*HostInternetScsiHbaSendTarget `xml:"targets,omitempty"`
}

type AddInternetScsiStaticTargetsRequestType struct {
	_this          *ManagedObjectReference            `xml:"_this,omitempty"`
	iScsiHbaDevice string                             `xml:"iScsiHbaDevice,omitempty"`
	targets        []*HostInternetScsiHbaStaticTarget `xml:"targets,omitempty"`
}

type RemoveInternetScsiStaticTargetsRequestType struct {
	_this          *ManagedObjectReference            `xml:"_this,omitempty"`
	iScsiHbaDevice string                             `xml:"iScsiHbaDevice,omitempty"`
	targets        []*HostInternetScsiHbaStaticTarget `xml:"targets,omitempty"`
}

type EnableMultipathPathRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	pathName string                  `xml:"pathName,omitempty"`
}

type DisableMultipathPathRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	pathName string                  `xml:"pathName,omitempty"`
}

type SetMultipathLunPolicyRequestType struct {
	_this  *ManagedObjectReference             `xml:"_this,omitempty"`
	lunId  string                              `xml:"lunId,omitempty"`
	policy *HostMultipathInfoLogicalUnitPolicy `xml:"policy,omitempty"`
}

type QueryPathSelectionPolicyOptionsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryStorageArrayTypePolicyOptionsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type UpdateScsiLunDisplayNameRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	lunUuid     string                  `xml:"lunUuid,omitempty"`
	displayName string                  `xml:"displayName,omitempty"`
}

type DetachScsiLunRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	lunUuid string                  `xml:"lunUuid,omitempty"`
}

type DeleteScsiLunStateRequestType struct {
	_this            *ManagedObjectReference `xml:"_this,omitempty"`
	lunCanonicalName string                  `xml:"lunCanonicalName,omitempty"`
}

type AttachScsiLunRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	lunUuid string                  `xml:"lunUuid,omitempty"`
}

type RefreshStorageSystemRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type DiscoverFcoeHbasRequestType struct {
	_this    *ManagedObjectReference      `xml:"_this,omitempty"`
	fcoeSpec *FcoeConfigFcoeSpecification `xml:"fcoeSpec,omitempty"`
}

type MarkForRemovalRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	hbaName string                  `xml:"hbaName,omitempty"`
	remove  bool                    `xml:"remove,omitempty"`
}

type FormatVffsRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	createSpec *HostVffsSpec           `xml:"createSpec,omitempty"`
}

type ExtendVffsRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	vffsPath   string                  `xml:"vffsPath,omitempty"`
	devicePath string                  `xml:"devicePath,omitempty"`
	spec       *HostDiskPartitionSpec  `xml:"spec,omitempty"`
}

type DestroyVffsRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vffsPath string                  `xml:"vffsPath,omitempty"`
}

type MountVffsVolumeRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vffsUuid string                  `xml:"vffsUuid,omitempty"`
}

type UnmountVffsVolumeRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vffsUuid string                  `xml:"vffsUuid,omitempty"`
}

type DeleteVffsVolumeStateRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vffsUuid string                  `xml:"vffsUuid,omitempty"`
}

type RescanVffsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryAvailableSsdsRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vffsPath string                  `xml:"vffsPath,omitempty"`
}

type ConfigureVFlashResourceExRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	devicePath []string                `xml:"devicePath,omitempty"`
}

type HostConfigureVFlashResourceRequestType struct {
	_this *ManagedObjectReference                    `xml:"_this,omitempty"`
	spec  *HostVFlashManagerVFlashResourceConfigSpec `xml:"spec,omitempty"`
}

type HostRemoveVFlashResourceRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type HostConfigVFlashCacheRequestType struct {
	_this *ManagedObjectReference                 `xml:"_this,omitempty"`
	spec  *HostVFlashManagerVFlashCacheConfigSpec `xml:"spec,omitempty"`
}

type HostGetVFlashModuleDefaultConfigRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	vFlashModule string                  `xml:"vFlashModule,omitempty"`
}

type UpdateIpConfigRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	ipConfig *HostIpConfig           `xml:"ipConfig,omitempty"`
}

type SelectVnicRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	device string                  `xml:"device,omitempty"`
}

type DeselectVnicRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryNetConfigRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	nicType string                  `xml:"nicType,omitempty"`
}

type SelectVnicForNicTypeRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	nicType string                  `xml:"nicType,omitempty"`
	device  string                  `xml:"device,omitempty"`
}

type DeselectVnicForNicTypeRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	nicType string                  `xml:"nicType,omitempty"`
	device  string                  `xml:"device,omitempty"`
}

type QueryCmmdsRequestType struct {
	_this   *ManagedObjectReference             `xml:"_this,omitempty"`
	queries []*HostVsanInternalSystemCmmdsQuery `xml:"queries,omitempty"`
}

type QueryPhysicalVsanDisksRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	props []string                `xml:"props,omitempty"`
}

type QueryVsanObjectsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	uuids []string                `xml:"uuids,omitempty"`
}

type QueryObjectsOnPhysicalVsanDiskRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	disks []string                `xml:"disks,omitempty"`
}

type QueryDisksForVsanRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	canonicalName []string                `xml:"canonicalName,omitempty"`
}

type AddDisksRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	disk  []*HostScsiDisk         `xml:"disk,omitempty"`
}

type InitializeDisksRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	mapping []*VsanHostDiskMapping  `xml:"mapping,omitempty"`
}

type RemoveDiskRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	disk  []*HostScsiDisk         `xml:"disk,omitempty"`
}

type RemoveDiskMappingRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	mapping []*VsanHostDiskMapping  `xml:"mapping,omitempty"`
}

type UpdateVsanRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	config *VsanHostConfigInfo     `xml:"config,omitempty"`
}

type QueryHostStatusRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type QueryOptionsRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	name  string                  `xml:"name,omitempty"`
}

type UpdateOptionsRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	changedValue []*OptionValue          `xml:"changedValue,omitempty"`
}

type CheckComplianceRequestType struct {
	_this   *ManagedObjectReference   `xml:"_this,omitempty"`
	profile []*ManagedObjectReference `xml:"profile,omitempty"`
	entity  []*ManagedObjectReference `xml:"entity,omitempty"`
}

type QueryComplianceStatusRequestType struct {
	_this   *ManagedObjectReference   `xml:"_this,omitempty"`
	profile []*ManagedObjectReference `xml:"profile,omitempty"`
	entity  []*ManagedObjectReference `xml:"entity,omitempty"`
}

type ClearComplianceStatusRequestType struct {
	_this   *ManagedObjectReference   `xml:"_this,omitempty"`
	profile []*ManagedObjectReference `xml:"profile,omitempty"`
	entity  []*ManagedObjectReference `xml:"entity,omitempty"`
}

type QueryExpressionMetadataRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	expressionName []string                `xml:"expressionName,omitempty"`
	profile        *ManagedObjectReference `xml:"profile,omitempty"`
}

type RetrieveDescriptionRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type DestroyProfileRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type AssociateProfileRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	entity []*ManagedObjectReference `xml:"entity,omitempty"`
}

type DissociateProfileRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	entity []*ManagedObjectReference `xml:"entity,omitempty"`
}

type CheckProfileComplianceRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	entity []*ManagedObjectReference `xml:"entity,omitempty"`
}

type ExportProfileRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateProfileRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	createSpec *ProfileCreateSpec      `xml:"createSpec,omitempty"`
}

type QueryPolicyMetadataRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	policyName []string                `xml:"policyName,omitempty"`
	profile    *ManagedObjectReference `xml:"profile,omitempty"`
}

type FindAssociatedProfileRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type UpdateClusterProfileRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	config *ClusterProfileConfigSpec `xml:"config,omitempty"`
}

type UpdateReferenceHostRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type UpdateHostProfileRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	config *HostProfileConfigSpec  `xml:"config,omitempty"`
}

type ExecuteHostProfileRequestType struct {
	_this         *ManagedObjectReference                 `xml:"_this,omitempty"`
	host          *ManagedObjectReference                 `xml:"host,omitempty"`
	deferredParam []*ProfileDeferredPolicyOptionParameter `xml:"deferredParam,omitempty"`
}

type ApplyHostConfigRequestType struct {
	_this      *ManagedObjectReference                 `xml:"_this,omitempty"`
	host       *ManagedObjectReference                 `xml:"host,omitempty"`
	configSpec *HostConfigSpec                         `xml:"configSpec,omitempty"`
	userInput  []*ProfileDeferredPolicyOptionParameter `xml:"userInput,omitempty"`
}

type GenerateConfigTaskListRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	configSpec *HostConfigSpec         `xml:"configSpec,omitempty"`
	host       *ManagedObjectReference `xml:"host,omitempty"`
}

type GenerateHostProfileTaskListRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	configSpec *HostConfigSpec         `xml:"configSpec,omitempty"`
	host       *ManagedObjectReference `xml:"host,omitempty"`
}

type QueryHostProfileMetadataRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	profileName []string                `xml:"profileName,omitempty"`
	profile     *ManagedObjectReference `xml:"profile,omitempty"`
}

type QueryProfileStructureRequestType struct {
	_this   *ManagedObjectReference `xml:"_this,omitempty"`
	profile *ManagedObjectReference `xml:"profile,omitempty"`
}

type CreateDefaultProfileRequestType struct {
	_this           *ManagedObjectReference `xml:"_this,omitempty"`
	profileType     string                  `xml:"profileType,omitempty"`
	profileTypeName string                  `xml:"profileTypeName,omitempty"`
	profile         *ManagedObjectReference `xml:"profile,omitempty"`
}

type UpdateAnswerFileRequestType struct {
	_this      *ManagedObjectReference `xml:"_this,omitempty"`
	host       *ManagedObjectReference `xml:"host,omitempty"`
	configSpec *AnswerFileCreateSpec   `xml:"configSpec,omitempty"`
}

type RetrieveAnswerFileRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type RetrieveAnswerFileForProfileRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	host         *ManagedObjectReference `xml:"host,omitempty"`
	applyProfile *HostApplyProfile       `xml:"applyProfile,omitempty"`
}

type ExportAnswerFileRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	host  *ManagedObjectReference `xml:"host,omitempty"`
}

type CheckAnswerFileStatusRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	host  []*ManagedObjectReference `xml:"host,omitempty"`
}

type QueryAnswerFileStatusRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	host  []*ManagedObjectReference `xml:"host,omitempty"`
}

type RemoveScheduledTaskRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type ReconfigureScheduledTaskRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	spec  *ScheduledTaskSpec      `xml:"spec,omitempty"`
}

type RunScheduledTaskRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateScheduledTaskRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
	spec   *ScheduledTaskSpec      `xml:"spec,omitempty"`
}

type RetrieveEntityScheduledTaskRequestType struct {
	_this  *ManagedObjectReference `xml:"_this,omitempty"`
	entity *ManagedObjectReference `xml:"entity,omitempty"`
}

type CreateObjectScheduledTaskRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	obj   *ManagedObjectReference `xml:"obj,omitempty"`
	spec  *ScheduledTaskSpec      `xml:"spec,omitempty"`
}

type RetrieveObjectScheduledTaskRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	obj   *ManagedObjectReference `xml:"obj,omitempty"`
}

type OpenInventoryViewFolderRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	entity []*ManagedObjectReference `xml:"entity,omitempty"`
}

type CloseInventoryViewFolderRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	entity []*ManagedObjectReference `xml:"entity,omitempty"`
}

type ModifyListViewRequestType struct {
	_this  *ManagedObjectReference   `xml:"_this,omitempty"`
	add    []*ManagedObjectReference `xml:"add,omitempty"`
	remove []*ManagedObjectReference `xml:"remove,omitempty"`
}

type ResetListViewRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	obj   []*ManagedObjectReference `xml:"obj,omitempty"`
}

type ResetListViewFromViewRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	view  *ManagedObjectReference `xml:"view,omitempty"`
}

type DestroyViewRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateInventoryViewRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CreateContainerViewRequestType struct {
	_this     *ManagedObjectReference `xml:"_this,omitempty"`
	container *ManagedObjectReference `xml:"container,omitempty"`
	type_     []string                `xml:"type,omitempty"`
	recursive bool                    `xml:"recursive,omitempty"`
}

type CreateListViewRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	obj   []*ManagedObjectReference `xml:"obj,omitempty"`
}

type CreateListViewFromViewRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	view  *ManagedObjectReference `xml:"view,omitempty"`
}

type RevertToSnapshotRequestType struct {
	_this           *ManagedObjectReference `xml:"_this,omitempty"`
	host            *ManagedObjectReference `xml:"host,omitempty"`
	suppressPowerOn bool                    `xml:"suppressPowerOn,omitempty"`
}

type RemoveSnapshotRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	removeChildren bool                    `xml:"removeChildren,omitempty"`
	consolidate    bool                    `xml:"consolidate,omitempty"`
}

type RenameSnapshotRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	name        string                  `xml:"name,omitempty"`
	description string                  `xml:"description,omitempty"`
}

type ExportSnapshotRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
}

type CheckCompatibilityRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vm       *ManagedObjectReference `xml:"vm,omitempty"`
	host     *ManagedObjectReference `xml:"host,omitempty"`
	pool     *ManagedObjectReference `xml:"pool,omitempty"`
	testType []string                `xml:"testType,omitempty"`
}

type QueryVMotionCompatibilityExRequestType struct {
	_this *ManagedObjectReference   `xml:"_this,omitempty"`
	vm    []*ManagedObjectReference `xml:"vm,omitempty"`
	host  []*ManagedObjectReference `xml:"host,omitempty"`
}

type CheckMigrateRequestType struct {
	_this    *ManagedObjectReference   `xml:"_this,omitempty"`
	vm       *ManagedObjectReference   `xml:"vm,omitempty"`
	host     *ManagedObjectReference   `xml:"host,omitempty"`
	pool     *ManagedObjectReference   `xml:"pool,omitempty"`
	state    *VirtualMachinePowerState `xml:"state,omitempty"`
	testType []string                  `xml:"testType,omitempty"`
}

type CheckRelocateRequestType struct {
	_this    *ManagedObjectReference     `xml:"_this,omitempty"`
	vm       *ManagedObjectReference     `xml:"vm,omitempty"`
	spec     *VirtualMachineRelocateSpec `xml:"spec,omitempty"`
	testType []string                    `xml:"testType,omitempty"`
}

type ValidateCredentialsInGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	auth  *GuestAuthentication    `xml:"auth,omitempty"`
}

type AcquireCredentialsInGuestRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	vm            *ManagedObjectReference `xml:"vm,omitempty"`
	requestedAuth *GuestAuthentication    `xml:"requestedAuth,omitempty"`
	sessionID     int64                   `xml:"sessionID,omitempty"`
}

type ReleaseCredentialsInGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	auth  *GuestAuthentication    `xml:"auth,omitempty"`
}

type MakeDirectoryInGuestRequestType struct {
	_this                   *ManagedObjectReference `xml:"_this,omitempty"`
	vm                      *ManagedObjectReference `xml:"vm,omitempty"`
	auth                    *GuestAuthentication    `xml:"auth,omitempty"`
	directoryPath           string                  `xml:"directoryPath,omitempty"`
	createParentDirectories bool                    `xml:"createParentDirectories,omitempty"`
}

type DeleteFileInGuestRequestType struct {
	_this    *ManagedObjectReference `xml:"_this,omitempty"`
	vm       *ManagedObjectReference `xml:"vm,omitempty"`
	auth     *GuestAuthentication    `xml:"auth,omitempty"`
	filePath string                  `xml:"filePath,omitempty"`
}

type DeleteDirectoryInGuestRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	vm            *ManagedObjectReference `xml:"vm,omitempty"`
	auth          *GuestAuthentication    `xml:"auth,omitempty"`
	directoryPath string                  `xml:"directoryPath,omitempty"`
	recursive     bool                    `xml:"recursive,omitempty"`
}

type MoveDirectoryInGuestRequestType struct {
	_this            *ManagedObjectReference `xml:"_this,omitempty"`
	vm               *ManagedObjectReference `xml:"vm,omitempty"`
	auth             *GuestAuthentication    `xml:"auth,omitempty"`
	srcDirectoryPath string                  `xml:"srcDirectoryPath,omitempty"`
	dstDirectoryPath string                  `xml:"dstDirectoryPath,omitempty"`
}

type MoveFileInGuestRequestType struct {
	_this       *ManagedObjectReference `xml:"_this,omitempty"`
	vm          *ManagedObjectReference `xml:"vm,omitempty"`
	auth        *GuestAuthentication    `xml:"auth,omitempty"`
	srcFilePath string                  `xml:"srcFilePath,omitempty"`
	dstFilePath string                  `xml:"dstFilePath,omitempty"`
	overwrite   bool                    `xml:"overwrite,omitempty"`
}

type CreateTemporaryFileInGuestRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	vm            *ManagedObjectReference `xml:"vm,omitempty"`
	auth          *GuestAuthentication    `xml:"auth,omitempty"`
	prefix        string                  `xml:"prefix,omitempty"`
	suffix        string                  `xml:"suffix,omitempty"`
	directoryPath string                  `xml:"directoryPath,omitempty"`
}

type CreateTemporaryDirectoryInGuestRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	vm            *ManagedObjectReference `xml:"vm,omitempty"`
	auth          *GuestAuthentication    `xml:"auth,omitempty"`
	prefix        string                  `xml:"prefix,omitempty"`
	suffix        string                  `xml:"suffix,omitempty"`
	directoryPath string                  `xml:"directoryPath,omitempty"`
}

type ListFilesInGuestRequestType struct {
	_this        *ManagedObjectReference `xml:"_this,omitempty"`
	vm           *ManagedObjectReference `xml:"vm,omitempty"`
	auth         *GuestAuthentication    `xml:"auth,omitempty"`
	filePath     string                  `xml:"filePath,omitempty"`
	index        int32                   `xml:"index,omitempty"`
	maxResults   int32                   `xml:"maxResults,omitempty"`
	matchPattern string                  `xml:"matchPattern,omitempty"`
}

type ChangeFileAttributesInGuestRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	vm             *ManagedObjectReference `xml:"vm,omitempty"`
	auth           *GuestAuthentication    `xml:"auth,omitempty"`
	guestFilePath  string                  `xml:"guestFilePath,omitempty"`
	fileAttributes *GuestFileAttributes    `xml:"fileAttributes,omitempty"`
}

type InitiateFileTransferFromGuestRequestType struct {
	_this         *ManagedObjectReference `xml:"_this,omitempty"`
	vm            *ManagedObjectReference `xml:"vm,omitempty"`
	auth          *GuestAuthentication    `xml:"auth,omitempty"`
	guestFilePath string                  `xml:"guestFilePath,omitempty"`
}

type InitiateFileTransferToGuestRequestType struct {
	_this          *ManagedObjectReference `xml:"_this,omitempty"`
	vm             *ManagedObjectReference `xml:"vm,omitempty"`
	auth           *GuestAuthentication    `xml:"auth,omitempty"`
	guestFilePath  string                  `xml:"guestFilePath,omitempty"`
	fileAttributes *GuestFileAttributes    `xml:"fileAttributes,omitempty"`
	fileSize       int64                   `xml:"fileSize,omitempty"`
	overwrite      bool                    `xml:"overwrite,omitempty"`
}

type StartProgramInGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	auth  *GuestAuthentication    `xml:"auth,omitempty"`
	spec  *GuestProgramSpec       `xml:"spec,omitempty"`
}

type ListProcessesInGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	auth  *GuestAuthentication    `xml:"auth,omitempty"`
	pids  []int64                 `xml:"pids,omitempty"`
}

type TerminateProcessInGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	auth  *GuestAuthentication    `xml:"auth,omitempty"`
	pid   int64                   `xml:"pid,omitempty"`
}

type ReadEnvironmentVariableInGuestRequestType struct {
	_this *ManagedObjectReference `xml:"_this,omitempty"`
	vm    *ManagedObjectReference `xml:"vm,omitempty"`
	auth  *GuestAuthentication    `xml:"auth,omitempty"`
	names []string                `xml:"names,omitempty"`
}

var timeout = time.Duration(30 * time.Second)

func dialTimeout(network, addr string) (net.Conn, error) {
	return net.DialTimeout(network, addr, timeout)
}

type VimPortType struct {
	url string
	tls bool
}

func NewVimPortType(url string, tls bool) *VimPortType {
	service := &VimPortType{
		url: url,
		tls: tls,
	}

	return service
}

func (service *VimPortType) call(operation, soapAction string, request interface{}) ([]byte, error) {
	envelope := gowsdl.SoapEnvelope{
		Header:        gowsdl.SoapHeader{},
		EncodingStyle: "http://schemas.xmlsoap.org/soap/encoding/",
	}

	reqXml, err := xml.Marshal(request)
	if err != nil {
		return nil, err
	}

	envelope.Body = gowsdl.SoapBody{
		Body: string(reqXml),
	}

	buffer := &bytes.Buffer{}

	encoder := xml.NewEncoder(buffer)
	//encoder.Indent("  ", "    ")

	err = encoder.Encode(envelope)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", service.url, buffer)
	req.Header.Add("Content-Type", "text/xml; charset=\"utf-8\"")
	req.Header.Add("SOAPAction", soapAction)
	req.Header.Set("User-Agent", "gowsdl/0.1")

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: service.tls,
		},
		Dial: dialTimeout,
	}

	client := &http.Client{Transport: tr}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)

	return body, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) AddAuthorizationRole(request *AddAuthorizationRoleRequestType) (*AddAuthorizationRoleResponse, error) {
	data, err := service.call("AddAuthorizationRole", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddAuthorizationRoleResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RemoveFailedFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveAuthorizationRole(request *RemoveAuthorizationRoleRequestType) (*RemoveAuthorizationRoleResponse, error) {
	data, err := service.call("RemoveAuthorizationRole", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveAuthorizationRoleResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - InvalidNameFault
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateAuthorizationRole(request *UpdateAuthorizationRoleRequestType) (*UpdateAuthorizationRoleResponse, error) {
	data, err := service.call("UpdateAuthorizationRole", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateAuthorizationRoleResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - AuthMinimumAdminPermissionFault
* - RuntimeFault
 */
func (service *VimPortType) MergePermissions(request *MergePermissionsRequestType) (*MergePermissionsResponse, error) {
	data, err := service.call("MergePermissions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MergePermissionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) RetrieveRolePermissions(request *RetrieveRolePermissionsRequestType) (*RetrieveRolePermissionsResponse, error) {
	data, err := service.call("RetrieveRolePermissions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveRolePermissionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveEntityPermissions(request *RetrieveEntityPermissionsRequestType) (*RetrieveEntityPermissionsResponse, error) {
	data, err := service.call("RetrieveEntityPermissions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveEntityPermissionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveAllPermissions(request *RetrieveAllPermissionsRequestType) (*RetrieveAllPermissionsResponse, error) {
	data, err := service.call("RetrieveAllPermissions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveAllPermissionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - UserNotFoundFault
* - NotFoundFault
* - AuthMinimumAdminPermissionFault
* - RuntimeFault
 */
func (service *VimPortType) SetEntityPermissions(request *SetEntityPermissionsRequestType) (*SetEntityPermissionsResponse, error) {
	data, err := service.call("SetEntityPermissions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetEntityPermissionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - UserNotFoundFault
* - NotFoundFault
* - AuthMinimumAdminPermissionFault
* - RuntimeFault
 */
func (service *VimPortType) ResetEntityPermissions(request *ResetEntityPermissionsRequestType) (*ResetEntityPermissionsResponse, error) {
	data, err := service.call("ResetEntityPermissions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetEntityPermissionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - AuthMinimumAdminPermissionFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveEntityPermission(request *RemoveEntityPermissionRequestType) (*RemoveEntityPermissionResponse, error) {
	data, err := service.call("RemoveEntityPermission", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveEntityPermissionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) HasPrivilegeOnEntity(request *HasPrivilegeOnEntityRequestType) (*HasPrivilegeOnEntityResponse, error) {
	data, err := service.call("HasPrivilegeOnEntity", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HasPrivilegeOnEntityResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) HasPrivilegeOnEntities(request *HasPrivilegeOnEntitiesRequestType) (*HasPrivilegeOnEntitiesResponse, error) {
	data, err := service.call("HasPrivilegeOnEntities", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HasPrivilegeOnEntitiesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureCluster_Task(request *ReconfigureClusterRequestType) (*ReconfigureCluster_TaskResponse, error) {
	data, err := service.call("ReconfigureCluster_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureCluster_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ApplyRecommendation(request *ApplyRecommendationRequestType) (*ApplyRecommendationResponse, error) {
	data, err := service.call("ApplyRecommendation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ApplyRecommendationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CancelRecommendation(request *CancelRecommendationRequestType) (*CancelRecommendationResponse, error) {
	data, err := service.call("CancelRecommendation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CancelRecommendationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RecommendHostsForVm(request *RecommendHostsForVmRequestType) (*RecommendHostsForVmResponse, error) {
	data, err := service.call("RecommendHostsForVm", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RecommendHostsForVmResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - HostConnectFaultFault
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) AddHost_Task(request *AddHostRequestType) (*AddHost_TaskResponse, error) {
	data, err := service.call("AddHost_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddHost_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - TooManyHostsFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) MoveInto_Task(request *MoveIntoRequestType) (*MoveInto_TaskResponse, error) {
	data, err := service.call("MoveInto_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveInto_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TooManyHostsFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) MoveHostInto_Task(request *MoveHostIntoRequestType) (*MoveHostInto_TaskResponse, error) {
	data, err := service.call("MoveHostInto_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveHostInto_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshRecommendation(request *RefreshRecommendationRequestType) (*RefreshRecommendationResponse, error) {
	data, err := service.call("RefreshRecommendation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshRecommendationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveDasAdvancedRuntimeInfo(request *RetrieveDasAdvancedRuntimeInfoRequestType) (*RetrieveDasAdvancedRuntimeInfoResponse, error) {
	data, err := service.call("RetrieveDasAdvancedRuntimeInfo", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveDasAdvancedRuntimeInfoResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ClusterEnterMaintenanceMode(request *ClusterEnterMaintenanceModeRequestType) (*ClusterEnterMaintenanceModeResponse, error) {
	data, err := service.call("ClusterEnterMaintenanceMode", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ClusterEnterMaintenanceModeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureComputeResource_Task(request *ReconfigureComputeResourceRequestType) (*ReconfigureComputeResource_TaskResponse, error) {
	data, err := service.call("ReconfigureComputeResource_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureComputeResource_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidPrivilegeFault
* - RuntimeFault
 */
func (service *VimPortType) AddCustomFieldDef(request *AddCustomFieldDefRequestType) (*AddCustomFieldDefResponse, error) {
	data, err := service.call("AddCustomFieldDef", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddCustomFieldDefResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RemoveCustomFieldDef(request *RemoveCustomFieldDefRequestType) (*RemoveCustomFieldDefResponse, error) {
	data, err := service.call("RemoveCustomFieldDef", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveCustomFieldDefResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) RenameCustomFieldDef(request *RenameCustomFieldDefRequestType) (*RenameCustomFieldDefResponse, error) {
	data, err := service.call("RenameCustomFieldDef", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RenameCustomFieldDefResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) SetField(request *SetFieldRequestType) (*SetFieldResponse, error) {
	data, err := service.call("SetField", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetFieldResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DoesCustomizationSpecExist(request *DoesCustomizationSpecExistRequestType) (*DoesCustomizationSpecExistResponse, error) {
	data, err := service.call("DoesCustomizationSpecExist", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DoesCustomizationSpecExistResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) GetCustomizationSpec(request *GetCustomizationSpecRequestType) (*GetCustomizationSpecResponse, error) {
	data, err := service.call("GetCustomizationSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &GetCustomizationSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CustomizationFaultFault
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) CreateCustomizationSpec(request *CreateCustomizationSpecRequestType) (*CreateCustomizationSpecResponse, error) {
	data, err := service.call("CreateCustomizationSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateCustomizationSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CustomizationFaultFault
* - NotFoundFault
* - ConcurrentAccessFault
* - RuntimeFault
 */
func (service *VimPortType) OverwriteCustomizationSpec(request *OverwriteCustomizationSpecRequestType) (*OverwriteCustomizationSpecResponse, error) {
	data, err := service.call("OverwriteCustomizationSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &OverwriteCustomizationSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteCustomizationSpec(request *DeleteCustomizationSpecRequestType) (*DeleteCustomizationSpecResponse, error) {
	data, err := service.call("DeleteCustomizationSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteCustomizationSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) DuplicateCustomizationSpec(request *DuplicateCustomizationSpecRequestType) (*DuplicateCustomizationSpecResponse, error) {
	data, err := service.call("DuplicateCustomizationSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DuplicateCustomizationSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) RenameCustomizationSpec(request *RenameCustomizationSpecRequestType) (*RenameCustomizationSpecResponse, error) {
	data, err := service.call("RenameCustomizationSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RenameCustomizationSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CustomizationSpecItemToXml(request *CustomizationSpecItemToXmlRequestType) (*CustomizationSpecItemToXmlResponse, error) {
	data, err := service.call("CustomizationSpecItemToXml", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CustomizationSpecItemToXmlResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CustomizationFaultFault
* - RuntimeFault
 */
func (service *VimPortType) XmlToCustomizationSpecItem(request *XmlToCustomizationSpecItemRequestType) (*XmlToCustomizationSpecItemResponse, error) {
	data, err := service.call("XmlToCustomizationSpecItem", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &XmlToCustomizationSpecItemResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CustomizationFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CheckCustomizationResources(request *CheckCustomizationResourcesRequestType) (*CheckCustomizationResourcesResponse, error) {
	data, err := service.call("CheckCustomizationResources", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckCustomizationResourcesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - HostConnectFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryConnectionInfo(request *QueryConnectionInfoRequestType) (*QueryConnectionInfoResponse, error) {
	data, err := service.call("QueryConnectionInfo", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryConnectionInfoResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) PowerOnMultiVM_Task(request *PowerOnMultiVMRequestType) (*PowerOnMultiVM_TaskResponse, error) {
	data, err := service.call("PowerOnMultiVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PowerOnMultiVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryDatacenterConfigOptionDescriptor(request *queryDatacenterConfigOptionDescriptorRequestType) (*queryDatacenterConfigOptionDescriptorResponse, error) {
	data, err := service.call("queryDatacenterConfigOptionDescriptor", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &queryDatacenterConfigOptionDescriptorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureDatacenter_Task(request *ReconfigureDatacenterRequestType) (*ReconfigureDatacenter_TaskResponse, error) {
	data, err := service.call("ReconfigureDatacenter_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureDatacenter_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RefreshDatastore(request *RefreshDatastoreRequestType) (*RefreshDatastoreResponse, error) {
	data, err := service.call("RefreshDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshDatastoreStorageInfo(request *RefreshDatastoreStorageInfoRequestType) (*RefreshDatastoreStorageInfoResponse, error) {
	data, err := service.call("RefreshDatastoreStorageInfo", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshDatastoreStorageInfoResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ResourceInUseFault
* - PlatformConfigFaultFault
* - TaskInProgressFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateVirtualMachineFiles_Task(request *UpdateVirtualMachineFilesRequestType) (*UpdateVirtualMachineFiles_TaskResponse, error) {
	data, err := service.call("UpdateVirtualMachineFiles_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateVirtualMachineFiles_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) RenameDatastore(request *RenameDatastoreRequestType) (*RenameDatastoreResponse, error) {
	data, err := service.call("RenameDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RenameDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) DestroyDatastore(request *DestroyDatastoreRequestType) (*DestroyDatastoreResponse, error) {
	data, err := service.call("DestroyDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) DatastoreEnterMaintenanceMode(request *DatastoreEnterMaintenanceModeRequestType) (*DatastoreEnterMaintenanceModeResponse, error) {
	data, err := service.call("DatastoreEnterMaintenanceMode", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DatastoreEnterMaintenanceModeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) DatastoreExitMaintenanceMode_Task(request *DatastoreExitMaintenanceModeRequestType) (*DatastoreExitMaintenanceMode_TaskResponse, error) {
	data, err := service.call("DatastoreExitMaintenanceMode_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DatastoreExitMaintenanceMode_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CannotCreateFileFault
* - FileAlreadyExistsFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) CreateDirectory(request *CreateDirectoryRequestType) (*CreateDirectoryResponse, error) {
	data, err := service.call("CreateDirectory", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateDirectoryResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - FileNotFoundFault
* - InvalidDatastoreFault
* - InvalidDatastorePathFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteDirectory(request *DeleteDirectoryRequestType) (*DeleteDirectoryResponse, error) {
	data, err := service.call("DeleteDirectory", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteDirectoryResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryDescriptions(request *QueryDescriptionsRequestType) (*QueryDescriptionsResponse, error) {
	data, err := service.call("QueryDescriptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDescriptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CannotAccessFileFault
* - RuntimeFault
 */
func (service *VimPortType) BrowseDiagnosticLog(request *BrowseDiagnosticLogRequestType) (*BrowseDiagnosticLogResponse, error) {
	data, err := service.call("BrowseDiagnosticLog", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &BrowseDiagnosticLogResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - LogBundlingFailedFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) GenerateLogBundles_Task(request *GenerateLogBundlesRequestType) (*GenerateLogBundles_TaskResponse, error) {
	data, err := service.call("GenerateLogBundles_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &GenerateLogBundles_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FetchDVPortKeys(request *FetchDVPortKeysRequestType) (*FetchDVPortKeysResponse, error) {
	data, err := service.call("FetchDVPortKeys", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FetchDVPortKeysResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FetchDVPorts(request *FetchDVPortsRequestType) (*FetchDVPortsResponse, error) {
	data, err := service.call("FetchDVPorts", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FetchDVPortsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryUsedVlanIdInDvs(request *QueryUsedVlanIdInDvsRequestType) (*QueryUsedVlanIdInDvsResponse, error) {
	data, err := service.call("QueryUsedVlanIdInDvs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryUsedVlanIdInDvsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - ConcurrentAccessFault
* - DuplicateNameFault
* - InvalidStateFault
* - InvalidNameFault
* - NotFoundFault
* - AlreadyExistsFault
* - LimitExceededFault
* - ResourceInUseFault
* - ResourceNotAvailableFault
* - DvsNotAuthorizedFault
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureDvs_Task(request *ReconfigureDvsRequestType) (*ReconfigureDvs_TaskResponse, error) {
	data, err := service.call("ReconfigureDvs_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureDvs_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - DvsFaultFault
* - RuntimeFault
 */
func (service *VimPortType) PerformDvsProductSpecOperation_Task(request *PerformDvsProductSpecOperationRequestType) (*PerformDvsProductSpecOperation_TaskResponse, error) {
	data, err := service.call("PerformDvsProductSpecOperation_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PerformDvsProductSpecOperation_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - NotFoundFault
* - ResourceInUseFault
* - InvalidHostStateFault
* - RuntimeFault
 */
func (service *VimPortType) MergeDvs_Task(request *MergeDvsRequestType) (*MergeDvs_TaskResponse, error) {
	data, err := service.call("MergeDvs_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MergeDvs_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) AddDVPortgroup_Task(request *AddDVPortgroupRequestType) (*AddDVPortgroup_TaskResponse, error) {
	data, err := service.call("AddDVPortgroup_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddDVPortgroup_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - NotFoundFault
* - ConcurrentAccessFault
* - RuntimeFault
 */
func (service *VimPortType) MoveDVPort_Task(request *MoveDVPortRequestType) (*MoveDVPort_TaskResponse, error) {
	data, err := service.call("MoveDVPort_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveDVPort_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateDvsCapability(request *UpdateDvsCapabilityRequestType) (*UpdateDvsCapabilityResponse, error) {
	data, err := service.call("UpdateDvsCapability", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateDvsCapabilityResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - NotFoundFault
* - ResourceInUseFault
* - ConcurrentAccessFault
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureDVPort_Task(request *ReconfigureDVPortRequestType) (*ReconfigureDVPort_TaskResponse, error) {
	data, err := service.call("ReconfigureDVPort_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureDVPort_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) RefreshDVPortState(request *RefreshDVPortStateRequestType) (*RefreshDVPortStateResponse, error) {
	data, err := service.call("RefreshDVPortState", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshDVPortStateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) RectifyDvsHost_Task(request *RectifyDvsHostRequestType) (*RectifyDvsHost_TaskResponse, error) {
	data, err := service.call("RectifyDvsHost_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RectifyDvsHost_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - NotFoundFault
* - InvalidNameFault
* - ConcurrentAccessFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateNetworkResourcePool(request *UpdateNetworkResourcePoolRequestType) (*UpdateNetworkResourcePoolResponse, error) {
	data, err := service.call("UpdateNetworkResourcePool", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateNetworkResourcePoolResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) AddNetworkResourcePool(request *AddNetworkResourcePoolRequestType) (*AddNetworkResourcePoolResponse, error) {
	data, err := service.call("AddNetworkResourcePool", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddNetworkResourcePoolResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - NotFoundFault
* - InvalidNameFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveNetworkResourcePool(request *RemoveNetworkResourcePoolRequestType) (*RemoveNetworkResourcePoolResponse, error) {
	data, err := service.call("RemoveNetworkResourcePool", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveNetworkResourcePoolResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - RuntimeFault
 */
func (service *VimPortType) EnableNetworkResourceManagement(request *EnableNetworkResourceManagementRequestType) (*EnableNetworkResourceManagementResponse, error) {
	data, err := service.call("EnableNetworkResourceManagement", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnableNetworkResourceManagementResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - RollbackFailureFault
* - RuntimeFault
 */
func (service *VimPortType) DVSRollback_Task(request *DVSRollbackRequestType) (*DVSRollback_TaskResponse, error) {
	data, err := service.call("DVSRollback_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DVSRollback_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateDVPortgroup_Task(request *CreateDVPortgroupRequestType) (*CreateDVPortgroup_TaskResponse, error) {
	data, err := service.call("CreateDVPortgroup_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateDVPortgroup_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateDVSHealthCheckConfig_Task(request *UpdateDVSHealthCheckConfigRequestType) (*UpdateDVSHealthCheckConfig_TaskResponse, error) {
	data, err := service.call("UpdateDVSHealthCheckConfig_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateDVSHealthCheckConfig_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) LookupDvPortGroup(request *LookupDvPortGroupRequestType) (*LookupDvPortGroupResponse, error) {
	data, err := service.call("LookupDvPortGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LookupDvPortGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryConfigOptionDescriptor(request *QueryConfigOptionDescriptorRequestType) (*QueryConfigOptionDescriptorResponse, error) {
	data, err := service.call("QueryConfigOptionDescriptor", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryConfigOptionDescriptorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryConfigOption(request *QueryConfigOptionRequestType) (*QueryConfigOptionResponse, error) {
	data, err := service.call("QueryConfigOption", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryConfigOptionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryConfigTarget(request *QueryConfigTargetRequestType) (*QueryConfigTargetResponse, error) {
	data, err := service.call("QueryConfigTarget", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryConfigTargetResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryTargetCapabilities(request *QueryTargetCapabilitiesRequestType) (*QueryTargetCapabilitiesResponse, error) {
	data, err := service.call("QueryTargetCapabilities", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryTargetCapabilitiesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) SetCustomValue(request *setCustomValueRequestType) (*setCustomValueResponse, error) {
	data, err := service.call("setCustomValue", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &setCustomValueResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) UnregisterExtension(request *UnregisterExtensionRequestType) (*UnregisterExtensionResponse, error) {
	data, err := service.call("UnregisterExtension", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnregisterExtensionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindExtension(request *FindExtensionRequestType) (*FindExtensionResponse, error) {
	data, err := service.call("FindExtension", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindExtensionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RegisterExtension(request *RegisterExtensionRequestType) (*RegisterExtensionResponse, error) {
	data, err := service.call("RegisterExtension", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RegisterExtensionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateExtension(request *UpdateExtensionRequestType) (*UpdateExtensionResponse, error) {
	data, err := service.call("UpdateExtension", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateExtensionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) GetPublicKey(request *GetPublicKeyRequestType) (*GetPublicKeyResponse, error) {
	data, err := service.call("GetPublicKey", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &GetPublicKeyResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) SetPublicKey(request *SetPublicKeyRequestType) (*SetPublicKeyResponse, error) {
	data, err := service.call("SetPublicKey", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetPublicKeyResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - NoClientCertificateFault
* - RuntimeFault
 */
func (service *VimPortType) SetExtensionCertificate(request *SetExtensionCertificateRequestType) (*SetExtensionCertificateResponse, error) {
	data, err := service.call("SetExtensionCertificate", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetExtensionCertificateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryManagedBy(request *QueryManagedByRequestType) (*QueryManagedByResponse, error) {
	data, err := service.call("QueryManagedBy", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryManagedByResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryExtensionIpAllocationUsage(request *QueryExtensionIpAllocationUsageRequestType) (*QueryExtensionIpAllocationUsageResponse, error) {
	data, err := service.call("QueryExtensionIpAllocationUsage", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryExtensionIpAllocationUsageResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MoveDatastoreFile_Task(request *MoveDatastoreFileRequestType) (*MoveDatastoreFile_TaskResponse, error) {
	data, err := service.call("MoveDatastoreFile_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveDatastoreFile_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CopyDatastoreFile_Task(request *CopyDatastoreFileRequestType) (*CopyDatastoreFile_TaskResponse, error) {
	data, err := service.call("CopyDatastoreFile_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CopyDatastoreFile_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteDatastoreFile_Task(request *DeleteDatastoreFileRequestType) (*DeleteDatastoreFile_TaskResponse, error) {
	data, err := service.call("DeleteDatastoreFile_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteDatastoreFile_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MakeDirectory(request *MakeDirectoryRequestType) (*MakeDirectoryResponse, error) {
	data, err := service.call("MakeDirectory", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MakeDirectoryResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - FileFaultFault
* - UserNotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) ChangeOwner(request *ChangeOwnerRequestType) (*ChangeOwnerResponse, error) {
	data, err := service.call("ChangeOwner", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ChangeOwnerResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateFolder(request *CreateFolderRequestType) (*CreateFolderResponse, error) {
	data, err := service.call("CreateFolder", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateFolderResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidFolderFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) MoveIntoFolder_Task(request *MoveIntoFolderRequestType) (*MoveIntoFolder_TaskResponse, error) {
	data, err := service.call("MoveIntoFolder_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveIntoFolder_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - VmConfigFaultFault
* - FileFaultFault
* - OutOfBoundsFault
* - DuplicateNameFault
* - InvalidNameFault
* - InvalidDatastoreFault
* - InsufficientResourcesFaultFault
* - AlreadyExistsFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CreateVM_Task(request *CreateVMRequestType) (*CreateVM_TaskResponse, error) {
	data, err := service.call("CreateVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - OutOfBoundsFault
* - DuplicateNameFault
* - AlreadyExistsFault
* - InvalidDatastoreFault
* - NotFoundFault
* - InvalidNameFault
* - VmConfigFaultFault
* - InsufficientResourcesFaultFault
* - FileFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) RegisterVM_Task(request *RegisterVMRequestType) (*RegisterVM_TaskResponse, error) {
	data, err := service.call("RegisterVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RegisterVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateCluster(request *CreateClusterRequestType) (*CreateClusterResponse, error) {
	data, err := service.call("CreateCluster", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateClusterResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateClusterEx(request *CreateClusterExRequestType) (*CreateClusterExResponse, error) {
	data, err := service.call("CreateClusterEx", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateClusterExResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - HostConnectFaultFault
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) AddStandaloneHost_Task(request *AddStandaloneHostRequestType) (*AddStandaloneHost_TaskResponse, error) {
	data, err := service.call("AddStandaloneHost_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddStandaloneHost_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateDatacenter(request *CreateDatacenterRequestType) (*CreateDatacenterResponse, error) {
	data, err := service.call("CreateDatacenter", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateDatacenterResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ConcurrentAccessFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) UnregisterAndDestroy_Task(request *UnregisterAndDestroyRequestType) (*UnregisterAndDestroy_TaskResponse, error) {
	data, err := service.call("UnregisterAndDestroy_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnregisterAndDestroy_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - DuplicateNameFault
* - InvalidNameFault
* - NotFoundFault
* - DvsNotAuthorizedFault
* - RuntimeFault
 */
func (service *VimPortType) CreateDVS_Task(request *CreateDVSRequestType) (*CreateDVS_TaskResponse, error) {
	data, err := service.call("CreateDVS_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateDVS_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateStoragePod(request *CreateStoragePodRequestType) (*CreateStoragePodResponse, error) {
	data, err := service.call("CreateStoragePod", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateStoragePodResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) SetCollectorPageSize(request *SetCollectorPageSizeRequestType) (*SetCollectorPageSizeResponse, error) {
	data, err := service.call("SetCollectorPageSize", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetCollectorPageSizeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RewindCollector(request *RewindCollectorRequestType) (*RewindCollectorResponse, error) {
	data, err := service.call("RewindCollector", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RewindCollectorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ResetCollector(request *ResetCollectorRequestType) (*ResetCollectorResponse, error) {
	data, err := service.call("ResetCollector", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetCollectorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DestroyCollector(request *DestroyCollectorRequestType) (*DestroyCollectorResponse, error) {
	data, err := service.call("DestroyCollector", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyCollectorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryTpmAttestationReport(request *QueryTpmAttestationReportRequestType) (*QueryTpmAttestationReportResponse, error) {
	data, err := service.call("QueryTpmAttestationReport", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryTpmAttestationReportResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryHostConnectionInfo(request *QueryHostConnectionInfoRequestType) (*QueryHostConnectionInfoResponse, error) {
	data, err := service.call("QueryHostConnectionInfo", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryHostConnectionInfoResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateSystemResources(request *UpdateSystemResourcesRequestType) (*UpdateSystemResourcesResponse, error) {
	data, err := service.call("UpdateSystemResources", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateSystemResourcesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateSystemSwapConfiguration(request *UpdateSystemSwapConfigurationRequestType) (*UpdateSystemSwapConfigurationResponse, error) {
	data, err := service.call("UpdateSystemSwapConfiguration", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateSystemSwapConfigurationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - InvalidStateFault
* - InvalidNameFault
* - HostConnectFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ReconnectHost_Task(request *ReconnectHostRequestType) (*ReconnectHost_TaskResponse, error) {
	data, err := service.call("ReconnectHost_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconnectHost_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DisconnectHost_Task(request *DisconnectHostRequestType) (*DisconnectHost_TaskResponse, error) {
	data, err := service.call("DisconnectHost_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DisconnectHost_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - TimedoutFault
* - RuntimeFault
 */
func (service *VimPortType) EnterMaintenanceMode_Task(request *EnterMaintenanceModeRequestType) (*EnterMaintenanceMode_TaskResponse, error) {
	data, err := service.call("EnterMaintenanceMode_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnterMaintenanceMode_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - TimedoutFault
* - RuntimeFault
 */
func (service *VimPortType) ExitMaintenanceMode_Task(request *ExitMaintenanceModeRequestType) (*ExitMaintenanceMode_TaskResponse, error) {
	data, err := service.call("ExitMaintenanceMode_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExitMaintenanceMode_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) RebootHost_Task(request *RebootHostRequestType) (*RebootHost_TaskResponse, error) {
	data, err := service.call("RebootHost_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RebootHost_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ShutdownHost_Task(request *ShutdownHostRequestType) (*ShutdownHost_TaskResponse, error) {
	data, err := service.call("ShutdownHost_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ShutdownHost_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostPowerOpFailedFault
* - InvalidStateFault
* - NotSupportedFault
* - TimedoutFault
* - RequestCanceledFault
* - RuntimeFault
 */
func (service *VimPortType) PowerDownHostToStandBy_Task(request *PowerDownHostToStandByRequestType) (*PowerDownHostToStandBy_TaskResponse, error) {
	data, err := service.call("PowerDownHostToStandBy_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PowerDownHostToStandBy_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostPowerOpFailedFault
* - InvalidStateFault
* - NotSupportedFault
* - TimedoutFault
* - RuntimeFault
 */
func (service *VimPortType) PowerUpHostFromStandBy_Task(request *PowerUpHostFromStandByRequestType) (*PowerUpHostFromStandBy_TaskResponse, error) {
	data, err := service.call("PowerUpHostFromStandBy_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PowerUpHostFromStandBy_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryMemoryOverhead(request *QueryMemoryOverheadRequestType) (*QueryMemoryOverheadResponse, error) {
	data, err := service.call("QueryMemoryOverhead", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryMemoryOverheadResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryMemoryOverheadEx(request *QueryMemoryOverheadExRequestType) (*QueryMemoryOverheadExResponse, error) {
	data, err := service.call("QueryMemoryOverheadEx", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryMemoryOverheadExResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DasConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureHostForDAS_Task(request *ReconfigureHostForDASRequestType) (*ReconfigureHostForDAS_TaskResponse, error) {
	data, err := service.call("ReconfigureHostForDAS_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureHostForDAS_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateFlags(request *UpdateFlagsRequestType) (*UpdateFlagsResponse, error) {
	data, err := service.call("UpdateFlags", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateFlagsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) EnterLockdownMode(request *EnterLockdownModeRequestType) (*EnterLockdownModeResponse, error) {
	data, err := service.call("EnterLockdownMode", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnterLockdownModeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ExitLockdownMode(request *ExitLockdownModeRequestType) (*ExitLockdownModeResponse, error) {
	data, err := service.call("ExitLockdownMode", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExitLockdownModeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AcquireCimServicesTicket(request *AcquireCimServicesTicketRequestType) (*AcquireCimServicesTicketResponse, error) {
	data, err := service.call("AcquireCimServicesTicket", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AcquireCimServicesTicketResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidIpmiLoginInfoFault
* - InvalidIpmiMacAddressFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateIpmi(request *UpdateIpmiRequestType) (*UpdateIpmiResponse, error) {
	data, err := service.call("UpdateIpmi", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateIpmiResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveHardwareUptime(request *RetrieveHardwareUptimeRequestType) (*RetrieveHardwareUptimeResponse, error) {
	data, err := service.call("RetrieveHardwareUptime", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveHardwareUptimeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TimedoutFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) HttpNfcLeaseGetManifest(request *HttpNfcLeaseGetManifestRequestType) (*HttpNfcLeaseGetManifestResponse, error) {
	data, err := service.call("HttpNfcLeaseGetManifest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HttpNfcLeaseGetManifestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TimedoutFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) HttpNfcLeaseComplete(request *HttpNfcLeaseCompleteRequestType) (*HttpNfcLeaseCompleteResponse, error) {
	data, err := service.call("HttpNfcLeaseComplete", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HttpNfcLeaseCompleteResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TimedoutFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) HttpNfcLeaseAbort(request *HttpNfcLeaseAbortRequestType) (*HttpNfcLeaseAbortResponse, error) {
	data, err := service.call("HttpNfcLeaseAbort", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HttpNfcLeaseAbortResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TimedoutFault
* - RuntimeFault
 */
func (service *VimPortType) HttpNfcLeaseProgress(request *HttpNfcLeaseProgressRequestType) (*HttpNfcLeaseProgressResponse, error) {
	data, err := service.call("HttpNfcLeaseProgress", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HttpNfcLeaseProgressResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryIpPools(request *QueryIpPoolsRequestType) (*QueryIpPoolsResponse, error) {
	data, err := service.call("QueryIpPools", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryIpPoolsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreateIpPool(request *CreateIpPoolRequestType) (*CreateIpPoolResponse, error) {
	data, err := service.call("CreateIpPool", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateIpPoolResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateIpPool(request *UpdateIpPoolRequestType) (*UpdateIpPoolResponse, error) {
	data, err := service.call("UpdateIpPool", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateIpPoolResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) DestroyIpPool(request *DestroyIpPoolRequestType) (*DestroyIpPoolResponse, error) {
	data, err := service.call("DestroyIpPool", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyIpPoolResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AllocateIpv4Address(request *AllocateIpv4AddressRequestType) (*AllocateIpv4AddressResponse, error) {
	data, err := service.call("AllocateIpv4Address", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AllocateIpv4AddressResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AllocateIpv6Address(request *AllocateIpv6AddressRequestType) (*AllocateIpv6AddressResponse, error) {
	data, err := service.call("AllocateIpv6Address", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AllocateIpv6AddressResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReleaseIpAllocation(request *ReleaseIpAllocationRequestType) (*ReleaseIpAllocationResponse, error) {
	data, err := service.call("ReleaseIpAllocation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReleaseIpAllocationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryIPAllocations(request *QueryIPAllocationsRequestType) (*QueryIPAllocationsResponse, error) {
	data, err := service.call("QueryIPAllocations", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryIPAllocationsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - LicenseEntityNotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateAssignedLicense(request *UpdateAssignedLicenseRequestType) (*UpdateAssignedLicenseResponse, error) {
	data, err := service.call("UpdateAssignedLicense", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateAssignedLicenseResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - LicenseEntityNotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveAssignedLicense(request *RemoveAssignedLicenseRequestType) (*RemoveAssignedLicenseResponse, error) {
	data, err := service.call("RemoveAssignedLicense", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveAssignedLicenseResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryAssignedLicenses(request *QueryAssignedLicensesRequestType) (*QueryAssignedLicensesResponse, error) {
	data, err := service.call("QueryAssignedLicenses", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryAssignedLicensesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QuerySupportedFeatures(request *QuerySupportedFeaturesRequestType) (*QuerySupportedFeaturesResponse, error) {
	data, err := service.call("QuerySupportedFeatures", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QuerySupportedFeaturesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryLicenseSourceAvailability(request *QueryLicenseSourceAvailabilityRequestType) (*QueryLicenseSourceAvailabilityResponse, error) {
	data, err := service.call("QueryLicenseSourceAvailability", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryLicenseSourceAvailabilityResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryLicenseUsage(request *QueryLicenseUsageRequestType) (*QueryLicenseUsageResponse, error) {
	data, err := service.call("QueryLicenseUsage", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryLicenseUsageResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - LicenseServerUnavailableFault
* - RuntimeFault
 */
func (service *VimPortType) SetLicenseEdition(request *SetLicenseEditionRequestType) (*SetLicenseEditionResponse, error) {
	data, err := service.call("SetLicenseEdition", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetLicenseEditionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CheckLicenseFeature(request *CheckLicenseFeatureRequestType) (*CheckLicenseFeatureResponse, error) {
	data, err := service.call("CheckLicenseFeature", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckLicenseFeatureResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - LicenseServerUnavailableFault
* - RuntimeFault
 */
func (service *VimPortType) EnableFeature(request *EnableFeatureRequestType) (*EnableFeatureResponse, error) {
	data, err := service.call("EnableFeature", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnableFeatureResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - LicenseServerUnavailableFault
* - RuntimeFault
 */
func (service *VimPortType) DisableFeature(request *DisableFeatureRequestType) (*DisableFeatureResponse, error) {
	data, err := service.call("DisableFeature", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DisableFeatureResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CannotAccessLocalSourceFault
* - InvalidLicenseFault
* - LicenseServerUnavailableFault
* - RuntimeFault
 */
func (service *VimPortType) ConfigureLicenseSource(request *ConfigureLicenseSourceRequestType) (*ConfigureLicenseSourceResponse, error) {
	data, err := service.call("ConfigureLicenseSource", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ConfigureLicenseSourceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateLicense(request *UpdateLicenseRequestType) (*UpdateLicenseResponse, error) {
	data, err := service.call("UpdateLicense", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateLicenseResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AddLicense(request *AddLicenseRequestType) (*AddLicenseResponse, error) {
	data, err := service.call("AddLicense", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddLicenseResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RemoveLicense(request *RemoveLicenseRequestType) (*RemoveLicenseResponse, error) {
	data, err := service.call("RemoveLicense", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveLicenseResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DecodeLicense(request *DecodeLicenseRequestType) (*DecodeLicenseResponse, error) {
	data, err := service.call("DecodeLicense", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DecodeLicenseResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateLicenseLabel(request *UpdateLicenseLabelRequestType) (*UpdateLicenseLabelResponse, error) {
	data, err := service.call("UpdateLicenseLabel", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateLicenseLabelResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RemoveLicenseLabel(request *RemoveLicenseLabelRequestType) (*RemoveLicenseLabelResponse, error) {
	data, err := service.call("RemoveLicenseLabel", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveLicenseLabelResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) Reload(request *ReloadRequestType) (*ReloadResponse, error) {
	data, err := service.call("Reload", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReloadResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) Rename_Task(request *RenameRequestType) (*Rename_TaskResponse, error) {
	data, err := service.call("Rename_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &Rename_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - VimFaultFault
* - RuntimeFault
 */
func (service *VimPortType) Destroy_Task(request *DestroyRequestType) (*Destroy_TaskResponse, error) {
	data, err := service.call("Destroy_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &Destroy_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) DestroyNetwork(request *DestroyNetworkRequestType) (*DestroyNetworkResponse, error) {
	data, err := service.call("DestroyNetwork", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyNetworkResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - ConcurrentAccessFault
* - FileFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ValidateHost(request *ValidateHostRequestType) (*ValidateHostResponse, error) {
	data, err := service.call("ValidateHost", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ValidateHostResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmConfigFaultFault
* - ConcurrentAccessFault
* - FileFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ParseDescriptor(request *ParseDescriptorRequestType) (*ParseDescriptorResponse, error) {
	data, err := service.call("ParseDescriptor", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ParseDescriptorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmConfigFaultFault
* - ConcurrentAccessFault
* - FileFaultFault
* - InvalidStateFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) CreateImportSpec(request *CreateImportSpecRequestType) (*CreateImportSpecResponse, error) {
	data, err := service.call("CreateImportSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateImportSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmConfigFaultFault
* - ConcurrentAccessFault
* - FileFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CreateDescriptor(request *CreateDescriptorRequestType) (*CreateDescriptorResponse, error) {
	data, err := service.call("CreateDescriptor", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateDescriptorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryPerfProviderSummary(request *QueryPerfProviderSummaryRequestType) (*QueryPerfProviderSummaryResponse, error) {
	data, err := service.call("QueryPerfProviderSummary", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPerfProviderSummaryResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryAvailablePerfMetric(request *QueryAvailablePerfMetricRequestType) (*QueryAvailablePerfMetricResponse, error) {
	data, err := service.call("QueryAvailablePerfMetric", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryAvailablePerfMetricResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryPerfCounter(request *QueryPerfCounterRequestType) (*QueryPerfCounterResponse, error) {
	data, err := service.call("QueryPerfCounter", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPerfCounterResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryPerfCounterByLevel(request *QueryPerfCounterByLevelRequestType) (*QueryPerfCounterByLevelResponse, error) {
	data, err := service.call("QueryPerfCounterByLevel", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPerfCounterByLevelResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryPerf(request *QueryPerfRequestType) (*QueryPerfResponse, error) {
	data, err := service.call("QueryPerf", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPerfResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryPerfComposite(request *QueryPerfCompositeRequestType) (*QueryPerfCompositeResponse, error) {
	data, err := service.call("QueryPerfComposite", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPerfCompositeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreatePerfInterval(request *CreatePerfIntervalRequestType) (*CreatePerfIntervalResponse, error) {
	data, err := service.call("CreatePerfInterval", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreatePerfIntervalResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RemovePerfInterval(request *RemovePerfIntervalRequestType) (*RemovePerfIntervalResponse, error) {
	data, err := service.call("RemovePerfInterval", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemovePerfIntervalResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdatePerfInterval(request *UpdatePerfIntervalRequestType) (*UpdatePerfIntervalResponse, error) {
	data, err := service.call("UpdatePerfInterval", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdatePerfIntervalResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateCounterLevelMapping(request *UpdateCounterLevelMappingRequestType) (*UpdateCounterLevelMappingResponse, error) {
	data, err := service.call("UpdateCounterLevelMapping", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateCounterLevelMappingResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ResetCounterLevelMapping(request *ResetCounterLevelMappingRequestType) (*ResetCounterLevelMappingResponse, error) {
	data, err := service.call("ResetCounterLevelMapping", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetCounterLevelMappingResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) EstimateDatabaseSize(request *EstimateDatabaseSizeRequestType) (*EstimateDatabaseSizeResponse, error) {
	data, err := service.call("EstimateDatabaseSize", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EstimateDatabaseSizeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - DuplicateNameFault
* - InsufficientResourcesFaultFault
* - ConcurrentAccessFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateConfig(request *UpdateConfigRequestType) (*UpdateConfigResponse, error) {
	data, err := service.call("UpdateConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MoveIntoResourcePool(request *MoveIntoResourcePoolRequestType) (*MoveIntoResourcePoolResponse, error) {
	data, err := service.call("MoveIntoResourcePool", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveIntoResourcePoolResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateChildResourceConfiguration(request *UpdateChildResourceConfigurationRequestType) (*UpdateChildResourceConfigurationResponse, error) {
	data, err := service.call("UpdateChildResourceConfiguration", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateChildResourceConfigurationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - DuplicateNameFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateResourcePool(request *CreateResourcePoolRequestType) (*CreateResourcePoolResponse, error) {
	data, err := service.call("CreateResourcePool", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateResourcePoolResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DestroyChildren(request *DestroyChildrenRequestType) (*DestroyChildrenResponse, error) {
	data, err := service.call("DestroyChildren", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyChildrenResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - DuplicateNameFault
* - InsufficientResourcesFaultFault
* - InvalidStateFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateVApp(request *CreateVAppRequestType) (*CreateVAppResponse, error) {
	data, err := service.call("CreateVApp", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateVAppResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - VmConfigFaultFault
* - FileFaultFault
* - OutOfBoundsFault
* - InvalidNameFault
* - InvalidDatastoreFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateChildVM_Task(request *CreateChildVMRequestType) (*CreateChildVM_TaskResponse, error) {
	data, err := service.call("CreateChildVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateChildVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - OutOfBoundsFault
* - AlreadyExistsFault
* - InvalidDatastoreFault
* - NotFoundFault
* - InvalidNameFault
* - VmConfigFaultFault
* - InsufficientResourcesFaultFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RegisterChildVM_Task(request *RegisterChildVMRequestType) (*RegisterChildVM_TaskResponse, error) {
	data, err := service.call("RegisterChildVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RegisterChildVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - VmConfigFaultFault
* - FileFaultFault
* - OutOfBoundsFault
* - DuplicateNameFault
* - InvalidNameFault
* - InvalidDatastoreFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ImportVApp(request *ImportVAppRequestType) (*ImportVAppResponse, error) {
	data, err := service.call("ImportVApp", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ImportVAppResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryResourceConfigOption(request *QueryResourceConfigOptionRequestType) (*QueryResourceConfigOptionResponse, error) {
	data, err := service.call("QueryResourceConfigOption", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryResourceConfigOptionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshRuntime(request *RefreshRuntimeRequestType) (*RefreshRuntimeResponse, error) {
	data, err := service.call("RefreshRuntime", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshRuntimeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindByUuid(request *FindByUuidRequestType) (*FindByUuidResponse, error) {
	data, err := service.call("FindByUuid", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindByUuidResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) FindByDatastorePath(request *FindByDatastorePathRequestType) (*FindByDatastorePathResponse, error) {
	data, err := service.call("FindByDatastorePath", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindByDatastorePathResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindByDnsName(request *FindByDnsNameRequestType) (*FindByDnsNameResponse, error) {
	data, err := service.call("FindByDnsName", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindByDnsNameResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindByIp(request *FindByIpRequestType) (*FindByIpResponse, error) {
	data, err := service.call("FindByIp", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindByIpResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindByInventoryPath(request *FindByInventoryPathRequestType) (*FindByInventoryPathResponse, error) {
	data, err := service.call("FindByInventoryPath", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindByInventoryPathResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindChild(request *FindChildRequestType) (*FindChildResponse, error) {
	data, err := service.call("FindChild", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindChildResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindAllByUuid(request *FindAllByUuidRequestType) (*FindAllByUuidResponse, error) {
	data, err := service.call("FindAllByUuid", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindAllByUuidResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindAllByDnsName(request *FindAllByDnsNameRequestType) (*FindAllByDnsNameResponse, error) {
	data, err := service.call("FindAllByDnsName", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindAllByDnsNameResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindAllByIp(request *FindAllByIpRequestType) (*FindAllByIpResponse, error) {
	data, err := service.call("FindAllByIp", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindAllByIpResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CurrentTime(request *CurrentTimeRequestType) (*CurrentTimeResponse, error) {
	data, err := service.call("CurrentTime", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CurrentTimeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveServiceContent(request *RetrieveServiceContentRequestType) (*RetrieveServiceContentResponse, error) {
	data, err := service.call("RetrieveServiceContent", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveServiceContentResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ValidateMigration(request *ValidateMigrationRequestType) (*ValidateMigrationResponse, error) {
	data, err := service.call("ValidateMigration", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ValidateMigrationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryVMotionCompatibility(request *QueryVMotionCompatibilityRequestType) (*QueryVMotionCompatibilityResponse, error) {
	data, err := service.call("QueryVMotionCompatibility", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVMotionCompatibilityResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveProductComponents(request *RetrieveProductComponentsRequestType) (*RetrieveProductComponentsResponse, error) {
	data, err := service.call("RetrieveProductComponents", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveProductComponentsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryServiceList(request *QueryServiceListRequestType) (*QueryServiceListResponse, error) {
	data, err := service.call("QueryServiceList", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryServiceListResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateServiceMessage(request *UpdateServiceMessageRequestType) (*UpdateServiceMessageResponse, error) {
	data, err := service.call("UpdateServiceMessage", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateServiceMessageResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - InvalidLocaleFault
* - RuntimeFault
 */
func (service *VimPortType) LoginByToken(request *LoginByTokenRequestType) (*LoginByTokenResponse, error) {
	data, err := service.call("LoginByToken", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LoginByTokenResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - InvalidLocaleFault
* - RuntimeFault
 */
func (service *VimPortType) Login(request *LoginRequestType) (*LoginResponse, error) {
	data, err := service.call("Login", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LoginResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - SSPIChallengeFault
* - InvalidLoginFault
* - InvalidLocaleFault
* - RuntimeFault
 */
func (service *VimPortType) LoginBySSPI(request *LoginBySSPIRequestType) (*LoginBySSPIResponse, error) {
	data, err := service.call("LoginBySSPI", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LoginBySSPIResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) Logout(request *LogoutRequestType) (*LogoutResponse, error) {
	data, err := service.call("Logout", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LogoutResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - RuntimeFault
 */
func (service *VimPortType) AcquireLocalTicket(request *AcquireLocalTicketRequestType) (*AcquireLocalTicketResponse, error) {
	data, err := service.call("AcquireLocalTicket", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AcquireLocalTicketResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AcquireGenericServiceTicket(request *AcquireGenericServiceTicketRequestType) (*AcquireGenericServiceTicketResponse, error) {
	data, err := service.call("AcquireGenericServiceTicket", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AcquireGenericServiceTicketResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) TerminateSession(request *TerminateSessionRequestType) (*TerminateSessionResponse, error) {
	data, err := service.call("TerminateSession", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &TerminateSessionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLocaleFault
* - RuntimeFault
 */
func (service *VimPortType) SetLocale(request *SetLocaleRequestType) (*SetLocaleResponse, error) {
	data, err := service.call("SetLocale", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetLocaleResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - InvalidLocaleFault
* - NotFoundFault
* - NoClientCertificateFault
* - NoSubjectNameFault
* - RuntimeFault
 */
func (service *VimPortType) LoginExtensionBySubjectName(request *LoginExtensionBySubjectNameRequestType) (*LoginExtensionBySubjectNameResponse, error) {
	data, err := service.call("LoginExtensionBySubjectName", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LoginExtensionBySubjectNameResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - InvalidLocaleFault
* - NoClientCertificateFault
* - RuntimeFault
 */
func (service *VimPortType) LoginExtensionByCertificate(request *LoginExtensionByCertificateRequestType) (*LoginExtensionByCertificateResponse, error) {
	data, err := service.call("LoginExtensionByCertificate", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LoginExtensionByCertificateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - InvalidLocaleFault
* - RuntimeFault
 */
func (service *VimPortType) ImpersonateUser(request *ImpersonateUserRequestType) (*ImpersonateUserResponse, error) {
	data, err := service.call("ImpersonateUser", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ImpersonateUserResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) SessionIsActive(request *SessionIsActiveRequestType) (*SessionIsActiveResponse, error) {
	data, err := service.call("SessionIsActive", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SessionIsActiveResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AcquireCloneTicket(request *AcquireCloneTicketRequestType) (*AcquireCloneTicketResponse, error) {
	data, err := service.call("AcquireCloneTicket", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AcquireCloneTicketResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidLoginFault
* - RuntimeFault
 */
func (service *VimPortType) CloneSession(request *CloneSessionRequestType) (*CloneSessionResponse, error) {
	data, err := service.call("CloneSession", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CloneSessionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ExecuteSimpleCommand(request *ExecuteSimpleCommandRequestType) (*ExecuteSimpleCommandResponse, error) {
	data, err := service.call("ExecuteSimpleCommand", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExecuteSimpleCommandResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - IORMNotSupportedHostOnDatastoreFault
* - InaccessibleDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) ConfigureDatastoreIORM_Task(request *ConfigureDatastoreIORMRequestType) (*ConfigureDatastoreIORM_TaskResponse, error) {
	data, err := service.call("ConfigureDatastoreIORM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ConfigureDatastoreIORM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryIORMConfigOption(request *QueryIORMConfigOptionRequestType) (*QueryIORMConfigOptionResponse, error) {
	data, err := service.call("QueryIORMConfigOption", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryIORMConfigOptionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) QueryDatastorePerformanceSummary(request *QueryDatastorePerformanceSummaryRequestType) (*QueryDatastorePerformanceSummaryResponse, error) {
	data, err := service.call("QueryDatastorePerformanceSummary", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDatastorePerformanceSummaryResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ApplyStorageDrsRecommendationToPod_Task(request *ApplyStorageDrsRecommendationToPodRequestType) (*ApplyStorageDrsRecommendationToPod_TaskResponse, error) {
	data, err := service.call("ApplyStorageDrsRecommendationToPod_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ApplyStorageDrsRecommendationToPod_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ApplyStorageDrsRecommendation_Task(request *ApplyStorageDrsRecommendationRequestType) (*ApplyStorageDrsRecommendation_TaskResponse, error) {
	data, err := service.call("ApplyStorageDrsRecommendation_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ApplyStorageDrsRecommendation_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CancelStorageDrsRecommendation(request *CancelStorageDrsRecommendationRequestType) (*CancelStorageDrsRecommendationResponse, error) {
	data, err := service.call("CancelStorageDrsRecommendation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CancelStorageDrsRecommendationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshStorageDrsRecommendation(request *RefreshStorageDrsRecommendationRequestType) (*RefreshStorageDrsRecommendationResponse, error) {
	data, err := service.call("RefreshStorageDrsRecommendation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshStorageDrsRecommendationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ConfigureStorageDrsForPod_Task(request *ConfigureStorageDrsForPodRequestType) (*ConfigureStorageDrsForPod_TaskResponse, error) {
	data, err := service.call("ConfigureStorageDrsForPod_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ConfigureStorageDrsForPod_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RecommendDatastores(request *RecommendDatastoresRequestType) (*RecommendDatastoresResponse, error) {
	data, err := service.call("RecommendDatastores", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RecommendDatastoresResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CancelTask(request *CancelTaskRequestType) (*CancelTaskResponse, error) {
	data, err := service.call("CancelTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CancelTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - OutOfBoundsFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateProgress(request *UpdateProgressRequestType) (*UpdateProgressResponse, error) {
	data, err := service.call("UpdateProgress", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateProgressResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) SetTaskState(request *SetTaskStateRequestType) (*SetTaskStateResponse, error) {
	data, err := service.call("SetTaskState", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetTaskStateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) SetTaskDescription(request *SetTaskDescriptionRequestType) (*SetTaskDescriptionResponse, error) {
	data, err := service.call("SetTaskDescription", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetTaskDescriptionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReadNextTasks(request *ReadNextTasksRequestType) (*ReadNextTasksResponse, error) {
	data, err := service.call("ReadNextTasks", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReadNextTasksResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReadPreviousTasks(request *ReadPreviousTasksRequestType) (*ReadPreviousTasksResponse, error) {
	data, err := service.call("ReadPreviousTasks", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReadPreviousTasksResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CreateCollectorForTasks(request *CreateCollectorForTasksRequestType) (*CreateCollectorForTasksResponse, error) {
	data, err := service.call("CreateCollectorForTasks", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateCollectorForTasksResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreateTask(request *CreateTaskRequestType) (*CreateTaskResponse, error) {
	data, err := service.call("CreateTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) RetrieveUserGroups(request *RetrieveUserGroupsRequestType) (*RetrieveUserGroupsResponse, error) {
	data, err := service.call("RetrieveUserGroups", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveUserGroupsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmConfigFaultFault
* - ConcurrentAccessFault
* - FileFaultFault
* - InvalidNameFault
* - DuplicateNameFault
* - InvalidStateFault
* - InsufficientResourcesFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateVAppConfig(request *UpdateVAppConfigRequestType) (*UpdateVAppConfigResponse, error) {
	data, err := service.call("UpdateVAppConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateVAppConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ConcurrentAccessFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateLinkedChildren(request *UpdateLinkedChildrenRequestType) (*UpdateLinkedChildrenResponse, error) {
	data, err := service.call("UpdateLinkedChildren", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateLinkedChildrenResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidDatastoreFault
* - TaskInProgressFault
* - VmConfigFaultFault
* - FileFaultFault
* - MigrationFaultFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CloneVApp_Task(request *CloneVAppRequestType) (*CloneVApp_TaskResponse, error) {
	data, err := service.call("CloneVApp_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CloneVApp_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidPowerStateFault
* - TaskInProgressFault
* - InvalidStateFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ExportVApp(request *ExportVAppRequestType) (*ExportVAppResponse, error) {
	data, err := service.call("ExportVApp", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExportVAppResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - InsufficientResourcesFaultFault
* - VmConfigFaultFault
* - VAppConfigFaultFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) PowerOnVApp_Task(request *PowerOnVAppRequestType) (*PowerOnVApp_TaskResponse, error) {
	data, err := service.call("PowerOnVApp_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PowerOnVApp_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - VAppConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) PowerOffVApp_Task(request *PowerOffVAppRequestType) (*PowerOffVApp_TaskResponse, error) {
	data, err := service.call("PowerOffVApp_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PowerOffVApp_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - VAppConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) SuspendVApp_Task(request *SuspendVAppRequestType) (*SuspendVApp_TaskResponse, error) {
	data, err := service.call("SuspendVApp_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SuspendVApp_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ConcurrentAccessFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) UnregisterVApp_Task(request *unregisterVAppRequestType) (*unregisterVApp_TaskResponse, error) {
	data, err := service.call("unregisterVApp_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &unregisterVApp_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) CreateVirtualDisk_Task(request *CreateVirtualDiskRequestType) (*CreateVirtualDisk_TaskResponse, error) {
	data, err := service.call("CreateVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteVirtualDisk_Task(request *DeleteVirtualDiskRequestType) (*DeleteVirtualDisk_TaskResponse, error) {
	data, err := service.call("DeleteVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) MoveVirtualDisk_Task(request *MoveVirtualDiskRequestType) (*MoveVirtualDisk_TaskResponse, error) {
	data, err := service.call("MoveVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDiskFormatFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) CopyVirtualDisk_Task(request *CopyVirtualDiskRequestType) (*CopyVirtualDisk_TaskResponse, error) {
	data, err := service.call("CopyVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CopyVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) ExtendVirtualDisk_Task(request *ExtendVirtualDiskRequestType) (*ExtendVirtualDisk_TaskResponse, error) {
	data, err := service.call("ExtendVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExtendVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) QueryVirtualDiskFragmentation(request *QueryVirtualDiskFragmentationRequestType) (*QueryVirtualDiskFragmentationResponse, error) {
	data, err := service.call("QueryVirtualDiskFragmentation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVirtualDiskFragmentationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) DefragmentVirtualDisk_Task(request *DefragmentVirtualDiskRequestType) (*DefragmentVirtualDisk_TaskResponse, error) {
	data, err := service.call("DefragmentVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DefragmentVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) ShrinkVirtualDisk_Task(request *ShrinkVirtualDiskRequestType) (*ShrinkVirtualDisk_TaskResponse, error) {
	data, err := service.call("ShrinkVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ShrinkVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) InflateVirtualDisk_Task(request *InflateVirtualDiskRequestType) (*InflateVirtualDisk_TaskResponse, error) {
	data, err := service.call("InflateVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &InflateVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) EagerZeroVirtualDisk_Task(request *EagerZeroVirtualDiskRequestType) (*EagerZeroVirtualDisk_TaskResponse, error) {
	data, err := service.call("EagerZeroVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EagerZeroVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) ZeroFillVirtualDisk_Task(request *ZeroFillVirtualDiskRequestType) (*ZeroFillVirtualDisk_TaskResponse, error) {
	data, err := service.call("ZeroFillVirtualDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ZeroFillVirtualDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) SetVirtualDiskUuid(request *SetVirtualDiskUuidRequestType) (*SetVirtualDiskUuidResponse, error) {
	data, err := service.call("SetVirtualDiskUuid", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetVirtualDiskUuidResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) QueryVirtualDiskUuid(request *QueryVirtualDiskUuidRequestType) (*QueryVirtualDiskUuidResponse, error) {
	data, err := service.call("QueryVirtualDiskUuid", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVirtualDiskUuidResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) QueryVirtualDiskGeometry(request *QueryVirtualDiskGeometryRequestType) (*QueryVirtualDiskGeometryResponse, error) {
	data, err := service.call("QueryVirtualDiskGeometry", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVirtualDiskGeometryResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshStorageInfo(request *RefreshStorageInfoRequestType) (*RefreshStorageInfoResponse, error) {
	data, err := service.call("RefreshStorageInfo", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshStorageInfoResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - SnapshotFaultFault
* - VmConfigFaultFault
* - FileFaultFault
* - InvalidNameFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CreateSnapshot_Task(request *CreateSnapshotRequestType) (*CreateSnapshot_TaskResponse, error) {
	data, err := service.call("CreateSnapshot_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateSnapshot_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - SnapshotFaultFault
* - InsufficientResourcesFaultFault
* - InvalidStateFault
* - VmConfigFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) RevertToCurrentSnapshot_Task(request *RevertToCurrentSnapshotRequestType) (*RevertToCurrentSnapshot_TaskResponse, error) {
	data, err := service.call("RevertToCurrentSnapshot_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RevertToCurrentSnapshot_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - SnapshotFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveAllSnapshots_Task(request *RemoveAllSnapshotsRequestType) (*RemoveAllSnapshots_TaskResponse, error) {
	data, err := service.call("RemoveAllSnapshots_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveAllSnapshots_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - FileFaultFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ConsolidateVMDisks_Task(request *ConsolidateVMDisksRequestType) (*ConsolidateVMDisks_TaskResponse, error) {
	data, err := service.call("ConsolidateVMDisks_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ConsolidateVMDisks_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - FileFaultFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) EstimateStorageForConsolidateSnapshots_Task(request *EstimateStorageForConsolidateSnapshotsRequestType) (*EstimateStorageForConsolidateSnapshots_TaskResponse, error) {
	data, err := service.call("EstimateStorageForConsolidateSnapshots_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EstimateStorageForConsolidateSnapshots_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmConfigFaultFault
* - ConcurrentAccessFault
* - FileFaultFault
* - InvalidNameFault
* - DuplicateNameFault
* - InvalidStateFault
* - InsufficientResourcesFaultFault
* - InvalidDatastoreFault
* - RuntimeFault
 */
func (service *VimPortType) ReconfigVM_Task(request *ReconfigVMRequestType) (*ReconfigVM_TaskResponse, error) {
	data, err := service.call("ReconfigVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - TaskInProgressFault
* - AlreadyUpgradedFault
* - NoDiskFoundFault
* - RuntimeFault
 */
func (service *VimPortType) UpgradeVM_Task(request *UpgradeVMRequestType) (*UpgradeVM_TaskResponse, error) {
	data, err := service.call("UpgradeVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpgradeVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ExtractOvfEnvironment(request *ExtractOvfEnvironmentRequestType) (*ExtractOvfEnvironmentResponse, error) {
	data, err := service.call("ExtractOvfEnvironment", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExtractOvfEnvironmentResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - InsufficientResourcesFaultFault
* - VmConfigFaultFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) PowerOnVM_Task(request *PowerOnVMRequestType) (*PowerOnVM_TaskResponse, error) {
	data, err := service.call("PowerOnVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PowerOnVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) PowerOffVM_Task(request *PowerOffVMRequestType) (*PowerOffVM_TaskResponse, error) {
	data, err := service.call("PowerOffVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PowerOffVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) SuspendVM_Task(request *SuspendVMRequestType) (*SuspendVM_TaskResponse, error) {
	data, err := service.call("SuspendVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SuspendVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ResetVM_Task(request *ResetVMRequestType) (*ResetVM_TaskResponse, error) {
	data, err := service.call("ResetVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ToolsUnavailableFault
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ShutdownGuest(request *ShutdownGuestRequestType) (*ShutdownGuestResponse, error) {
	data, err := service.call("ShutdownGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ShutdownGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ToolsUnavailableFault
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) RebootGuest(request *RebootGuestRequestType) (*RebootGuestResponse, error) {
	data, err := service.call("RebootGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RebootGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ToolsUnavailableFault
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) StandbyGuest(request *StandbyGuestRequestType) (*StandbyGuestResponse, error) {
	data, err := service.call("StandbyGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StandbyGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ConcurrentAccessFault
* - RuntimeFault
 */
func (service *VimPortType) AnswerVM(request *AnswerVMRequestType) (*AnswerVMResponse, error) {
	data, err := service.call("AnswerVM", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AnswerVMResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CustomizationFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CustomizeVM_Task(request *CustomizeVMRequestType) (*CustomizeVM_TaskResponse, error) {
	data, err := service.call("CustomizeVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CustomizeVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CustomizationFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CheckCustomizationSpec(request *CheckCustomizationSpecRequestType) (*CheckCustomizationSpecResponse, error) {
	data, err := service.call("CheckCustomizationSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckCustomizationSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - MigrationFaultFault
* - FileFaultFault
* - TimedoutFault
* - InsufficientResourcesFaultFault
* - InvalidStateFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MigrateVM_Task(request *MigrateVMRequestType) (*MigrateVM_TaskResponse, error) {
	data, err := service.call("MigrateVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MigrateVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidDatastoreFault
* - MigrationFaultFault
* - VmConfigFaultFault
* - FileFaultFault
* - TimedoutFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RelocateVM_Task(request *RelocateVMRequestType) (*RelocateVM_TaskResponse, error) {
	data, err := service.call("RelocateVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RelocateVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - CustomizationFaultFault
* - InvalidStateFault
* - InvalidDatastoreFault
* - TaskInProgressFault
* - VmConfigFaultFault
* - FileFaultFault
* - MigrationFaultFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CloneVM_Task(request *CloneVMRequestType) (*CloneVM_TaskResponse, error) {
	data, err := service.call("CloneVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CloneVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidPowerStateFault
* - TaskInProgressFault
* - InvalidStateFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ExportVm(request *ExportVmRequestType) (*ExportVmResponse, error) {
	data, err := service.call("ExportVm", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExportVmResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - VmConfigFaultFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MarkAsTemplate(request *MarkAsTemplateRequestType) (*MarkAsTemplateResponse, error) {
	data, err := service.call("MarkAsTemplate", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MarkAsTemplateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidDatastoreFault
* - VmConfigFaultFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MarkAsVirtualMachine(request *MarkAsVirtualMachineRequestType) (*MarkAsVirtualMachineResponse, error) {
	data, err := service.call("MarkAsVirtualMachine", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MarkAsVirtualMachineResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidPowerStateFault
* - RuntimeFault
 */
func (service *VimPortType) UnregisterVM(request *UnregisterVMRequestType) (*UnregisterVMResponse, error) {
	data, err := service.call("UnregisterVM", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnregisterVMResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ResetGuestInformation(request *ResetGuestInformationRequestType) (*ResetGuestInformationResponse, error) {
	data, err := service.call("ResetGuestInformation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetGuestInformationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - VmConfigFaultFault
* - VmToolsUpgradeFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MountToolsInstaller(request *MountToolsInstallerRequestType) (*MountToolsInstallerResponse, error) {
	data, err := service.call("MountToolsInstaller", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MountToolsInstallerResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UnmountToolsInstaller(request *UnmountToolsInstallerRequestType) (*UnmountToolsInstallerResponse, error) {
	data, err := service.call("UnmountToolsInstaller", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnmountToolsInstallerResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - TaskInProgressFault
* - VmToolsUpgradeFaultFault
* - ToolsUnavailableFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpgradeTools_Task(request *UpgradeToolsRequestType) (*UpgradeTools_TaskResponse, error) {
	data, err := service.call("UpgradeTools_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpgradeTools_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AcquireMksTicket(request *AcquireMksTicketRequestType) (*AcquireMksTicketResponse, error) {
	data, err := service.call("AcquireMksTicket", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AcquireMksTicketResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) AcquireTicket(request *AcquireTicketRequestType) (*AcquireTicketResponse, error) {
	data, err := service.call("AcquireTicket", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AcquireTicketResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - ToolsUnavailableFault
* - RuntimeFault
 */
func (service *VimPortType) SetScreenResolution(request *SetScreenResolutionRequestType) (*SetScreenResolutionResponse, error) {
	data, err := service.call("SetScreenResolution", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetScreenResolutionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidPowerStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DefragmentAllDisks(request *DefragmentAllDisksRequestType) (*DefragmentAllDisksResponse, error) {
	data, err := service.call("DefragmentAllDisks", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DefragmentAllDisksResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - InsufficientResourcesFaultFault
* - VmFaultToleranceIssueFault
* - FileFaultFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateSecondaryVM_Task(request *CreateSecondaryVMRequestType) (*CreateSecondaryVM_TaskResponse, error) {
	data, err := service.call("CreateSecondaryVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateSecondaryVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmFaultToleranceIssueFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) TurnOffFaultToleranceForVM_Task(request *TurnOffFaultToleranceForVMRequestType) (*TurnOffFaultToleranceForVM_TaskResponse, error) {
	data, err := service.call("TurnOffFaultToleranceForVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &TurnOffFaultToleranceForVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmFaultToleranceIssueFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) MakePrimaryVM_Task(request *MakePrimaryVMRequestType) (*MakePrimaryVM_TaskResponse, error) {
	data, err := service.call("MakePrimaryVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MakePrimaryVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmFaultToleranceIssueFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) TerminateFaultTolerantVM_Task(request *TerminateFaultTolerantVMRequestType) (*TerminateFaultTolerantVM_TaskResponse, error) {
	data, err := service.call("TerminateFaultTolerantVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &TerminateFaultTolerantVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmFaultToleranceIssueFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) DisableSecondaryVM_Task(request *DisableSecondaryVMRequestType) (*DisableSecondaryVM_TaskResponse, error) {
	data, err := service.call("DisableSecondaryVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DisableSecondaryVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - VmFaultToleranceIssueFault
* - InvalidStateFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) EnableSecondaryVM_Task(request *EnableSecondaryVMRequestType) (*EnableSecondaryVM_TaskResponse, error) {
	data, err := service.call("EnableSecondaryVM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnableSecondaryVM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - ToolsUnavailableFault
* - RuntimeFault
 */
func (service *VimPortType) SetDisplayTopology(request *SetDisplayTopologyRequestType) (*SetDisplayTopologyResponse, error) {
	data, err := service.call("SetDisplayTopology", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetDisplayTopologyResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidPowerStateFault
* - TaskInProgressFault
* - FileFaultFault
* - SnapshotFaultFault
* - VmConfigFaultFault
* - RecordReplayDisabledFault
* - HostIncompatibleForRecordReplayFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) StartRecording_Task(request *StartRecordingRequestType) (*StartRecording_TaskResponse, error) {
	data, err := service.call("StartRecording_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StartRecording_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidPowerStateFault
* - TaskInProgressFault
* - FileFaultFault
* - SnapshotFaultFault
* - RuntimeFault
 */
func (service *VimPortType) StopRecording_Task(request *StopRecordingRequestType) (*StopRecording_TaskResponse, error) {
	data, err := service.call("StopRecording_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StopRecording_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidPowerStateFault
* - TaskInProgressFault
* - FileFaultFault
* - SnapshotFaultFault
* - NotFoundFault
* - VmConfigFaultFault
* - RecordReplayDisabledFault
* - HostIncompatibleForRecordReplayFault
* - RuntimeFault
 */
func (service *VimPortType) StartReplaying_Task(request *StartReplayingRequestType) (*StartReplaying_TaskResponse, error) {
	data, err := service.call("StartReplaying_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StartReplaying_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidPowerStateFault
* - TaskInProgressFault
* - FileFaultFault
* - SnapshotFaultFault
* - RuntimeFault
 */
func (service *VimPortType) StopReplaying_Task(request *StopReplayingRequestType) (*StopReplaying_TaskResponse, error) {
	data, err := service.call("StopReplaying_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StopReplaying_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidPowerStateFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) PromoteDisks_Task(request *PromoteDisksRequestType) (*PromoteDisks_TaskResponse, error) {
	data, err := service.call("PromoteDisks_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PromoteDisks_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - FileFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CreateScreenshot_Task(request *CreateScreenshotRequestType) (*CreateScreenshot_TaskResponse, error) {
	data, err := service.call("CreateScreenshot_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateScreenshot_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) QueryChangedDiskAreas(request *QueryChangedDiskAreasRequestType) (*QueryChangedDiskAreasResponse, error) {
	data, err := service.call("QueryChangedDiskAreas", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryChangedDiskAreasResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryUnownedFiles(request *QueryUnownedFilesRequestType) (*QueryUnownedFilesResponse, error) {
	data, err := service.call("QueryUnownedFiles", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryUnownedFilesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidPowerStateFault
* - TaskInProgressFault
* - FileFaultFault
* - InvalidStateFault
* - VmConfigFaultFault
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) ReloadVirtualMachineFromPath_Task(request *reloadVirtualMachineFromPathRequestType) (*reloadVirtualMachineFromPath_TaskResponse, error) {
	data, err := service.call("reloadVirtualMachineFromPath_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &reloadVirtualMachineFromPath_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryFaultToleranceCompatibility(request *QueryFaultToleranceCompatibilityRequestType) (*QueryFaultToleranceCompatibilityResponse, error) {
	data, err := service.call("QueryFaultToleranceCompatibility", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryFaultToleranceCompatibilityResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) TerminateVM(request *TerminateVMRequestType) (*TerminateVMResponse, error) {
	data, err := service.call("TerminateVM", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &TerminateVMResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RemoveAlarm(request *RemoveAlarmRequestType) (*RemoveAlarmResponse, error) {
	data, err := service.call("RemoveAlarm", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveAlarmResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureAlarm(request *ReconfigureAlarmRequestType) (*ReconfigureAlarmResponse, error) {
	data, err := service.call("ReconfigureAlarm", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureAlarmResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateAlarm(request *CreateAlarmRequestType) (*CreateAlarmResponse, error) {
	data, err := service.call("CreateAlarm", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateAlarmResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) GetAlarm(request *GetAlarmRequestType) (*GetAlarmResponse, error) {
	data, err := service.call("GetAlarm", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &GetAlarmResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AreAlarmActionsEnabled(request *AreAlarmActionsEnabledRequestType) (*AreAlarmActionsEnabledResponse, error) {
	data, err := service.call("AreAlarmActionsEnabled", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AreAlarmActionsEnabledResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) EnableAlarmActions(request *EnableAlarmActionsRequestType) (*EnableAlarmActionsResponse, error) {
	data, err := service.call("EnableAlarmActions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnableAlarmActionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) GetAlarmState(request *GetAlarmStateRequestType) (*GetAlarmStateResponse, error) {
	data, err := service.call("GetAlarmState", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &GetAlarmStateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AcknowledgeAlarm(request *AcknowledgeAlarmRequestType) (*AcknowledgeAlarmResponse, error) {
	data, err := service.call("AcknowledgeAlarm", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AcknowledgeAlarmResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - ConcurrentAccessFault
* - DuplicateNameFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureDVPortgroup_Task(request *ReconfigureDVPortgroupRequestType) (*ReconfigureDVPortgroup_TaskResponse, error) {
	data, err := service.call("ReconfigureDVPortgroup_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureDVPortgroup_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - RollbackFailureFault
* - RuntimeFault
 */
func (service *VimPortType) DVPortgroupRollback_Task(request *DVPortgroupRollbackRequestType) (*DVPortgroupRollback_TaskResponse, error) {
	data, err := service.call("DVPortgroupRollback_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DVPortgroupRollback_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryAvailableDvsSpec(request *QueryAvailableDvsSpecRequestType) (*QueryAvailableDvsSpecResponse, error) {
	data, err := service.call("QueryAvailableDvsSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryAvailableDvsSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryCompatibleHostForNewDvs(request *QueryCompatibleHostForNewDvsRequestType) (*QueryCompatibleHostForNewDvsResponse, error) {
	data, err := service.call("QueryCompatibleHostForNewDvs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryCompatibleHostForNewDvsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryCompatibleHostForExistingDvs(request *QueryCompatibleHostForExistingDvsRequestType) (*QueryCompatibleHostForExistingDvsResponse, error) {
	data, err := service.call("QueryCompatibleHostForExistingDvs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryCompatibleHostForExistingDvsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryDvsCompatibleHostSpec(request *QueryDvsCompatibleHostSpecRequestType) (*QueryDvsCompatibleHostSpecResponse, error) {
	data, err := service.call("QueryDvsCompatibleHostSpec", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDvsCompatibleHostSpecResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryDvsFeatureCapability(request *QueryDvsFeatureCapabilityRequestType) (*QueryDvsFeatureCapabilityResponse, error) {
	data, err := service.call("QueryDvsFeatureCapability", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDvsFeatureCapabilityResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) QueryDvsByUuid(request *QueryDvsByUuidRequestType) (*QueryDvsByUuidResponse, error) {
	data, err := service.call("QueryDvsByUuid", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDvsByUuidResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryDvsConfigTarget(request *QueryDvsConfigTargetRequestType) (*QueryDvsConfigTargetResponse, error) {
	data, err := service.call("QueryDvsConfigTarget", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDvsConfigTargetResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryDvsCheckCompatibility(request *QueryDvsCheckCompatibilityRequestType) (*QueryDvsCheckCompatibilityResponse, error) {
	data, err := service.call("QueryDvsCheckCompatibility", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDvsCheckCompatibilityResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RectifyDvsOnHost_Task(request *RectifyDvsOnHostRequestType) (*RectifyDvsOnHost_TaskResponse, error) {
	data, err := service.call("RectifyDvsOnHost_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RectifyDvsOnHost_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - BackupBlobWriteFailureFault
* - RuntimeFault
 */
func (service *VimPortType) DVSManagerExportEntity_Task(request *DVSManagerExportEntityRequestType) (*DVSManagerExportEntity_TaskResponse, error) {
	data, err := service.call("DVSManagerExportEntity_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DVSManagerExportEntity_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) DVSManagerImportEntity_Task(request *DVSManagerImportEntityRequestType) (*DVSManagerImportEntity_TaskResponse, error) {
	data, err := service.call("DVSManagerImportEntity_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DVSManagerImportEntity_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) DVSManagerLookupDvPortGroup(request *DVSManagerLookupDvPortGroupRequestType) (*DVSManagerLookupDvPortGroupResponse, error) {
	data, err := service.call("DVSManagerLookupDvPortGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DVSManagerLookupDvPortGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DvsFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateDVSLacpGroupConfig_Task(request *UpdateDVSLacpGroupConfigRequestType) (*UpdateDVSLacpGroupConfig_TaskResponse, error) {
	data, err := service.call("UpdateDVSLacpGroupConfig_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateDVSLacpGroupConfig_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReadNextEvents(request *ReadNextEventsRequestType) (*ReadNextEventsResponse, error) {
	data, err := service.call("ReadNextEvents", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReadNextEventsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReadPreviousEvents(request *ReadPreviousEventsRequestType) (*ReadPreviousEventsResponse, error) {
	data, err := service.call("ReadPreviousEvents", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReadPreviousEventsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveArgumentDescription(request *RetrieveArgumentDescriptionRequestType) (*RetrieveArgumentDescriptionResponse, error) {
	data, err := service.call("RetrieveArgumentDescription", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveArgumentDescriptionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CreateCollectorForEvents(request *CreateCollectorForEventsRequestType) (*CreateCollectorForEventsResponse, error) {
	data, err := service.call("CreateCollectorForEvents", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateCollectorForEventsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) LogUserEvent(request *LogUserEventRequestType) (*LogUserEventResponse, error) {
	data, err := service.call("LogUserEvent", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LogUserEventResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryEvents(request *QueryEventsRequestType) (*QueryEventsResponse, error) {
	data, err := service.call("QueryEvents", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryEventsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidEventFault
* - RuntimeFault
 */
func (service *VimPortType) PostEvent(request *PostEventRequestType) (*PostEventResponse, error) {
	data, err := service.call("PostEvent", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &PostEventResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - HostConfigFaultFault
* - InvalidLoginFault
* - ActiveDirectoryFaultFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) JoinDomain_Task(request *JoinDomainRequestType) (*JoinDomain_TaskResponse, error) {
	data, err := service.call("JoinDomain_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &JoinDomain_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - HostConfigFaultFault
* - ActiveDirectoryFaultFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) JoinDomainWithCAM_Task(request *JoinDomainWithCAMRequestType) (*JoinDomainWithCAM_TaskResponse, error) {
	data, err := service.call("JoinDomainWithCAM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &JoinDomainWithCAM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FileNotFoundFault
* - ActiveDirectoryFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ImportCertificateForCAM_Task(request *ImportCertificateForCAMRequestType) (*ImportCertificateForCAM_TaskResponse, error) {
	data, err := service.call("ImportCertificateForCAM_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ImportCertificateForCAM_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - AuthMinimumAdminPermissionFault
* - ActiveDirectoryFaultFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) LeaveCurrentDomain_Task(request *LeaveCurrentDomainRequestType) (*LeaveCurrentDomain_TaskResponse, error) {
	data, err := service.call("LeaveCurrentDomain_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &LeaveCurrentDomain_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureAutostart(request *ReconfigureAutostartRequestType) (*ReconfigureAutostartResponse, error) {
	data, err := service.call("ReconfigureAutostart", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureAutostartResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AutoStartPowerOn(request *AutoStartPowerOnRequestType) (*AutoStartPowerOnResponse, error) {
	data, err := service.call("AutoStartPowerOn", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AutoStartPowerOnResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AutoStartPowerOff(request *AutoStartPowerOffRequestType) (*AutoStartPowerOffResponse, error) {
	data, err := service.call("AutoStartPowerOff", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AutoStartPowerOffResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryBootDevices(request *QueryBootDevicesRequestType) (*QueryBootDevicesResponse, error) {
	data, err := service.call("QueryBootDevices", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryBootDevicesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateBootDevice(request *UpdateBootDeviceRequestType) (*UpdateBootDeviceResponse, error) {
	data, err := service.call("UpdateBootDevice", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateBootDeviceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ConfigureHostCache_Task(request *ConfigureHostCacheRequestType) (*ConfigureHostCache_TaskResponse, error) {
	data, err := service.call("ConfigureHostCache_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ConfigureHostCache_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) EnableHyperThreading(request *EnableHyperThreadingRequestType) (*EnableHyperThreadingResponse, error) {
	data, err := service.call("EnableHyperThreading", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnableHyperThreadingResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DisableHyperThreading(request *DisableHyperThreadingRequestType) (*DisableHyperThreadingResponse, error) {
	data, err := service.call("DisableHyperThreading", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DisableHyperThreadingResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) SearchDatastore_Task(request *SearchDatastoreRequestType) (*SearchDatastore_TaskResponse, error) {
	data, err := service.call("SearchDatastore_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SearchDatastore_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) SearchDatastoreSubFolders_Task(request *SearchDatastoreSubFoldersRequestType) (*SearchDatastoreSubFolders_TaskResponse, error) {
	data, err := service.call("SearchDatastoreSubFolders_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SearchDatastoreSubFolders_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidDatastoreFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteFile(request *DeleteFileRequestType) (*DeleteFileResponse, error) {
	data, err := service.call("DeleteFile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteFileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InaccessibleDatastoreFault
* - DatastoreNotWritableOnHostFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateLocalSwapDatastore(request *UpdateLocalSwapDatastoreRequestType) (*UpdateLocalSwapDatastoreResponse, error) {
	data, err := service.call("UpdateLocalSwapDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateLocalSwapDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryAvailableDisksForVmfs(request *QueryAvailableDisksForVmfsRequestType) (*QueryAvailableDisksForVmfsResponse, error) {
	data, err := service.call("QueryAvailableDisksForVmfs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryAvailableDisksForVmfsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryVmfsDatastoreCreateOptions(request *QueryVmfsDatastoreCreateOptionsRequestType) (*QueryVmfsDatastoreCreateOptionsResponse, error) {
	data, err := service.call("QueryVmfsDatastoreCreateOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVmfsDatastoreCreateOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateVmfsDatastore(request *CreateVmfsDatastoreRequestType) (*CreateVmfsDatastoreResponse, error) {
	data, err := service.call("CreateVmfsDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateVmfsDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryVmfsDatastoreExtendOptions(request *QueryVmfsDatastoreExtendOptionsRequestType) (*QueryVmfsDatastoreExtendOptionsResponse, error) {
	data, err := service.call("QueryVmfsDatastoreExtendOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVmfsDatastoreExtendOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryVmfsDatastoreExpandOptions(request *QueryVmfsDatastoreExpandOptionsRequestType) (*QueryVmfsDatastoreExpandOptionsResponse, error) {
	data, err := service.call("QueryVmfsDatastoreExpandOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVmfsDatastoreExpandOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ExtendVmfsDatastore(request *ExtendVmfsDatastoreRequestType) (*ExtendVmfsDatastoreResponse, error) {
	data, err := service.call("ExtendVmfsDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExtendVmfsDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ExpandVmfsDatastore(request *ExpandVmfsDatastoreRequestType) (*ExpandVmfsDatastoreResponse, error) {
	data, err := service.call("ExpandVmfsDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExpandVmfsDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - AlreadyExistsFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateNasDatastore(request *CreateNasDatastoreRequestType) (*CreateNasDatastoreResponse, error) {
	data, err := service.call("CreateNasDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateNasDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - HostConfigFaultFault
* - FileNotFoundFault
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateLocalDatastore(request *CreateLocalDatastoreRequestType) (*CreateLocalDatastoreResponse, error) {
	data, err := service.call("CreateLocalDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateLocalDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveDatastore(request *RemoveDatastoreRequestType) (*RemoveDatastoreResponse, error) {
	data, err := service.call("RemoveDatastore", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveDatastoreResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ConfigureDatastorePrincipal(request *ConfigureDatastorePrincipalRequestType) (*ConfigureDatastorePrincipalResponse, error) {
	data, err := service.call("ConfigureDatastorePrincipal", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ConfigureDatastorePrincipalResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryUnresolvedVmfsVolumes(request *QueryUnresolvedVmfsVolumesRequestType) (*QueryUnresolvedVmfsVolumesResponse, error) {
	data, err := service.call("QueryUnresolvedVmfsVolumes", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryUnresolvedVmfsVolumesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - VmfsAmbiguousMountFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ResignatureUnresolvedVmfsVolume_Task(request *ResignatureUnresolvedVmfsVolumeRequestType) (*ResignatureUnresolvedVmfsVolume_TaskResponse, error) {
	data, err := service.call("ResignatureUnresolvedVmfsVolume_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResignatureUnresolvedVmfsVolume_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateDateTimeConfig(request *UpdateDateTimeConfigRequestType) (*UpdateDateTimeConfigResponse, error) {
	data, err := service.call("UpdateDateTimeConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateDateTimeConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryAvailableTimeZones(request *QueryAvailableTimeZonesRequestType) (*QueryAvailableTimeZonesResponse, error) {
	data, err := service.call("QueryAvailableTimeZones", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryAvailableTimeZonesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryDateTime(request *QueryDateTimeRequestType) (*QueryDateTimeResponse, error) {
	data, err := service.call("QueryDateTime", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDateTimeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateDateTime(request *UpdateDateTimeRequestType) (*UpdateDateTimeResponse, error) {
	data, err := service.call("UpdateDateTime", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateDateTimeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshDateTimeSystem(request *RefreshDateTimeSystemRequestType) (*RefreshDateTimeSystemResponse, error) {
	data, err := service.call("RefreshDateTimeSystem", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshDateTimeSystemResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryAvailablePartition(request *QueryAvailablePartitionRequestType) (*QueryAvailablePartitionResponse, error) {
	data, err := service.call("QueryAvailablePartition", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryAvailablePartitionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) SelectActivePartition(request *SelectActivePartitionRequestType) (*SelectActivePartitionResponse, error) {
	data, err := service.call("SelectActivePartition", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SelectActivePartitionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryPartitionCreateOptions(request *QueryPartitionCreateOptionsRequestType) (*QueryPartitionCreateOptionsResponse, error) {
	data, err := service.call("QueryPartitionCreateOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPartitionCreateOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryPartitionCreateDesc(request *QueryPartitionCreateDescRequestType) (*QueryPartitionCreateDescResponse, error) {
	data, err := service.call("QueryPartitionCreateDesc", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPartitionCreateDescResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateDiagnosticPartition(request *CreateDiagnosticPartitionRequestType) (*CreateDiagnosticPartitionResponse, error) {
	data, err := service.call("CreateDiagnosticPartition", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateDiagnosticPartitionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) EsxAgentHostManagerUpdateConfig(request *EsxAgentHostManagerUpdateConfigRequestType) (*EsxAgentHostManagerUpdateConfigResponse, error) {
	data, err := service.call("EsxAgentHostManagerUpdateConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EsxAgentHostManagerUpdateConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateDefaultPolicy(request *UpdateDefaultPolicyRequestType) (*UpdateDefaultPolicyResponse, error) {
	data, err := service.call("UpdateDefaultPolicy", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateDefaultPolicyResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) EnableRuleset(request *EnableRulesetRequestType) (*EnableRulesetResponse, error) {
	data, err := service.call("EnableRuleset", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnableRulesetResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DisableRuleset(request *DisableRulesetRequestType) (*DisableRulesetResponse, error) {
	data, err := service.call("DisableRuleset", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DisableRulesetResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateRuleset(request *UpdateRulesetRequestType) (*UpdateRulesetResponse, error) {
	data, err := service.call("UpdateRuleset", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateRulesetResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshFirewall(request *RefreshFirewallRequestType) (*RefreshFirewallResponse, error) {
	data, err := service.call("RefreshFirewall", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshFirewallResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ResetFirmwareToFactoryDefaults(request *ResetFirmwareToFactoryDefaultsRequestType) (*ResetFirmwareToFactoryDefaultsResponse, error) {
	data, err := service.call("ResetFirmwareToFactoryDefaults", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetFirmwareToFactoryDefaultsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) BackupFirmwareConfiguration(request *BackupFirmwareConfigurationRequestType) (*BackupFirmwareConfigurationResponse, error) {
	data, err := service.call("BackupFirmwareConfiguration", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &BackupFirmwareConfigurationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryFirmwareConfigUploadURL(request *QueryFirmwareConfigUploadURLRequestType) (*QueryFirmwareConfigUploadURLResponse, error) {
	data, err := service.call("QueryFirmwareConfigUploadURL", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryFirmwareConfigUploadURLResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - FileFaultFault
* - MismatchedBundleFault
* - InvalidBundleFault
* - RuntimeFault
 */
func (service *VimPortType) RestoreFirmwareConfiguration(request *RestoreFirmwareConfigurationRequestType) (*RestoreFirmwareConfigurationResponse, error) {
	data, err := service.call("RestoreFirmwareConfiguration", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RestoreFirmwareConfigurationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshGraphicsManager(request *RefreshGraphicsManagerRequestType) (*RefreshGraphicsManagerResponse, error) {
	data, err := service.call("RefreshGraphicsManager", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshGraphicsManagerResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) IsSharedGraphicsActive(request *IsSharedGraphicsActiveRequestType) (*IsSharedGraphicsActiveResponse, error) {
	data, err := service.call("IsSharedGraphicsActive", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &IsSharedGraphicsActiveResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshHealthStatusSystem(request *RefreshHealthStatusSystemRequestType) (*RefreshHealthStatusSystemResponse, error) {
	data, err := service.call("RefreshHealthStatusSystem", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshHealthStatusSystemResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ResetSystemHealthInfo(request *ResetSystemHealthInfoRequestType) (*ResetSystemHealthInfoResponse, error) {
	data, err := service.call("ResetSystemHealthInfo", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetSystemHealthInfoResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) HostImageConfigGetAcceptance(request *HostImageConfigGetAcceptanceRequestType) (*HostImageConfigGetAcceptanceResponse, error) {
	data, err := service.call("HostImageConfigGetAcceptance", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HostImageConfigGetAcceptanceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) HostImageConfigGetProfile(request *HostImageConfigGetProfileRequestType) (*HostImageConfigGetProfileResponse, error) {
	data, err := service.call("HostImageConfigGetProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HostImageConfigGetProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateHostImageAcceptanceLevel(request *UpdateHostImageAcceptanceLevelRequestType) (*UpdateHostImageAcceptanceLevelResponse, error) {
	data, err := service.call("UpdateHostImageAcceptanceLevel", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateHostImageAcceptanceLevelResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - IscsiFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryVnicStatus(request *QueryVnicStatusRequestType) (*QueryVnicStatusResponse, error) {
	data, err := service.call("QueryVnicStatus", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVnicStatusResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - IscsiFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryPnicStatus(request *QueryPnicStatusRequestType) (*QueryPnicStatusResponse, error) {
	data, err := service.call("QueryPnicStatus", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPnicStatusResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - IscsiFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) QueryBoundVnics(request *QueryBoundVnicsRequestType) (*QueryBoundVnicsResponse, error) {
	data, err := service.call("QueryBoundVnics", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryBoundVnicsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - IscsiFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) QueryCandidateNics(request *QueryCandidateNicsRequestType) (*QueryCandidateNicsResponse, error) {
	data, err := service.call("QueryCandidateNics", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryCandidateNicsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - IscsiFaultVnicAlreadyBoundFault
* - IscsiFaultVnicHasNoUplinksFault
* - IscsiFaultVnicHasMultipleUplinksFault
* - IscsiFaultVnicHasWrongUplinkFault
* - IscsiFaultVnicNotFoundFault
* - IscsiFaultInvalidVnicFault
* - PlatformConfigFaultFault
* - IscsiFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) BindVnic(request *BindVnicRequestType) (*BindVnicResponse, error) {
	data, err := service.call("BindVnic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &BindVnicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - IscsiFaultVnicNotBoundFault
* - IscsiFaultVnicHasActivePathsFault
* - IscsiFaultVnicIsLastPathFault
* - PlatformConfigFaultFault
* - IscsiFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) UnbindVnic(request *UnbindVnicRequestType) (*UnbindVnicResponse, error) {
	data, err := service.call("UnbindVnic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnbindVnicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryMigrationDependencies(request *QueryMigrationDependenciesRequestType) (*QueryMigrationDependenciesResponse, error) {
	data, err := service.call("QueryMigrationDependencies", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryMigrationDependenciesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryModules(request *QueryModulesRequestType) (*QueryModulesResponse, error) {
	data, err := service.call("QueryModules", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryModulesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateModuleOptionString(request *UpdateModuleOptionStringRequestType) (*UpdateModuleOptionStringResponse, error) {
	data, err := service.call("UpdateModuleOptionString", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateModuleOptionStringResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) QueryConfiguredModuleOptionString(request *QueryConfiguredModuleOptionStringRequestType) (*QueryConfiguredModuleOptionStringResponse, error) {
	data, err := service.call("QueryConfiguredModuleOptionString", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryConfiguredModuleOptionStringResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) CreateUser(request *CreateUserRequestType) (*CreateUserResponse, error) {
	data, err := service.call("CreateUser", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateUserResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - UserNotFoundFault
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateUser(request *UpdateUserRequestType) (*UpdateUserResponse, error) {
	data, err := service.call("UpdateUser", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateUserResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) CreateGroup(request *CreateGroupRequestType) (*CreateGroupResponse, error) {
	data, err := service.call("CreateGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - UserNotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveUser(request *RemoveUserRequestType) (*RemoveUserResponse, error) {
	data, err := service.call("RemoveUser", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveUserResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - UserNotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveGroup(request *RemoveGroupRequestType) (*RemoveGroupResponse, error) {
	data, err := service.call("RemoveGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - UserNotFoundFault
* - AlreadyExistsFault
* - RuntimeFault
 */
func (service *VimPortType) AssignUserToGroup(request *AssignUserToGroupRequestType) (*AssignUserToGroupResponse, error) {
	data, err := service.call("AssignUserToGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AssignUserToGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - UserNotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) UnassignUserFromGroup(request *UnassignUserFromGroupRequestType) (*UnassignUserFromGroupResponse, error) {
	data, err := service.call("UnassignUserFromGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnassignUserFromGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureServiceConsoleReservation(request *ReconfigureServiceConsoleReservationRequestType) (*ReconfigureServiceConsoleReservationResponse, error) {
	data, err := service.call("ReconfigureServiceConsoleReservation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureServiceConsoleReservationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureVirtualMachineReservation(request *ReconfigureVirtualMachineReservationRequestType) (*ReconfigureVirtualMachineReservationResponse, error) {
	data, err := service.call("ReconfigureVirtualMachineReservation", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureVirtualMachineReservationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - NotFoundFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateNetworkConfig(request *UpdateNetworkConfigRequestType) (*UpdateNetworkConfigResponse, error) {
	data, err := service.call("UpdateNetworkConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateNetworkConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateDnsConfig(request *UpdateDnsConfigRequestType) (*UpdateDnsConfigResponse, error) {
	data, err := service.call("UpdateDnsConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateDnsConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateIpRouteConfig(request *UpdateIpRouteConfigRequestType) (*UpdateIpRouteConfigResponse, error) {
	data, err := service.call("UpdateIpRouteConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateIpRouteConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateConsoleIpRouteConfig(request *UpdateConsoleIpRouteConfigRequestType) (*UpdateConsoleIpRouteConfigResponse, error) {
	data, err := service.call("UpdateConsoleIpRouteConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateConsoleIpRouteConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateIpRouteTableConfig(request *UpdateIpRouteTableConfigRequestType) (*UpdateIpRouteTableConfigResponse, error) {
	data, err := service.call("UpdateIpRouteTableConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateIpRouteTableConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - ResourceInUseFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) AddVirtualSwitch(request *AddVirtualSwitchRequestType) (*AddVirtualSwitchResponse, error) {
	data, err := service.call("AddVirtualSwitch", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddVirtualSwitchResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - ResourceInUseFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveVirtualSwitch(request *RemoveVirtualSwitchRequestType) (*RemoveVirtualSwitchResponse, error) {
	data, err := service.call("RemoveVirtualSwitch", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveVirtualSwitchResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - ResourceInUseFault
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateVirtualSwitch(request *UpdateVirtualSwitchRequestType) (*UpdateVirtualSwitchResponse, error) {
	data, err := service.call("UpdateVirtualSwitch", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateVirtualSwitchResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) AddPortGroup(request *AddPortGroupRequestType) (*AddPortGroupResponse, error) {
	data, err := service.call("AddPortGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddPortGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - ResourceInUseFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RemovePortGroup(request *RemovePortGroupRequestType) (*RemovePortGroupResponse, error) {
	data, err := service.call("RemovePortGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemovePortGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdatePortGroup(request *UpdatePortGroupRequestType) (*UpdatePortGroupResponse, error) {
	data, err := service.call("UpdatePortGroup", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdatePortGroupResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdatePhysicalNicLinkSpeed(request *UpdatePhysicalNicLinkSpeedRequestType) (*UpdatePhysicalNicLinkSpeedResponse, error) {
	data, err := service.call("UpdatePhysicalNicLinkSpeed", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdatePhysicalNicLinkSpeedResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryNetworkHint(request *QueryNetworkHintRequestType) (*QueryNetworkHintResponse, error) {
	data, err := service.call("QueryNetworkHint", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryNetworkHintResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - HostConfigFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) AddVirtualNic(request *AddVirtualNicRequestType) (*AddVirtualNicResponse, error) {
	data, err := service.call("AddVirtualNic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddVirtualNicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveVirtualNic(request *RemoveVirtualNicRequestType) (*RemoveVirtualNicResponse, error) {
	data, err := service.call("RemoveVirtualNic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveVirtualNicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateVirtualNic(request *UpdateVirtualNicRequestType) (*UpdateVirtualNicResponse, error) {
	data, err := service.call("UpdateVirtualNic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateVirtualNicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) AddServiceConsoleVirtualNic(request *AddServiceConsoleVirtualNicRequestType) (*AddServiceConsoleVirtualNicResponse, error) {
	data, err := service.call("AddServiceConsoleVirtualNic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddServiceConsoleVirtualNicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - ResourceInUseFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveServiceConsoleVirtualNic(request *RemoveServiceConsoleVirtualNicRequestType) (*RemoveServiceConsoleVirtualNicResponse, error) {
	data, err := service.call("RemoveServiceConsoleVirtualNic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveServiceConsoleVirtualNicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - ResourceInUseFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateServiceConsoleVirtualNic(request *UpdateServiceConsoleVirtualNicRequestType) (*UpdateServiceConsoleVirtualNicResponse, error) {
	data, err := service.call("UpdateServiceConsoleVirtualNic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateServiceConsoleVirtualNicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RestartServiceConsoleVirtualNic(request *RestartServiceConsoleVirtualNicRequestType) (*RestartServiceConsoleVirtualNicResponse, error) {
	data, err := service.call("RestartServiceConsoleVirtualNic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RestartServiceConsoleVirtualNicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshNetworkSystem(request *RefreshNetworkSystemRequestType) (*RefreshNetworkSystemResponse, error) {
	data, err := service.call("RefreshNetworkSystem", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshNetworkSystemResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RequestCanceledFault
* - InvalidStateFault
* - TaskInProgressFault
* - PlatformConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CheckHostPatch_Task(request *CheckHostPatchRequestType) (*CheckHostPatch_TaskResponse, error) {
	data, err := service.call("CheckHostPatch_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckHostPatch_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RequestCanceledFault
* - PatchMetadataInvalidFault
* - PlatformConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ScanHostPatch_Task(request *ScanHostPatchRequestType) (*ScanHostPatch_TaskResponse, error) {
	data, err := service.call("ScanHostPatch_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ScanHostPatch_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RequestCanceledFault
* - InvalidStateFault
* - TaskInProgressFault
* - PlatformConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ScanHostPatchV2_Task(request *ScanHostPatchV2RequestType) (*ScanHostPatchV2_TaskResponse, error) {
	data, err := service.call("ScanHostPatchV2_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ScanHostPatchV2_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RequestCanceledFault
* - InvalidStateFault
* - TaskInProgressFault
* - PlatformConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) StageHostPatch_Task(request *StageHostPatchRequestType) (*StageHostPatch_TaskResponse, error) {
	data, err := service.call("StageHostPatch_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StageHostPatch_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - PatchMetadataInvalidFault
* - PatchBinariesNotFoundFault
* - PatchNotApplicableFault
* - NoDiskSpaceFault
* - PatchInstallFailedFault
* - RebootRequiredFault
* - InvalidStateFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) InstallHostPatch_Task(request *InstallHostPatchRequestType) (*InstallHostPatch_TaskResponse, error) {
	data, err := service.call("InstallHostPatch_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &InstallHostPatch_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RequestCanceledFault
* - InvalidStateFault
* - TaskInProgressFault
* - PlatformConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) InstallHostPatchV2_Task(request *InstallHostPatchV2RequestType) (*InstallHostPatchV2_TaskResponse, error) {
	data, err := service.call("InstallHostPatchV2_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &InstallHostPatchV2_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - TaskInProgressFault
* - PlatformConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UninstallHostPatch_Task(request *UninstallHostPatchRequestType) (*UninstallHostPatch_TaskResponse, error) {
	data, err := service.call("UninstallHostPatch_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UninstallHostPatch_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RequestCanceledFault
* - InvalidStateFault
* - TaskInProgressFault
* - PlatformConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryHostPatch_Task(request *QueryHostPatchRequestType) (*QueryHostPatch_TaskResponse, error) {
	data, err := service.call("QueryHostPatch_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryHostPatch_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) Refresh(request *RefreshRequestType) (*RefreshResponse, error) {
	data, err := service.call("Refresh", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdatePassthruConfig(request *UpdatePassthruConfigRequestType) (*UpdatePassthruConfigResponse, error) {
	data, err := service.call("UpdatePassthruConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdatePassthruConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ConfigurePowerPolicy(request *ConfigurePowerPolicyRequestType) (*ConfigurePowerPolicyResponse, error) {
	data, err := service.call("ConfigurePowerPolicy", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ConfigurePowerPolicyResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateServicePolicy(request *UpdateServicePolicyRequestType) (*UpdateServicePolicyResponse, error) {
	data, err := service.call("UpdateServicePolicy", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateServicePolicyResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) StartService(request *StartServiceRequestType) (*StartServiceResponse, error) {
	data, err := service.call("StartService", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StartServiceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) StopService(request *StopServiceRequestType) (*StopServiceResponse, error) {
	data, err := service.call("StopService", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StopServiceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RestartService(request *RestartServiceRequestType) (*RestartServiceResponse, error) {
	data, err := service.call("RestartService", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RestartServiceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UninstallService(request *UninstallServiceRequestType) (*UninstallServiceResponse, error) {
	data, err := service.call("UninstallService", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UninstallServiceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshServices(request *RefreshServicesRequestType) (*RefreshServicesResponse, error) {
	data, err := service.call("RefreshServices", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshServicesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureSnmpAgent(request *ReconfigureSnmpAgentRequestType) (*ReconfigureSnmpAgentResponse, error) {
	data, err := service.call("ReconfigureSnmpAgent", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureSnmpAgentResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - InsufficientResourcesFaultFault
* - RuntimeFault
 */
func (service *VimPortType) SendTestNotification(request *SendTestNotificationRequestType) (*SendTestNotificationResponse, error) {
	data, err := service.call("SendTestNotification", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SendTestNotificationResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveDiskPartitionInfo(request *RetrieveDiskPartitionInfoRequestType) (*RetrieveDiskPartitionInfoResponse, error) {
	data, err := service.call("RetrieveDiskPartitionInfo", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveDiskPartitionInfoResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ComputeDiskPartitionInfo(request *ComputeDiskPartitionInfoRequestType) (*ComputeDiskPartitionInfoResponse, error) {
	data, err := service.call("ComputeDiskPartitionInfo", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ComputeDiskPartitionInfoResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ComputeDiskPartitionInfoForResize(request *ComputeDiskPartitionInfoForResizeRequestType) (*ComputeDiskPartitionInfoForResizeResponse, error) {
	data, err := service.call("ComputeDiskPartitionInfoForResize", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ComputeDiskPartitionInfoForResizeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateDiskPartitions(request *UpdateDiskPartitionsRequestType) (*UpdateDiskPartitionsResponse, error) {
	data, err := service.call("UpdateDiskPartitions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateDiskPartitionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) FormatVmfs(request *FormatVmfsRequestType) (*FormatVmfsResponse, error) {
	data, err := service.call("FormatVmfs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FormatVmfsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - InvalidStateFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) MountVmfsVolume(request *MountVmfsVolumeRequestType) (*MountVmfsVolumeResponse, error) {
	data, err := service.call("MountVmfsVolume", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MountVmfsVolumeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - InvalidStateFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) UnmountVmfsVolume(request *UnmountVmfsVolumeRequestType) (*UnmountVmfsVolumeResponse, error) {
	data, err := service.call("UnmountVmfsVolume", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnmountVmfsVolumeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteVmfsVolumeState(request *DeleteVmfsVolumeStateRequestType) (*DeleteVmfsVolumeStateResponse, error) {
	data, err := service.call("DeleteVmfsVolumeState", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteVmfsVolumeStateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RescanVmfs(request *RescanVmfsRequestType) (*RescanVmfsResponse, error) {
	data, err := service.call("RescanVmfs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RescanVmfsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) AttachVmfsExtent(request *AttachVmfsExtentRequestType) (*AttachVmfsExtentResponse, error) {
	data, err := service.call("AttachVmfsExtent", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AttachVmfsExtentResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ExpandVmfsExtent(request *ExpandVmfsExtentRequestType) (*ExpandVmfsExtentResponse, error) {
	data, err := service.call("ExpandVmfsExtent", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExpandVmfsExtentResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpgradeVmfs(request *UpgradeVmfsRequestType) (*UpgradeVmfsResponse, error) {
	data, err := service.call("UpgradeVmfs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpgradeVmfsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpgradeVmLayout(request *UpgradeVmLayoutRequestType) (*UpgradeVmLayoutResponse, error) {
	data, err := service.call("UpgradeVmLayout", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpgradeVmLayoutResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryUnresolvedVmfsVolume(request *QueryUnresolvedVmfsVolumeRequestType) (*QueryUnresolvedVmfsVolumeResponse, error) {
	data, err := service.call("QueryUnresolvedVmfsVolume", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryUnresolvedVmfsVolumeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ResolveMultipleUnresolvedVmfsVolumes(request *ResolveMultipleUnresolvedVmfsVolumesRequestType) (*ResolveMultipleUnresolvedVmfsVolumesResponse, error) {
	data, err := service.call("ResolveMultipleUnresolvedVmfsVolumes", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResolveMultipleUnresolvedVmfsVolumesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ResolveMultipleUnresolvedVmfsVolumesEx_Task(request *ResolveMultipleUnresolvedVmfsVolumesExRequestType) (*ResolveMultipleUnresolvedVmfsVolumesEx_TaskResponse, error) {
	data, err := service.call("ResolveMultipleUnresolvedVmfsVolumesEx_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResolveMultipleUnresolvedVmfsVolumesEx_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UnmountForceMountedVmfsVolume(request *UnmountForceMountedVmfsVolumeRequestType) (*UnmountForceMountedVmfsVolumeResponse, error) {
	data, err := service.call("UnmountForceMountedVmfsVolume", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnmountForceMountedVmfsVolumeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RescanHba(request *RescanHbaRequestType) (*RescanHbaResponse, error) {
	data, err := service.call("RescanHba", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RescanHbaResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RescanAllHba(request *RescanAllHbaRequestType) (*RescanAllHbaResponse, error) {
	data, err := service.call("RescanAllHba", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RescanAllHbaResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateSoftwareInternetScsiEnabled(request *UpdateSoftwareInternetScsiEnabledRequestType) (*UpdateSoftwareInternetScsiEnabledResponse, error) {
	data, err := service.call("UpdateSoftwareInternetScsiEnabled", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateSoftwareInternetScsiEnabledResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateInternetScsiDiscoveryProperties(request *UpdateInternetScsiDiscoveryPropertiesRequestType) (*UpdateInternetScsiDiscoveryPropertiesResponse, error) {
	data, err := service.call("UpdateInternetScsiDiscoveryProperties", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateInternetScsiDiscoveryPropertiesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateInternetScsiAuthenticationProperties(request *UpdateInternetScsiAuthenticationPropertiesRequestType) (*UpdateInternetScsiAuthenticationPropertiesResponse, error) {
	data, err := service.call("UpdateInternetScsiAuthenticationProperties", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateInternetScsiAuthenticationPropertiesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateInternetScsiDigestProperties(request *UpdateInternetScsiDigestPropertiesRequestType) (*UpdateInternetScsiDigestPropertiesResponse, error) {
	data, err := service.call("UpdateInternetScsiDigestProperties", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateInternetScsiDigestPropertiesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateInternetScsiAdvancedOptions(request *UpdateInternetScsiAdvancedOptionsRequestType) (*UpdateInternetScsiAdvancedOptionsResponse, error) {
	data, err := service.call("UpdateInternetScsiAdvancedOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateInternetScsiAdvancedOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateInternetScsiIPProperties(request *UpdateInternetScsiIPPropertiesRequestType) (*UpdateInternetScsiIPPropertiesResponse, error) {
	data, err := service.call("UpdateInternetScsiIPProperties", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateInternetScsiIPPropertiesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateInternetScsiName(request *UpdateInternetScsiNameRequestType) (*UpdateInternetScsiNameResponse, error) {
	data, err := service.call("UpdateInternetScsiName", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateInternetScsiNameResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateInternetScsiAlias(request *UpdateInternetScsiAliasRequestType) (*UpdateInternetScsiAliasResponse, error) {
	data, err := service.call("UpdateInternetScsiAlias", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateInternetScsiAliasResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) AddInternetScsiSendTargets(request *AddInternetScsiSendTargetsRequestType) (*AddInternetScsiSendTargetsResponse, error) {
	data, err := service.call("AddInternetScsiSendTargets", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddInternetScsiSendTargetsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveInternetScsiSendTargets(request *RemoveInternetScsiSendTargetsRequestType) (*RemoveInternetScsiSendTargetsResponse, error) {
	data, err := service.call("RemoveInternetScsiSendTargets", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveInternetScsiSendTargetsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) AddInternetScsiStaticTargets(request *AddInternetScsiStaticTargetsRequestType) (*AddInternetScsiStaticTargetsResponse, error) {
	data, err := service.call("AddInternetScsiStaticTargets", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddInternetScsiStaticTargetsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveInternetScsiStaticTargets(request *RemoveInternetScsiStaticTargetsRequestType) (*RemoveInternetScsiStaticTargetsResponse, error) {
	data, err := service.call("RemoveInternetScsiStaticTargets", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveInternetScsiStaticTargetsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) EnableMultipathPath(request *EnableMultipathPathRequestType) (*EnableMultipathPathResponse, error) {
	data, err := service.call("EnableMultipathPath", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &EnableMultipathPathResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DisableMultipathPath(request *DisableMultipathPathRequestType) (*DisableMultipathPathResponse, error) {
	data, err := service.call("DisableMultipathPath", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DisableMultipathPathResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) SetMultipathLunPolicy(request *SetMultipathLunPolicyRequestType) (*SetMultipathLunPolicyResponse, error) {
	data, err := service.call("SetMultipathLunPolicy", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SetMultipathLunPolicyResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryPathSelectionPolicyOptions(request *QueryPathSelectionPolicyOptionsRequestType) (*QueryPathSelectionPolicyOptionsResponse, error) {
	data, err := service.call("QueryPathSelectionPolicyOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPathSelectionPolicyOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryStorageArrayTypePolicyOptions(request *QueryStorageArrayTypePolicyOptionsRequestType) (*QueryStorageArrayTypePolicyOptionsResponse, error) {
	data, err := service.call("QueryStorageArrayTypePolicyOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryStorageArrayTypePolicyOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - InvalidNameFault
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateScsiLunDisplayName(request *UpdateScsiLunDisplayNameRequestType) (*UpdateScsiLunDisplayNameResponse, error) {
	data, err := service.call("UpdateScsiLunDisplayName", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateScsiLunDisplayNameResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - InvalidStateFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) DetachScsiLun(request *DetachScsiLunRequestType) (*DetachScsiLunResponse, error) {
	data, err := service.call("DetachScsiLun", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DetachScsiLunResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteScsiLunState(request *DeleteScsiLunStateRequestType) (*DeleteScsiLunStateResponse, error) {
	data, err := service.call("DeleteScsiLunState", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteScsiLunStateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) AttachScsiLun(request *AttachScsiLunRequestType) (*AttachScsiLunResponse, error) {
	data, err := service.call("AttachScsiLun", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AttachScsiLunResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RefreshStorageSystem(request *RefreshStorageSystemRequestType) (*RefreshStorageSystemResponse, error) {
	data, err := service.call("RefreshStorageSystem", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RefreshStorageSystemResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - FcoeFaultPnicHasNoPortSetFault
* - HostConfigFaultFault
* - NotFoundFault
* - RuntimeFault
 */
func (service *VimPortType) DiscoverFcoeHbas(request *DiscoverFcoeHbasRequestType) (*DiscoverFcoeHbasResponse, error) {
	data, err := service.call("DiscoverFcoeHbas", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DiscoverFcoeHbasResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MarkForRemoval(request *MarkForRemovalRequestType) (*MarkForRemovalResponse, error) {
	data, err := service.call("MarkForRemoval", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MarkForRemovalResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AlreadyExistsFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) FormatVffs(request *FormatVffsRequestType) (*FormatVffsResponse, error) {
	data, err := service.call("FormatVffs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FormatVffsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) ExtendVffs(request *ExtendVffsRequestType) (*ExtendVffsResponse, error) {
	data, err := service.call("ExtendVffs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExtendVffsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) DestroyVffs(request *DestroyVffsRequestType) (*DestroyVffsResponse, error) {
	data, err := service.call("DestroyVffs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyVffsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - InvalidStateFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) MountVffsVolume(request *MountVffsVolumeRequestType) (*MountVffsVolumeResponse, error) {
	data, err := service.call("MountVffsVolume", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MountVffsVolumeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - InvalidStateFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) UnmountVffsVolume(request *UnmountVffsVolumeRequestType) (*UnmountVffsVolumeResponse, error) {
	data, err := service.call("UnmountVffsVolume", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UnmountVffsVolumeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteVffsVolumeState(request *DeleteVffsVolumeStateRequestType) (*DeleteVffsVolumeStateResponse, error) {
	data, err := service.call("DeleteVffsVolumeState", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteVffsVolumeStateResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RescanVffs(request *RescanVffsRequestType) (*RescanVffsResponse, error) {
	data, err := service.call("RescanVffs", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RescanVffsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) QueryAvailableSsds(request *QueryAvailableSsdsRequestType) (*QueryAvailableSsdsResponse, error) {
	data, err := service.call("QueryAvailableSsds", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryAvailableSsdsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ConfigureVFlashResourceEx_Task(request *ConfigureVFlashResourceExRequestType) (*ConfigureVFlashResourceEx_TaskResponse, error) {
	data, err := service.call("ConfigureVFlashResourceEx_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ConfigureVFlashResourceEx_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) HostConfigureVFlashResource(request *HostConfigureVFlashResourceRequestType) (*HostConfigureVFlashResourceResponse, error) {
	data, err := service.call("HostConfigureVFlashResource", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HostConfigureVFlashResourceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) HostRemoveVFlashResource(request *HostRemoveVFlashResourceRequestType) (*HostRemoveVFlashResourceResponse, error) {
	data, err := service.call("HostRemoveVFlashResource", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HostRemoveVFlashResourceResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - InaccessibleVFlashSourceFault
* - ResourceInUseFault
* - RuntimeFault
 */
func (service *VimPortType) HostConfigVFlashCache(request *HostConfigVFlashCacheRequestType) (*HostConfigVFlashCacheResponse, error) {
	data, err := service.call("HostConfigVFlashCache", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HostConfigVFlashCacheResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) HostGetVFlashModuleDefaultConfig(request *HostGetVFlashModuleDefaultConfigRequestType) (*HostGetVFlashModuleDefaultConfigResponse, error) {
	data, err := service.call("HostGetVFlashModuleDefaultConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &HostGetVFlashModuleDefaultConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - NotFoundFault
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateIpConfig(request *UpdateIpConfigRequestType) (*UpdateIpConfigResponse, error) {
	data, err := service.call("UpdateIpConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateIpConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) SelectVnic(request *SelectVnicRequestType) (*SelectVnicResponse, error) {
	data, err := service.call("SelectVnic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SelectVnicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DeselectVnic(request *DeselectVnicRequestType) (*DeselectVnicResponse, error) {
	data, err := service.call("DeselectVnic", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeselectVnicResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - InvalidArgumentFault
* - RuntimeFault
 */
func (service *VimPortType) QueryNetConfig(request *QueryNetConfigRequestType) (*QueryNetConfigResponse, error) {
	data, err := service.call("QueryNetConfig", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryNetConfigResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - InvalidArgumentFault
* - RuntimeFault
 */
func (service *VimPortType) SelectVnicForNicType(request *SelectVnicForNicTypeRequestType) (*SelectVnicForNicTypeResponse, error) {
	data, err := service.call("SelectVnicForNicType", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &SelectVnicForNicTypeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - HostConfigFaultFault
* - InvalidArgumentFault
* - RuntimeFault
 */
func (service *VimPortType) DeselectVnicForNicType(request *DeselectVnicForNicTypeRequestType) (*DeselectVnicForNicTypeResponse, error) {
	data, err := service.call("DeselectVnicForNicType", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeselectVnicForNicTypeResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryCmmds(request *QueryCmmdsRequestType) (*QueryCmmdsResponse, error) {
	data, err := service.call("QueryCmmds", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryCmmdsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryPhysicalVsanDisks(request *QueryPhysicalVsanDisksRequestType) (*QueryPhysicalVsanDisksResponse, error) {
	data, err := service.call("QueryPhysicalVsanDisks", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPhysicalVsanDisksResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryVsanObjects(request *QueryVsanObjectsRequestType) (*QueryVsanObjectsResponse, error) {
	data, err := service.call("QueryVsanObjects", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVsanObjectsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryObjectsOnPhysicalVsanDisk(request *QueryObjectsOnPhysicalVsanDiskRequestType) (*QueryObjectsOnPhysicalVsanDiskResponse, error) {
	data, err := service.call("QueryObjectsOnPhysicalVsanDisk", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryObjectsOnPhysicalVsanDiskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryDisksForVsan(request *QueryDisksForVsanRequestType) (*QueryDisksForVsanResponse, error) {
	data, err := service.call("QueryDisksForVsan", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryDisksForVsanResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AddDisks_Task(request *AddDisksRequestType) (*AddDisks_TaskResponse, error) {
	data, err := service.call("AddDisks_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AddDisks_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) InitializeDisks_Task(request *InitializeDisksRequestType) (*InitializeDisks_TaskResponse, error) {
	data, err := service.call("InitializeDisks_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &InitializeDisks_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RemoveDisk_Task(request *RemoveDiskRequestType) (*RemoveDisk_TaskResponse, error) {
	data, err := service.call("RemoveDisk_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveDisk_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RemoveDiskMapping_Task(request *RemoveDiskMappingRequestType) (*RemoveDiskMapping_TaskResponse, error) {
	data, err := service.call("RemoveDiskMapping_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveDiskMapping_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateVsan_Task(request *UpdateVsanRequestType) (*UpdateVsan_TaskResponse, error) {
	data, err := service.call("UpdateVsan_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateVsan_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryHostStatus(request *QueryHostStatusRequestType) (*QueryHostStatusResponse, error) {
	data, err := service.call("QueryHostStatus", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryHostStatusResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) QueryOptions(request *QueryOptionsRequestType) (*QueryOptionsResponse, error) {
	data, err := service.call("QueryOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateOptions(request *UpdateOptionsRequestType) (*UpdateOptionsResponse, error) {
	data, err := service.call("UpdateOptions", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateOptionsResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CheckCompliance_Task(request *CheckComplianceRequestType) (*CheckCompliance_TaskResponse, error) {
	data, err := service.call("CheckCompliance_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckCompliance_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryComplianceStatus(request *QueryComplianceStatusRequestType) (*QueryComplianceStatusResponse, error) {
	data, err := service.call("QueryComplianceStatus", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryComplianceStatusResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ClearComplianceStatus(request *ClearComplianceStatusRequestType) (*ClearComplianceStatusResponse, error) {
	data, err := service.call("ClearComplianceStatus", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ClearComplianceStatusResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryExpressionMetadata(request *QueryExpressionMetadataRequestType) (*QueryExpressionMetadataResponse, error) {
	data, err := service.call("QueryExpressionMetadata", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryExpressionMetadataResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveDescription(request *RetrieveDescriptionRequestType) (*RetrieveDescriptionResponse, error) {
	data, err := service.call("RetrieveDescription", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveDescriptionResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DestroyProfile(request *DestroyProfileRequestType) (*DestroyProfileResponse, error) {
	data, err := service.call("DestroyProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) AssociateProfile(request *AssociateProfileRequestType) (*AssociateProfileResponse, error) {
	data, err := service.call("AssociateProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AssociateProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DissociateProfile(request *DissociateProfileRequestType) (*DissociateProfileResponse, error) {
	data, err := service.call("DissociateProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DissociateProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CheckProfileCompliance_Task(request *CheckProfileComplianceRequestType) (*CheckProfileCompliance_TaskResponse, error) {
	data, err := service.call("CheckProfileCompliance_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckProfileCompliance_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ExportProfile(request *ExportProfileRequestType) (*ExportProfileResponse, error) {
	data, err := service.call("ExportProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExportProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateProfile(request *CreateProfileRequestType) (*CreateProfileResponse, error) {
	data, err := service.call("CreateProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryPolicyMetadata(request *QueryPolicyMetadataRequestType) (*QueryPolicyMetadataResponse, error) {
	data, err := service.call("QueryPolicyMetadata", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryPolicyMetadataResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) FindAssociatedProfile(request *FindAssociatedProfileRequestType) (*FindAssociatedProfileResponse, error) {
	data, err := service.call("FindAssociatedProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &FindAssociatedProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateClusterProfile(request *UpdateClusterProfileRequestType) (*UpdateClusterProfileResponse, error) {
	data, err := service.call("UpdateClusterProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateClusterProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) UpdateReferenceHost(request *UpdateReferenceHostRequestType) (*UpdateReferenceHostResponse, error) {
	data, err := service.call("UpdateReferenceHost", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateReferenceHostResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - DuplicateNameFault
* - ProfileUpdateFailedFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateHostProfile(request *UpdateHostProfileRequestType) (*UpdateHostProfileResponse, error) {
	data, err := service.call("UpdateHostProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateHostProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ExecuteHostProfile(request *ExecuteHostProfileRequestType) (*ExecuteHostProfileResponse, error) {
	data, err := service.call("ExecuteHostProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExecuteHostProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - HostConfigFailedFault
* - RuntimeFault
 */
func (service *VimPortType) ApplyHostConfig_Task(request *ApplyHostConfigRequestType) (*ApplyHostConfig_TaskResponse, error) {
	data, err := service.call("ApplyHostConfig_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ApplyHostConfig_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) GenerateConfigTaskList(request *GenerateConfigTaskListRequestType) (*GenerateConfigTaskListResponse, error) {
	data, err := service.call("GenerateConfigTaskList", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &GenerateConfigTaskListResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) GenerateHostProfileTaskList_Task(request *GenerateHostProfileTaskListRequestType) (*GenerateHostProfileTaskList_TaskResponse, error) {
	data, err := service.call("GenerateHostProfileTaskList_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &GenerateHostProfileTaskList_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryHostProfileMetadata(request *QueryHostProfileMetadataRequestType) (*QueryHostProfileMetadataResponse, error) {
	data, err := service.call("QueryHostProfileMetadata", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryHostProfileMetadataResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryProfileStructure(request *QueryProfileStructureRequestType) (*QueryProfileStructureResponse, error) {
	data, err := service.call("QueryProfileStructure", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryProfileStructureResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreateDefaultProfile(request *CreateDefaultProfileRequestType) (*CreateDefaultProfileResponse, error) {
	data, err := service.call("CreateDefaultProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateDefaultProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - AnswerFileUpdateFailedFault
* - RuntimeFault
 */
func (service *VimPortType) UpdateAnswerFile_Task(request *UpdateAnswerFileRequestType) (*UpdateAnswerFile_TaskResponse, error) {
	data, err := service.call("UpdateAnswerFile_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &UpdateAnswerFile_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveAnswerFile(request *RetrieveAnswerFileRequestType) (*RetrieveAnswerFileResponse, error) {
	data, err := service.call("RetrieveAnswerFile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveAnswerFileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveAnswerFileForProfile(request *RetrieveAnswerFileForProfileRequestType) (*RetrieveAnswerFileForProfileResponse, error) {
	data, err := service.call("RetrieveAnswerFileForProfile", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveAnswerFileForProfileResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ExportAnswerFile_Task(request *ExportAnswerFileRequestType) (*ExportAnswerFile_TaskResponse, error) {
	data, err := service.call("ExportAnswerFile_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExportAnswerFile_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CheckAnswerFileStatus_Task(request *CheckAnswerFileStatusRequestType) (*CheckAnswerFileStatus_TaskResponse, error) {
	data, err := service.call("CheckAnswerFileStatus_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckAnswerFileStatus_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryAnswerFileStatus(request *QueryAnswerFileStatusRequestType) (*QueryAnswerFileStatusResponse, error) {
	data, err := service.call("QueryAnswerFileStatus", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryAnswerFileStatusResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveScheduledTask(request *RemoveScheduledTaskRequestType) (*RemoveScheduledTaskResponse, error) {
	data, err := service.call("RemoveScheduledTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveScheduledTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - InvalidNameFault
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) ReconfigureScheduledTask(request *ReconfigureScheduledTaskRequestType) (*ReconfigureScheduledTaskResponse, error) {
	data, err := service.call("ReconfigureScheduledTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReconfigureScheduledTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) RunScheduledTask(request *RunScheduledTaskRequestType) (*RunScheduledTaskResponse, error) {
	data, err := service.call("RunScheduledTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RunScheduledTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateScheduledTask(request *CreateScheduledTaskRequestType) (*CreateScheduledTaskResponse, error) {
	data, err := service.call("CreateScheduledTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateScheduledTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveEntityScheduledTask(request *RetrieveEntityScheduledTaskRequestType) (*RetrieveEntityScheduledTaskResponse, error) {
	data, err := service.call("RetrieveEntityScheduledTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveEntityScheduledTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - DuplicateNameFault
* - RuntimeFault
 */
func (service *VimPortType) CreateObjectScheduledTask(request *CreateObjectScheduledTaskRequestType) (*CreateObjectScheduledTaskResponse, error) {
	data, err := service.call("CreateObjectScheduledTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateObjectScheduledTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) RetrieveObjectScheduledTask(request *RetrieveObjectScheduledTaskRequestType) (*RetrieveObjectScheduledTaskResponse, error) {
	data, err := service.call("RetrieveObjectScheduledTask", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrieveObjectScheduledTaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) OpenInventoryViewFolder(request *OpenInventoryViewFolderRequestType) (*OpenInventoryViewFolderResponse, error) {
	data, err := service.call("OpenInventoryViewFolder", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &OpenInventoryViewFolderResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CloseInventoryViewFolder(request *CloseInventoryViewFolderRequestType) (*CloseInventoryViewFolderResponse, error) {
	data, err := service.call("CloseInventoryViewFolder", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CloseInventoryViewFolderResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ModifyListView(request *ModifyListViewRequestType) (*ModifyListViewResponse, error) {
	data, err := service.call("ModifyListView", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ModifyListViewResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ResetListView(request *ResetListViewRequestType) (*ResetListViewResponse, error) {
	data, err := service.call("ResetListView", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetListViewResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) ResetListViewFromView(request *ResetListViewFromViewRequestType) (*ResetListViewFromViewResponse, error) {
	data, err := service.call("ResetListViewFromView", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ResetListViewFromViewResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DestroyView(request *DestroyViewRequestType) (*DestroyViewResponse, error) {
	data, err := service.call("DestroyView", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyViewResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreateInventoryView(request *CreateInventoryViewRequestType) (*CreateInventoryViewResponse, error) {
	data, err := service.call("CreateInventoryView", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateInventoryViewResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreateContainerView(request *CreateContainerViewRequestType) (*CreateContainerViewResponse, error) {
	data, err := service.call("CreateContainerView", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateContainerViewResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreateListView(request *CreateListViewRequestType) (*CreateListViewResponse, error) {
	data, err := service.call("CreateListView", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateListViewResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreateListViewFromView(request *CreateListViewFromViewRequestType) (*CreateListViewFromViewResponse, error) {
	data, err := service.call("CreateListViewFromView", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateListViewFromViewResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InsufficientResourcesFaultFault
* - InvalidStateFault
* - FileFaultFault
* - VmConfigFaultFault
* - RuntimeFault
 */
func (service *VimPortType) RevertToSnapshot_Task(request *RevertToSnapshotRequestType) (*RevertToSnapshot_TaskResponse, error) {
	data, err := service.call("RevertToSnapshot_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RevertToSnapshot_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) RemoveSnapshot_Task(request *RemoveSnapshotRequestType) (*RemoveSnapshot_TaskResponse, error) {
	data, err := service.call("RemoveSnapshot_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RemoveSnapshot_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidNameFault
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) RenameSnapshot(request *RenameSnapshotRequestType) (*RenameSnapshotResponse, error) {
	data, err := service.call("RenameSnapshot", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RenameSnapshotResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - TaskInProgressFault
* - InvalidStateFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ExportSnapshot(request *ExportSnapshotRequestType) (*ExportSnapshotResponse, error) {
	data, err := service.call("ExportSnapshot", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ExportSnapshotResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - NoActiveHostInClusterFault
* - RuntimeFault
 */
func (service *VimPortType) CheckCompatibility_Task(request *CheckCompatibilityRequestType) (*CheckCompatibility_TaskResponse, error) {
	data, err := service.call("CheckCompatibility_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckCompatibility_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) QueryVMotionCompatibilityEx_Task(request *QueryVMotionCompatibilityExRequestType) (*QueryVMotionCompatibilityEx_TaskResponse, error) {
	data, err := service.call("QueryVMotionCompatibilityEx_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &QueryVMotionCompatibilityEx_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CheckMigrate_Task(request *CheckMigrateRequestType) (*CheckMigrate_TaskResponse, error) {
	data, err := service.call("CheckMigrate_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckMigrate_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) CheckRelocate_Task(request *CheckRelocateRequestType) (*CheckRelocate_TaskResponse, error) {
	data, err := service.call("CheckRelocate_Task", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckRelocate_TaskResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) ValidateCredentialsInGuest(request *ValidateCredentialsInGuestRequestType) (*ValidateCredentialsInGuestResponse, error) {
	data, err := service.call("ValidateCredentialsInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ValidateCredentialsInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) AcquireCredentialsInGuest(request *AcquireCredentialsInGuestRequestType) (*AcquireCredentialsInGuestResponse, error) {
	data, err := service.call("AcquireCredentialsInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &AcquireCredentialsInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - TaskInProgressFault
* - InvalidStateFault
* - RuntimeFault
 */
func (service *VimPortType) ReleaseCredentialsInGuest(request *ReleaseCredentialsInGuestRequestType) (*ReleaseCredentialsInGuestResponse, error) {
	data, err := service.call("ReleaseCredentialsInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReleaseCredentialsInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MakeDirectoryInGuest(request *MakeDirectoryInGuestRequestType) (*MakeDirectoryInGuestResponse, error) {
	data, err := service.call("MakeDirectoryInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MakeDirectoryInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteFileInGuest(request *DeleteFileInGuestRequestType) (*DeleteFileInGuestResponse, error) {
	data, err := service.call("DeleteFileInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteFileInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) DeleteDirectoryInGuest(request *DeleteDirectoryInGuestRequestType) (*DeleteDirectoryInGuestResponse, error) {
	data, err := service.call("DeleteDirectoryInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DeleteDirectoryInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MoveDirectoryInGuest(request *MoveDirectoryInGuestRequestType) (*MoveDirectoryInGuestResponse, error) {
	data, err := service.call("MoveDirectoryInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveDirectoryInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) MoveFileInGuest(request *MoveFileInGuestRequestType) (*MoveFileInGuestResponse, error) {
	data, err := service.call("MoveFileInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &MoveFileInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateTemporaryFileInGuest(request *CreateTemporaryFileInGuestRequestType) (*CreateTemporaryFileInGuestResponse, error) {
	data, err := service.call("CreateTemporaryFileInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateTemporaryFileInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) CreateTemporaryDirectoryInGuest(request *CreateTemporaryDirectoryInGuestRequestType) (*CreateTemporaryDirectoryInGuestResponse, error) {
	data, err := service.call("CreateTemporaryDirectoryInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateTemporaryDirectoryInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ListFilesInGuest(request *ListFilesInGuestRequestType) (*ListFilesInGuestResponse, error) {
	data, err := service.call("ListFilesInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ListFilesInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) ChangeFileAttributesInGuest(request *ChangeFileAttributesInGuestRequestType) (*ChangeFileAttributesInGuestResponse, error) {
	data, err := service.call("ChangeFileAttributesInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ChangeFileAttributesInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) InitiateFileTransferFromGuest(request *InitiateFileTransferFromGuestRequestType) (*InitiateFileTransferFromGuestResponse, error) {
	data, err := service.call("InitiateFileTransferFromGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &InitiateFileTransferFromGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) InitiateFileTransferToGuest(request *InitiateFileTransferToGuestRequestType) (*InitiateFileTransferToGuestResponse, error) {
	data, err := service.call("InitiateFileTransferToGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &InitiateFileTransferToGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - FileFaultFault
* - RuntimeFault
 */
func (service *VimPortType) StartProgramInGuest(request *StartProgramInGuestRequestType) (*StartProgramInGuestResponse, error) {
	data, err := service.call("StartProgramInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &StartProgramInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) ListProcessesInGuest(request *ListProcessesInGuestRequestType) (*ListProcessesInGuestResponse, error) {
	data, err := service.call("ListProcessesInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ListProcessesInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) TerminateProcessInGuest(request *TerminateProcessInGuestRequestType) (*TerminateProcessInGuestResponse, error) {
	data, err := service.call("TerminateProcessInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &TerminateProcessInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - GuestOperationsFaultFault
* - InvalidStateFault
* - TaskInProgressFault
* - RuntimeFault
 */
func (service *VimPortType) ReadEnvironmentVariableInGuest(request *ReadEnvironmentVariableInGuestRequestType) (*ReadEnvironmentVariableInGuestResponse, error) {
	data, err := service.call("ReadEnvironmentVariableInGuest", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ReadEnvironmentVariableInGuestResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DestroyPropertyFilter(request *DestroyPropertyFilterRequestType) (*DestroyPropertyFilterResponse, error) {
	data, err := service.call("DestroyPropertyFilter", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyPropertyFilterResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidPropertyFault
* - RuntimeFault
 */
func (service *VimPortType) CreateFilter(request *CreateFilterRequestType) (*CreateFilterResponse, error) {
	data, err := service.call("CreateFilter", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreateFilterResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidPropertyFault
* - RuntimeFault
 */
func (service *VimPortType) RetrieveProperties(request *RetrievePropertiesRequestType) (*RetrievePropertiesResponse, error) {
	data, err := service.call("RetrieveProperties", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrievePropertiesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidCollectorVersionFault
* - RuntimeFault
 */
func (service *VimPortType) CheckForUpdates(request *CheckForUpdatesRequestType) (*CheckForUpdatesResponse, error) {
	data, err := service.call("CheckForUpdates", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CheckForUpdatesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidCollectorVersionFault
* - RuntimeFault
 */
func (service *VimPortType) WaitForUpdates(request *WaitForUpdatesRequestType) (*WaitForUpdatesResponse, error) {
	data, err := service.call("WaitForUpdates", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &WaitForUpdatesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CancelWaitForUpdates(request *CancelWaitForUpdatesRequestType) (*CancelWaitForUpdatesResponse, error) {
	data, err := service.call("CancelWaitForUpdates", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CancelWaitForUpdatesResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidCollectorVersionFault
* - RuntimeFault
 */
func (service *VimPortType) WaitForUpdatesEx(request *WaitForUpdatesExRequestType) (*WaitForUpdatesExResponse, error) {
	data, err := service.call("WaitForUpdatesEx", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &WaitForUpdatesExResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidPropertyFault
* - RuntimeFault
 */
func (service *VimPortType) RetrievePropertiesEx(request *RetrievePropertiesExRequestType) (*RetrievePropertiesExResponse, error) {
	data, err := service.call("RetrievePropertiesEx", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &RetrievePropertiesExResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidPropertyFault
* - RuntimeFault
 */
func (service *VimPortType) ContinueRetrievePropertiesEx(request *ContinueRetrievePropertiesExRequestType) (*ContinueRetrievePropertiesExResponse, error) {
	data, err := service.call("ContinueRetrievePropertiesEx", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &ContinueRetrievePropertiesExResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - InvalidPropertyFault
* - RuntimeFault
 */
func (service *VimPortType) CancelRetrievePropertiesEx(request *CancelRetrievePropertiesExRequestType) (*CancelRetrievePropertiesExResponse, error) {
	data, err := service.call("CancelRetrievePropertiesEx", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CancelRetrievePropertiesExResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) CreatePropertyCollector(request *CreatePropertyCollectorRequestType) (*CreatePropertyCollectorResponse, error) {
	data, err := service.call("CreatePropertyCollector", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &CreatePropertyCollectorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

/**
* Error can be either of the following types:
*
* - RuntimeFault
 */
func (service *VimPortType) DestroyPropertyCollector(request *DestroyPropertyCollectorRequestType) (*DestroyPropertyCollectorResponse, error) {
	data, err := service.call("DestroyPropertyCollector", "urn:vim25/5.5", request)
	if err != nil {
		return nil, err
	}

	envelope := &gowsdl.SoapEnvelope{}

	err = xml.Unmarshal(data, envelope)
	if err != nil {
		return nil, err
	}

	if envelope.Body.Body == "" {
		log.Printf("%#v\n", envelope.Body)
		return nil, nil
	}

	res := &DestroyPropertyCollectorResponse{}
	err = xml.Unmarshal([]byte(envelope.Body.Body), res)
	if err != nil {
		return nil, err
	}

	return res, nil
}
