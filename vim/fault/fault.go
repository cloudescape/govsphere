//Generated by https://github.com/c4milo/govsphere
//Do not modify
//Copyright (c) 2014, Cloudescape. All rights reserved.

package fault

//
// Base fault for Active Directory related problems.
//
//
type ActiveDirectoryFault struct {
	*VimFault

	// The error code reported by the Active Directory API.
	ErrorCode int32
}

//
// Fault thrown if an attempt to disable the Administrator permission
// on a host of which the Administator permission has already been disabled.
//
//
type AdminDisabled struct {
	*HostConfigFault
}

//
// Fault thrown if an attempt to enable the Administrator permission
// on a host of which the Administator permission is not disabled.
//
//
type AdminNotDisabled struct {
	*HostConfigFault
}

//
// Virtual machine has a configured memory and/or CPU affinity that will
// prevent VMotion. This is an error for powered-on virtual machines.
//
//
type AffinityConfigured struct {
	*MigrationFault

	// Configured affinity types for the virtual machine.
	// See AffinityType for valid values.
	ConfiguredAffinity []string
}

//
// An AgentInstallFailed fault is thrown when VirtualCenter
// fails to install the VirtualCenter agent on a host. For example, a fault is
// thrown if the agent software cannot be uploaded to the host or an error occurred
// during the agent installation.
//
//
type AgentInstallFailed struct {
	*HostConnectFault

	// The output (stdout/stderr) from executing the agent installer.
	//
	// Since vSphere API 4.0
	InstallerOutput string

	// The reason why the agent install failed, if known.
	// Values should come from Reason.
	//
	// Since vSphere API 4.0
	Reason string

	// The status code returned by the agent installer, if it was run.
	//
	// Since vSphere API 4.0
	StatusCode int32
}

//
// AlreadyBeingManaged fault is thrown by the host
// connect method if the host is already being managed
// by a VirtualCenter server.
//
//
type AlreadyBeingManaged struct {
	*HostConnectFault

	// IP address of server that is currently managing the host.
	IpAddress string
}

//
// AlreadyConnect fault is thrown by the host connect method
// if the host is already connected to a VirtualCenter server.
// This might occur if the host has been added more than once
// in the same VirtualCenter in different folders or compute
// resources.
//
//
type AlreadyConnected struct {
	*HostConnectFault

	// Name of the host
	Name string
}

//
// An AlreadyExists fault is thrown when an attempt is made to add an element
// to a collection, if the element's key, name, or identifier already exists in that
// collection.
//
//
type AlreadyExists struct {
	*VimFault

	Name string
}

//
// An AlreadyUpgraded fault is thrown when an attempt is made to upgrade the
// virtual hardware of a Virtual machine whose virtual hardware is already
// up-to-date.
//
//
type AlreadyUpgraded struct {
	*VimFault
}

//
// Could not update the answer file as it has invalid inputs.
//
//
type AnswerFileUpdateFailed struct {
	*VimFault

	// Failures encountered during answer file update
	Failure []*do.AnswerFileUpdateFailure
}

//
// This fault is thrown when creating a quiesced snapshot failed
// because the (user-supplied) custom pre-freeze script in the
// virtual machine exited with a non-zero return code.
//
// This indicates that the script failed to perform its quiescing
// task, which causes us to fail the quiesced snapshot operation.
//
//
//
type ApplicationQuiesceFault struct {
	*SnapshotFault
}

//
// This fault is thrown when the requested change
// would result in a loss of full administrative privileges
// for at least one user or group.
//
//
type AuthMinimumAdminPermission struct {
	*VimFault
}

//
// Thrown if backupConfig blob is corrupted
//
//
type BackupBlobReadFailure struct {
	*DvsFault

	// The entity name on which backupConfig read failed
	EntityName string

	// The entity type on which backupConfig read failed
	EntityType string

	// The fault that occurred.
	Fault *do.LocalizedMethodFault
}

//
// Thrown if backupConfig blob write fails
//
//
type BackupBlobWriteFailure struct {
	*DvsFault

	// The entity name on which backupConfig write failed
	EntityName string

	// The entity type on which backupConfig write failed
	EntityType string

	// The fault that occurred.
	Fault *do.LocalizedMethodFault
}

//
// Fault indicating that firewall configuration prevents
// an operation from completing successfully.
//
//
type BlockedByFirewall struct {
	*HostConfigFault
}

//
// Fault indicating that the CAM server
// cannot be connected.
//
//
type CAMServerRefusedConnection struct {
	*InvalidCAMServer
}

//
// This fault is thrown when an operation fails because of insufficient
// permissions to access a file.
//
//
type CannotAccessFile struct {
	*FileFault
}

//
// An CannotAccessLocalSourceFault exception is thrown when a
// an attempt is made to upload license content
// and the local source cannot be accesed.
//
//
type CannotAccessLocalSource struct {
	*VimFault
}

//
// A network associated with the virtual machine is not accessible. If returned as
// part of migration checks, this is an error if either of the following is true,
// a warning otherwise:
//
//
// • The virtual ethernet card device backing is a distributed virtual switch,
// of which the destination host is not a member
//
// • The virtual ethernet card device backing is a standard network and the
// the device is connected
//
//
//
//
//
type CannotAccessNetwork struct {
	*CannotAccessVmDevice
}

//
// One of the virtual machine's components is not accessible on the execution host.
// This is a base class. Subclasses will encode the type of component that is not
// accessible.
//
//
type CannotAccessVmComponent struct {
	*VmConfigFault
}

//
// One or more of the virtual machine's configuration files are not accessible.
//
//
type CannotAccessVmConfig struct {
	*CannotAccessVmComponent

	// Contains the reason why the VM file could not be found. This is typically
	// a FileFault.
	Reason *do.LocalizedMethodFault
}

//
// One of the virtual machine's devices uses a backing that is not accessible
// on the host.
//
// Following is a discussion of this fault's use in migration validation.
//
//
// This is an error if the device is currently connected  and a warning
// otherwise. Devices that can be disconnected can only be connected if the virtual
// machine is powered on.
//
// The usage of this fault is slightly different if the backing of a device is
// inherently host-local, and therefore not shared or globally named among
// hosts. (Examples of such backings: physical CD-ROM drive, physical serial
// port.) If a device with such a backing is currently connected, that will
// be a migration error. If the device is disconnected, there will be a
// warning if no backing with the same name exists on the destination host.
// If the device is disconnected and a backing with the same name exists on
// the destination host, this is neither a warning nor an error case, even
// though the destination host's backing is not the same instance as the
// source host's. It is assumed that use of the host-local backing is what is
// desired for the device.
//
//
//
type CannotAccessVmDevice struct {
	*CannotAccessVmComponent

	// The backing of the device.
	Backing string

	// The connected/disconnected state of the device.
	Connected bool

	// The label of the device.
	Device string
}

//
// One of the virtual machine's virtual disks is not accessible.
//
//
type CannotAccessVmDisk struct {
	*CannotAccessVmDevice

	// The reason why the disk could not be accessed
	Fault *do.LocalizedMethodFault
}

//
// Can not add a host with fault tolerance vms to be standalone
//
//
type CannotAddHostWithFTVmAsStandalone struct {
	*HostConnectFault
}

//
// Can not add a host with fault tolerance vms to a different cluster other
// than the one used other vms in the same fault tolerance group.
//
//
type CannotAddHostWithFTVmToDifferentCluster struct {
	*HostConnectFault
}

//
// Can not add a host with fault tolerance vms to a non HA enabled cluster
//
//
type CannotAddHostWithFTVmToNonHACluster struct {
	*HostConnectFault
}

//
// This fault is used to report that the DRS behavior cannot be modified
// for a FT secondary virtual machine
//
//
type CannotChangeDrsBehaviorForFtSecondary struct {
	*VmFaultToleranceIssue

	// The virtual machine whose behavior cannot be modified
	Vm *mo.VirtualMachine

	// Name of the virtual machine
	VmName string
}

//
// This fault is used to report that the HA settings cannot be modified
// for a FT secondary virtual machine
//
//
type CannotChangeHaSettingsForFtSecondary struct {
	*VmFaultToleranceIssue

	// The FT secondary virtual machine whose behavior cannot be modified
	Vm *mo.VirtualMachine

	// Name of the FT secondary virtual machine
	VmName string
}

//
// Fault thrown for cases that a VSAN cluster UUID may not be changed.
//
// For example, the VSAN cluster UUID for a host may not be changed so long
// as that host is enabled for VSAN.
//
// The VSAN cluster UUID for a given ClusterComputeResource may
// not be changed so long as that vim.ClusterComputeResource is enabled for
// VSAN.See UpdateVsan_TaskSee ReconfigureComputeResource_Task
//
//
type CannotChangeVsanClusterUuid struct {
	*VsanFault
}

//
// Fault thrown for cases that a VSAN node UUID may not be changed.
//
// For example, the VSAN node UUID for a host may not be changed so long as
// that host is enabled for VSAN.See UpdateVsan_TaskSee ReconfigureComputeResource_Task
//
//
type CannotChangeVsanNodeUuid struct {
	*VsanFault
}

//
// A CannotCreateFile exception is thrown if a file create
// operation fails.
//
//
type CannotCreateFile struct {
	*FileFault
}

//
// The VirtualCenter server is unable to decrypt passwords stored in
// the customization specification.
//
//
type CannotDecryptPasswords struct {
	*CustomizationFault
}

//
// A CannotDeleteFile exception is thrown if a file-deletion
// operation fails.
//
//
type CannotDeleteFile struct {
	*FileFault
}

//
// This fault is thrown when an attempt is made to disable DRS on a cluster,
// which contains a vApp.
//
//
type CannotDisableDrsOnClustersWithVApps struct {
	*RuntimeFault
}

//
// Fault thrown when an attempt is made to disable snapshots on a virtual
// machine which has a snapshot.  To disable the snapshot feature, the
// virtual machine must not currently have a snapshot.
//
//
type CannotDisableSnapshot struct {
	*VmConfigFault
}

//
// This fault is thrown when an attempt is made to disconnect a host, which
// has one or more fault tolerance vms and is not in maintenance mode.
//
//
type CannotDisconnectHostWithFaultToleranceVm struct {
	*VimFault

	// The name of the host to be disconnected
	HostName string
}

//
// A virtual machine's total CPU feature requirements are determined by
// overlaying the requirements specified in its configuration (if any) on top
// of the requirements specified in the descriptor for its guest OS.  It is
// therefore possible for a host change to implicitly change a virtual
// machine's CPU feature requirements.  The guest OS descriptor may have
// different requirements on the new host.  Or, if the virtual machine
// currently specifies requirements in its configuration, those requirements
// will be lost if the new host does not support this.
//
// This fault indicates that the virtual machine's CPU feature requirements
// would change because of a migration, and also that the destination host
// does not support storing CPU feature requirements in the virtual machine's
// configuration.  (If the destination host does support such an action,
// WillModifyConfigCpuRequirements is used instead of this fault.)
//
//
// For a powered-off virtual machine, this is a warning.  The migration may
// proceed, but the virtual machine will be operating under different
// CPU feature requirements if it is powered on after the migration.
//
//
// For a powered-on or suspended virtual machine, this is an error.
//
//
//
type CannotModifyConfigCpuRequirements struct {
	*MigrationFault
}

//
// This fault is thrown when an attempt is made to move a fault tolerance
// vm to a different resource pool or cluster.
//
//
type CannotMoveFaultToleranceVm struct {
	*VimFault

	// The type of the move
	MoveType string

	// The virtual machine name to be moved.
	VmName string
}

//
// This fault is thrown when an attempt is made to move a host which has
// one or more fault tolerance vms out of the current cluster.
//
//
type CannotMoveHostWithFaultToleranceVm struct {
	*VimFault
}

//
// This fault is thrown when an attempt is made to relocate a virtual machine
// with virtual disk(s) having delta disk backing.
//
//
type CannotMoveVmWithDeltaDisk struct {
	*MigrationFault

	// The label of the delta disk device
	Device string
}

//
// This fault is thrown when an attempt is made to migrate a virtual machine
// with native delta disks to different datastores.
//
//
type CannotMoveVmWithNativeDeltaDisk struct {
	*MigrationFault
}

//
// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into an unsuitable ClusterComputeResource.
//
// The destination vim.ClusterComputeResource may be disabled for VSAN, or
// may be using VSAN with a different cluster UUID.See AddHost_TaskSee MoveHostInto_TaskSee MoveInto_TaskSee VsanClusterUuidMismatchSee DestinationVsanDisabled
//
//
type CannotMoveVsanEnabledHost struct {
	*VsanFault
}

//
// This fault is thrown when Storage DRS cannot recommend to place disks of
// a virtual machine without moving existing virtual disks in a
// datastore cluster.
//
//
type CannotPlaceWithoutPrerequisiteMoves struct {
	*VimFault
}

//
// This fault is reported when a user attempts to power off or
// suspend a VM when the HA master agent to which vCenter Server is
// connected does not manage the VM.
//
//
type CannotPowerOffVmInCluster struct {
	*InvalidState

	// The operation being performed. Values come from
	// Operation.
	Operation string

	// The Virtual Machine
	Vm *mo.VirtualMachine

	// Name of the Virtual Machine
	VmName string
}

//
// Fault thrown for the case that an attempt is made to reconfigure VSAN
// when HA is currently enabled for a given ClusterComputeResource.See ReconfigureComputeResource_Task
//
//
type CannotReconfigureVsanWhenHaEnabled struct {
	*VsanFault
}

//
// A network associated with the virtual machine is accessible, but it
// cannot be used for some reason.
//
//
type CannotUseNetwork struct {
	*VmConfigFault

	// The backing of the network device.
	Backing string

	// The connected/disconnected state of the device.
	Connected bool

	// The label of the network device.
	Device string

	// Reason describing why the network cannot be used.
	Reason string
}

//
// Fault indicating that the clock skew in the system exceeds the limit.
//
//
type ClockSkew struct {
	*HostConfigFault
}

//
// An attempt is being made to clone a virtual machine from a snapshot
// point, and this is not supported.
// See snapshotSee snapshotConfigSupportedSee cloneFromSnapshotSupported
//
//
//
type CloneFromSnapshotNotSupported struct {
	*MigrationFault
}

//
// The distributed virtual switch received a reconfiguration request to
// activate ipfix monitoring of the switch traffic. However, the address
// and/or the port of the ipfix collector has not been specified.
//
//
type CollectorAddressUnset struct {
	*DvsFault
}

//
// A ConcurrentAccess fault is thrown when an operation
// fails because another operation has modified the
// datastructure.
//
// For non-transactional operations, such as a recursive
// delete of a subtree of the inventory, the operation might
// fail with ConcurrentAccess if another thread has added
// a new entity to the hierarchy.
//
//
//
type ConcurrentAccess struct {
	*VimFault
}

//
// Thrown if the configurations of the objects are in conflict.
//
//
type ConflictingConfiguration struct {
	*DvsFault

	// The configurations that are in conflict.
	ConfigInConflict []*do.ConflictingConfigurationConfig
}

//
// ConflictingDatastoreFound is thrown when the conflicting datastores
// with the same url but backed by different disks are found in the host
// and the target datacenter.
//
//
type ConflictingDatastoreFound struct {
	*RuntimeFault

	// The name of the datastore.
	Name string

	// The unique locator for the datastore.
	Url string
}

type ConnectedIso struct {
	*OvfExport

	// The CD-ROM drive that caused the event.
	Cdrom *do.VirtualCdrom

	// The filename of the ISO
	Filename string
}

// Deprecated.
// As of VI API 2.5, use CpuIncompatible and its other subclasses,
// not this one.
//
//
// Compatibility between the virtual machine's host and its CPU
// feature requirements cannot be determined, because not enough information
// is available about the CPU features of the host.
//
//
type CpuCompatibilityUnknown struct {
	*CpuIncompatible
}

//
// Thrown when virtual CPUs cannot be hot-added or hot-removed from
// the virtual machine.
//
//
type CpuHotPlugNotSupported struct {
	*VmConfigFault
}

//
// The host is not compatible with the CPU feature requirements of the
// virtual machine, for a particular CPUID register. A subclass of this fault
// may be used to express the incompatibilities in a more easily
// understandable format.
//
//
type CpuIncompatible struct {
	*VirtualHardwareCompatibilityIssue

	// The desired values for the register's bits.  The 'x' character indicates
	// don't-care.
	//
	// Since VI API 2.5
	DesiredBits string

	// The host that is not compatible with the requirements.
	//
	// Since VI API 2.5
	Host *mo.HostSystem

	// The CpuIdInfo level where a problem was detected. Other levels may
	// also have problems.
	Level int32

	// The contents of the register on the target host, in CpuIdInfo register
	// format.  The '-' character indicates an unknown value.
	//
	// Since VI API 2.5
	RegisterBits string

	// The CpuIdInfo register where a problem was detected. Other registers
	// may also have problems. Possible register names are eax, ebx, ecx, or edx.
	RegisterName string
}

//
// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 1 register ecx.
//
//
type CpuIncompatible1ECX struct {
	*CpuIncompatible

	// Flag to indicate bit 25 is incompatible.
	//
	// Since vSphere API 5.0
	Aes bool

	// Flag to indicate that bits other than 0/1/9/19/20/25 are incompatible.
	// I.e. the detected incompatibilities cannot be completely described by
	// the sse3, pclmulqdq, ssse3, sse41, sse42, and/or aes flags.
	Other bool

	// Flag to indicate that the sse3, pclmulqdq, ssse3, sse41, sse42, and aes
	// flags are all false, and the "other" flag is true. Purely a convenience
	// property for the client processing this fault.
	OtherOnly bool

	// Flag to indicate bit 1 is incompatible.
	//
	// Since vSphere API 5.0
	Pclmulqdq bool

	// Flag to indicate bit 0 is incompatible.
	Sse3 bool

	// Flag to indicate bit 19 is incompatible.
	Sse41 bool

	// Flag to indicate bit 20 is incompatible.
	Sse42 bool

	// Flag to indicate bit 9 is incompatible.
	Ssse3 bool
}

//
// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 0x80000001 register edx.
//
//
type CpuIncompatible81EDX struct {
	*CpuIncompatible

	// Flag to indicate bit 25 is incompatible.
	Ffxsr bool

	// Flag to indicate bit 29 is incompatible.
	Lm bool

	// Flag to indicate bit 20 is incompatible.
	Nx bool

	// Flag to indicate that bits other than 20/25/27/29 are incompatible.
	// I.e. the detected incompatibilities cannot be completely described by
	// the nx, ffxsr, rdtscp, and/or lm flags.
	Other bool

	// Flag to indicate that the nx, ffxsr, rdtscp, and lm flags are all false,
	// and the "other" flag is true. Purely a convenience property for the
	// client processing this fault.
	OtherOnly bool

	// Flag to indicate bit 27 is incompatible.
	Rdtscp bool
}

//
// Base for exceptions that can be thrown from the customizer.
//
//
type CustomizationFault struct {
	*VimFault
}

//
// A customization operation is already pending on this virtual
// machine and is awaiting power-up to complete.
//
//
type CustomizationPending struct {
	*CustomizationFault
}

//
// The virtual machine is configured to use a DVPort, which is not
// supported on the host.  This could be because the host
// does not support VDS at all, or because the host has not
// joined a VDS.
//
//
type DVPortNotSupported struct {
	*DeviceBackingNotSupported
}

//
// This fault indicates that some error has occurred during the
// configuration of the host for HA. This may be subclassed by a more specific fault.
//
//
type DasConfigFault struct {
	*VimFault

	// The list of events containing details why the configuration failed, if known.
	//
	// Since vSphere API 4.0
	Event []*do.Event

	// The output (stdout/stderr) from executing the configuration.
	//
	// Since vSphere API 4.0
	Output string

	// The reason why the HA configuration failed, if known.
	// Values should come from DasConfigFaultReason.
	//
	// Since vSphere API 4.0
	Reason string
}

//
// A DatabaseError exception is thrown if an
// operation failed when accessing the external
// database. This typically is because
// the database is (temporarily) unavailable or
// because of network problems.
//
//
type DatabaseError struct {
	*RuntimeFault
}

//
// The input arguments had entities that did not belong to the same
// datacenter.
//
//
type DatacenterMismatch struct {
	*MigrationFault

	// The expected datacenter for the arguments.
	ExpectedDatacenter *mo.Datacenter

	// The list of invalid arguments.
	InvalidArgument []*do.DatacenterMismatchArgument
}

//
// This exception is thrown if a datastore is not
// writable on the target host.
//
//
type DatastoreNotWritableOnHost struct {
	*InvalidDatastore

	// The target host on which the datastore is not writable.
	Host *mo.HostSystem
}

//
// Thrown on an attempt to use an unsupported delta disk format.
//
//
type DeltaDiskFormatNotSupported struct {
	*VmConfigFault

	// The datastores which do not support the specified format.
	Datastore []*mo.Datastore

	// The format not supported.
	//
	// See DeltaDiskFormat.
	DeltaDiskFormat string
}

//
// For one of the networks that the virtual machine is using, the corresponding
// switch on the host is full. If returned as part of migration checks, this is an error
// if either of the following is true, a warning otherwise:
//
//
// • The virtual ethernet card device backing is a distributed virtual switch
//
// • The virtual ethernet card device backing is a standard network and the
// the device is connected
//
//
//
//
//
type DestinationSwitchFull struct {
	*CannotAccessNetwork
}

//
// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into a ClusterComputeResource which is
// disabled for VSAN.See CannotMoveVsanEnabledHost
//
//
type DestinationVsanDisabled struct {
	*CannotMoveVsanEnabledHost

	// Name of the disabled destination ClusterComputeResource.See vim.ClusterComputeResource#name
	DestinationCluster string
}

//
// The device is backed by a backing type which is not supported
// for this particular device.
//
// If this fault is returned as a subfault of
// DisallowedMigrationDeviceAttached, this indicates that although
// this backing for the device may be supported on the destination
// host, the hosts do not support the requested migration of the
// virtual machine while using this device with this backing.
//
//
//
//
//
type DeviceBackingNotSupported struct {
	*DeviceNotSupported

	// The type of the backing.
	Backing string
}

//
// The device in question is supported, but the device-controller
// combination is not supported.
//
// If this fault is returned as a subfault of
// DisallowedMigrationDeviceAttached, this indicates that although
// this device-controller combination may be supported on the
// destination host, the hosts do not support the requested migration
// of the virtual machine while using this device and controller.
//
//
//
//
//
type DeviceControllerNotSupported struct {
	*DeviceNotSupported

	// The type of the controller.
	Controller string
}

//
// A DeviceHotPlugNotSupported exception is thrown if the specified device
// cannot be hot-added or hot-removed from the virtual machine
// at this time.
//
//
type DeviceHotPlugNotSupported struct {
	*InvalidDeviceSpec
}

//
// A DeviceNotFound exception is thrown if
// a device to be edited or removed
// cannot be found. Most likely, the client incorrectly passed
// the device key.
//
//
type DeviceNotFound struct {
	*InvalidDeviceSpec
}

//
// The virtual machine uses a device type that is not supported on the
// host.
//
// If this fault is returned as a subfault of
// DisallowedMigrationDeviceAttached, this indicates that although
// this device may be supported on the destination host, the hosts do
// not support the requested migration of the virtual machine while
// using this device.
//
//
//
type DeviceNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The label of the device.
	Device string

	// The specific reason why the device is not supported.
	// Values should come from DeviceNotSupportedReason.
	// This might not be set if we're not sure of the reason, or
	// if this doesn't make sense in the context.  For example,
	// in the DisallowedMigrationDeviceAttached context
	// we already know the problem.
	//
	// Since VI API 2.5
	Reason string
}

//
// A DeviceUnsupportedForVmPlatform exception is thrown if the specified device
// is not supported on the platform on which the virtual machine is being
// created/configured. For example, this exception might be thrown if a client
// incorrectly attempts to add a device supported only on ESX Server to a
// virtual machine on a hosted product.
//
//
type DeviceUnsupportedForVmPlatform struct {
	*InvalidDeviceSpec
}

//
// A DeviceUnsupportedForVmVersion exception is thrown if a specific device
// is not supported for a given version of the virtual machine.
//
//
type DeviceUnsupportedForVmVersion struct {
	*InvalidDeviceSpec

	// The current version of the virtual machine.
	CurrentVersion string

	// The minimum expected virtual mahcine version needed to
	// support this device.
	ExpectedVersion string
}

//
// This fault is thrown when an operation fails because the specified
// directory is not empty.
//
//
type DirectoryNotEmpty struct {
	*FileFault
}

//
// Fault thrown when an attempt is made to move a disk with associated snapshots to a destination host.
// If such a move were to occur, snapshots associated with the disk would be irrevocably
// lost.  This is always an error.
//
//
type DisableAdminNotSupported struct {
	*HostConfigFault
}

//
// Fault thrown if the disallowed operation is invoked by the client. The
// change is disallowed because it conflicts with target state maintained
// by a service. The corresponding method is usually not disabled because
// only a subset of changes carried out by the method is disallowed. For
// example, an online extend executed via virtual machine reconfigure
// method is not allowed if replication is enabled on a virtual machine.
//
//
type DisallowedChangeByService struct {
	*RuntimeFault

	// The change this is not allowed, the set of possible values is
	// described in DisallowedChangeByServiceDisallowedChange.
	DisallowedChange string

	// The service that has disallowed the change.
	ServiceName string
}

//
// Thrown when the ReconfigVM_Task operation
// includes a change to the VirtualDiskMode
// property. This property cannot be changed as long as a virtual machine
// has an existing snapshot.
//
//
type DisallowedDiskModeChange struct {
	*InvalidDeviceSpec
}

//
// The virtual machine is using a type of device that prevents migration.
//
//
type DisallowedMigrationDeviceAttached struct {
	*MigrationFault

	// A fault specifies the particular device issue. This is typically
	// a subclass of VirtualHardwareCompatibilityIssue, such as
	// RawDiskNotSupported, RemoteDeviceNotSupported, or SharedBusControllerNotSupported
	Fault *do.LocalizedMethodFault
}

//
// Fault thrown when an attempt is made to perform a disallowed operation on a
// host that has been configured as a failover host in an cluster that has High
// Availability enabled. See ClusterFailoverHostAdmissionControlPolicy.
// Examples of such operations are destroying a host, moving a host out of a cluster,
// or powering on a virtual machine on a specific host.
//
//
type DisallowedOperationOnFailoverHost struct {
	*RuntimeFault

	// The failover host.
	Host *mo.HostSystem

	// Name of the failover host.
	Hostname string
}

//
// Fault used for disks which have existing, non-VSAN partitions.See UpdateDiskPartitionsSee QueryDisksForVsan
//
//
type DiskHasPartitions struct {
	*VsanDiskFault
}

//
// Fault thrown for the case that an attempt is made to delete the last
// DiskMapping#nonSsd from a DiskMapping.See RemoveDisk_TaskSee RemoveDiskMapping_Task
//
//
type DiskIsLastRemainingNonSSD struct {
	*VsanDiskFault
}

//
// Fault used for disks which are ineligible for VSAN because they are
// considered non-local.See QueryDisksForVsan
//
//
type DiskIsNonLocal struct {
	*VsanDiskFault
}

//
// Fault used for disks which are ineligible for VSAN because they are USB
// disks.See QueryDisksForVsan
//
//
type DiskIsUSB struct {
	*VsanDiskFault
}

//
// Specifying non-standard disk movement types is not supported.
// See diskMoveTypeSee diskMoveType
//
//
//
type DiskMoveTypeNotSupported struct {
	*MigrationFault
}

//
// The host does not support the backings for the disks specified by the virtual
// machine. For example, this fault is thrown if a virtual machine is created from
// a template that specifies backings that the host does not have. Similarly, this fault
// is thrown if a virtual machine is registered on a host that does not support the
// specified backings.
//
//
type DiskNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The ID of disk that is not supported.
	Disk int32
}

//
// Fault used for disks which are too small for usage by VSAN.
//
//
type DiskTooSmall struct {
	*VsanDiskFault
}

//
// Fault indicating that the domain controller
// for domainName cannot be reached.
//
//
type DomainNotFound struct {
	*ActiveDirectoryFault

	// The domain that cannot be accessed.
	DomainName string
}

//
// This fault is thrown when DRS cannot move a virtual machine because
// DRS is disabled on it (i.e., it is pinned on its registered host).
//
//
type DrsDisabledOnVm struct {
	*VimFault
}

//
// This fault is thrown when DRS tries to migrate a virtual machine to a host,
// but finds that the host is incompatible with the given virtual machine.
//
//
type DrsVmotionIncompatibleFault struct {
	*VirtualHardwareCompatibilityIssue

	// The host that is incompatible with a given virtual machine.
	Host *mo.HostSystem
}

//
// Fault used to denote a duplicate set of disks were incorrectly specified
// for a given operation.See AddDisks_TaskSee InitializeDisks_Task
//
//
type DuplicateDisks struct {
	*VsanDiskFault
}

//
// A DuplicateName exception is thrown because a name already exists
// in the same name space.
//
//
type DuplicateName struct {
	*VimFault

	// The name that is already bound in the name space.
	Name string

	// Managed object that already holds the name.
	Object *do.ManagedObjectReference
}

//
// Fault thrown for cases that duplicate network interface names are
// incorrectly specified for a VSAN operation.See UpdateVsan_TaskSee ReconfigureComputeResource_Task
//
//
type DuplicateVsanNetworkInterface struct {
	*VsanFault

	// The network interface name found to be duplicated.
	Device string
}

//
// Thrown if a vSphere Distributed Switch apply operation failed to set or remove
// some of the specified objects.
//
//
type DvsApplyOperationFault struct {
	*DvsFault

	// Faults occured on the host during a DistributedVirtualSwitch operation.
	ObjectFault []*do.DvsApplyOperationFaultFaultOnObject
}

//
// Base class for faults that can be thrown while invoking a distributed virtual switch
// operation.
//
//
type DvsFault struct {
	*VimFault
}

//
// Thrown if
// dvsOperationSupported
// is false and extensionKey is not same
// as the extension key of the login-session.
//
//
type DvsNotAuthorized struct {
	*DvsFault

	// The value of extensionKey.
	DvsExtensionKey string

	// The extension key associated with the user-session.
	SessionExtensionKey string
}

//
// Thrown if a DistributedVirtualSwitch operation failed on some of the host members.
//
//
type DvsOperationBulkFault struct {
	*DvsFault

	// Faults occured on the host during a DistributedVirtualSwitch operation.
	HostFault []*do.DvsOperationBulkFaultFaultOnHost
}

// Deprecated.
// as of vSphere API 5.5
//
//
// Thrown if a entity trying to connect to a port or portgroup but it is not in the
// port or portgroup's scope.
//
//
type DvsScopeViolated struct {
	*DvsFault

	// The entity that violates the scope.
	Entity *mo.ManagedEntity

	// The configured scope.
	Scope []*mo.ManagedEntity
}

//
// The host does not satisfy the admission requirements for the Enhanced
// VMotion Compatibility mode of the cluster.
//
//
type EVCAdmissionFailed struct {
	*NotSupportedHostInCluster

	// The faults that caused this EVC test to fail
	// (e.g. FeatureRequirementsNotMet faults).
	//
	// Since vSphere API 5.1
	Faults []*do.LocalizedMethodFault
}

//
// The host's CPU hardware is a family/model that should support the
// Enhanced VMotion Compatibility mode of the cluster, but some necessary
// CPU features are not present.
//
//
type EVCAdmissionFailedCPUFeaturesForMode struct {
	*EVCAdmissionFailed

	// The Enhanced VMotion Compatibility mode that is currently in effect for
	// the cluster.
	CurrentEVCModeKey string
}

//
// The host's CPU hardware is a family/model that does not support any
// Enhanced VMotion Compatibility mode.
//
//
type EVCAdmissionFailedCPUModel struct {
	*EVCAdmissionFailed
}

//
// The host's CPU hardware is a family/model that does not support the Enhanced
// VMotion Compatibility mode of the cluster.
//
//
type EVCAdmissionFailedCPUModelForMode struct {
	*EVCAdmissionFailed

	// The Enhanced VMotion Compatibility mode that is currently in effect for
	// the cluster.
	CurrentEVCModeKey string
}

//
// The host's CPU vendor does not match the required CPU vendor for the
// Enhanced VMotion Compatibility mode of the cluster.
//
//
type EVCAdmissionFailedCPUVendor struct {
	*EVCAdmissionFailed

	// The CPU vendor required for entering the cluster.
	ClusterCPUVendor string

	// The CPU vendor of the host.
	HostCPUVendor string
}

//
// The host's CPU vendor is unknown, which prevents admission into an Enhanced
// VMotion Compatibility cluster.
//
//
type EVCAdmissionFailedCPUVendorUnknown struct {
	*EVCAdmissionFailed
}

//
// The host is not connected, which prevents admission into an Enhanced
// VMotion Compatibility cluster.
//
//
type EVCAdmissionFailedHostDisconnected struct {
	*EVCAdmissionFailed
}

//
// The host's software does not support any Enhanced VMotion Compatibility mode.
//
//
type EVCAdmissionFailedHostSoftware struct {
	*EVCAdmissionFailed
}

//
// The host's software does not support the Enhanced VMotion Compatibility
// mode of the cluster.
//
//
type EVCAdmissionFailedHostSoftwareForMode struct {
	*EVCAdmissionFailed
}

//
// An attempt to move or add a host into an Enhanced VMotion Compatibility
// cluster has failed for the following reason:
//
//
// • The host exposes additional compatibility-relevant CPU features beyond
// those present in the baseline mandated by the cluster's EVC mode.
//
// • The host has powered-on or suspended virtual machines.
//
//
//
// Therefore the host may not be admitted into the cluster, since its virtual
// machines may be using CPU features suppressed in the cluster.
//
// Note that in rare cases, this may occur even if the host's
// maxEVCModeKey corresponds to the EVC
// mode of the cluster.  This means that even though that EVC mode is the best
// match for the host's hardware, the host still has some features beyond
// those present in the baseline for that EVC mode.
//
//
//
type EVCAdmissionFailedVmActive struct {
	*EVCAdmissionFailed
}

//
// Only virtual machines on eight different hosts can have a single
// virtual disk backing opened for read at once.
//
// This fault occurs when moving or powering on this virtual
// machine would cause a violation of the above constraint.
// This only occurs when multiple virtual machines are sharing a
// single disk backing.
//
//
// Note that there is no limit on the number of virtual machines
// who share a disk backings, so long as they are running on
// eight or fewer hosts.
//
//
//
type EightHostLimitViolated struct {
	*VmConfigFault
}

//
// An ExpiredAddonLicense fault is thrown if an attempt to acquire an Addon license
// 'feature failed for count 'count'.
//
//
type ExpiredAddonLicense struct {
	*ExpiredFeatureLicense
}

//
// An ExpiredEditionLicense fault is thrown if an attempt to acquire an Edition license
// 'feature failed for count 'count'.
//
//
type ExpiredEditionLicense struct {
	*ExpiredFeatureLicense
}

//
// An ExpiredFeatureLicense fault is thrown if an attempt to acquire an Addon license
// 'feature failed for count 'count'.
//
//
type ExpiredFeatureLicense struct {
	*NotEnoughLicenses

	Count int32

	ExpirationDate time.Time

	Feature string
}

//
// This fault is the container for faults logged by extensions.
//
//
type ExtendedFault struct {
	*VimFault

	// Key/value pairs associated with fault.
	Data []*do.KeyValue

	// The id of the type of extended fault.
	FaultTypeId string
}

//
// Fault type that could be thrown when enabling SPBM(Storage Policy
// Based Management) feature of a compute resource.
//
//
type FailToEnableSPBM struct {
	*NotEnoughLicenses

	// The compute resource
	Cs *mo.ComputeResource

	// The computer resource name
	CsName string

	// Array of ComputeResourceHostSPBMLicenseInfo that
	// contains SPBM license information for all hosts in the compute resource
	HostLicenseStates []*do.ComputeResourceHostSPBMLicenseInfo
}

//
// Thrown when trying to state lock a Fault Tolerance VM, and the
// other VM in the same Fault Tolerance pair is already locked.
//
//
type FailToLockFaultToleranceVMs struct {
	*RuntimeFault

	// The vm that is already locked, this can be a Fault Tolerance primary or secondary VM
	AlreadyLockedVm *mo.VirtualMachine

	// The vm to be locked, this can be a Fault Tolerance primary or secondary VM
	Vm *mo.VirtualMachine

	// The name of the vm to be locked.
	VmName string
}

//
// More than one VM in the same fault tolerance group are placed on the same host
//
//
type FaultToleranceAntiAffinityViolated struct {
	*MigrationFault

	// The host.
	Host *mo.HostSystem

	// The name of the host.
	HostName string
}

//
// The memory size, reservation, limit or shares of a virtual machine cannot
// be edited if Fault Tolerance is turned on
//
//
type FaultToleranceCannotEditMem struct {
	*VmConfigFault

	// The VM.
	Vm *mo.VirtualMachine

	// The name of the VM.
	VmName string
}

//
// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 1 register ecx for FT vms.
//
//
type FaultToleranceCpuIncompatible struct {
	*CpuIncompatible

	// Flag to indicate CPU family is incompatible.
	Family bool

	// Flag to indicate CPU model is incompatible.
	Model bool

	// Flag to indicate CPU stepping is incompatible.
	Stepping bool
}

//
// Fault Tolerance VM requires thick disks
//
//
type FaultToleranceNeedsThickDisk struct {
	*MigrationFault

	// The name of the VM.
	VmName string
}

//
// This fault is thrown when fault tolerance has not been licensed on the
// source or destination host. It must be licensed on both hosts.
//
//
type FaultToleranceNotLicensed struct {
	*VmFaultToleranceIssue

	// The host name
	HostName string
}

//
// The destination host does not have the same build or Fault Tolerance
// feature version number as the source host.
//
//
type FaultToleranceNotSameBuild struct {
	*MigrationFault

	// The string.
	Build string
}

//
// This fault is used to report that VirtualCenter did not attempt to power on
// a Fault Tolerance secondary virtual machine because it was unable to
// power on the corresponding Fault Tolerance primary virtual machine.
//
//
type FaultTolerancePrimaryPowerOnNotAttempted struct {
	*VmFaultToleranceIssue

	// The corresponding primary virtual machine
	PrimaryVm *mo.VirtualMachine

	// The secondary virtual machine that was not attempted
	SecondaryVm *mo.VirtualMachine
}

//
// A FaultToleranceVmNotDasProtected fault occurs when an Fault Tolerance VM
// is not protected by HA and the operation for terminating the primary VM
// or secondary VM is invoked.
//
//
type FaultToleranceVmNotDasProtected struct {
	*VimFault

	// The Fault Toelrance primary VM
	Vm *mo.VirtualMachine

	// Name of the VM
	VmName string
}

//
// Base class for faults that can be thrown while invoking FCoE management operations.
//
//
type FcoeFault struct {
	*VimFault
}

//
// This fault indicates the given Software Fcoe NIC has no uplink ports
// that is required for initiating a discovery.
//
//
type FcoeFaultPnicHasNoPortSet struct {
	*FcoeFault

	NicDevice string
}

//
// The host does not meet feature requirements of the virtual machine.
//
//
type FeatureRequirementsNotMet struct {
	*VirtualHardwareCompatibilityIssue

	// The feature requirements that were not met.
	FeatureRequirement []*do.VirtualMachineFeatureRequirement

	// The host whose capabilities did not meet the virtual machine's feature requirements.
	Host *mo.HostSystem

	// The virtual machine whose feature requirements were not met.
	Vm *mo.VirtualMachine
}

//
// This fault is thrown when an operation attempts to create a file using the name of
// an existing file.
//
//
type FileAlreadyExists struct {
	*FileFault
}

//
// The virtual machine has a port (either a SerialPort or a ParallelPort) which is
// backed by a file. This is an error when migrating a virtual machine with the device
// connected, and can be returned as a subfault of DisallowedMigrationDeviceAttached.
//
//
type FileBackedPortNotSupported struct {
	*DeviceNotSupported
}

//
// The common base type for all file-related exceptions.
//
//
type FileFault struct {
	*VimFault

	// The file in question.
	File string
}

//
// Thrown if an attempt is made to lock a file that is already in use.
//
//
type FileLocked struct {
	*FileFault
}

//
// This fault is thrown when an operation fails because the name of the
// specified file is too long.
//
//
type FileNameTooLong struct {
	*FileFault
}

//
// This fault is thrown when an operation fails because the specified file
// does not exist.
//
//
type FileNotFound struct {
	*FileFault
}

//
// Thrown if an attempt is made to write to a read-only file.
//
//
type FileNotWritable struct {
	*FileFault
}

//
// This fault is thrown when an operation fails because the file is larger
// than the maximum file size supported by the datastore.
//
//
type FileTooLarge struct {
	*FileFault

	// The name of the datastore that does not support the file's size.
	Datastore string

	// The size (in bytes) of the file.
	FileSize int64

	// The max file size (in bytes) supported on the datastore.
	MaxFileSize int64
}

//
// This fault is thrown when creating a quiesced snapshot failed
// because the create snapshot operation exceeded the time limit
// for holding off I/O in the frozen VM.
//
// This indicates that when we attempted to thaw the VM after
// creating the snapshot, we got an error back indicating that
// the VM was not frozen anymore. In this case, we roll back
// the entire snapshot create operation and throw this exception.
//
//
//
type FilesystemQuiesceFault struct {
	*SnapshotFault
}

//
// The FtIssuesOnHost fault reports issues that prevent a particular
// host from being used as the register or power on host for a Fault
// Tolerance secondary virtual machine
//
//
type FtIssuesOnHost struct {
	*VmFaultToleranceIssue

	// Information on the details of the Fault Tolerance issues
	Errors []*do.LocalizedMethodFault

	// The host which has Fault Tolerance issues.
	Host *mo.HostSystem

	// Name for the host which has Fault Tolerance issues.
	HostName string
}

//
// An operation on a powered-on virtual machine requests a simultaneous change
// of storage location and execution host, but the host does not have that
// capability.
//
//
type FullStorageVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// DRS returns more than one faults for each virtual machine, or DRS returns
// VimFault because of some internal errors.
//
//
type GenericDrsFault struct {
	*VimFault

	// This is an optional field to return the detailed information back to
	// the client. This optional array may consist of the exact fault for
	// some hosts in the cluster.
	HostFaults []*do.LocalizedMethodFault
}

//
// Thrown when a running virtual machine reports an error.
//
//
type GenericVmConfigFault struct {
	*VmConfigFault

	// Message from the virtual machine
	Reason string
}

//
// Fault is thrown when a call to AcquireCredentialsInGuest requires a challenge
// response in order to authenticate in the guest. The authToken string
// in serverChallenge contains a base64 encoded challenge token.
//
//
type GuestAuthenticationChallenge struct {
	*GuestOperationsFault

	// Contains the server challenge information
	ServerChallenge *do.GuestAuthentication

	// Contains a session ID number that associates the server response
	// with the initial request.
	SessionID int64
}

//
// A GuestComponentsOutOfDate exception is thrown when an
// operation fails because the guest operations agent is out of date and lacks
// the functionality to execute the operation.
//
//
type GuestComponentsOutOfDate struct {
	*GuestOperationsFault
}

//
// The common base type for all guest operations faults.
//
//
type GuestOperationsFault struct {
	*VimFault
}

//
// A GuestOperationsUnavailable exception is thrown when an
// operation fails to contact the guest operations agent
// running inside the virtual machine.
//
//
type GuestOperationsUnavailable struct {
	*GuestOperationsFault
}

//
// A GuestPermissionDenied exception is thrown when an
// operation fails because the authentication used
// is insufficient to perform the operation.
//
//
type GuestPermissionDenied struct {
	*GuestOperationsFault
}

//
// A GuestProcessNotFound exception is thrown when an
// operation fails because the guest process specified does not exist.
//
//
type GuestProcessNotFound struct {
	*GuestOperationsFault

	// The process ID that was not found.
	Pid int64
}

//
// The destination compute resource is HA-enabled, and HA is not running
// properly.  This will cause the following problems:
// 1) The VM will not have HA protection.
// 2) If this is an intracluster VMotion, HA will not be properly
// informed that the migration completed.  This can have serious
// consequences to the functioning of HA.
//
//
type HAErrorsAtDest struct {
	*MigrationFault
}

//
// Fault thrown when an attempt is made to adjust resource settings
// directly on a host that is being managed by VC. VC is currently the
// source of truth for all resource pools on the host.
//
// Examples of methods affected by this are:
// •  create respool
//
// •  update respool
//
// •  change VM resource settings.
//
//
type HostAccessRestrictedToManagementServer struct {
	*NotSupported
}

//
// A HostCommunication fault is thrown if an error happened
// while communicating to a host. This would typically be
// due to network connections or server failures.
//
//
type HostCommunication struct {
	*RuntimeFault
}

//
// Fault to indicate configuration of the host failed.
// Configuration could have failed because of multiple
// reasons and individual failures will be reported in
// #failure.
//
//
type HostConfigFailed struct {
	*HostConfigFault

	Failure []*do.LocalizedMethodFault
}

//
// Base class for all Host configuration related faults
//
//
type HostConfigFault struct {
	*VimFault
}

//
// A base clase for faults that are related to connecting or
// adding a host to the inventory.
//
//
type HostConnectFault struct {
	*VimFault
}

//
// Fault indicating that an operation cannot be performed while
// the host is part of a Windows domain.
//
//
type HostInDomain struct {
	*HostConfigFault
}

//
// This fault is thrown when an attempt is made to configure a fault tolerant
// virtual machine on a host that is incompatible.
//
//
type HostIncompatibleForFaultTolerance struct {
	*VmFaultToleranceIssue

	HostName string

	// The specific reason why the host does not support fault tolerance.
	// Values should come from HostIncompatibleForFaultToleranceReason.
	Reason string
}

//
// This fault is thrown when an attempt is made record or replay
// a virtual machine on a host that is incompatible.
//
//
type HostIncompatibleForRecordReplay struct {
	*VimFault

	HostName string

	// The specific reason why the host does not support record/replay.
	// Values should come from HostIncompatibleForRecordReplayReason.
	Reason string
}

//
// A HostInventoryFull is thrown if the inventory has reach the max capacity of hosts.
//
//
type HostInventoryFull struct {
	*NotEnoughLicenses

	Capacity int32
}

//
// A HostNotConnected fault is thrown if a method needs
// to communicate with a host that has been disconnected in
// VirtualCenter.
//
//
type HostNotConnected struct {
	*HostCommunication
}

//
// A HostNotReachable fault is thrown if the server was unable
// to communicate with the host
//
//
type HostNotReachable struct {
	*HostCommunication
}

//
// This fault is thrown when a host power operation fails.
//
//
type HostPowerOpFailed struct {
	*VimFault
}

//
// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the virtual machine is currently powered on.
//
//
type HotSnapshotMoveNotSupported struct {
	*SnapshotCopyNotSupported
}

// Deprecated.
// As of VI API 2.5, use DeviceControllerNotSupported.
//
//
// The virtual machine uses a virtual disk with an IDE controller, but this
// is not supported on the host.
//
//
type IDEDiskNotSupported struct {
	*DiskNotSupported
}

//
// A IORMNotSupportedHostOnDatastore fault occurs when the datastore is connected
// to one or more hosts that do not support storage I/O resource management.
//
//
type IORMNotSupportedHostOnDatastore struct {
	*VimFault

	// The datastore.
	Datastore *mo.Datastore

	// The name of the datastore.
	DatastoreName string

	// The list of hosts that do not support storage I/O
	// resource management.
	Host []*mo.HostSystem
}

//
// Thrown if failure occurs while adding host to DVS during import operation
//
//
type ImportHostAddFailure struct {
	*DvsFault

	// Hosts on which import operation failed
	HostIp []string
}

//
// Thrown if a Import operation fails
//
//
type ImportOperationBulkFault struct {
	*DvsFault

	// Faults occurred during the import operation
	ImportFaults []*do.ImportOperationBulkFaultFaultOnImport
}

//
// A InUseFeatureManipulationDisallowed fault is thrown if an Vim.LicenseAssignmentManager.SetFeatureInUse or Vim.LicenseAssignmentManager.ResetFeatureInUse call can not complete because a feature is not available or the manipulation is not allowed.
//
//
type InUseFeatureManipulationDisallowed struct {
	*NotEnoughLicenses
}

//
// An InaccessibleDatastore exception is thrown if the datastore corresponding to the
// given datastore path isn't currently accessible.
//
//
type InaccessibleDatastore struct {
	*InvalidDatastore

	// Since vSphere API 5.0
	Detail string
}

//
// An InaccessibleVFlashSource exception is thrown when
// an attempt is made to access the vFlash resource on
// the host, such as creating vFlash cache file for the
// virtual disk.
//
//
type InaccessibleVFlashSource struct {
	*VimFault

	// Name of the host which has the vFlash resource
	HostName string
}

//
// A default device (see defaultDevice for a
// definition) which the virtual machine is using is incompatible with
// the corresponding default device which will be created on the target host.
//
// This is an issue with powered-on or suspended migration under some
// circumstances.  The problem is that in cases where the virtual machine
// must be recreated, it will have the default device created with default
// settings that are appropriate for the target host.  If those are not
// compatible with the settings for that device that the virtual machine is currently
// using, then resuming the virtual machine on the target host might fail.
//
//
// This might happen if the device in question were reconfigured or the default
// is different between the source and the destination host.  An example of
// a default device and associated setting which might cause this is
// videoRamSizeInKB.
// This is an error.
//
//
//
type IncompatibleDefaultDevice struct {
	*MigrationFault

	// The label of the device.
	Device string
}

//
// The IncompatibleHostForFtSecondary fault is thrown when an invalid
// host has been specified when calling CreateSecondaryVM_Task
// or EnableSecondaryVM_Task.
//
//
type IncompatibleHostForFtSecondary struct {
	*VmFaultToleranceIssue

	// Information on why the host that was specified could not be used for
	// the FaultTolerance Secondary VirtualMachine.
	Error []*do.LocalizedMethodFault

	// The host that is not compatible with the secondary virtual machine.
	Host *mo.HostSystem
}

//
// Thrown when two parameters in the customization settings conflict with each other.
// For example, a client may not specify both a Workgroup and a DomainName.
//
//
type IncompatibleSetting struct {
	*InvalidArgument

	// The name of the setting that is conflicting.
	ConflictingProperty string
}

//
// Thrown when an operation fails because the files do not match a
// specified file type.
//
//
type IncorrectFileType struct {
	*FileFault
}

//
// A IncorrectHostInformation is thrown if the host does not provide the information
// needed to acquire the correct set of licenses.
//
//
type IncorrectHostInformation struct {
	*NotEnoughLicenses
}

//
// An operation on a powered-on virtual machine requests that the virtual
// machine's disks be moved without choosing a new home datastore for the
// virtual machine, but the host does not have that capability.
//
//
type IndependentDiskVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// This fault is returned when the required number of deployed agent virtual
// machines is not currently deployed on a host and hence the host cannot be
// used to run client virtual machines.
//
//
type InsufficientAgentVmsDeployed struct {
	*InsufficientResourcesFault

	// The number of agent virtual machines currently deployed on the host.
	CurrentNumAgentVms int32

	HostName string

	// The number of agent virtual machines required to be deployed on the host.
	RequiredNumAgentVms int32
}

//
// CPU resources admission control failed
//
//
type InsufficientCpuResourcesFault struct {
	*InsufficientResourcesFault

	// The CPU resource amount requested in the failed operation in MHz.
	Requested int64

	// The CPU available in the resource pool requested in MHz.
	Unreserved int64
}

//
// Fault used to denote an insufficient group of disks for a given operation.See AddDisks_TaskSee InitializeDisks_Task
//
//
type InsufficientDisks struct {
	*VsanDiskFault
}

//
// This is thrown if an operation would violate the configured failover level of a HA
// cluster.
//
// In a HA cluster, virtual machines provide high availability by moving among physical
// machines in the event of a failure. HA Admission Control ensures that the total
// resource requirements for the set of virtual machines in a HA cluster does not exceed
// the resources that would be available in the worst-case scenario failure. If HA
// Admission Control is not used, physical machines may have insufficient resources to
// provide the expected level of service.
//
//
// This fault indicates that the virtual machine operation you attempted would have
// created a situation where the remaining physical machines would not meet the needs of
// the virtual machines in the event of a failure.
//
//
//
type InsufficientFailoverResourcesFault struct {
	*InsufficientResourcesFault
}

//
// The host does not have enough capacity for running the virtual machine.
//
//
type InsufficientHostCapacityFault struct {
	*InsufficientResourcesFault

	// The host which does not have the enough capacity.
	//
	// Since VI API 2.5
	Host *mo.HostSystem
}

//
// The host does not have enough CPU capacity for running the virtual machine.
//
//
type InsufficientHostCpuCapacityFault struct {
	*InsufficientHostCapacityFault

	// The CPU resource amount requested in the failed operation in MHz.
	Requested int64

	// The CPU available on the host in MHz.
	Unreserved int64
}

//
// The host does not have enough memory capacity for running the virtual machine.
//
//
type InsufficientHostMemoryCapacityFault struct {
	*InsufficientHostCapacityFault

	// The memory resource amount requested in the failed operation in bytes.
	Requested int64

	// The memory available on the host in bytes.
	Unreserved int64
}

//
// Memory resource admission control failed
//
//
type InsufficientMemoryResourcesFault struct {
	*InsufficientResourcesFault

	// The memory resource amount requested in the failed operation in bytes.
	Requested int64

	// The memory available in the resource pool requested in bytes.
	Unreserved int64
}

//
// The host does not have enough per CPU capacity.
//
//
type InsufficientPerCpuCapacity struct {
	*InsufficientHostCapacityFault
}

//
// Base fault that occurs when an operation conflicts with a resource configuration
// policy. For example, this fault occurs if a power-on operation reserves more memory
// than is allocated to a resource pool.
//
//
type InsufficientResourcesFault struct {
	*VimFault
}

//
// This fault is thrown when Distributed Power Management cannot perform
// a given opeartion because there is insufficient CPU resource
// on standby hosts (if any) to meet the requirements of the operation.
//
//
type InsufficientStandbyCpuResource struct {
	*InsufficientStandbyResource

	// The total amount of CPU resource available (in MHz) on all the usable hosts
	// in the cluster (including powered on and standby hosts).
	Available int64

	// The additional amount of CPU resource (other than that on the hosts included
	// in "available") needed (in MHz).
	Requested int64
}

//
// This fault is thrown by Distributed Power Management algorithm. It indicates
// that there are insufficient memory resources on standby hosts (if any)
// to meet the requirements of a given operation.
//
//
type InsufficientStandbyMemoryResource struct {
	*InsufficientStandbyResource

	// The total amount of memory resource available (in bytes) on all the usable hosts
	// in the cluster (including powered on and standby hosts).
	Available int64

	// The additional amount of memory resource (other than that on the hosts included
	// in "available") needed (in bytes).
	Requested int64
}

//
// This fault is thrown when Distributed Power Management cannot perform
// a given opeartion because there are insufficient CPU/memory resources
// on standby hosts (if any) to meet the requirements of the operation.
//
//
type InsufficientStandbyResource struct {
	*InsufficientResourcesFault
}

//
// The fault occurs when Storage DRS cannot perform a given operation (e.g., fix the
// out of space condition, or place a virtual disk) because there is insufficient
// storage space in the given storage pod to meet the requirements of the operation.
//
//
type InsufficientStorageSpace struct {
	*InsufficientResourcesFault
}

//
// Insufficient vFlash resource to consume
//
//
type InsufficientVFlashResourcesFault struct {
	*InsufficientResourcesFault

	// The vFlash resource available capacity in bytes.
	FreeSpace int64

	// The vFlash resource amount requested in bytes.
	RequestedSpace int64
}

//
// An InvalidAffinitySettingsFault is thrown if an invalid affinity setting is
// specified for a virtual machine.
//
//
type InvalidAffinitySettingFault struct {
	*VimFault
}

//
// An InvalidArgument exception is thrown if the
// set of arguments passed to the function is not
// specified correctly.
//
//
type InvalidArgument struct {
	*RuntimeFault

	// Optional name of the invalid property.
	InvalidProperty string
}

//
// An InvalidBmcRole fault is thrown when a BMC user doesn't have the necessary
// privileges. BMC (Board Management Controller) is a piece of hardware required for
// IPMI.
//
//
type InvalidBmcRole struct {
	*VimFault
}

//
// An Invalid Bundle fault is thrown if an operation fails because of a
// problem with the supplied bundle.
//
//
type InvalidBundle struct {
	*PlatformConfigFault
}

//
// Fault indicating that the CAM server's certificate
// cannot be verified.
//
//
type InvalidCAMCertificate struct {
	*InvalidCAMServer
}

//
// Fault indicating that the CAM server
// for camServer cannot be reached,
// or is not a valid IP address.
//
//
type InvalidCAMServer struct {
	*ActiveDirectoryFault

	// The address of the CAM server.
	CamServer string
}

//
// This exception is thrown when a client has provided a
// certificate that fails certificate validation at the server.
//
//
type InvalidClientCertificate struct {
	*InvalidLogin
}

//
// InvalidCollectorVersion is thrown when a collector version is out
// of date or invalid.
//
//
type InvalidCollectorVersion struct {
	*MethodFault
}

//
// An InvalidController exception is thrown if
// a device refers to a controller that cannot be found.
// For example, an exception might be thrown if the client
// incorrectly passes a controller key,
// or if the client did not specify a controller where one is
// required (such as for disks or CD-ROMs).
//
//
type InvalidController struct {
	*InvalidDeviceSpec

	ControllerKey int32
}

//
// This fault is thrown when an attempt is made to configure an HA cluster with
// invalid argument.
//
//
type InvalidDasConfigArgument struct {
	*InvalidArgument

	// Name of the cluster to be configured
	ClusterName string

	// The entry for the invalid argument
	Entry string
}

//
// This fault is thrown when an attempt is made to set the DAS restart
// priority of a FT VM to disabled.
//
//
type InvalidDasRestartPriorityForFtVm struct {
	*InvalidArgument

	// The virtual machine
	Vm *mo.VirtualMachine

	// The name of the virtual machine
	VmName string
}

//
// An InvalidDatastore exception is thrown if an operation fails because of a
// problem with the specified datastore. Typically, a subclass of this
// exception is thrown, indicating a problem such as an inaccessible datastore
// or an invalid datastore path.
//
//
type InvalidDatastore struct {
	*VimFault

	// The datastore that is invalid.
	Datastore *mo.Datastore

	// The name of the datastore that is invalid.
	Name string
}

//
// An InvalidDatastorePath exception is thrown if a datastore path violates
// the expected format. The expected format is "[dsName] path", e.g.
// "[storage1] folder/Vm1.vmdk".  This exception is also thrown if a datastore
// corresponding to the given datastore path is not found.
//
//
type InvalidDatastorePath struct {
	*InvalidDatastore

	// The invalid datastore path name, if one was provided.
	DatastorePath string
}

//
// The datastore is in an invalid state (e.g., maintenance mode)
// for a given operation.
//
//
type InvalidDatastoreState struct {
	*InvalidState

	// The name of the datastore.
	DatastoreName string
}

//
// An InvalidDeviceBacking exception is thrown if
// a device with an incompatible
// device backing is added or edited.
//
//
type InvalidDeviceBacking struct {
	*InvalidDeviceSpec
}

//
// An InvalidDeviceOperation exception is thrown if
// virtual machine creation or configuration fails because an invalid
// operation is attempted on the given device.
//
//
type InvalidDeviceOperation struct {
	*InvalidDeviceSpec

	// The invalid file operation attempted.
	BadFileOp *enum.VirtualDeviceConfigSpecFileOperation

	// The invalid operation attempted.
	BadOp *enum.VirtualDeviceConfigSpecOperation
}

//
// An InvalidDeviceSpec exception is thrown if
// a virtual machine creation or configuration fails because a device
// specification contains an invalid value.
//
//
type InvalidDeviceSpec struct {
	*InvalidVmConfig

	// Index of the device in the configuration specification that has the invalid value.
	DeviceIndex int32
}

//
// The disk format is either corrupted or not supported.
//
//
type InvalidDiskFormat struct {
	*InvalidFormat
}

//
// This fault is thrown when an attempt is made to set the DRS behavior
// of an FT VM to an unsupported value. Currently, the only supported
// behavior is DRS Disabled.
//
//
type InvalidDrsBehaviorForFtVm struct {
	*InvalidArgument

	// The virtual machine
	Vm *mo.VirtualMachine

	// The name of the virtual machine
	VmName string
}

//
// An ExpiredEditionLicense fault is thrown if an attempt to acquire an Edition license
// 'feature failed for count 'count'.
//
//
type InvalidEditionLicense struct {
	*NotEnoughLicenses

	Feature string
}

//
// A InvalidEvent fault is thrown when the event
// is malformed.
//
//
type InvalidEvent struct {
	*VimFault
}

//
// An InvalidFolderFault exception is thrown when a
// node is moved to an invalid place in the hierarchy.
//
// This can be because it is a child of the current node,
// or a wrong kind of container.
//
//
//
type InvalidFolder struct {
	*VimFault

	// Reference to invalid target.
	Target *mo.ManagedEntity
}

//
// Throws when an invalid format is detected. For example, when
// a virtual machine is registered and the system is unable to parse
// the files as a virtual machine.
//
//
type InvalidFormat struct {
	*VmConfigFault
}

//
// An InvalidGuestLogin exception is thrown when an operation fails because
// authentication information used to authenticate with the guest was not
// accepted.
//
//
type InvalidGuestLogin struct {
	*GuestOperationsFault
}

//
// The host has an invalid connection state.
//
//
type InvalidHostConnectionState struct {
	*InvalidHostState
}

//
// The attempted operation requires that the host has a suitable FQDN.
//
//
type InvalidHostName struct {
	*HostConfigFault
}

//
// The host has an invalid state.
//
//
type InvalidHostState struct {
	*InvalidState

	// The host that has an invalid state.
	Host *mo.HostSystem
}

//
// An InvalidIndexArgument exception is thrown if the
// index was not found
//
//
type InvalidIndexArgument struct {
	*InvalidArgument

	// Value of index that was not found
	Key string
}

//
// Illegal value specified for a property of the switch's IpfixConfig.
//
//
type InvalidIpfixConfig struct {
	*DvsFault

	// Path of the property in IpfixConfig that has an invalid value.
	Property string
}

//
// A InvalidIpmiLoginInfo fault is thrown when the IPMI user name and/or password is
// invalid.
//
//
type InvalidIpmiLoginInfo struct {
	*VimFault
}

//
// A InvalidIpmiMacAddress fault is thrown when the IPMI mac address provided by the
// user doesn't match with the observed mac address on the host.
//
//
type InvalidIpmiMacAddress struct {
	*VimFault

	ObservedMacAddress string

	UserProvidedMacAddress string
}

//
// Thrown when
// an attempt is made to upload license content
// that is invalid.
//
//
type InvalidLicense struct {
	*VimFault

	// The content of the license being reported as invalid.
	LicenseContent string
}

//
// Thrown when a locale name is unknown or invalid.
//
//
type InvalidLocale struct {
	*VimFault
}

//
// Thrown when a server logon fails due to a bad user name or
// password.
//
//
type InvalidLogin struct {
	*VimFault
}

//
// A InvalidName fault is thrown when the name
// contains an invalid character or format.
//
//
type InvalidName struct {
	*VimFault

	// Entity, if any, that has an invalid name.
	Entity *mo.ManagedEntity

	// The invalid name.
	Name string
}

//
// This fault is thrown when an operation to configure a CIFS volume
// fails because the credentials specified in the
// spec are incorrect.
//
//
type InvalidNasCredentials struct {
	*NasConfigFault

	// The username associated with the CIFS connection.
	UserName string
}

//
// The network specified in the property does not exists.
//
//
type InvalidNetworkInType struct {
	*VAppPropertyFault
}

//
// This fault is thrown when an operation to configure a NAS volume fails
// because the network resource specified is invalid.
//
//
type InvalidNetworkResource struct {
	*NasConfigFault

	// The host that runs the CIFS or NFS server.
	RemoteHost string

	// The remote share.
	RemotePath string
}

//
// This fault is thrown when an attempt is made to invoke an operation on
// a secondary virtual machine that is only supported on the primary virtual
// machine of the fault tolerant group.
//
//
type InvalidOperationOnSecondaryVm struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// This exception is thrown if the
// power operation attempted could not be performed given
// the current power state of the virtual machine.
//
//
type InvalidPowerState struct {
	*InvalidState

	// Power state of the virtual machine that
	// prevented the operation from succeeding.
	ExistingState *enum.VirtualMachinePowerState

	// Power state of the virtual machine required to
	// allow the operation to succeed.
	RequestedState *enum.VirtualMachinePowerState
}

//
// A InvalidPrivilege fault is thrown when the privilege
// does not exist.
//
//
type InvalidPrivilege struct {
	*VimFault

	// The invalid privilege.
	Privilege string
}

//
// A InvalidProfileReferenceHost fault is thrown when a valid host is not
// associated with a profile in the Virtual Center inventory. This could
// be because there is no host assciated with the profile or because the
// associated host is incompatible with the profile.
//
//
type InvalidProfileReferenceHost struct {
	*RuntimeFault

	// The incompatible host if associated with the profile.
	Host *mo.HostSystem

	Profile *mo.Profile

	// The reason for the invalid reference host if known.
	Reason string
}

//
// Thrown when an invalid property path has been referenced.
//
//
type InvalidProperty struct {
	*MethodFault

	// The property name that generated the error.
	Name string
}

//
// The type specification in the property in invalid.
//
//
type InvalidPropertyType struct {
	*VAppPropertyFault
}

//
// The value of the property is not valid given the type of the property.
//
//
type InvalidPropertyValue struct {
	*VAppPropertyFault
}

//
// An InvalidRequest fault is thrown in response to a malformed
// request to the server that fails in the transport layer, e.g.,
// the SOAP XML request was invalid. Subtypes of this fault,
// provides more specific transport errors, such as a using a
// reference to an unknown managed object type or method.
//
//
type InvalidRequest struct {
	*RuntimeFault
}

//
// This fault is thrown when an operation will cause the structure of a resource
// pool hiearchy to exceed its limit. The limits are typically imposed by the total
// number of nodes, maximum fan-out, and total depth of the hierarchy.
//
//
type InvalidResourcePoolStructureFault struct {
	*InsufficientResourcesFault
}

//
// Thrown when an invalid snapshot configuration is detected. For
// example, when a virtual machine's snapshot tree includes
// snapshots that are no longer present.
//
//
type InvalidSnapshotFormat struct {
	*InvalidFormat
}

//
// An InvalidState fault is thrown if the
// operation failed due to the current state of the system.
//
//
type InvalidState struct {
	*VimFault
}

//
// InvalidType is thrown when a managed object request refers to
// an unexpected or unknown type.
//
//
type InvalidType struct {
	*InvalidRequest

	// Name of the argument that was malformed.
	Argument string
}

//
// Thrown when virtual machine creation or configuration fails. This is
// a base type for all virtual machine configuration errors.
//
//
type InvalidVmConfig struct {
	*VmConfigFault

	// Path of the property in configSpec that has an invalid value.
	Property string
}

//
// A InventoryHasStandardAloneHosts fault is thrown if an assignment operation tries to downgrade a license that does have allow hosts licensed with StandardAlone license in the inventory.
//
//
type InventoryHasStandardAloneHosts struct {
	*NotEnoughLicenses

	Hosts []string
}

//
// An error occurred while running the IP/hostname generator application
//
//
type IpHostnameGeneratorError struct {
	*CustomizationFault
}

//
// Base class for faults that can be thrown while invoking iSCSI management operations.
//
//
type IscsiFault struct {
	*VimFault
}

//
// This fault indicates an attempt is made to bind a Virtual NIC to an iSCSI adapter
// where the Virtual NIC has no association with the adapter. For ex: The uplink for
// the given Virtual NIC is not valid for the iSCSI HBA.
//
//
type IscsiFaultInvalidVnic struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates the given Physical NIC is being used by iSCSI HBA.
//
//
type IscsiFaultPnicInUse struct {
	*IscsiFault

	PnicDevice string
}

//
// This fault indicates that the given Virtual NIC is already bound to the iSCSI HBA.
//
//
type IscsiFaultVnicAlreadyBound struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates the given Virtual NIC has active storage paths associated with it.
//
//
type IscsiFaultVnicHasActivePaths struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates that the Virtual NIC has multiple uplinks and not suitable for iSCSI
// multi-pathing and can not be bound to iSCSI HBA.
//
//
type IscsiFaultVnicHasMultipleUplinks struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates the given Virtual NIC has no uplinks and not suitable for iSCSI
// multi-pathing configuration.
//
//
type IscsiFaultVnicHasNoUplinks struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates the given Virtual NIC has the wrong Physical uplink
// for iSCSI multi-pathing configuration. The Physical uplink is not associated
// with the iSCSI Host Bus Adapter.
//
//
type IscsiFaultVnicHasWrongUplink struct {
	*IscsiFault

	// Contains the VMkernel virtual NIC device name.
	VnicDevice string
}

//
// This fault indicates the given Virtual NIC is being used by iSCSI and the requested operation can't be completed.
//
//
type IscsiFaultVnicInUse struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates that the given Virtual NIC is associated with the only path to the storage. Any attempt to unbind this
// from iSCSI HBA would result in storage being inaccessible.
//
//
type IscsiFaultVnicIsLastPath struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates an attempt was made to remove a Virtual NIC from an iSCSI HBA while
// Virtual NIC is not associated with the adapter.
//
//
type IscsiFaultVnicNotBound struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates an attempt was made to add a non-existent Virtual NIC adapter.
//
//
type IscsiFaultVnicNotFound struct {
	*IscsiFault

	VnicDevice string
}

//
// The virtual machine is using a 2TB+ RDM device and operation is
// unable to convert the disk to a different type.
//
//
type LargeRDMConversionNotSupported struct {
	*MigrationFault

	// The name of the disk device using the RDM.
	Device string
}

//
// The virtual machine is configured with a 2TB+ Raw Disk Mapping. This is not
// supported on the datastore.
//
//
type LargeRDMNotSupportedOnDatastore struct {
	*VmConfigFault

	// The datastore.
	Datastore *mo.Datastore

	// The name of the datastore.
	DatastoreName string

	// The label of the 2TB+ RDM device that would have its backing placed on
	// the datastore.
	// This is not guaranteed to be the only such device.
	Device string
}

//
// A virtual machine's network connectivity cannot be determined
// because it uses a legacy network interface. If returned as part of migration checks,
// this is an error if the virtual  machine is currently connected to the legacy
// interface, and a warning otherwise.
//
//
type LegacyNetworkInterfaceInUse struct {
	*CannotAccessNetwork
}

//
// A  LicenseAssignmentFailed fault is thrown when VirtualCenter
// fails to assign a license to an entity.
//
//
type LicenseAssignmentFailed struct {
	*RuntimeFault

	// The reason why the assignment failed, if known.
	Reason string
}

//
// A LicenseDowngradeDisallowed fault is thrown if an assignment operation tries to downgrade a license that does have certain licensed features which are in use.
//
//
type LicenseDowngradeDisallowed struct {
	*NotEnoughLicenses

	Edition string

	EntityId string

	// List of conflicting features that prevent
	// downgrade
	Features []*do.KeyAnyValue
}

//
// An LicenseEntityNotFound fault is thrown when an attempt is
// do any operation on an entity/licensed asset that does not exist.
// Example, remove an entity that does not exist.
//
//
type LicenseEntityNotFound struct {
	*VimFault

	EntityId string
}

//
// A LicenseExpired fault is thrown if it an operation is unsuccessful because the license used for the operation has expired.
//
//
type LicenseExpired struct {
	*NotEnoughLicenses

	// License key that has expired
	LicenseKey string
}

//
// A LicenseKeyEntityMismatch fault is thrown if an assignment operation tries to assign a license that does not apply to an entity. For example assigning a host license to VirtualCenter.
//
//
type LicenseKeyEntityMismatch struct {
	*NotEnoughLicenses
}

//
// This fault is thrown if the required licenses were unable to be checked
// out due to a restriction in the option file of the license server.
//
//
type LicenseRestricted struct {
	*NotEnoughLicenses
}

//
// This fault is thrown when the License Server
// is unavailable during an attempt to change license state.
//
//
type LicenseServerUnavailable struct {
	*VimFault

	// The name of the unavailable license server.
	LicenseServer string
}

//
// A LicenseSourceUnavailable is thrown if it is unable to check out a license because
// the license source is unavailable.
//
//
type LicenseSourceUnavailable struct {
	*NotEnoughLicenses

	// License source
	LicenseSource *do.LicenseSource
}

//
// This exception is thrown if one of the arguments passed to the function exceeds
// a limit.
//
//
type LimitExceeded struct {
	*VimFault

	// The limit value.
	Limit int32

	// The name of the property that exceeds the limit.
	Property string
}

//
// Customization operation is performed on a linux source vm that
// was not shut down properly. If the filesystem has significant
// fsck errors on it, customization process cannot make changes
// to it.
//
//
type LinuxVolumeNotClean struct {
	*CustomizationFault
}

//
// A LogBundlingFailed exception is thrown when generation of a diagnostic
// data bundle fails.
//
//
type LogBundlingFailed struct {
	*VimFault
}

//
// Migration of the virtual machine to the target host will need a move of
// virtual machine files, like configuration file or virtual disks, which is
// not permitted if the source host is in maintenance mode.
//
//
type MaintenanceModeFileMove struct {
	*MigrationFault
}

//
// A ManagedObjectNotFound exception is thrown when a request refers to
// a managed object that no longer exists or has never existed.
//
//
type ManagedObjectNotFound struct {
	*RuntimeFault

	// The managed object reference that generated the error.
	Obj *do.ManagedObjectReference
}

//
// Thrown when memory cannot be hot-added or hot-removed from the virtual machine.
//
//
type MemoryHotPlugNotSupported struct {
	*VmConfigFault
}

//
// The memory amount of the virtual machine is not within the recommended
// memory bounds for the virtual machine's guest OS.
//
//
type MemorySizeNotRecommended struct {
	*VirtualHardwareCompatibilityIssue

	// The maximum recommended memory size.
	MaxMemorySizeMB int32

	// The configured memory size of the virtual machine.
	MemorySizeMB int32

	// The minimum recommended memory size.
	MinMemorySizeMB int32
}

//
// The memory amount of the virtual machine is not within the acceptable
// guest memory bounds supported by the virtual machine's host.
//
//
type MemorySizeNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The maximum acceptable memory size.
	MaxMemorySizeMB int32

	// The configured memory size of the virtual machine.
	MemorySizeMB int32

	// The minimum acceptable memory size.
	MinMemorySizeMB int32
}

//
// The memory amount of the virtual machine is not within the acceptable
// guest memory bounds supported by the virtual machine's datastore.
//
//
type MemorySizeNotSupportedByDatastore struct {
	*VirtualHardwareCompatibilityIssue

	// The datastore which does not support the requested memory size.
	Datastore *mo.Datastore

	// The maximum acceptable memory size supported by the datastore.
	MaxMemorySizeMB int32

	// The configured memory size of the virtual machine.
	MemorySizeMB int32
}

//
// Thrown if a request to take a memory snapshot is issued
// on a virtual machine with an independent disk.
//
//
type MemorySnapshotOnIndependentDisk struct {
	*SnapshotFault
}

//
// A MethodAlreadyDisabledFault fault is thrown when an attempt
// is made to disable a method that is already disabled.
//
//
type MethodAlreadyDisabledFault struct {
	*RuntimeFault

	SourceId string
}

//
// A MethodDisabled fault is thrown if a disabled method
// is invoked by the client. The method denote an invalid state
// operation or may have been explicitly disabled.
//
//
type MethodDisabled struct {
	*RuntimeFault

	// Since vSphere API 4.1
	Source string
}

//
// The base data object type for all the object model faults
// that an application might handle.
//
//
type MethodFault struct {

	// Set of dynamic properties. This property is optional because only the
	// properties of an object that are unknown to a client will be part of this set.
	// This property is not readonly just in case we want to send such properties
	// from a client in the future.
	DynamicProperty []*do.DynamicProperty

	// Reserved.
	DynamicType string

	// Fault which is the cause of this fault.
	//
	// Since vSphere API 4.0
	FaultCause *do.LocalizedMethodFault

	// Message which has details about the error
	// Message can also contain a key to message catalogue which
	// can be used to generate better localized messages.
	//
	// Since vSphere API 4.0
	FaultMessage []*do.LocalizableMessage
}

//
// MethodNotFound is thrown to indicate that a method called on a managed
// object does not exist.
//
//
type MethodNotFound struct {
	*InvalidRequest

	// The method called.
	Method string

	// The receiver of the call
	Receiver *do.ManagedObjectReference
}

//
// An MigrationDisabled fault is thrown if the
// migration failed due to disabled migration
//
//
type MigrationDisabled struct {
	*MigrationFault
}

//
// Base object type for issues that can occur when reassigning the execution
// host of a virtual machine using migrate or relocate. These issues are typically
// used as argument in the MigrationEvent. When a MigrationFault is used as a value
// in a MigrationEvent, the type of MigrationEvent determines if the issue is a
// warning or an error (for example, MigrationHostWarningEvent or
// MigrationHostErrorEvent). When thrown as an exception, the fault is an error.
//
// Issues are categorized as errors or warnings according to the following
// criteria:
//
//
// If the virtual machine is powered on:
//
//
// • Error for fatal problems with the VMotion interfaces or licensing.
//
// • Error if VMotion would fail.
//
// • Error if VMotion would in any way interrupt the continuous and consistent
// operation of the virtual machine.
//
// • Warning for potential performance or connectivity problems between the
// source and destination VMotion interfaces.
//
// • Warning if the virtual machine's currently disconnected devices may not
// be connectable after VMotion.
//
//
// If the virtual machine is powered off or suspended:
//
// • Error if the destination host cannot access all the files that comprise
// the virtual machine (including virtual disks).
//
// • Error if aspects of the virtual machine are not supported by the
// destination host's hardware or software.
//
// • Warning if problems would occur when powering on or resuming the
// virtual machine, if the usage/configuration of the destination
// host were to remain in its current state.
//
//
//
//
type MigrationFault struct {
	*VimFault
}

//
// A migration operation that requires feature support on source and
// destination hosts is lacking support on the host.
//
//
type MigrationFeatureNotSupported struct {
	*MigrationFault

	// Whether this error is for the source host.
	AtSourceHost bool

	// The host.
	FailedHost *mo.HostSystem

	// The name of the host.
	FailedHostName string
}

//
// The VM to be migrated is not ready for the migration operation. This might
// because the VM is still in the progress of powering on or resuming from a
// suspended state.
//
//
type MigrationNotReady struct {
	*MigrationFault

	Reason string
}

//
// A MismatchedBundle fault is thrown when the bundle supplied for
// RestoreFirmwareConfiguration does not match the
// specifications of the host
//
//
type MismatchedBundle struct {
	*VimFault

	// The build number of the host that the bundle was generated for
	BundleBuildNumber int32

	// The uuid of the host that the bundle was generated for
	BundleUuid string

	// The build number of the host
	HostBuildNumber int32

	// The uuid of the host
	HostUuid string
}

// Deprecated.
// As of vSphere API 5.5, use CannotUseNetwork with
// a correct reason for the fault.
//
//
// The virtual machine network uses different offload or security
// policies on the destination host than on the source host. This is an error
// if the virtual machine is currently connected to the network, and a warning
// otherwise.
//
//
type MismatchedNetworkPolicies struct {
	*MigrationFault

	// The name of the network.
	Backing string

	// The connected/disconnected state of the device.
	Connected bool

	// The label of the interface device.
	Device string
}

//
// The source and destination hosts do not use the same network name for
// their VMotion interfaces. This is a warning for migrating powered-on virtual
// machines.
//
//
type MismatchedVMotionNetworkNames struct {
	*MigrationFault

	// The name of the network used by the destination host VMotion interface.
	DestNetwork string

	// The name of the network used by the source host VMotion interface.
	SourceNetwork string
}

//
// A MissingBmcSuppport fault is thrown when a host's BMC doesn't support IPMI.
// BMC (Board Management Controller) is a piece of hardware required for IPMI.
//
//
type MissingBmcSupport struct {
	*VimFault
}

//
// A controller key has not been specified for a new device
// that requires a controller, such as a disk or CD-ROM device.
//
//
type MissingController struct {
	*InvalidDeviceSpec
}

//
// No IP pool is associated with a network.
//
//
type MissingIpPool struct {
	*VAppPropertyFault
}

//
// Usable open source components required for Linux customization were not found
// on the server.
//
//
type MissingLinuxCustResources struct {
	*CustomizationFault
}

//
// No IP configuration exists for network.
//
//
type MissingNetworkIpConfig struct {
	*VAppPropertyFault
}

//
// Attempting to power-off a vApp for which no virtual machines has been
// configured to power off.
//
//
type MissingPowerOffConfiguration struct {
	*VAppConfigFault
}

//
// Attempting to power-on a vApp service for which no virtual machines has been
// configured to power on.
//
//
type MissingPowerOnConfiguration struct {
	*VAppConfigFault
}

//
// A usable sysprep file was not found on the server.
//
//
type MissingWindowsCustResources struct {
	*CustomizationFault
}

//
// Thrown when a mouse-keyboard-screen connection ticket to a virtual machine
// cannot be granted because the configured connection limit has been reached.
//
//
type MksConnectionLimitReached struct {
	*InvalidState

	// MKS connection limit for the virtual machine.
	ConnectionLimit int32
}

//
// Customization failed because the customization process was unable to mount a remote
// virtual disk file.
//
//
type MountError struct {
	*CustomizationFault

	// Index into the virtual machine's device list,
	// representing the key value that identifies the virtual device
	// that is the presumed boot disk.
	DiskIndex int32

	// The virtual machine to be customized.
	Vm *mo.VirtualMachine
}

//
// MultipleCertificatesVerifyFault is thrown by the host connect method
// ReconnectHost_Task as well as the methods to add a host to
// VirtualCenter (AddStandaloneHost_Task and
// AddHost_Task) if VirtualCenter detects that the
// host has different SSL certificates for different management ports. This
// can occur, for example, if an ESX 2.x host has different SSL certificates
// for the authd service (port 902) and the Management UI port (port 443).
// VirtualCenter is not able to manage such hosts. To fix this issue, the user
// should modify the host to ensure there is only one certificate for
// all services. Alternatively, different certificates are allowed as long as each
// certificate is verifiable (trusted) by the VirtualCenter server.
//
//
type MultipleCertificatesVerifyFault struct {
	*HostConnectFault

	// The thumbprints (and associated ports) used by the services on the host.
	ThumbprintData []*do.MultipleCertificatesVerifyFaultThumbprintData
}

//
// Fault thrown when an attempt is made to create a second snapshot on a VM that only
// supports a single snapshot at a time.
//
//
type MultipleSnapshotsNotSupported struct {
	*SnapshotFault
}

//
// A NamespaceFull fault is thrown when an operation
// on namespace requires more space to complete.
//
//
type NamespaceFull struct {
	*VimFault

	// Current maximum size.
	CurrentMaxSize int64

	// The namespace in question.
	Name string

	// Size necessary to complete operation.  If not present,
	// system was not able to determine how much space would
	// be necessary to complete operation.
	RequiredSize int64
}

//
// A NamespaceLimitReached fault is thrown when the maximum allowed
// namespaces for a virtual machine will be exceeded.
//
//
type NamespaceLimitReached struct {
	*VimFault

	// Allowed maximum number of namespaces per virtual machine.
	Limit int32
}

//
// A NamespaceWriteProtected fault is thrown when an operation
// on namespace fails because namespace is write-protected.
//
//
type NamespaceWriteProtected struct {
	*VimFault

	// The namespace in question.
	Name string
}

//
// Base class for all network-attached storage configuration faults.
//
//
type NasConfigFault struct {
	*HostConfigFault

	// Name of the Nas datastore being configured.
	Name string
}

//
// This fault is thrown when an operation to configure a CIFS volume fails
// because the request exceeds the maximum allowed connections on this host
// for the specified remote path.
//
//
type NasConnectionLimitReached struct {
	*NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string

	// The remote share.
	RemotePath string
}

//
// This fault is thrown when an operation to configure a CIFS volume fails
// when attempting to log on more than once with the same user name.
//
//
type NasSessionCredentialConflict struct {
	*NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string

	// The remote share.
	RemotePath string

	UserName string
}

//
// This fault is thrown when an operation to configure a NAS datastore
// fails because the specified NFS volume is not mounted.
//
//
type NasVolumeNotMounted struct {
	*NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string

	// The remote share.
	RemotePath string
}

//
// A network copy of the file failed.
//
//
type NetworkCopyFault struct {
	*FileFault
}

//
// Thrown if network configuration change disconnected the host from vCenter server
// and has been rolled back.
//
//
type NetworkDisruptedAndConfigRolledBack struct {
	*VimFault

	// The name of host on which the network configuration was rolled back.
	Host string
}

//
// This fault is thrown when an operation to configure a NAS volume fails
// because network access is unavailable.
//
//
type NetworkInaccessible struct {
	*NasConfigFault
}

//
// Used as a warning if a virtual machine provisioning operation is done
// across datacenters.  This warns that the network used by the virtual
// machine before and after the operation may not be the same even though
// the two networks have the same name.  This is because network names
// are only unique within a datacenter.
//
//
type NetworksMayNotBeTheSame struct {
	*MigrationFault

	// The name of the network.
	Name string
}

//
// The number of network adapter settings in the customization specification
// does not match the number of network adapters present in the virtual machine.
//
//
type NicSettingMismatch struct {
	*CustomizationFault

	// The number of network adapter settings specified in the customization
	// specification.
	NumberOfNicsInSpec int32

	// The number of network adapters present in the virtual machine.
	NumberOfNicsInVM int32
}

//
// A NoActiveHostInCluster fault is thrown when there is no host in a valid
// state in the given compute resource to perform a specified operation. This
// can happen, for example, if all the hosts are disconnected or in maintenance
// mode.
//
//
type NoActiveHostInCluster struct {
	*InvalidState

	// The compute resource that does not have any active hosts.
	ComputeResource *mo.ComputeResource
}

//
// There are no more IP addresses available on the given network.
//
//
type NoAvailableIp struct {
	*VAppPropertyFault

	// A reference to the network
	Network *mo.Network
}

//
// This exception is thrown when a client has connected without supplying a
// certificate but the associated call expects that the client has done so.
//
//
type NoClientCertificate struct {
	*VimFault
}

//
// A NoCompatibleDatastore fault is thrown when Storage DRS cannnot find a compatible
// datastore in a given storage pod to place a disk or a virtual machine.
// a virtual machine.
//
//
type NoCompatibleDatastore struct {
	*VimFault
}

//
// The cluster contains no hosts satisfying the hard VM/host affinity rules
// constraint for the VM.
//
//
type NoCompatibleHardAffinityHost struct {
	*VmConfigFault

	// The vm for which there are no compatible hard-affine hosts in the cluster.
	VmName string
}

//
// A NoCompatibleHost fault is thrown when DRS cannnot find a compatible
// host in a given compute resource to run a virtual machine on.
//
//
type NoCompatibleHost struct {
	*VimFault

	// An error in this array indicates why the corresponding host in the
	// host array is incompatible.
	Error []*do.LocalizedMethodFault

	// The list of hosts that are not compatible, each element has a
	// corresponding fault in the error array.
	Host []*mo.HostSystem
}

//
// This fault is used to report that a FT VM cannot be placed because there is
// no compatible host that can access all devices required to be connected when
// the VM powers on.
//
//
type NoCompatibleHostWithAccessToDevice struct {
	*NoCompatibleHost
}

//
// The cluster contains no hosts satisfying the soft VM/host affinity rules
// constraint for the VM.
//
//
type NoCompatibleSoftAffinityHost struct {
	*VmConfigFault

	// The vm for which there are no compatible soft-affine hosts in the cluster.
	VmName string
}

//
// The fault occurs when Storage DRS cannot move a virtual machine because
// the host it is registered on is not connected to any other datastore
// in the storage pod.
//
//
type NoConnectedDatastore struct {
	*VimFault
}

//
// This exception is thrown when a virtual machine
// which has no virtual disks is being upgraded or relaid out
// using the VirtualMachine.upgradeVirtualHardware or upgradeVmLayout
// commands.
//
//
type NoDiskFound struct {
	*VimFault
}

//
// This fault is thrown when an operation fails because of insufficient
// disk space.
//
//
type NoDiskSpace struct {
	*FileFault

	// The name of the datastore with insufficient disk space.
	Datastore string
}

//
// None of the disks attached to the VM are suitable for customization.
//
//
type NoDisksToCustomize struct {
	*CustomizationFault
}

//
// This error occurs when an operation fails because of vmkernel gateway
// is unset.
//
//
type NoGateway struct {
	*HostConfigFault
}

//
// A powered-on virtual machine has a guest OS with Tools installed, but it does not
// have a valid heartbeat.
//
//
type NoGuestHeartbeat struct {
	*MigrationFault
}

//
// A NoHostFault fault occurs when a host
// cannot be reached.
//
//
type NoHost struct {
	*HostConnectFault

	Name string
}

//
// The NoHostSuitableForFtSecondary fault is thrown when the system is unable to
// find a suitable host for the Fault Tolerance secondary virtual machine.
// This fault can be thrown when Virtual Center is trying to place or power on
// a Fault Tolerance Secondary, in both DRS or non-DRS cases.
//
//
type NoHostSuitableForFtSecondary struct {
	*VmFaultToleranceIssue

	// The primary virtual machine corresponding to the secondary virtual
	// machine.
	Vm *mo.VirtualMachine

	// The name of the primary virtual machine corresponding to the secondary
	// virtual machine.
	VmName string
}

//
// The NoLicenseServerConfigured fault is thrown when there is no
// valid license server configured for the system and the system
// is not in evaluation mode. Any operation occurs that requires
// evaluation license or a valid license will throw the
// NoLicenseServerConfigured. This can happen with the new licensing
// scheme that is a hybrid of flex-based licensing and serial number
// based licensing. There can be cases where VirtualCenter is licensed
// by a serial number and there is no need for a flex license server.
// These cases are valid as long as no operation that requires flex-
// based license server is invoked, for example, adding a pre-4.0
// host that requires flex licenses. If however, such an operation is
// invoked, the NoLicenseServerConfigured fault is thrown.
//
//
type NoLicenseServerConfigured struct {
	*NotEnoughLicenses
}

//
// This fault is thrown when no peer host is found to wake up this host.
//
//
type NoPeerHostFound struct {
	*HostPowerOpFailed
}

//
// Thrown when an operation is denied because of a privilege
// not held on a managed object.
//
//
type NoPermission struct {
	*SecurityError

	// The managed object on which permission is required
	Object *do.ManagedObjectReference

	// The privilege identifier required
	PrivilegeId string
}

//
// Fault indicating that the user account used to connect to the
// Active Directory doesn not have enough permissions for the action
// that was attempted.
//
//
type NoPermissionOnAD struct {
	*ActiveDirectoryFault
}

//
// This indicates that the user account used to connect to the host does
// not have enough permissions to enable VirtualCenter to manage the host.
//
//
type NoPermissionOnHost struct {
	*HostConnectFault
}

//
// This fault is thrown when an operation to configure a NAS volume fails
// because of insufficient user permissions.
//
// For CIFS volumes, this implies that the user specified in the
// spec does not have access to the
// network resource.
//
//
type NoPermissionOnNasVolume struct {
	*NasConfigFault

	UserName string
}

//
// This exception is thrown when an extension has attempted to use certificate-based
// authentication but the extension has been registered without a subject name.
//
//
type NoSubjectName struct {
	*VimFault
}

//
// The IP address of the VC server has not be configured, and a vApp
// property is requesting to use it.
//
//
type NoVcManagedIpConfigured struct {
	*VAppPropertyFault
}

//
// This error occurs when an operation fails because of
// no virtual NIC available.
//
//
type NoVirtualNic struct {
	*HostConfigFault
}

//
// Attempting to power-on or power-off a vApp that contains no
// virtual machines.
//
//
type NoVmInVApp struct {
	*VAppConfigFault
}

//
// Fault indicating that an operation must be executed by a
// non Active Directory user.
//
//
type NonADUserRequired struct {
	*ActiveDirectoryFault
}

//
// An operation on a powered-on virtual machine requests that an existing
// Raw Disk Mapping end up in a location other than the new home datastore
// for the virtual machine, but the host does not have that capability.
//
//
type NonHomeRDMVMotionNotSupported struct {
	*MigrationFeatureNotSupported

	// The label of an RDM device for which an unsupported move was requested.
	// This is not guaranteed to be the only such device.
	Device string
}

//
// The virtual machine has nonpersistent virtual disk.  This is an error for
// any powered-on migration which involves moving virtual disks.
//
//
type NonPersistentDisksNotSupported struct {
	*DeviceNotSupported
}

//
// The host does not support VM that has VPX assigned prefix or ranged based
// MAC address (i.e. MAC is not prefixed with 00:50:56:[80-BF])
//
//
type NonVmwareOuiMacNotSupportedHost struct {
	*NotSupportedHost

	// The name of the host.
	HostName string
}

//
// This fault is thrown when an operation fails because the specified object
// is not a directory.
//
//
type NotADirectory struct {
	*FileFault
}

//
// This fault is thrown when an operation fails because the specified object
// is not a file.
//
//
type NotAFile struct {
	*FileFault
}

//
// Thrown when an operation is denied because the session
// has not yet successfully logged in.
//
//
type NotAuthenticated struct {
	*NoPermission
}

//
// The host hardware does not have enough CPU cores to support the number of
// virtual CPUs in the virtual machine.
//
// If the host is using hyperthreading, NotEnoughLogicalCpus is
// employed instead of NotEnoughCpus.
//
//
//
type NotEnoughCpus struct {
	*VirtualHardwareCompatibilityIssue

	// The number of CPUs present on the host.
	NumCpuDest int32

	// The number of virtual CPUs present in the virtual machine.
	NumCpuVm int32
}

//
// A NotEnoughLicensesFault occurs when an operation
// fails because there are not enough licenses installed.
//
//
type NotEnoughLicenses struct {
	*RuntimeFault
}

//
// The host hardware does not have enough logical CPUs (hyperthreads) to
// support the number of virtual CPUs in the virtual machine.
//
//
type NotEnoughLogicalCpus struct {
	*NotEnoughCpus

	// The host that does not have enough logical CPUs.
	//
	// Since VI API 2.5
	Host *mo.HostSystem
}

//
// A NotFound error occurs when a referenced component of a managed
// object cannot be found.  The referenced component can be a data
// object type (such as a role or permission) or a primitive
// (such as a string).
//
// For example, if the missing referenced component is a data object, such as
// VirtualSwitch, the NotFound error is
// thrown.  The NotFound error is also thrown if the data object is found, but the referenced name
// (for example, "vswitch0") is not.
//
//
//
type NotFound struct {
	*VimFault
}

//
// NotImplemented exception is thrown if the method is not
// yet implemeneted.
//
//
type NotImplemented struct {
	*RuntimeFault
}

//
// Thrown if the method is not supported on the
// server. Not all methods are supported on all servers
// (for example, an ESX Server host supports less functionality than
// a VirtualCenter server). A feature might also be disabled
// due to missing liceneses.
//
//
type NotSupported struct {
	*RuntimeFault
}

//
// VMs with pvscsi or vmxnet3 virtual devices support Fault Tolerance only
// on 4.1 or later hosts.
//
//
type NotSupportedDeviceForFT struct {
	*VmFaultToleranceIssue

	// The device label
	DeviceLabel string

	// The device type
	DeviceType string

	// The host
	Host *mo.HostSystem

	// The host name
	HostName string

	// The virtual machine
	Vm *mo.VirtualMachine

	// The virtual machine name
	VmName string
}

//
// A NotSupportedHostFault occurs when the host is of a type
// that is not supported.
//
//
type NotSupportedHost struct {
	*HostConnectFault

	// The name of the unsupported product if available;
	// for example, "VMware ESX Server".
	ProductName string

	// The version of the unsupported product; for example, "1.5.2"
	ProductVersion string
}

//
// The host does not support vFlash feature.
//
//
type NotSupportedHostForVFlash struct {
	*NotSupportedHost

	// The name of the host.
	HostName string
}

//
// The host does not support VSAN.
//
//
type NotSupportedHostForVsan struct {
	*NotSupportedHost

	// The name of the host.
	HostName string
}

//
// A NotSupportedHostInCluster fault occurs when the host does not support
// the necessary features to participate in the cluster.
//
//
type NotSupportedHostInCluster struct {
	*NotSupportedHost
}

//
// A NotSupportedHostInDvs fault occurs when the host does not support
// the necessary features to participate in the DVS.
//
//
type NotSupportedHostInDvs struct {
	*NotSupportedHost

	// The product spec of the DVS. This determines which host versions may
	// participate in the DVS; that information may be queried by using
	// QueryDvsCompatibleHostSpec.
	SwitchProductSpec *do.DistributedVirtualSwitchProductSpec
}

//
// A NotSupportedHostInHACluster fault occurs when the host does not support
// the necessary features to participate in the HA cluster.
//
//
type NotSupportedHostInHACluster struct {
	*NotSupportedHost

	// The product build number of the host.
	Build string

	// The name of the host.
	HostName string
}

//
// The property value cannot be changed since it is not
// user configurable.
//
//
type NotUserConfigurableProperty struct {
	*VAppPropertyFault
}

//
// The host's software does not support enough cores per socket to
// accomodate the virtual machine. This is always an error.
//
//
type NumVirtualCoresPerSocketNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The maximum number of cores per socket supported on the host.
	MaxSupportedCoresPerSocketDest int32

	// The number of cores per socket in the virtual machine.
	NumCoresPerSocketVm int32
}

//
// This fault is thrown when the total number of virtual CPUs present or requested
// in virtual machines' configuration has exceeded the limit on the host.
//
//
type NumVirtualCpusExceedsLimit struct {
	*InsufficientResourcesFault

	// The maximum number of virtual CPUs supported on the host.
	MaxSupportedVcpus int32
}

//
// The number of virtual CPUs present or requested in the virtual machine's
// configuration is not supported for a specific feature.
//
//
type NumVirtualCpusIncompatible struct {
	*VmConfigFault

	// The number of virtual CPUs in the virtual machine.
	NumCpu int32

	// The reason for the incompatibility.
	// See NumVirtualCpusIncompatibleReason for valid values.
	Reason string
}

//
// The host's software does not support enough virtual CPUs to
// accomodate the virtual machine. This is always an error.
//
//
type NumVirtualCpusNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The maximum number of virtual CPUs supported on the host.
	MaxSupportedVcpusDest int32

	// The number of virtual CPUs in the virtual machine.
	NumCpuVm int32
}

//
// An OperationDisabledByGuest exception is thrown when an
// operation fails because the guest operations agent has been configured to
// disable the operation.
//
//
type OperationDisabledByGuest struct {
	*GuestOperationsFault
}

//
// An OperationDisallowedOnHost is thrown if an operation is diasllowed
// on host when a direct connection is used.
//
// Examples for such operations include VM powering on / memory hot-plug
// which could potentially violate hard-enforcement licenses if allowed
// on host.
//
// The functionality these operations provide is still available, but only
// through calls to an external entity.
//
//
type OperationDisallowedOnHost struct {
	*RuntimeFault
}

//
// An OperationNotSupportedByGuest exception is thrown when an
// operation fails because the guest OS does not support
// the operation (e.g., Registry manipulation in Linux guests.).
//
//
type OperationNotSupportedByGuest struct {
	*GuestOperationsFault
}

//
// Thrown if a parameter exceeds the acceptable range of values.
//
//
type OutOfBounds struct {
	*VimFault

	// This should be the name of the field that holds the allowed maximum
	// (for example, Host.capability.maxSupportedVMs).
	ArgumentName string
}

//
// An OVF descriptor Attribute base class.
//
//
type OvfAttribute struct {
	*OvfInvalidPackage

	// Attribute name
	AttributeName string

	// Element name where the attribute is defined
	ElementName string
}

type OvfConnectedDevice struct {
	*OvfHardwareExport
}

type OvfConnectedDeviceFloppy struct {
	*OvfConnectedDevice

	// The filename of the floppy image
	Filename string
}

type OvfConnectedDeviceIso struct {
	*OvfConnectedDevice

	// The filename of the ISO
	Filename string
}

//
// A base fault for Ovf descriptor constraints
//
//
type OvfConstraint struct {
	*OvfInvalidPackage

	// The name of the element
	Name string
}

//
// Superclass for all faults that can be thrown during the callback to an OVF
// consumer. The faultCause gives details about what went
// wrong.
//
//
type OvfConsumerCallbackFault struct {
	*OvfFault

	// The OVF consumer's extension key.
	ExtensionKey string

	// The OVF consumer's extension name.
	ExtensionName string
}

//
// A fault type indicating that network communication with an OVF consumer failed.
//
//
type OvfConsumerCommunicationError struct {
	*OvfConsumerCallbackFault

	// The network library error message.
	Description string
}

//
// Localized fault that may be thrown by an OVF consumer.
//
//
type OvfConsumerFault struct {
	*OvfConsumerCallbackFault

	// An error code that uniquely describes the fault within this extension.
	ErrorKey string

	// The error message, localized by the OVF consumer
	Message string

	// Additional parameters for this fault
	Params []*do.KeyValue
}

//
// A fault type indicating that the XML of a section appended by an OVF consumer was
// invalid.
//
//
type OvfConsumerInvalidSection struct {
	*OvfConsumerCallbackFault

	// The XML parser error message.
	Description string

	// The line number in the section on which the error was found.
	LineNumber int32
}

//
// A fault type indicating that the power on operation failed.
//
//
type OvfConsumerPowerOnFault struct {
	*InvalidState

	// A localized, human-readable description of the error.
	Description string

	// The OVF consumer's extension key.
	ExtensionKey string

	// The OVF consumer's extension name.
	ExtensionName string
}

//
// A fault type indicating that an OVF consumer appended an undeclared section to an OST.
//
// An undeclared section means a section with a qualified type that the OVF consumer was
// not registered as a handler of.
//
//
//
type OvfConsumerUndeclaredSection struct {
	*OvfConsumerCallbackFault

	// The undeclared qualified section type appended by the OVF consumer.
	QualifiedSectionType string
}

//
// A fault type indicating that an OVF consumer added a section with an unbound prefix.
//
//
type OvfConsumerUndefinedPrefix struct {
	*OvfConsumerCallbackFault

	// The prefix for which no namespace definition was found.
	Prefix string
}

//
// Thrown by an OVF consumer if an error occurred while validating an instantiation OST.
//
//
type OvfConsumerValidationFault struct {
	*VmConfigFault

	// The OVF consumer's extension key.
	ExtensionKey string

	// The OVF consumer's extension name.
	ExtensionName string

	// The error message, localized by the OVF consumer
	Message string
}

type OvfCpuCompatibility struct {
	*OvfImport

	// The desired register value return from the host
	DesiredRegisterValue string

	// The CpuId level where a problem was detected. Other levels may
	// also have problems
	Level int32

	// Possible register names are eax, ebx, ecx, or edx.
	RegisterName string

	// The register value where the problem was detected
	RegisterValue string
}

type OvfCpuCompatibilityCheckNotSupported struct {
	*OvfImport
}

type OvfDiskMappingNotFound struct {
	*OvfSystemFault

	// The disk name that is not found
	DiskName string

	// The VM Name
	VmName string
}

//
// Class used to indicate that the Disks in a DiskSection was not defined
// in the same order as in the Reference section
//
//
type OvfDiskOrderConstraint struct {
	*OvfConstraint
}

//
// OvfDuplicateElement is thrown if Ovf descriptor contains an invalid duplicate element.
//
//
type OvfDuplicateElement struct {
	*OvfElement
}

//
// If the Ovf descriptor element have duplicated element bound.
//
//
type OvfDuplicatedElementBoundary struct {
	*OvfElement

	// Name of duplicated boundary
	Boundary string
}

//
// Two or more user-configurable properties are
// found with the same fully-qualified property
// name.
//
//
type OvfDuplicatedPropertyIdExport struct {
	*OvfExport

	// The fully qualified property id.
	Fqid string
}

//
// Two or more user-configurable properties are
// found with the same fully-qualified property
// name.
//
//
type OvfDuplicatedPropertyIdImport struct {
	*OvfExport
}

//
// A base fault for element exceptions in the Ovf XML descriptor.
//
//
type OvfElement struct {
	*OvfInvalidPackage

	// The name of the element
	Name string
}

//
// A class used if a element node is found to have an invalid value.
// Base class for OvfProperty errors.
//
//
type OvfElementInvalidValue struct {
	*OvfElement

	// The value of the element
	Value string
}

//
// A common base class to host all the Ovf Lib Export Exceptions.
//
//
type OvfExport struct {
	*OvfFault
}

//
// This fault is used if we fail to export an OVF package.
//
//
type OvfExportFailed struct {
	*OvfExport
}

//
// A common base type fault for all Ovf related faults.
//
// The structure of OvfFault is as listed.
//
//
//
//
// • OvfFault
//
//
//
// • OvfInvalidPackage
//
//
//
// • OvfXmlFormat
//
// • OvfWrongNamespace
//
// • OvfElement
//
//
//
// • OvfElementInvalidValue
//
// • OvfUnexpectedElement
//
// • OvfDuplicateElement
//
// • OvfMissingElement
//
// • OvfMissingElementNormalBoundary
//
// • OvfDuplicatedElementBoundary
//
//
//
// • OvfAttribute
//
//
//
// • OvfMissingAttribute
//
// • OvfInvalidValue
//
//
//
// • OvfInvalidValueFormatMalformed
//
// • OvfInvalidValueConfiguration
//
// • OvfInvalidValueReference
//
// • OvfInvalidValueEmpty
//
//
//
//
//
// • OvfProperty
//
//
//
// • OvfPropertyType
//
// • OvfPropertyValue
//
// • OvfPropertyNetwork
//
// • OvfPropertyQualifier
//
// • OvfPropertyQualifierWarning
//
//
//
//
//
// • OvfConstraint
//
//
//
// • OvfDiskOrderConstraint
//
// • OvfHostResourceConstraint
//
//
//
// • OvfUnsupportedPackage
//
//
//
// • OvfNoHostNic
//
// • OvfInvalidVmName
//
// • OvfUnsupportedAttribute
//
//
//
// • OvfUnsupportedAttributeValue
//
//
//
// • OvfUnsupportedElement
//
//
//
// • OvfUnsupportedElementValue
//
// • OvfUnsupportedSection
//
// • OvfNoSpaceOnController
//
//
//
// • OvfUnsupportedType
//
// • OvfUnsupportedSubType
//
// • OvfHardwareCheck
//
// • OvfNoSupportedHardwareFamily
//
//
//
// • OvfExport
//
//
//
// • OvfExportFailed
//
// • OvfHardwareExport
//
//
//
// • OvfUnsupportedDeviceExport
//
// • OvfUnknownDeviceBacking
//
// • OvfConnectedDevice
//
//
//
// • OvfConnectedDeviceISO
//
//
//
// • OvfUnableToExportDisk
//
//
//
// • OvfPropertyExport
//
// • OvfPropertyNetworkExport
//
// • OvfDuplicatedPropertyIdExport
//
//
//
// • OvfImport  (these are typically returned as warnings
// )
//
//
// • OvfImportFailed
//
// • OvfHardwareCheck
//
// • OvfMissingHardware
//
// • OvfCpuCompatibility
//
// • OvfCpuCompatibilityCheckNotSupported
//
// • OvfUnsupportedDiskProvisioning
//
// • OvfDuplicatedPropertyIdImport
//
// • OvfNetworkMappingNotSupported
//
//
//
// • OvfSystemFault
//
//
//
// • OvfDiskMappingNotFound
//
// • OvfHostValueNotParsed
//
// • OvfInternalError
//
// • OvfUnsupportedDeviceBackingOption
//
// • OvfUnsupportedDeviceBackingInfo
//
// • OvfToXmlUnsupportedElement
//
// • OvfUnknownDevice
//
// • OvfUnknownEntity
//
//
//
// • OvfConsumerCallbackFault
//
//
//
// • OvfConsumerFault
//
// • OvfConsumerCommunicationError
//
// • OvfConsumerInvalidSection
//
// • OvfConsumerUndeclaredSection
//
// • OvfConsumerUndefinedPrefix
//
//
//
//
//
//
//
//
// All messages go into the vimlocale
//
//
//
type OvfFault struct {
	*VimFault
}

type OvfHardwareCheck struct {
	*OvfImport
}

//
// A common base class to host all the OvfLib Export Exceptions for hardware.
//
//
type OvfHardwareExport struct {
	*OvfExport

	// The virtual device we are exporting to OVF
	Device *do.VirtualDevice

	// The path to the VM containing the device.
	//
	// This path shows the location of the VM in the vApp hierarchy, on the form:
	//
	// /ParentVApp/ChildVApp/VMName
	VmPath string
}

//
// Class used to indicate that the value in HostResoruce did not map to
// a valid reference element.
//
//
type OvfHostResourceConstraint struct {
	*OvfConstraint

	// Value of the element
	Value string
}

type OvfHostValueNotParsed struct {
	*OvfSystemFault

	// The host property field that could not be parsed.
	Property string

	// Value of the field that could not be parsed.
	Value string
}

//
// A common base class for errors that can happen during Import and
// that is not due to an invalid package (OvfInvalidPackage). These
// are typically issued as warnings.
//
//
type OvfImport struct {
	*OvfFault
}

//
// This fault is used if we fail to deploy an OVF package.
//
//
type OvfImportFailed struct {
	*OvfImport
}

//
// Disk mode not supported
//
//
type OvfInternalError struct {
	*OvfSystemFault
}

//
// Base fault class for all Invalid OVF package faults.
//
//
type OvfInvalidPackage struct {
	*OvfFault

	// XML OVF descriptor line numbers
	LineNumber int32
}

//
// If an invalid value is found in the Ovf descriptor we throw an OvfInvalidValue exception.
//
//
type OvfInvalidValue struct {
	*OvfAttribute

	// Attribute value
	Value string
}

//
// If an malformed ovf:configuration attribute value is found in the
// Ovf descriptor we throw an OvfInvalidValueConfiguration exception.
//
//
type OvfInvalidValueConfiguration struct {
	*OvfInvalidValue
}

//
// If an attribute is found with an empty value where it is not allowed.
//
//
type OvfInvalidValueEmpty struct {
	*OvfInvalidValue
}

//
// If an malformed value is found in the Ovf descriptor we throw an OvfInvalidValueFormatMalformed
// exception.
//
//
type OvfInvalidValueFormatMalformed struct {
	*OvfInvalidValue
}

//
// If a value refer to something that is not found is found in the Ovf descriptor
// we throw an OvfInvalidValueReference exception.
//
//
type OvfInvalidValueReference struct {
	*OvfInvalidValue
}

//
// This fault is used if we can not normalize the vm name
//
//
type OvfInvalidVmName struct {
	*OvfUnsupportedPackage

	// The name of the invalid Virtual Machine
	Name string
}

type OvfMappedOsId struct {
	*OvfImport

	// The OS description specified in the OVF descriptor.
	OvfDescription string

	// The operating system id specified in the OVF descriptor.
	OvfId int32

	// The display name of the target OS
	TargetDescription string
}

//
// If the Ovf descriptor is missing an attribute this exception is thrown.
//
//
type OvfMissingAttribute struct {
	*OvfAttribute
}

//
// If the Ovf descriptor is missing an Element this exception is thrown.
//
//
type OvfMissingElement struct {
	*OvfElement
}

//
// If the Ovf descriptor element normal boundary is not met this exception is thrown.
//
//
type OvfMissingElementNormalBoundary struct {
	*OvfMissingElement

	// The missing bound
	Boundary string
}

type OvfMissingHardware struct {
	*OvfImport

	// Name of the missing hardware.
	Name string

	// OVF rasd resource type of the missing hardware.
	ResourceType int32
}

//
// The network mapping provided for OVF Import
// is not supported by any hosts
//
//
type OvfNetworkMappingNotSupported struct {
	*OvfImport
}

//
// This fault is used if there is no network defined on host
//
//
type OvfNoHostNic struct {
	*OvfUnsupportedPackage
}

//
// If the hardware element (RASD) point to a parent controller where there is no
// space left.
//
//
type OvfNoSpaceOnController struct {
	*OvfUnsupportedElement

	// The parent reference
	Parent string
}

type OvfNoSupportedHardwareFamily struct {
	*OvfUnsupportedPackage

	// Version found that was not supported
	Version string
}

//
// A base fault for property faults in the property section of the Ovf XML descriptor.
//
//
type OvfProperty struct {
	*OvfInvalidPackage

	// The type of the property
	Type string

	// The value of the property
	Value string
}

//
// VIM property type that can not be converted to OVF
//
//
type OvfPropertyExport struct {
	*OvfExport

	// VIM type
	Type string

	// VIM value
	Value string
}

//
// A class used indicate there was a property network error
//
//
type OvfPropertyNetwork struct {
	*OvfProperty
}

//
// VIM property type that refers to a network that
// does not exist in the package since no virtual machines
// are hooked up to it.
//
//
type OvfPropertyNetworkExport struct {
	*OvfExport

	// name of network
	Network string
}

//
// A class used to indicate there was a property qualifier error
//
//
type OvfPropertyQualifier struct {
	*OvfProperty

	// qualifiers
	Qualifier string
}

//
// Indicate that a property qualifier was duplicated.
//
//
type OvfPropertyQualifierDuplicate struct {
	*OvfProperty

	// qualifiers
	Qualifier string
}

//
// Indicate that the was qualifier was ignored
//
//
type OvfPropertyQualifierIgnored struct {
	*OvfProperty

	// qualifiers
	Qualifier string
}

//
// A class used to indicate there was a property type error
//
//
type OvfPropertyType struct {
	*OvfProperty
}

//
// A class used indicate there was a property value error
//
//
type OvfPropertyValue struct {
	*OvfProperty
}

//
// A common base class to host all the OVF subsystems's system  faults.
//
// This is a class of fault that can be thrown because of
// some api changes, new hardware that are not supported by
// the host.
//
//
//
type OvfSystemFault struct {
	*OvfFault
}

//
// Unsupported element to export to XML
//
//
type OvfToXmlUnsupportedElement struct {
	*OvfSystemFault

	// The name of the xml element we could not write to the xml descriptor
	Name string
}

type OvfUnableToExportDisk struct {
	*OvfHardwareExport

	// disk name
	DiskName string
}

//
// Class used to indicate an unexpected element in the Ovf descriptor
//
//
type OvfUnexpectedElement struct {
	*OvfElement
}

type OvfUnknownDevice struct {
	*OvfSystemFault

	// The unknown device
	Device *do.VirtualDevice

	// The name of the Virtual Machine containing the unkown device
	VmName string
}

type OvfUnknownDeviceBacking struct {
	*OvfHardwareExport

	// The VirtualDevice BackingInfo that is not supported by OVF export.
	Backing *do.VirtualDeviceBackingInfo
}

type OvfUnknownEntity struct {
	*OvfSystemFault

	// line number where the unknown entity was found
	LineNumber int32
}

//
// If the Ovf descriptor have an unsupported attribute.
//
//
type OvfUnsupportedAttribute struct {
	*OvfUnsupportedPackage

	// The name of the unsupported attribute
	AttributeName string

	// The name of the element with the unsupported attribute
	ElementName string
}

//
// Used when an OVF descriptor attribute has an unsupported value.
//
//
type OvfUnsupportedAttributeValue struct {
	*OvfUnsupportedAttribute

	// Unsupported attribute value
	Value string
}

type OvfUnsupportedDeviceBackingInfo struct {
	*OvfSystemFault

	// The name of the VirtualDevice Backing Info not supported on the device.
	BackingName string

	// The device name
	DeviceName string

	// The element name
	ElementName string

	// The InstanceId on the hardware description
	InstanceId string
}

type OvfUnsupportedDeviceBackingOption struct {
	*OvfSystemFault

	// The name of the VirtualDevice Backing Option not supported on the device.
	BackingName string

	// The device name
	DeviceName string

	// The element name
	ElementName string

	// The InstanceId for the hardware element
	InstanceId string
}

type OvfUnsupportedDeviceExport struct {
	*OvfHardwareExport
}

//
// Disk provisioning not supported
//
//
type OvfUnsupportedDiskProvisioning struct {
	*OvfImport

	// The disk provisioning that was not supported.
	DiskProvisioning string

	// Disk modes supported by the host.
	SupportedDiskProvisioning string
}

//
// If the Ovf descriptor has an unsupported element where it is not allowed.
//
//
type OvfUnsupportedElement struct {
	*OvfUnsupportedPackage

	// The name of the unsupported element
	Name string
}

//
// If the Ovf descriptor has an unsupported value of a element in the
// OVF descriptor.
//
//
type OvfUnsupportedElementValue struct {
	*OvfUnsupportedElement

	// The unsupported element value
	Value string
}

//
// A common base class to host all the Ovf Lib Unsupported Package faults
//
//
type OvfUnsupportedPackage struct {
	*OvfFault

	// OVF descriptor linenumber
	LineNumber int32
}

//
// If the Ovf descriptor has an unsupported required section.
//
//
type OvfUnsupportedSection struct {
	*OvfUnsupportedElement

	// The info of the unsupported section
	Info string
}

type OvfUnsupportedSubType struct {
	*OvfUnsupportedPackage

	// The device subtype that is unsupported
	DeviceSubType string

	// The device type
	DeviceType int32

	// The name of the element with the unsupported type
	ElementName string

	// The OVF RASD InstanceId for the hardware description
	InstanceId string
}

type OvfUnsupportedType struct {
	*OvfUnsupportedPackage

	// The device type that is unsupported
	DeviceType int32

	// The OVF RASD InstanceId for the hardware description
	InstanceId string

	// The name of the element with the unsupported type
	Name string
}

//
// If the Ovf descriptor has an element that is not accepted, this exception is thrown.
//
//
type OvfWrongElement struct {
	*OvfElement
}

//
// A OvfWrongNamespace exception is throw if the ovf descriptor has a
// Namespace error as defined in the Ovf spec
//
//
type OvfWrongNamespace struct {
	*OvfInvalidPackage

	// The name of the invalid namespace
	NamespaceName string
}

//
// Class used to specify if the Ovf XML descriptor could not be parsed
//
//
type OvfXmlFormat struct {
	*OvfInvalidPackage

	// Description of the XML parser error
	//
	// High level error description
	Description string
}

//
// This fault is thrown if a patch install fails because the patch
// is already installed on the host.
//
//
type PatchAlreadyInstalled struct {
	*PatchNotApplicable
}

//
// This fault is thrown if a patch install fails
// because the binaries associated with the patch are not found.
//
//
type PatchBinariesNotFound struct {
	*VimFault

	// The binaries that are not found.
	Binary []string

	// The patch whose associated binaries are not found.
	PatchID string
}

//
// This is a general-purpose fault indicating that some error has
// occurred regarding a patch install.  Data about the fault is
// available and is presented as a platform specific string.
//
//
type PatchInstallFailed struct {
	*PlatformConfigFault

	// Whether or not the patch install has been rolled back. If not,
	// a manual rollback is required.
	RolledBack bool
}

//
// This fault is thrown if a patch operation fails because the signature of
// the patch did not check out.
//
//
type PatchIntegrityError struct {
	*PlatformConfigFault
}

//
// This fault is thrown if the metadata associated with a patch is
// corrupted or unreadable when a patch query or install is attempted.
//
//
type PatchMetadataCorrupted struct {
	*PatchMetadataInvalid
}

//
// This fault is thrown if a patch query or
// installation operation fails because of a problem with the metadata
// associated with the patch. Typically, a subclass of this exception is
// thrown, indicating a problem such as the metadata is not found or the
// metadata is corrupted.
//
//
type PatchMetadataInvalid struct {
	*VimFault

	// The metadata file that is not available or corrupted.
	MetaData []string

	// The patch ID whose associated metadata is invalid.
	PatchID string
}

//
// This fault is thrown if the metadata associated with a patch is not
// found when a patch query or install is attempted.
//
//
type PatchMetadataNotFound struct {
	*PatchMetadataInvalid
}

//
// This fault is thrown if a patch install fails because the patch
// requires other patches or libraries that are not installed on the host.
//
//
type PatchMissingDependencies struct {
	*PatchNotApplicable

	// The names of required libraries or RPMs.
	PrerequisiteLib []string

	// The ID of required patches.
	PrerequisitePatch []string
}

//
// This fault is thrown if a patch install fails because the patch is not
// applicable to the host. Typically, a subclass of this exception is
// thrown, indicating a problem such as the patch is superseded, already
// installed, or has dependencies missing, and so on.
//
//
type PatchNotApplicable struct {
	*VimFault

	// The ID of the patch that is not applicable to the host.
	PatchID string
}

//
// This fault is thrown if a patch install fails because the patch is
// superseded by patches already installed.
//
//
type PatchSuperseded struct {
	*PatchNotApplicable

	// The patches that supersede this patch.
	Supersede []string
}

//
// The virtual machine is configured with a Raw Disk Mapping in physical compatibility mode.
// This mode is not supported on the host.
//
//
type PhysCompatRDMNotSupported struct {
	*RDMNotSupported
}

//
// A PlatformConfigFault is a catch-all fault indicating that some error has
// occurred regarding the configuration of the host.  Data about the fault is
// available and will be presented as a platform specific string.
//
// This information carried by this fault cannot be localized.  Most likely
// this information will already have been localized to the locale of the
// server that generated this fault.  Where possible, a more specific fault
// will be thrown.
//
//
//
type PlatformConfigFault struct {
	*HostConfigFault

	// Platform specific text string describing this error.
	Text string
}

//
// The PowerOnFtSecondaryFailed fault is thrown when the system is unable to
// power on a Fault Tolerance secondary virtual machine. It includes a list
// of failures on different hosts.
//
//
type PowerOnFtSecondaryFailed struct {
	*VmFaultToleranceIssue

	// Information on why the system can not power on a Fault Tolerance
	// secondary virtual machine on specific hosts. Everything in the array
	// should be FtIssuesOnHost.
	HostErrors []*do.LocalizedMethodFault

	// The host selection type
	HostSelectionBy *enum.FtIssuesOnHostHostSelectionType

	// The reason why powering on secondary failed.
	RootCause *do.LocalizedMethodFault

	// The primary virtual machine corresponding to the secondary that is to
	// be powered on
	Vm *mo.VirtualMachine

	// The name of the primary virtual machine corresponding to the secondary
	// that is to be powered on.
	VmName string
}

//
// PowerOnFtSecondaryTimedout exception is thrown when Virtual Center
// fails the operation to power on a Fault Tolerance secondary virtual
// machine because it is taking longer than expected.
//
//
type PowerOnFtSecondaryTimedout struct {
	*Timedout

	// The time out value in seconds
	Timeout int32

	// The primary virtual machine corresponding to the secondary that is to
	// be powered on
	Vm *mo.VirtualMachine

	// The name of the primary virtual machine corresponding to the secondary
	// that is to be powered on.
	VmName string
}

//
// Errors were detected during Profile update.
//
//
type ProfileUpdateFailed struct {
	*VimFault

	// Failures encountered during update
	Failure []*do.ProfileUpdateFailedUpdateFailure
}

//
// Thrown when an operation cannot be performed on a virtual machine
// because it has a pending question requiring user input.
//
//
type QuestionPending struct {
	*InvalidState

	// Text of the question from the virtual machine.
	Text string
}

//
// A QuiesceDatastoreIOForHAFailed fault occurs when the HA agent on a host
// cannot quiesce file activity on a datastore to be unmouonted or removed.
//
//
type QuiesceDatastoreIOForHAFailed struct {
	*ResourceInUse

	// The datastore.
	Ds *mo.Datastore

	// Name of the datastore.
	DsName string

	// The host.
	Host *mo.HostSystem

	// Name of the host.
	HostName string
}

//
// The virtual machine is using an RDM device with compatibility
// mode set to 'physicalMode' and operation is unable to convert
// the disk to a different type.
//
//
type RDMConversionNotSupported struct {
	*MigrationFault

	// The name of the disk device using the RDM.
	Device string
}

//
// The virtual machine is configured with a Raw Disk Mapping. The host only supports Raw
// Disk Mappings in a limited fashion. After the migration, the RDM will function correctly,
// but it will be indistinguishable from a virtual disk when viewing the virtual machine's
// properties. This change will persist even if the virtual machine is migrated
// back to a host with full RDM support.
//
// This is a warning only for migrations to ESX 2.1.x hosts.
//
//
//
type RDMNotPreserved struct {
	*MigrationFault

	// The name of the disk device using the RDM.
	Device string
}

//
// The virtual machine is configured with a Raw Disk Mapping. This is not
// supported on the host.
//
//
type RDMNotSupported struct {
	*DeviceNotSupported
}

//
// The virtual machine is configured with a Raw Disk Mapping. This is not
// supported on the datastore.
//
//
type RDMNotSupportedOnDatastore struct {
	*VmConfigFault

	// The datastore.
	Datastore *mo.Datastore

	// The name of the datastore.
	DatastoreName string

	// The label of the RDM device that would have its backing placed on
	// the datastore.
	// This is not guaranteed to be the only such device.
	Device string
}

//
// One of the virtual machine's virtual disks is a Raw Disk Mapping
// that is itself accessible, but points to a LUN that is inaccessible.
//
//
type RDMPointsToInaccessibleDisk struct {
	*CannotAccessVmDisk
}

//
// The virtual machine has a raw disk attached that is not supported. This is often
// used as a subfault for DisallowedMigrationDeviceAttached or
// DisallowedSnapshotDeviceAttached.
//
//
type RawDiskNotSupported struct {
	*DeviceNotSupported
}

//
// Fault thrown on host connect if we were unable to correctly read the
// existing tree on the root. This is bad because then we don't know the
// available resources on the host, and all kinds of admission control will
// fail.
//
// This just allows for more robust error handling - we should be able to
// read the existing hierarchy under normal conditions.
//
//
type ReadHostResourcePoolTreeFailed struct {
	*HostConnectFault
}

//
// The virtual machine uses read-only (undoable or nonpersistent) disks that
// can cause a slower power on at the migration destination. As a result, VMtion
// could slow down considerably or timeout. This is an issue only for migration of
// powered-on virtual machines from an ESX host with version greater
// than 2.0.x to an ESX host with version 2.0.x. It will be an error if the
// number of such disks is great enough to cause timeout ( &gt;= 3 ), or a warning
// otherwise.
//
//
type ReadOnlyDisksWithLegacyDestination struct {
	*MigrationFault

	// The number of read-only disks in use.
	RoDiskCount int32

	// Whether this number of disks will cause a timeout failure.
	TimeoutDanger bool
}

//
// This fault is thrown if a patch install fails because an installed
// nonchainable patch has not taken effect.
//
//
type RebootRequired struct {
	*VimFault

	// The nonchainable patch installed.
	Patch string
}

//
// Fault thrown if a record or replay operation cannot be performed
// because these capabilities have been disabled on the virtual machine.
//
//
type RecordReplayDisabled struct {
	*VimFault
}

//
// The virtual machine has a currently connected device with a remote backing.
// This is an error when migrating a powered-on virtual machine, and can be returned
// as a subfault of DisallowedMigrationDeviceAttached.
//
//
type RemoteDeviceNotSupported struct {
	*DeviceNotSupported
}

//
// This fault is thrown when the client attempts to remove an object that has
// active related objects (for example, a role that has active permissions).
//
//
type RemoveFailed struct {
	*VimFault
}

//
// Base type for Replication-related configuration errors.
//
//
type ReplicationConfigFault struct {
	*ReplicationFault
}

//
// A ReplicationDiskConfigFault is thrown when there is an issue with
// configuring disk replication properties.
//
//
type ReplicationDiskConfigFault struct {
	*ReplicationConfigFault

	// The disk (device) key in the parent VM for identification
	// purposes.
	Key int32

	// The reason for the failure. One of the above.
	Reason string

	// The virtual machine, for identification purposes.
	VmRef *mo.VirtualMachine
}

//
// Base type for Replication-related errors.
//
//
type ReplicationFault struct {
	*VimFault
}

//
// Used to indicate that FT cannot be enabled on a replicated virtual machine
// (returned by QueryFaultToleranceCompatibility).
//
//
type ReplicationIncompatibleWithFT struct {
	*ReplicationFault
}

//
// A ReplicationInvalidOptions fault is thrown when the options
// string passed contains invalid characters or broken format.
//
//
type ReplicationInvalidOptions struct {
	*ReplicationFault

	// Entity, if any, that has invalid options.
	Entity *mo.ManagedEntity

	// The invalid options string.
	Options string
}

//
// Thrown if the replication module is not loaded in the host.
//
//
type ReplicationNotSupportedOnHost struct {
	*ReplicationFault
}

//
// A ReplicationVmConfigFault is thrown when there is an issue with
// configuring VM-wide replication properties.
//
//
type ReplicationVmConfigFault struct {
	*ReplicationConfigFault

	// The reason for the failure. One of the above.
	Reason string

	// The virtual machine, for identification purposes.
	VmRef *mo.VirtualMachine
}

//
// A ReplicationVmFault is thrown when there is an issue with
// an operation performed on a replicated VirtualMachine
//
//
type ReplicationVmFault struct {
	*ReplicationFault

	// The name of the instance currently being created.
	InstanceId string

	// The reason for the failure. One of the above.
	Reason string

	// The current ReplicationVmState of the
	// VirtualMachine
	State string

	// The virtual machine, for identification purposes.
	Vm *mo.VirtualMachine
}

//
// A RequestCanceled fault is thrown if the user canceled the task.
//
//
type RequestCanceled struct {
	*RuntimeFault
}

//
// A ResourceInUse fault indicating that some error has occurred because a
// resource was in use.  Information about the resource that is in use may
// be supplied.
//
//
type ResourceInUse struct {
	*VimFault

	// Name of the instance of the resource that is in use.
	Name string

	// Type of resource that is in use.
	Type string
}

//
// A ResourceNotAvailable fault indicating that some error has occurred because a
// resource was not available.  Information about the resource that is in use may
// be supplied.
//
//
type ResourceNotAvailable struct {
	*VimFault

	// Name of container that contains the resource. .
	ContainerName string

	// Type of container that contains the resource.
	ContainerType string

	// Type of resource that is not available.
	Type string
}

//
// Thrown when the caller is not permitted to perform the specified
// operation due to product versioning restrictions.
//
//
type RestrictedVersion struct {
	*SecurityError
}

//
// Thrown if a Rollback operation fails
//
//
type RollbackFailure struct {
	*DvsFault

	// The entity name on which rollback failed
	EntityName string

	// The entity type on which rollback failed
	EntityType string
}

//
// The virtual machine if powered on, would violate an
// affinity/anti-affinity rule. In this case, the VM can still be powered
// on manually by a user who knows what they are doing, but VirtualCenter
// will never automatically move or power on a VM such that it triggers
// the violation.
//
//
type RuleViolation struct {
	*VmConfigFault

	// The host that the virtual machine can not be powered on without
	// violate a rule.
	//
	// Since VI API 2.5
	Host *mo.HostSystem

	// The rule that is violated. It can be an affinity or anti-affinity rule.
	//
	// Since vSphere API 4.0
	Rule *do.ClusterRuleInfo
}

//
// The base data object type for all runtime faults that can be
// thrown by a method.
//
//
type RuntimeFault struct {
	*MethodFault
}

//
// A SSLDisabledFault fault occurs when a host does not have ssl enabled.
//
//
type SSLDisabledFault struct {
	*HostConnectFault
}

//
// SSLVerifyFault is thrown by the host connect method if the VC
// server could not verify the authenticity of the host's SSL
// certificate.
//
// Currently, we do not distinguish the various possible reasons why
// the certificate could not be verified because we don't provide a
// way for the user to overwrite these reasons other than turning off
// SSL certificate verification completely.
//
// The only exception is the case when the certificate was rejected
// because it was self-signed. This is the most likely case when the
// user may want to overwrite the behavior by specifying the
// certificate's thumbprint in the ConnectSpec the next time the user
// connects to the host.
//
//
type SSLVerifyFault struct {
	*HostConnectFault

	// Whether the host's certificate was self signed
	SelfSigned bool

	// The thumbprint of the host's certificate
	Thumbprint string
}

//
// Thrown during SSPI pass-through authentication if further
// negotiation is required.
//
//
type SSPIChallenge struct {
	*VimFault

	// The opaque server response token, base-64 encoded.
	Base64Token string
}

//
// This fault is thrown when an attempt is made to disable a secondary
// virtual machine that has already been disabled.
//
//
type SecondaryVmAlreadyDisabled struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// This fault is thrown when an attempt is made to enable a secondary
// virtual machine that has already been enabled.
//
//
type SecondaryVmAlreadyEnabled struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// This fault is thrown when an attempt is made to register a secondary
// virtual machine with a primary virtual machine with whom it is
// already registered.
//
//
type SecondaryVmAlreadyRegistered struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// This fault is thrown when an attempt is made to unregister a secondary
// virtual machine from a primary virtual machine with whom it has not
// been previously registered.
//
//
type SecondaryVmNotRegistered struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// Thrown when the client is not allowed access to the property or method.
//
//
type SecurityError struct {
	*RuntimeFault
}

//
// The virtual machine has one or more SCSI controllers that are engaged
// in bus sharing. This is an error when migrating a powered-on virtual machine,
// and can be returned as a subfault of DisallowedMigrationDeviceAttached.
//
//
type SharedBusControllerNotSupported struct {
	*DeviceNotSupported
}

//
// This exception is thrown when VirtualMachine.shrinkDisk
// encounters an error
//
//
type ShrinkDiskFault struct {
	*VimFault

	// Disk Id of the virtual disk that caused the fault
	DiskId int32
}

//
// An attempt is being made to copy a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host under any circumstances. This is a warning.
//
//
type SnapshotCloneNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// An attempt is being made to move or copy a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported
// because of some aspect of the virtual machine configuration, virtual
// machine power state, or the requested disk placement.  This is an error
// for move operations (where the source is deleted after the copy) and a
// warning for clones (where the source is preserved).
//
//
type SnapshotCopyNotSupported struct {
	*MigrationFault
}

//
// Fault thrown if a snapshot operation cannot be performed because
// snapshots are disabled on the virtual machine.
//
//
type SnapshotDisabled struct {
	*SnapshotFault
}

//
// Base type for Snapshot-related errors.
//
//
type SnapshotFault struct {
	*VimFault
}

//
// Thrown if a snapshot operation cannot be performed on account
// of an incompatible device. This fault can be thrown for instance
// if a virtual machine uses a raw disk or a shared bus controller.
//
//
type SnapshotIncompatibleDeviceInVm struct {
	*SnapshotFault

	// A fault specifies the particular device issue. This is typically
	// a subclass of VirtualHardwareCompatibilityIssue, such as
	// RawDiskNotSupported, or SharedBusControllerNotSupported.
	Fault *do.LocalizedMethodFault
}

//
// Fault thrown when an attempt is made to create or delete a snapshot on a
// virtual machine that has its snapshot locked.
//
//
type SnapshotLocked struct {
	*SnapshotFault
}

//
// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the disk is currently located somewhere other than the virtual
// machine's home datastore.
//
//
type SnapshotMoveFromNonHomeNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host under any circumstances.
//
//
type SnapshotMoveNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the disk is being moved to some location other than the new
// home datastore for the virtual machine.
//
//
type SnapshotMoveToNonHomeNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// This fault is for a snapshot request on a virtual machine whose state
// has not changed since a previous successful snapshot. For example, this
// occurs when you suspend the virtual machine, create a snapshot, and
// then request another snapshot of the suspended virtual machine.
//
//
type SnapshotNoChange struct {
	*SnapshotFault
}

//
// If the virtual machine is migrated to the destination host, there may be
// a problem reverting to one of its snapshots. This is a warning.  If the
// snapshot name is not set and the event array is empty, then it the snapshot
// might possibly revert correctly.  If the name is set and the event array is not
// empty then there surely will be a problem reverting to the snapshot.
//
//
type SnapshotRevertIssue struct {
	*MigrationFault

	// True if any of the events above are error events.
	Errors bool

	// The problem(s) that would occur on reverting to the snapshot. This
	// is determined similarly to invoking validateMigration on a powered-off
	// virtual machine with the snapshot's state.  However, not all errors
	// or warnings for virtual machine migration are guaranteed to be
	// detected for snapshots.
	Event []*do.Event

	// The name of the problematic snapshot.
	SnapshotName string
}

//
// The current DRS migration priority setting prevents generating
// a recommendation to correct the soft VM/Host affinity rules constraint
// violation for the VM so the violation will not be corrected.
//
//
type SoftRuleVioCorrectionDisallowed struct {
	*VmConfigFault

	// The vm for which the VM/Host soft affinity rules constraint violation
	// is not being corrected by DRS.
	VmName string
}

//
// DRS has determined that correcting the soft VM/Host affinity rules
// constraint violation for the VM impacts respecting cluster constraints
// or performance goals so the violation will not be corrected.
//
//
type SoftRuleVioCorrectionImpact struct {
	*VmConfigFault

	// The vm for which the VM/Host soft affinity rules constraint violation
	// is not being corrected by DRS.
	VmName string
}

//
// A SsdDiskNotAvailable fault indicating that the specified SSD
// disk is not available. The disk either has been used or not a
// SSD disk.
//
//
type SsdDiskNotAvailable struct {
	*VimFault

	// The device path of the disk.See devicePath
	DevicePath string
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate one or more virtual disks of a VM because the disk has
// multi-writer mode enabled.
//
//
type StorageDrsCannotMoveDiskInMultiWriterMode struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate Fault Tolerant VMs across datastores.
//
//
type StorageDrsCannotMoveFTVm struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate an independent disk.
//
//
type StorageDrsCannotMoveIndependentDisk struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VM because it has a manually selected fixed location for its
// swap file.
//
//
type StorageDrsCannotMoveManuallyPlacedSwapFile struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate a Vm that is placed by user to a specific datastore.
//
//
type StorageDrsCannotMoveManuallyPlacedVm struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate a shared virtual disk that is attached to more than one Vm.
//
//
type StorageDrsCannotMoveSharedDisk struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate template VMs across datastores.
//
//
type StorageDrsCannotMoveTemplate struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs placed in user-specified folders.
//
//
type StorageDrsCannotMoveVmInUserFolder struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs that have a CD-ROM device mounted.
//
//
type StorageDrsCannotMoveVmWithMountedCDROM struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs that have no files in its file layout.
//
//
type StorageDrsCannotMoveVmWithNoFilesInLayout struct {
	*VimFault
}

//
// This fault is thrown when one datastore using Storage DRS is added to two
// different datacenters.
//
//
type StorageDrsDatacentersCannotShareDatastore struct {
	*VimFault
}

//
// This fault is thrown when Storage DRS cannot move disks of a virtual machine
// because Storage DRS is disabled on it.
//
//
type StorageDrsDisabledOnVm struct {
	*VimFault
}

//
// The fault occurs when Storage DRS disables IO Load balancing internally
// even though it is enabled by the user. This can happen due to one of the
// following reasons:
// 1. SIOC couldn't get enabled on at least one of the datastores
// 2. The connectivity between hosts and datastores is not uniform for all datastores.
// 3. Some statistics are not available to run IO load balancing
//
//
type StorageDrsIolbDisabledInternally struct {
	*VimFault
}

//
// This fault is thrown when Storage DRS cannot generate recommendations
// to move VM files due to pre-existing cross datastore disk backings.
//
//
type StorageDrsUnableToMoveFiles struct {
	*VimFault
}

//
// An operation on a powered-on virtual machine requests a change of storage
// location, but the host does not have that capability.
//
//
type StorageVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// This fault is thrown when Storage DRS tries to migrate disks of a virtual machine to a datastore,
// but finds that the datastore is incompatible with the given virtual machine.
//
//
type StorageVmotionIncompatible struct {
	*VirtualHardwareCompatibilityIssue

	// The datastore that is incompatible with a given virtual machine.
	Datastore *mo.Datastore
}

//
// Either the source host product or the destination host product does not support
// relocation of suspended VMs.  It must be supported on both, in order for the
// relocation to succeed.  This fault is only applicable to suspended virtual machines.
//
//
type SuspendedRelocateNotSupported struct {
	*MigrationFault
}

//
// The compute resource and/or virtual machine configurations indicate that
// when executing on the host the virtual machine should use a specific
// datastore, but host does not have read/write access to that datastore.
// (It may have no access at all, or read-only access.)  If executing on the
// host the virtual machine would instead use its own directory for swapfile
// placement.  This is a compatibility warning, not an error.
//
//
type SwapDatastoreNotWritableOnHost struct {
	*DatastoreNotWritableOnHost
}

//
// The compute resource and/or virtual machine configurations indicate that
// when executing on the host the virtual machine should use a swap
// datastore, but the host does not have a swap datastore configured.  If
// executing on the host the virtual machine would instead use its own directory
// for swapfile placement.  This is a compatibility warning, not an error.
// Note it is actually the common case for a host to not have a configured
// swap datastore, and the problem may rest with the compute resource and/or
// virtual machine configuration; therefore this is not a HostConfigFault.
//
//
type SwapDatastoreUnset struct {
	*VimFault
}

//
// The virtual machine is configured to override the default swapfile placement
// policy, which is not supported on the host.
//
//
type SwapPlacementOverrideNotSupported struct {
	*InvalidVmConfig
}

//
// The distributed virtual switch received a reconfiguration request to
// activate a feature that requires a switch IP address. However, the IP
// address for the switch has not been specified.
//
//
type SwitchIpUnset struct {
	*DvsFault
}

//
// Thrown if an operation is not supported while the DistributedVirtualSwitch
// is not in upgrade mode.
//
//
type SwitchNotInUpgradeMode struct {
	*DvsFault
}

//
// Exception type for reporting a low-level operating system
// error.
//
//
type SystemError struct {
	*RuntimeFault

	// A message to indicate detailed information about the error.
	// This property is not internationalization friendly and
	// normally reported by the underlying operating system.
	Reason string
}

//
// The TaskInProgress data object type represents a fault when an operation tries
// to access an entity that already has another (long) operation in progress.
//
//
type TaskInProgress struct {
	*VimFault

	// The task already in progress when the operation was attempted.
	Task *mo.Task
}

//
// A ThirdPartyLicenseAssignmentFailed fault is thrown when
// the license assignment to a 3rd party module fails.
//
// The 3rd-party modules are installed and ran on ESX hosts,
// so this fault provides both host and module IDs.
//
//
type ThirdPartyLicenseAssignmentFailed struct {
	*RuntimeFault

	// The ESX host where 3rd party license was applied.
	Host *mo.HostSystem

	// The asset-id of 3rd party module
	Module string

	// The reason why the assignment failed, if known.
	Reason string
}

//
// Timedout exception is thrown when a server abandons an operation that
// is taking longer than expected.
//
//
type Timedout struct {
	*VimFault
}

//
// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
//
//
type TooManyConcurrentNativeClones struct {
	*FileFault
}

//
// Thrown if there are too many consecutive user overrides of
// server-managed settings. There are some properties which users are
// allowed to set only in certain configurations. The system controls them
// in other configurations, and overrides all user updates. If there are
// such frequent user overrides in the system controlled state that the
// next update arrives before the previous override is complete, the
// system can enter a tight loop and appear unresponsive to the user. This
// would typically happen if the user overrides are generated by a script.
//
// If the number of such user overrides exceeds the supported maximum, we
// conceptually "throw" this fault. In practice, this is converted into a
// host-level ConfigIssue in VC.
//
//
type TooManyConsecutiveOverrides struct {
	*VimFault
}

//
// Thrown when the number of virtual devices exceeds the maximum for
// a given controller.
//
//
type TooManyDevices struct {
	*InvalidVmConfig
}

// Deprecated.
// As of vSphere 4.1, this error condition is no longer possible.
//
//
// The VM has too many disks which can cause the VM to take a long time
// to power-on. This can result in migration taking a long time to complete
// or to fail due to timeout. This is a problem only for migration of
// powered-on virtual machines from or to ESX 2.x hosts.
//
//
type TooManyDisksOnLegacyHost struct {
	*MigrationFault

	// The number disks this VM has.
	DiskCount int32

	// Whether this number of disks will cause a timeout failure.
	TimeoutDanger bool
}

//
// A TooManyGuestLogons exception is thrown when
// there are too many concurrent login sessions active
// in the guest. ReleaseCredentialsInGuest can be called
// on ticketed sessions that are no longer needed. This will decrease
// the number of concurrent sessions active in the guest.
//
//
type TooManyGuestLogons struct {
	*GuestOperationsFault
}

//
// Thrown when a computer resource does not accept any more hosts. Clusters with DRS or
// HA enabled might impose a limit on the size of the cluster.
//
//
type TooManyHosts struct {
	*HostConnectFault
}

//
// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
//
//
type TooManyNativeCloneLevels struct {
	*FileFault
}

//
// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
//
//
type TooManyNativeClonesOnFile struct {
	*FileFault
}

//
// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
//
//
type TooManySnapshotLevels struct {
	*SnapshotFault
}

//
// Thrown when tools upgrade fails because the version of tools
// installed in the guest is already up-to-date.
//
//
type ToolsAlreadyUpgraded struct {
	*VmToolsUpgradeFault
}

//
// Thrown when tools upgrade fails because the virtual machine's
// guest operating system doesn't support tools auto-upgrades.
//
//
type ToolsAutoUpgradeNotSupported struct {
	*VmToolsUpgradeFault
}

//
// Thrown when the tools image couldn't be copied to the guest
// operating system: disk out of space, file access error, etc.
//
//
type ToolsImageCopyFailed struct {
	*VmToolsUpgradeFault
}

//
// Thrown when tools install or upgrade fails because the required
// tools image is not available.
//
//
type ToolsImageNotAvailable struct {
	*VmToolsUpgradeFault
}

//
// Thrown when tools install or upgrade fails because the
// signature check on the tools image failed.
//
//
type ToolsImageSignatureCheckFailed struct {
	*VmToolsUpgradeFault
}

//
// The virtual machine is currently in the progress of guest tools installation
// that prevents the migration operation.
//
//
type ToolsInstallationInProgress struct {
	*MigrationFault
}

//
// A ToolsUnavailableFault exception is thrown when an
// operation fails to contact VMware Tools
// running inside the virtual machine.
//
//
type ToolsUnavailable struct {
	*VimFault
}

//
// Thrown when tools install or upgrade fails because the
// operation was canclled by the user.
//
//
type ToolsUpgradeCancelled struct {
	*VmToolsUpgradeFault
}

//
// VFlash is not supported on the datastore.
//
//
type UnSupportedDatastoreForVFlash struct {
	*UnsupportedDatastore

	// The name of the Datastore.
	DatastoreName string

	// Datastore file system volume type.
	// See type
	Type string
}

//
// Fault thrown when an attempt is made to move or clone an undoable disk with an
// uncommitted REDO log.  This is an error.  Undoable disks may be moved but they must
// be committed.
//
//
type UncommittedUndoableDisk struct {
	*MigrationFault
}

//
// The property value has not been configured by the user, so the application
// cannot be started. This is thrown if a property value is the empty string
// and the types does not allow it. For example, for an integer type or
// a string where the minimum length is 1, and so forth.
//
//
type UnconfiguredPropertyValue struct {
	*InvalidPropertyValue
}

//
// The specified guest operating system is not supported by the guest
// customization process.
//
//
type UncustomizableGuest struct {
	*CustomizationFault

	// The guest OS ID for the uncustomizable guest.
	UncustomizableGuestOS string
}

//
// Error received when customization fails, possibly due to a scripting runtime
// error or invalid script parameters.
//
//
type UnexpectedCustomizationFault struct {
	*CustomizationFault
}

//
// An UnexpectedFault may be thrown when a newer version of the server
// reports a error that a cannot be converted to a fault that a client
// that is using an older version of the API would expect.
//
//
type UnexpectedFault struct {
	*RuntimeFault

	// The unexpected fault if the server can send it in a form that the client
	// will be able to deserialize.
	Fault *do.LocalizedMethodFault

	// Name of the unexpected fault.
	FaultName string
}

//
// A UnrecognizedHost is thrown if the VirtualCenter server fails to
// validate the identity of the host using host-key.
//
// If a reconnect is attempted on a host and if the host-key of the host
// has changed since the last successful connection attempt,
// (might be changed by another instance of VirtualCenter), VirtualCenter
// server will fail to recognize the host.
//
//
type UnrecognizedHost struct {
	*VimFault

	// Host in the VirtualCenter inventory which failed the identity
	// validation.
	HostName string
}

//
// The compute resource and virtual machine configurations for swapfile
// placement would require the virtual machine swapfile to change location for
// this VMotion; however the host does not support this.
//
//
type UnsharedSwapVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// The virtual machine is not supported on the target datastore. This fault is
// thrown by provisioning operations when an attempt is made to create a virtual
// machine on an unsupported datastore (for example, creating a non-legacy
// virtual machine on a legacy datastore).
//
//
type UnsupportedDatastore struct {
	*VmConfigFault

	// The invalid datastore for this virtual machine.
	Datastore *mo.Datastore
}

//
// The specified guest operating system is not supported on the host
// that is the target of the operation.
//
//
type UnsupportedGuest struct {
	*InvalidVmConfig

	// The guest OS ID for the unsupported guest.
	UnsupportedGuestOS string
}

//
// This exception will be thrown if a client tries to connect with a unsupported version
// of the Vim API.
//
//
type UnsupportedVimApiVersion struct {
	*VimFault

	Version string
}

//
// ESX 3 Server products requires the .vmx file to be stored
// on NAS or VMFS3 storage. If attempting to power on a virtual
// machine with the .vmx file stored on the service console, this
// fault will be thrown.
//
//
type UnsupportedVmxLocation struct {
	*VmConfigFault
}

//
// The unused disk blocks of the specified virtual disk have not been
// scrubbed on the file system.
//
// Typically, this fault is returned as part of a parent fault like
// VmConfigIncompatibleForFaultTolerance, indicating that the
// unused blocks of the virtual disk must be zeroed-out on the file system before
// before fault tolerance can be enabled on the associated virtual machine.
//
//
//
//
type UnusedVirtualDiskBlocksNotScrubbed struct {
	*DeviceBackingNotSupported
}

//
// Thrown when the request refers to a user or group name that could not
// be resolved.
//
//
type UserNotFound struct {
	*VimFault

	// Principal value that failed lookup.
	Principal string

	// Flag to indicate whether or not the lookup was unsuccessful.
	// A false value indicates that the user does not exist in the directory. A true
	// value indicates that the directory could not be contacted, possibly due to a
	// network error.
	Unresolved bool
}

//
// Base for configuration / environment issues that can be thrown when powering on or
// changing the configuration of a vApp.
//
//
type VAppConfigFault struct {
	*VimFault
}

//
// A virtual machine in a vApp cannot be powered on unless the
// parent vApp is running.
//
//
type VAppNotRunning struct {
	*VmConfigFault
}

//
// This fault is thrown when an operation is attempted on a target where
// a vApp operation is already in progress. E.g. when trying to move a
// virtual machine from a vApp that is being powered on.
//
//
type VAppOperationInProgress struct {
	*RuntimeFault
}

//
// The base fault for all vApp property configuration issues
//
//
type VAppPropertyFault struct {
	*VmConfigFault

	// The user-readable category
	Category string

	// The fully-qualified id of the property, including instance and class
	// identifiers.
	Id string

	// The user-readable label
	Label string

	// The type specified for the property
	Type string

	// The value of the property
	Value string
}

//
// A specialized TaskInProgress when an operation is performed
// on a VM and it is failed due to a vApp-level operation
// is in progress. For example, while the power-on sequence is
// executed on a vApp, individual power-on's of child VMs are
// failed.
//
//
type VAppTaskInProgress struct {
	*TaskInProgress
}

//
// vFlash module is not supported due to its configuration is not
// supported by the host.
//
//
type VFlashModuleNotSupported struct {
	*VmConfigFault

	// Host name
	HostName string

	// The vFlash module name.
	ModuleName string

	// Message of reason.
	Reason string

	// VM name
	VmName string
}

//
// The vFlash module version of the vFlash cache asscociated with the
// virtual disk of a VM is not compatible with the supported versions of
// the specified vFlash module on the host.
//
//
type VFlashModuleVersionIncompatible struct {
	*VimFault

	// The minimum supported version of the specified module on the host.
	HostMinSupportedVerson string

	// The verson of the specified module on the host.
	HostModuleVersion string

	// The vFlash module name.
	ModuleName string

	// The VM request module version.
	VmRequestModuleVersion string
}

//
// The virtual machine is configured to use a VMI ROM, which is not
// supported on the host.
//
//
type VMINotSupported struct {
	*DeviceNotSupported
}

//
// The virtual machine is using a conflict DVPort, which is a temporary port created
// to avoid conflict with another port. Conflict DVPort cannot be moved.
//
//
type VMOnConflictDVPort struct {
	*CannotAccessNetwork
}

//
// The virtual machine is using a "virtual intranet", a virtual network
// that exists only within a single host. If returned as part of a migration check, this
// is an error if the virtual machine is currently connected to the network and a
// warning otherwise.
//
//
type VMOnVirtualIntranet struct {
	*CannotAccessNetwork
}

//
// An operation on a powered-on virtual machine requests a change of
// networks, but the host does not have that capability.
//
//
type VMotionAcrossNetworkNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// A VMotion interface has a problem. This may be an error or warning depending
// on the specific fault subclass. This is an error or warning only when
// migrating a powered-on virtual machine.
//
//
type VMotionInterfaceIssue struct {
	*MigrationFault

	// Whether this error is for the source host.
	AtSourceHost bool

	// The name of the host with the bad interface.
	FailedHost string

	// The host with the bad interface.
	//
	// Since VI API 2.5
	FailedHostEntity *mo.HostSystem
}

//
// The VMotion interface does not have the recommended capacity to support
// VMotion. VMotion is supported on links that have a speed of at least 1000
// Mbps and are full duplex. This is a warning for migrating powered-on virtual
// machines.
//
//
type VMotionLinkCapacityLow struct {
	*VMotionInterfaceIssue

	// Name of the network being used for the VMotion interface.
	Network string
}

//
// The VMotion interface does not have any operational physical links
// associated with it. This is an error for migrating powered-on virtual
// machines.
//
//
type VMotionLinkDown struct {
	*VMotionInterfaceIssue

	// Name of the network being used for the VMotion interface.
	Network string
}

//
// A VMotion interface is not configured (or is misconfigured) on
// either the source or destination host.  This is an error only
// when migrating a powered-on virtual machine.
//
//
type VMotionNotConfigured struct {
	*VMotionInterfaceIssue
}

//
// VMotion is not licensed on a source or destination host. It must be licensed on both
// hosts.
//
//
type VMotionNotLicensed struct {
	*VMotionInterfaceIssue
}

//
// The source or the destination host does not support VMotion.  This is an
// error only when migrating a powered-on virtual machine.
//
//
type VMotionNotSupported struct {
	*VMotionInterfaceIssue
}

//
// VMotion protocol version incompatibility prevents VMotion from the
// virtual machine's current host to the requested destination host.
// (VMotion in the other direction may or may not be supported.)
//
//
type VMotionProtocolIncompatible struct {
	*MigrationFault
}

//
// The common base type for all virtual infrastructure management
// exceptions.
//
//
type VimFault struct {
	*MethodFault
}

//
// The disk blocks of the specified virtual disk have not been fully
// provisioned on the file system.
//
// Typically, this fault is returned as part of a parent fault like
// VmConfigIncompatibleForFaultTolerance, indicating that the
// disk blocks of the virtual disk must be fully provisioned on the file system
// before fault tolerance can be enabled on the associated virtual machine.
//
//
//
//
type VirtualDiskBlocksNotFullyProvisioned struct {
	*DeviceBackingNotSupported
}

//
// The disk mode of the specified virtual disk is not supported.
//
// Typically, this fault is returned as part of a parent fault like
// VmConfigIncompatibleForFaultTolerance, indicating that the
// virtual disk's mode needs to be changed before fault tolerance can be
// enabled on the associated virtual machine.
//
//
//
//
type VirtualDiskModeNotSupported struct {
	*DeviceNotSupported

	// Disk mode that is not supported
	Mode string
}

//
// The virtual machine's virtual ethernet card is not supported.
//
//
type VirtualEthernetCardNotSupported struct {
	*DeviceNotSupported
}

//
// There is a problem with the compatibility between the intended execution host
// and the virtual machine. This may be an error or warning depending on
// the specific fault subclass.
//
//
type VirtualHardwareCompatibilityIssue struct {
	*VmConfigFault
}

//
// The virtual machine's virtual hardware version is not supported on the host.
//
//
type VirtualHardwareVersionNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The host.
	//
	// Since VI API 2.5
	Host *mo.HostSystem

	// Since VI API 2.5
	HostName string
}

//
// Fault thrown when moving a standalone host between datacenters, and
// one or more of the virtual machines registered on the host are already
// registered to hosts in the target datacenter.
//
//
type VmAlreadyExistsInDatacenter struct {
	*InvalidFolder

	// The target host.
	Host *mo.HostSystem

	// Name of the target host.
	Hostname string

	// Virtual machines in the target datacenter which have the same
	// registration information as those belonging to the target host.
	Vm []*mo.VirtualMachine
}

//
// Base for configuration / environment issues that can be thrown when powering on or
// changing the configuration of a virtual machine. Subclasses of this fault is also
// used as recent why a migration can fail.
//
//
type VmConfigFault struct {
	*VimFault
}

//
// Thrown when a virtual machine's existing or requested configuration is
// incompatible for fault tolerance.
//
//
type VmConfigIncompatibleForFaultTolerance struct {
	*VmConfigFault

	// Fault indicating the specific configuration issue. This is typically
	// a subclass of VirtualHardwareCompatibilityIssue.
	Fault *do.LocalizedMethodFault
}

//
// Thrown when a virtual machine's existing or requested configuration is
// incompatible for record and replay.
//
//
type VmConfigIncompatibleForRecordReplay struct {
	*VmConfigFault

	// Fault indicating the specific configuration issue. This is typically
	// a subclass of VirtualHardwareCompatibilityIssue.
	Fault *do.LocalizedMethodFault
}

//
// Configuration issues that can occur during operations
// related to fault tolerance protection for virtual machines.
//
//
type VmFaultToleranceConfigIssue struct {
	*VmFaultToleranceIssue

	// The entity
	Entity *mo.ManagedEntity

	// The entity name. Depending on the issue, it could
	// be virtual machine or host.
	EntityName string

	// The reason for the failure.
	Reason string
}

//
// Configuration issues that can occur during operations
// related to fault tolerance protection for virtual machines.
//
//
type VmFaultToleranceConfigIssueWrapper struct {
	*VmFaultToleranceIssue

	// The entity
	Entity *mo.ManagedEntity

	// The entity name. Depending on the issue, it could
	// be virtual machine or host.
	EntityName string

	// The nested error when the reason field is other
	Error *do.LocalizedMethodFault
}

//
// Indicates the file backing for some device prevents fault tolerance
// protection
//
//
type VmFaultToleranceInvalidFileBacking struct {
	*VmFaultToleranceIssue

	BackingFilename string

	// The device type of the file backing
	BackingType string
}

//
// Base object type for issues that can occur during operations
// related to fault tolerance protection for virtual machines.
//
//
type VmFaultToleranceIssue struct {
	*VimFault
}

//
// Container for a list of configuration issues that can occur during
// operations related to fault tolerance protection for virtual machines.
//
//
type VmFaultToleranceOpIssuesList struct {
	*VmFaultToleranceIssue

	// A list of faults representing errors
	Errors []*do.LocalizedMethodFault

	Warnings []*do.LocalizedMethodFault
}

//
// This fault is returned when a host has more than the recommended number of
// Fault Tolerance VMs running on it.
//
//
type VmFaultToleranceTooManyVMsOnHost struct {
	*InsufficientResourcesFault

	HostName string

	// The recommended number of Fault Tolerance VMs running on the host.
	MaxNumFtVms int32
}

//
// The virtual machine if powered on or VMotioned, would violate a VM-Host affinity rule.
//
//
type VmHostAffinityRuleViolation struct {
	*VmConfigFault

	// The host that the virtual machine can not be powered on without violating a rule.
	HostName string

	// The vm that can not be powered on or VMotioned without violating a rule.
	VmName string
}

//
// A VmLimitLicense fault is thrown if powering on the virtual
// machine would exceed the maximum number of running virtual
// machines allowed.
//
//
type VmLimitLicense struct {
	*NotEnoughLicenses

	// The maximum number of running virtual machines
	// limit.
	Limit int32
}

//
// This fault indicates that some error has occurred during the processing of
// of a MetadataManager operation. This may be subclassed by a more specific
// fault.
//
//
type VmMetadataManagerFault struct {
	*VimFault
}

//
// Thrown when turning on Fault Tolerance protection on a running virtual machine
// if the virtual machine is running in a monitor mode that is incompatible.
//
//
type VmMonitorIncompatibleForFaultTolerance struct {
	*VimFault
}

//
// This exception is thrown if the power-on of a virtual machine is attempted
// when the operation is disabled on the host
//
//
type VmPowerOnDisabled struct {
	*InvalidState
}

//
// A base fault to indicate that something went wrong when upgrading tools.
//
//
type VmToolsUpgradeFault struct {
	*VimFault
}

type VmValidateMaxDevice struct {
	*VimFault

	// number of devices found in vim.vm.ConfigSpec
	Count int32

	// The device
	Device string

	// max count for the device
	Max int32
}

//
// Thrown if a user attempts to assign a
// WWN that is currently being used by other virtual machine or host.
//
//
type VmWwnConflict struct {
	*InvalidVmConfig

	// The host that is using the same WWN.
	Host *mo.HostSystem

	// The name of the virtual machine/host that is using the same WWN.
	Name string

	// The virtual machine that is using the same WWN.
	Vm *mo.VirtualMachine

	// The WWN that is in conflict.
	Wwn int64
}

//
// A VmfsAlreadyMounted fault indicates that VMFS volume with same UUID
// is already mounted on the host.
//
//
type VmfsAlreadyMounted struct {
	*VmfsMountFault
}

//
// An 'VmfsAmbiguousMount' fault occurs when ESX is unable to resolve the
// extents of a VMFS volume unambiguously. This is thrown only when a VMFS
// volume has multiple extents and multiple copies of VMFS volumes are available.
// VMFS layer will not be able to determine how to re-construct the VMFS
// volume as multiple choices are available.
//
//
type VmfsAmbiguousMount struct {
	*VmfsMountFault
}

//
// This is a base class for all VMFS volume mount related faults.
//
//
type VmfsMountFault struct {
	*HostConfigFault

	// Vmfs volume uuid
	Uuid string
}

//
// This fault is thrown when the Vmotion Interface on this host is not enabled.
// The Vmotion Interface is needed for waking up the host from standby mode.
//
//
type VmotionInterfaceNotEnabled struct {
	*HostPowerOpFailed
}

//
// An error occurred in the Open Source Components applications during
// volume editing. Possibly caused by an incompatible cygwin version
// installed in the VirtualCenter server.
//
//
type VolumeEditorError struct {
	*CustomizationFault
}

//
// A VramLimitLicense fault is thrown if executing an operation
// would result in exceeding maximum allowed vRAM amount.
//
// For example, this could happen when powering on a VM,
// hot-plugging memory into a running VMm, etc.
//
//
type VramLimitLicense struct {
	*NotEnoughLicenses

	// The maximum allowed vRAM amount.
	Limit int32
}

//
// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into a ClusterComputeResource whose
// VSAN cluster UUID does not match.See CannotMoveVsanEnabledHost
//
//
type VsanClusterUuidMismatch struct {
	*CannotMoveVsanEnabledHost

	// The VSAN cluster UUID in use by the destination
	// ClusterComputeResource.
	DestinationClusterUuid string

	// The VSAN cluster UUID in use by the host at hand.
	HostClusterUuid string
}

//
// Base exception class for VSAN disk-related faults.
//
//
type VsanDiskFault struct {
	*VsanFault

	// The canonical name for the disk at hand, if applicable.See canonicalName
	Device string
}

//
// Base exception class for VSAN-specific faults raised for host
// or cluster operations.See HostVsanSystemSee ReconfigureComputeResource_Task
//
//
type VsanFault struct {
	*VimFault
}

//
// Thrown if a dvPort is used as destination in multiple Distributed Port Mirroring sessions.
//
//
type VspanDestPortConflict struct {
	*DvsFault

	// The key of the the port that is used as destination in multiple Distributed Port Mirroring sessions
	PortKey string

	// The key of the Distributed Port Mirroring session whose destination ports include a port
	// that is also used as destination ports of other Distributed Port Mirroring sessions
	VspanSessionKey1 string

	// The key of the Distributed Port Mirroring session whose destination ports include a port
	// that is also used as destination ports of other Distributed Port Mirroring sessions
	VspanSessionKey2 string
}

//
// Thrown if a DistributedVirtualPort appears in both the transmitted source and destination
// ports of any Distributed Port Mirroring session.
//
//
type VspanPortConflict struct {
	*DvsFault

	// The key of the port that is both the transmitted source and destination.
	PortKey string

	// The key of the Distributed Port Mirroring session that is in conflict
	VspanSessionKey1 string

	// The key of the Distributed Port Mirroring session that is in conflict
	VspanSessionKey2 string
}

//
// Thrown when moving a port used as tranmistted source or destination ports in vspan
// session to a promiscuous portgroup if this operation may change
// the non-promiscuous port to promiscuous mode.
//
//
type VspanPortMoveFault struct {
	*DvsFault

	// The key of the dest portgroup.
	DestPortgroupName string

	// The key of the port.
	PortKey string

	// The key of the source portgroup.
	SrcPortgroupName string
}

//
// Thrown when changing a non-promiscuous port used as tranmistted source or dest
// ports in Distributed Port Mirroring session to promiscuous mode.
//
//
type VspanPortPromiscChangeFault struct {
	*DvsFault

	// The key of the port.
	PortKey string
}

//
// Thrown when changing a non-promiscous portgroup to promiscuous mode if any port
// in this portgroup is used as tranmistted source or dest ports in vspan
// session.
//
//
type VspanPortgroupPromiscChangeFault struct {
	*DvsFault

	// The key of the port.
	PortgroupName string
}

//
// Thrown when changing a portgroup from static/dynamic binding to
// ephemeral(no binding) if any ports in this portgroup participate in
// Distributed Port Mirroring session.
//
//
type VspanPortgroupTypeChangeFault struct {
	*DvsFault

	// The name of the portgroup.
	PortgroupName string
}

//
// Thrown if a promiscuous port appears in transmitted source or destination
// ports of any Distributed Port Mirroring session.
//
//
type VspanPromiscuousPortNotSupported struct {
	*DvsFault

	// The key of the promiscuous port that appears in transmitted
	// source or destination ports.
	PortKey string

	// The key of the Distributed Port Mirroring session in which a promiscuous port is used as
	// transmitted source or destination ports.
	VspanSessionKey string
}

//
// Thrown if a dvPort appears in both the source and destination
// ports of the same Distributed Port Mirroring session.
//
//
type VspanSameSessionPortConflict struct {
	*DvsFault

	// The key of the port that appears in both the source and
	// destination ports of the same Distributed Port Mirroring session.
	PortKey string

	// The key of the Distributed Port Mirroring session in which a dvPort appears in both the source and destination ports
	VspanSessionKey string
}

//
// The virtual machine and at least one of its virtual NICs are configured to
// use Wake-on-LAN, but the host does not support Wake-on-LAN for the
// virtual machine's selected guest OS.
//
//
type WakeOnLanNotSupported struct {
	*VirtualHardwareCompatibilityIssue
}

//
// This fault is thrown when Wake-on-LAN isn't supported by the Vmotion NIC on the host.
//
//
type WakeOnLanNotSupportedByVmotionNIC struct {
	*HostPowerOpFailed
}

//
// This fault is reported when the execution of a storage vmotion or
// relocate operation would impact vSphere HA's ability to
// restart a VM. For storage vmotion, this fault
// is reported when HA protection will be lost after the vmotion
// completes. Consequently, HA would not restart the VM if it
// subsequently failed. For relocate, relocate is not supported on
// VMs that failed before the operation is attempted and are in the
// process of being restarted at the time the operation is performed.
//
//
type WillLoseHAProtection struct {
	*MigrationFault

	// The steps the user can take to restore protection if the
	// the operation is performed. Values come from
	// Resolution.
	Resolution string
}

//
// A virtual machine's total CPU feature requirements are determined by
// overlaying the requirements specified in its configuration (if any) on top
// of the requirements specified in the descriptor for its guest OS.  It is
// therefore possible for a host change to implicitly change a virtual
// machine's CPU feature requirements.  The guest OS descriptor may have
// different requirements on the new host.  Or, if the virtual machine
// currently specifies requirements in its configuration, those requirements
// will be lost if the new host does not support this.
//
// This fault indicates that the virtual machine's CPU feature requirements
// would change because of a migration, and also that the destination host
// does support storing CPU feature requirements in the virtual machine's
// configuration.  (If the destination host does not support such an action,
// CannotModifyConfigCpuRequirements is used instead of this fault.)
//
//
// This is a warning to notify the user that the migration process will
// adjust the virtual machine's configuration so that it will be operating
// under an unchanged set of CPU feature requirements on its new host.  If the
// user wishes to expose the different guest OS requirements of the new host,
// the user will need to edit the virtual machine's configuration after the
// migration.
//
//
//
type WillModifyConfigCpuRequirements struct {
	*MigrationFault
}

//
// This fault is reported when the execution of a storage vmotion or
// relocate operation would reset the snapshotDirectory settings
// to its default value (VM's home/config directory).
//
//
type WillResetSnapshotDirectory struct {
	*MigrationFault
}

//
// This exception is thrown when VirtualMachine.wipeDisk
// encounters an error
//
//
type WipeDiskFault struct {
	*VimFault
}
