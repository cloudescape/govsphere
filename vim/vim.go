//Generated by https://github.com/c4milo/govsphere
//Do not modify
//Copyright (c) 2014, Cloudescape. All rights reserved.

package vim

import (
	"errors"
	"github.com/c4milo/govsphere/vim/enum"
	"time"
)

//
// This data object type describes system information
// including the name, type, version, and build number.
//
//
type AboutInfo struct {
	*DynamicData

	// Indicates whether or not the service instance represents a
	// standalone host.
	// If the service instance represents a standalone host, then the physical
	// inventory for that service instance is fixed to that single host.
	// VirtualCenter server provides additional features over single hosts.
	// For example, VirtualCenter offers multi-host management.
	//
	// Examples of values are:
	//
	// "VirtualCenter" - For a VirtualCenter instance.
	// "HostAgent" - For host agent on an ESX Server or VMware Server host.
	ApiType string

	// The version of the API as a dot-separated string. For example, "1.0.0".
	ApiVersion string

	// Build string for the server on which this call is made. For example, x.y.z-num.
	// This string does not apply to the API.
	Build string

	// The complete product name, including the version information.
	FullName string

	// A globally unique identifier associated with this service instance.
	//
	// Since vSphere API 4.0
	InstanceUuid string

	// The license product name
	//
	// Since vSphere API 4.0
	LicenseProductName string

	// The license product version
	//
	// Since vSphere API 4.0
	LicenseProductVersion string

	// Build number for the current session's locale.
	// Typically, this is a small number reflecting a
	// localization change from the normal product build.
	LocaleBuild string

	// Version of the message catalog for the current session's locale.
	LocaleVersion string

	// Short form of the product name.
	Name string

	// Operating system type and architecture.
	//
	// Examples of values are:
	//
	// "win32-x86" - For x86-based Windows systems.
	// "linux-x86" - For x86-based Linux systems.
	// "vmnix-x86" - For the x86 ESX Server microkernel.
	OsType string

	// The product ID is a unique identifier for a product line.
	//
	// Examples of values are:
	//
	// "gsx" - For the VMware Server product.
	// "esx" - For the ESX product.
	// "embeddedEsx" - For the ESXi product.
	// "vpx" - For the VirtualCenter product.
	ProductLineId string

	// Name of the vendor of this product.
	Vendor string

	// Dot-separated version string. For example, "1.2".
	Version string
}

//
// This event records that an account was created on a host.
//
//
type AccountCreatedEvent struct {
	*HostEvent

	Group bool

	Spec *HostAccountSpec
}

//
// This event records that an account was removed from a host.
//
//
type AccountRemovedEvent struct {
	*HostEvent

	Account string

	Group bool
}

//
// This event records that an account was updated on a host.
//
//
type AccountUpdatedEvent struct {
	*HostEvent

	Group bool

	Spec *HostAccountSpec
}

//
// This data object type defines the action initiated by a scheduled task or alarm.
//
// This is an abstract type.
// A client creates a scheduled task or an alarm each of which triggers
// an action, defined by a subclass of this type.
//
//
//
type Action struct {
	*DynamicData
}

//
// These constant strings can be used as parameters in user-specified
// email subject and body templates as well as in scripts. The action processor
// in VirtualCenter substitutes the run-time values for the parameters.
//
// For example, an email subject provided by the client could be the string:
// "Alarm - {alarmName} Description:\n{eventDescription}".
// Or a script action provided could be: "myScript {alarmName}"
//
//
type ActionParameter struct {
}

//
// Pre-defined constants for possible action types. Virtual Center
// uses this information to coordinate with the clients.
//
//
type ActionType struct {
}

//
// Base fault for Active Directory related problems.
//
//
type ActiveDirectoryFault struct {
	*VimFault

	// The error code reported by the Active Directory API.
	ErrorCode int32
}

//
// The ActiveDirectoryProfile data object represents Active Directory
// configuration. Use the policy list for
// access to configuration data for the Active Directory profile. Use the
// property list for access to subprofiles, if any.
//
//
type ActiveDirectoryProfile struct {
	*ApplyProfile
}

//
// Fault thrown if an attempt to disable the Administrator permission
// on a host of which the Administator permission has already been disabled.
//
//
type AdminDisabled struct {
	*HostConfigFault
}

//
// Fault thrown if an attempt to enable the Administrator permission
// on a host of which the Administator permission is not disabled.
//
//
type AdminNotDisabled struct {
	*HostConfigFault
}

//
// Default password for the Admin user on the host has not been changed.
//
//
type AdminPasswordNotChangedEvent struct {
	*HostEvent
}

//
// Virtual machine has a configured memory and/or CPU affinity that will
// prevent VMotion. This is an error for powered-on virtual machines.
//
//
type AffinityConfigured struct {
	*MigrationFault

	// Configured affinity types for the virtual machine.
	// See AffinityType for valid values.
	ConfiguredAffinity []string
}

//
// Types of affinities.
//
//
type AffinityType struct {
}

//
// The AfterStartupTaskScheduler data object establishes the time
// that a scheduled task will run after the vCenter server restarts.
//
//
type AfterStartupTaskScheduler struct {
	*TaskScheduler

	// The delay in minutes after vCenter server is restarted.
	// The value must be greater than or equal to 0.
	Minute int32
}

//
// An AgentInstallFailed fault is thrown when VirtualCenter
// fails to install the VirtualCenter agent on a host. For example, a fault is
// thrown if the agent software cannot be uploaded to the host or an error occurred
// during the agent installation.
//
//
type AgentInstallFailed struct {
	*HostConnectFault

	// The output (stdout/stderr) from executing the agent installer.
	//
	// Since vSphere API 4.0
	InstallerOutput string

	// The reason why the agent install failed, if known.
	// Values should come from Reason.
	//
	// Since vSphere API 4.0
	Reason string

	// The status code returned by the agent installer, if it was run.
	//
	// Since vSphere API 4.0
	StatusCode int32
}

type AgentInstallFailedReason struct {
}

//
// This managed object type defines an alarm that is triggered and
// an action that occurs due to the triggered alarm when certain conditions
// are met on a specific ManagedEntity object.
//
type Alarm struct {
	*ExtensibleManagedObject

	info *AlarmInfo
}

// Information about this alarm.
// Required Privilege: System.View
func (mo *Alarm) Info() (*AlarmInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*AlarmInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *AlarmInfo")
	}
	return v, nil
}

//
// Reconfigures the alarm properties. This operation requires access
// privileges on the entity with which the alarm is associated.
//
// In addition to the Alarm.Edit privilege, may also require the
// Global.ScriptAction if a RunScriptAction action is specified in
// the AlarmSpec.
//
//
// Required Privileges
// Alarm.Edit
//
func (mo *Alarm) ReconfigureAlarm(
	_this *ManagedObjectReference, spec *AlarmSpec,
) error {

	return nil

}

//
// Removes the alarm.
//
// Required Privileges
// Alarm.Delete
//
func (mo *Alarm) RemoveAlarm(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// This event records the acknowledgement of an Alarm
//
//
type AlarmAcknowledgedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The entity that triggered the alarm.
	Source *ManagedEntityEventArgument
}

//
// Action invoked by triggered alarm.
//
// This is an abstract type.
//
//
//
type AlarmAction struct {
	*DynamicData
}

//
// This event records that an alarm was triggered.
//
//
type AlarmActionTriggeredEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The entity that triggered the alarm.
	Source *ManagedEntityEventArgument
}

//
// This event records the manual clearing of an Alarm
//
//
type AlarmClearedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The original alarm status from which it was cleared
	From string

	// The entity that triggered the alarm.
	Source *ManagedEntityEventArgument
}

//
// This event records the creation of an alarm.
//
//
type AlarmCreatedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument
}

//
// Static strings for alarms.
//
//
type AlarmDescription struct {
	*DynamicData

	// Action class descriptions for an alarm.
	Action []*TypeDescription

	// accessible and
	// description
	//
	// Since vSphere API 4.0
	DatastoreConnectionState []*ElementDescription

	// ManagedEntity Status enum description
	EntityStatus []*ElementDescription

	// Descriptions of expression types for a trigger.
	Expr []*TypeDescription

	// Host System Connection State enum description
	HostSystemConnectionState []*ElementDescription

	// Host System Power State enum description
	//
	// Since vSphere API 4.0
	HostSystemPowerState []*ElementDescription

	// MetricAlarmExpression Metric Operator enum description
	MetricOperator []*ElementDescription

	// State Operator enum description
	StateOperator []*ElementDescription

	// Guest Heartbeat Status enum description
	//
	// Since vSphere API 4.0
	VirtualMachineGuestHeartbeatStatus []*ElementDescription

	// Virtual Machine Power State enum description
	VirtualMachinePowerState []*ElementDescription
}

//
// This event records the completion of an alarm email notification.
//
//
type AlarmEmailCompletedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The destination email address.
	To string
}

//
// This event records a failure to complete an alarm email notification.
//
//
type AlarmEmailFailedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The reason for the failure.
	Reason *LocalizedMethodFault

	// The destination email address.
	To string
}

//
// This event is an alarm events.
//
//
type AlarmEvent struct {
	*Event

	// The associated alarm object.
	Alarm *AlarmEventArgument
}

//
// The event argument is an Alarm object.
//
//
type AlarmEventArgument struct {
	*EntityEventArgument

	// The Alarm object.
	Alarm *Alarm
}

//
// Base type for the expressions specifying the conditions that define
// the status of an alarm.
//
//
type AlarmExpression struct {
	*DynamicData
}

//
// Attributes of an alarm.
//
//
type AlarmInfo struct {
	*AlarmSpec

	// The alarm object.
	Alarm *Alarm

	// The event ID that records the alarm creation.
	CreationEventId int32

	// The entity on which the alarm is registered.
	Entity *ManagedEntity

	// The unique key.
	Key string

	// The time the alarm was created or modified.
	LastModifiedTime time.Time

	// User name that modified the alarm most recently.
	LastModifiedUser string
}

//
// The alarm manager is a singleton object for managing alarms
// within a service instance.
//
type AlarmManager struct {
	*ManagedObject

	defaultExpression []*AlarmExpression

	description *AlarmDescription
}

// The default setting for each alarm expression, used to populate the
// initial client wizard screen.
// Required Privilege: System.View
func (mo *AlarmManager) DefaultExpression() ([]*AlarmExpression, error) {
	t, err := mo.currentProperty("defaultExpression")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*AlarmExpression)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*AlarmExpression")
	}
	return v, nil
}

// The static descriptive strings used in alarms.
// Required Privilege: System.View
func (mo *AlarmManager) Description() (*AlarmDescription, error) {
	t, err := mo.currentProperty("description")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*AlarmDescription)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *AlarmDescription")
	}
	return v, nil
}

//
// Acknowledge the alarm on a managed entity.  The actions associated
// with the alarm will not fire until the alarm's next distinct
// occurrence; that is, until after the alarm has entered the green
// or gray states at least once.  Calling this method on an acknowledged
// or non-triggered alarm.
//
// Required Privileges
// None
// Since
// vSphere API 4.0
//
func (mo *AlarmManager) AcknowledgeAlarm(
	_this *ManagedObjectReference, alarm *Alarm, entity *ManagedEntity,
) error {

	return nil

}

//
// Returns true if alarm actions are enabled on the specified managed entity.
//
// Required Privileges
// None
// Since
// vSphere API 4.0
//
func (mo *AlarmManager) AreAlarmActionsEnabled(
	_this *ManagedObjectReference, entity *ManagedEntity,
) (bool, error) {

	return false, nil

}

//
// Creates an alarm.
//
// In addition to the Alarm.Create privilege, may also require the
// Global.ScriptAction if a RunScriptAction action is specified in
// the AlarmSpec.
//
//
// Required Privileges
// None
//
func (mo *AlarmManager) CreateAlarm(
	_this *ManagedObjectReference, entity *ManagedEntity, spec *AlarmSpec,
) (*Alarm, error) {

	return nil, nil

}

//
// Enables or disables alarms on the specified managed entity.
//
// Required Privileges
// None
// Since
// vSphere API 4.0
//
func (mo *AlarmManager) EnableAlarmActions(
	_this *ManagedObjectReference, entity *ManagedEntity, enabled bool,
) error {

	return nil

}

//
// Available alarms defined on the entity.
// These alarms do not include any inherited alarms; that is,
// alarms associated with parent entities.
//
//
//
// Required Privileges
// System.View
//
func (mo *AlarmManager) GetAlarm(
	_this *ManagedObjectReference, entity *ManagedEntity,
) ([]*Alarm, error) {

	return nil, nil

}

//
// The state of instantiated alarms on the entity.
//
//
//
// Required Privileges
// None
//
func (mo *AlarmManager) GetAlarmState(
	_this *ManagedObjectReference, entity *ManagedEntity,
) ([]*AlarmState, error) {

	return nil, nil

}

//
// This event records the reconfiguration of an alarm.
//
//
type AlarmReconfiguredEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument
}

//
// This event records the removal of an alarm.
//
//
type AlarmRemovedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument
}

//
// This event records the completion of an alarm-triggered script.
//
//
type AlarmScriptCompleteEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The script triggered by the alarm.
	Script string
}

//
// This event records a failure to complete an alarm-triggered script.
//
//
type AlarmScriptFailedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The reason for the failure.
	Reason *LocalizedMethodFault

	// The script triggered by the alarm.
	Script string
}

//
// Tolerance and frequency limits of an alarm.
//
//
type AlarmSetting struct {
	*DynamicData

	// How often the alarm is triggered, measured in seconds.
	//
	//
	//
	// A zero value means that the alarm is allowed
	//
	// to trigger as often as possible.
	//
	// A nonzero value means that any subsequent triggers
	//
	// are suppressed for a period of seconds following a
	//
	// reported trigger.
	ReportingFrequency int32

	// Tolerance range for the metric triggers, measured in one hundredth percentage.
	//
	//
	//
	// A zero value means that the alarm
	//
	// triggers whenever the metric value is above
	//
	// or below the specified value.
	//
	// A nonzero value means that the alarm
	//
	// triggers only after reaching a certain percentage
	//
	// above or below the nominal trigger value.
	ToleranceRange int32
}

//
// This event records the completion of an alarm SNMP notification.
//
//
type AlarmSnmpCompletedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument
}

//
// This event records a failure to complete an alarm SNMP notification.
//
//
type AlarmSnmpFailedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// Parameters for alarm creation.
//
//
type AlarmSpec struct {
	*DynamicData

	// Action to perform when the alarm is triggered.
	Action *AlarmAction

	// Frequency in seconds, which specifies how often appropriate actions
	// should repeat when an alarm does not change state.
	//
	// Since vSphere API 4.0
	ActionFrequency int32

	// Description of the alarm.
	Description string

	// Flag to indicate whether or not the alarm is enabled or disabled.
	Enabled bool

	// Top-level alarm expression that defines trigger conditions.
	Expression *AlarmExpression

	// Name of the alarm.
	Name string

	// Tolerance and maximum frequency settings.
	Setting *AlarmSetting

	// System name of the alarm.
	//
	// This is set only for predefined Alarms - i.e. Alarms created by the
	// server automatically. Editing or renaming Alarms from the UI does
	// not affect this value, and user-created Alarms do not have a
	// systemName at all.
	//
	// The purpose of this field is to identify system-created Alarms
	// reliably, even if they are edited by users.
	//
	// Since vSphere API 5.0
	SystemName string
}

//
// Information about the alarm's state.
//
//
type AlarmState struct {
	*DynamicData

	// Flag to indicate if the alarm's actions have been acknowledged for the
	// associated ManagedEntity.
	//
	// Since vSphere API 4.0
	Acknowledged bool

	// The user who acknowledged this triggering.  If the triggering has not
	// been acknowledged, then the value is not valid.
	//
	// Since vSphere API 4.0
	AcknowledgedByUser string

	// The time this triggering was acknowledged.  If the triggering has not
	// been acknowledged, then the value is not valid.
	//
	// Since vSphere API 4.0
	AcknowledgedTime time.Time

	// Alarm object from which the AlarmState object is instantiated.
	Alarm *Alarm

	// Entity on which the alarm is instantiated.
	Entity *ManagedEntity

	// Unique key that identifies the alarm.
	Key string

	// Overall status of the alarm object.
	// This is the value of the alarm's top-level expression.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	OverallStatus *enum.ManagedEntityStatus

	// Time the alarm triggered.
	Time time.Time
}

//
// This event records a status change for an alarm.
//
//
type AlarmStatusChangedEvent struct {
	*AlarmEvent

	// The entity with which the alarm is registered.
	Entity *ManagedEntityEventArgument

	// The original alarm status.
	From string

	// The entity for which the alarm status has been changed.
	Source *ManagedEntityEventArgument

	// The new alarm status.
	To string
}

//
// This data object type describes one or more
// triggering transitions and an action to be done
// when an alarm is triggered.
//
// There are four triggering transitions; at least one of them must
// be provided. A gray state is considered the same as a green state,
// for the purpose of detecting transitions.
//
//
//
type AlarmTriggeringAction struct {
	*AlarmAction

	// The action to be done when the alarm is triggered.
	Action *Action

	// Deprecated.
	// As of vSphere API 4.0, use
	// AlarmTriggeringActionTransitionSpec .
	//
	//
	// Flag to specify that the alarm should trigger on a transition
	// from green to yellow.
	Green2yellow bool

	// Deprecated.
	// As of vSphere API 4.0, use
	// AlarmTriggeringActionTransitionSpec .
	//
	//
	// Flag to specify that the alarm should trigger on a transition
	// from red to yellow.
	Red2yellow bool

	// Indicates on which transitions this action executes and repeats.
	// This is optional only for backwards compatibility.
	//
	// Since vSphere API 4.0
	TransitionSpecs []*AlarmTriggeringActionTransitionSpec

	// Deprecated.
	// As of vSphere API 4.0, use
	// AlarmTriggeringActionTransitionSpec .
	//
	//
	// Flag to specify that the alarm should trigger on a transition
	// from yellow to green.
	Yellow2green bool

	// Deprecated.
	// As of vSphere API 4.0, use
	// AlarmTriggeringActionTransitionSpec .
	//
	//
	// Flag to specify that the alarm should trigger on a transition
	// from yellow to red.
	Yellow2red bool
}

//
// Specification indicating which on transitions this action fires.
// The existence of a Spec indicates that this action fires on
// transitions from that Spec's startState to finalState.
//
// There are only four acceptable {startState, finalState} pairs:
// {green, yellow}, {yellow, red}, {red, yellow} and {yellow, green}.
// At least one of these pairs must be specified.
// Any deviation from the above will render the enclosing AlarmSpec invalid.
//
//
//
type AlarmTriggeringActionTransitionSpec struct {
	*DynamicData

	// The state to which the alarm must transition for the action to fire.
	// Valid choices are red, yellow, and green.
	FinalState *enum.ManagedEntityStatus

	// Whether or not the action repeats, as per the actionFrequency defined
	// in the enclosing Alarm.
	Repeats bool

	// The state from which the alarm must transition for the action to
	// fire.  Valid choices are red, yellow and green.
	StartState *enum.ManagedEntityStatus
}

//
// This event records that the previously unlicensed virtual machines on
// the specified host are now licensed. After this event is entered into
// the event log, we expect to see that the (@link
// vim.event.Event.UnlicensedVirtualMachinesEvent
// UnlicensedVirtualMachinesEvent) (@link vim.ManagedEntity.configIssue
// configIssue) is removed from the host.
//
//
type AllVirtualMachinesLicensedEvent struct {
	*LicenseEvent
}

//
// This event records a failed user logon due to the user already being logged on.
//
//
type AlreadyAuthenticatedSessionEvent struct {
	*SessionEvent
}

//
// AlreadyBeingManaged fault is thrown by the host
// connect method if the host is already being managed
// by a VirtualCenter server.
//
//
type AlreadyBeingManaged struct {
	*HostConnectFault

	// IP address of server that is currently managing the host.
	IpAddress string
}

//
// AlreadyConnect fault is thrown by the host connect method
// if the host is already connected to a VirtualCenter server.
// This might occur if the host has been added more than once
// in the same VirtualCenter in different folders or compute
// resources.
//
//
type AlreadyConnected struct {
	*HostConnectFault

	// Name of the host
	Name string
}

//
// An AlreadyExists fault is thrown when an attempt is made to add an element
// to a collection, if the element's key, name, or identifier already exists in that
// collection.
//
//
type AlreadyExists struct {
	*VimFault

	Name string
}

//
// An AlreadyUpgraded fault is thrown when an attempt is made to upgrade the
// virtual hardware of a Virtual machine whose virtual hardware is already
// up-to-date.
//
//
type AlreadyUpgraded struct {
	*VimFault
}

//
// A data object type that links multiple alarm expressions with AND operators.
//
//
type AndAlarmExpression struct {
	*AlarmExpression

	// List of alarm expressions that define the overall status of the alarm.
	//
	//
	// The state of the alarm expression is gray if all subexpressions are gray.
	// Otherwise, gray subexpressions are ignored.
	// The state is red if all subexpressions are red.
	// Otherwise, the state is yellow if all subexpressions are red or yellow.
	// Otherwise, the state of the alarm expression is green.
	Expression []*AlarmExpression
}

//
// The AnswerFile data object contains host-specific information that a host
// will use in combination with a HostProfile for configuration.
// Answer files are stored on the vCenter Server, along with host profiles.
// An answer file is always associated with a particular host.
//
// To supply host-specific data:
//
//
//
// • Specify deferred parameters when you call the
// HostProfile.ExecuteHostProfile
// method. The host profile engine will verify the set of parameters for the
// additional configuration data.
//
// • Use the complete required input list
// (ProfileExecuteResult.requireInput[])
// as user input for the
// HostProfileManager.ApplyHostConfig_Task
// method. When you apply the profile, the vCenter Server saves the additional configuration
// data in the userInput list.
//
// • Use the HostProfileManager.UpdateAnswerFile_Task method. This method will update an existing answer file or create a new one.
//
//
//
//
//
type AnswerFile struct {
	*DynamicData

	// Time at which the answer file was created.
	CreatedTime time.Time

	// Time at which the answer file was last modified.
	ModifiedTime time.Time

	// List containing host-specific configuration data.
	UserInput []*ProfileDeferredPolicyOptionParameter
}

//
// Base class for host-specific answer file options.
//
//
type AnswerFileCreateSpec struct {
	*DynamicData
}

//
// The AnswerFileOptionsCreateSpec
// data object contains host-specific user input for an answer file.
//
//
type AnswerFileOptionsCreateSpec struct {
	*AnswerFileCreateSpec

	// List of parameters that contain host-specific data.
	UserInput []*ProfileDeferredPolicyOptionParameter
}

//
// The AnswerFileSerializedCreateSpec data object
// contains a serialized string representation of host-specific data for an answer file.
//
//
type AnswerFileSerializedCreateSpec struct {
	*AnswerFileCreateSpec

	// Host-specific user input.
	AnswerFileConfigString string
}

//
// The AnswerFileStatusError data object describes an answer file
// error and identifies the profile or policy option with which the error
// is associated.
//
//
type AnswerFileStatusError struct {
	*DynamicData

	// Message describing the error.
	ErrMsg *LocalizableMessage

	// Path to a profile or a policy option for host-specific data.
	UserInputPath *ProfilePropertyPath
}

//
// The AnswerFileStatusResult data object shows the validity of the
// answer file associated with a host.
//
//
type AnswerFileStatusResult struct {
	*DynamicData

	// Time that the answer file status was determined.
	CheckedTime time.Time

	// If status is invalid, this property contains a list
	// of status error objects.
	Error []*AnswerFileStatusError

	// Host associated with the answer file.
	Host *HostSystem

	// Status of the answer file.
	// See HostProfileManagerAnswerFileStatus for valid values.
	Status string
}

//
// Could not update the answer file as it has invalid inputs.
//
//
type AnswerFileUpdateFailed struct {
	*VimFault

	// Failures encountered during answer file update
	Failure []*AnswerFileUpdateFailure
}

//
// DataObject which represents the errors that ocurred when an
// answer file update was performed.
//
//
type AnswerFileUpdateFailure struct {
	*DynamicData

	// Message which explains the error
	ErrMsg *LocalizableMessage

	// The user input that has the error
	UserInputPath *ProfilePropertyPath
}

//
// This fault is thrown when creating a quiesced snapshot failed
// because the (user-supplied) custom pre-freeze script in the
// virtual machine exited with a non-zero return code.
//
// This indicates that the script failed to perform its quiescing
// task, which causes us to fail the quiesced snapshot operation.
//
//
//
type ApplicationQuiesceFault struct {
	*SnapshotFault
}

//
// The ApplyProfile data object is the base class for all data objects
// that define profile configuration data.
// ApplyProfile defines ESX configuration data storage and it
// supports recursive profile definition for the profile plug-in architecture.
//
//
type ApplyProfile struct {
	*DynamicData

	// Indicates whether the profile is enabled.
	Enabled bool

	// The list of policies comprising the profile. A ProfilePolicy
	// stores one or more configuration data values in a PolicyOption.
	// The policy option is one of the configuration options from the
	// ProfilePolicyMetadata.possibleOption
	// list.
	Policy []*ProfilePolicy

	// Identifies the profile type.
	//
	// Since vSphere API 5.0
	ProfileTypeName string

	// Profile engine version.
	//
	// Since vSphere API 5.0
	ProfileVersion string

	// List of subprofiles for this profile.
	// This list can change depending on which profile plug-ins are available in the system.
	// Subprofiles can be nested to arbitrary depths to represent host capabilities.
	//
	// Since vSphere API 5.0
	Property []*ProfileApplyProfileProperty
}

//
// Both RecommendDatastores and
// DatastoreEnterMaintenanceMode methods may invoke Storage DRS
// for recommendations on placing or evacuating virtual disks.
// All initial placement recommendations, and some enterMaintenanceMode
// recommendations need to be approved by the user. Recommendations that
// are approved will be applied using the
// ApplyStorageDrsRecommendation_Task
// method.
//
// This class encapsulates the result of applying a subset of the
// recommendations.
//
//
//
//
type ApplyStorageRecommendationResult struct {
	*DynamicData

	// The result applying the recommendation, if it was successful.
	// This is the equivalent of the result key for the
	// task launched when the recommendation was applied.
	Vm *VirtualMachine
}

//
// This list specifies the type of operation being performed on the array.
//
//
type ArrayUpdateOperation struct {
}

//
// An ArrayUpdateSpec data object type is a common superclass
// for supporting incremental updates to arrays.
//
// The common code pattern is:
//
// class MyTypeSpec extrends ArrayUpdateSpec {
// MyTypeInfo info;
// }
//
// The ArrayUpdateSpec contains the following:
//
//
//
//
// • operation: the type of operation being performed.
//
// • removeKey: In the case of a remove operation, the
// key value that identifies the array to be removed.
//
//
//
//
//
type ArrayUpdateSpec struct {
	*DynamicData

	// The type of operation being performed on the specified virtual device.
	Operation *enum.ArrayUpdateOperation

	// Key for the element to be removed. Only used if the operation
	// is "remove".
	RemoveKey interface{}
}

//
// This fault is thrown when the requested change
// would result in a loss of full administrative privileges
// for at least one user or group.
//
//
type AuthMinimumAdminPermission struct {
	*VimFault
}

//
// The AuthenticationProfile data object represents the host configuration
// for authentication. If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type AuthenticationProfile struct {
	*ApplyProfile

	// Subprofile representing the Active Directory configuration.
	ActiveDirectory *ActiveDirectoryProfile
}

//
// Static strings for authorization.
//
//
type AuthorizationDescription struct {
	*DynamicData

	// Description of the privilege.
	Privilege []*ElementDescription

	// Description of a category of similar privileges, grouped
	// together for convenience.
	PrivilegeGroup []*ElementDescription
}

//
// These events indicate authorization events.
//
//
type AuthorizationEvent struct {
	*Event
}

//
// This managed object provides operations to query and update
// roles and permissions.
//
// Privileges are the basic individual rights required to
// perform operations.  They are statically defined and
// never change for a single version of a product.  Examples
// of privileges are "Power on a virtual machine"
// or "Configure a host."
//
//
// Roles are aggregations of privileges, used for convenience.
// For user-defined roles, the system-defined privileges, "System.Anonymous",
// "System.View", and "System.Read" are always present.
//
//
// Permissions are the actual access-control rules.  A
// permission is defined on a ManagedEntity and
// specifies the user or group ("principal") to which
// the rule applies. The role specifies the
// privileges to apply, and the propagate flag
// specifies whether or not the rule applies to sub-objects
// of the managed entity.
//
//
// A ManagedEntity may have multiple permissions,
// but may have only one permission per user or group. If, when logging
// in, a user has both a user permission and a group permission
// (as a group member) for the same entity, then the
// user-specific permission takes precedent.  If there is no
// user-specific permission, but two or more group permissions
// are present, and the user is a member of the groups, then the
// privileges are the union of the specified roles.
//
//
// Managed entities may be collected together into a "complex entity" for
// the purpose of applying permissions consistently. Complex entities may have a
// Datacenter, ComputeResource, or ClusterComputeResource as a parent, with other
// child managed objects as additional parts of the complex entity:
//
//
//
// • A Datacenter's child objects are the root virtual machine and host Folders.
//
// • A ComputeResource's child objects are the root ResourcePool and HostSystem.
//
// • A ClusterComputeResource has only the root ResourcePool as a child object.
//
//
//
// Child objects in a complex entity are forced to inherit permissions from the
// parent object. When query operations are used to discover permissions on child
// objects of complex entities, different results may be returned for the owner of the
// permission. In some cases, the child object of the complex entity is returned as
// the object that defines the permission, and in other cases, the parent from which
// the permission is propagated is returned as the object that defines the permission.
// In both cases, the information about the owner of the permission is correct, since
// the entities within a complex entity are considered equivalent.  Permissions
// defined on complex entities are always applicable on the child entities,
// regardless of the propagation flag, but may only be defined or modified on the
// parent object.
//
// In a group of fault-tolerance (FT) protected VirtualMachines, the secondary
// VirtualMachines are forced to inherit permissions from the primary VirtualMachine.
// Queries to discover permissions on FT secondary VMs always return the primary VM
// as the object that defines the permissions. Permissions defined on an FT primary
// VM are always applicable on its secondary VMs, but can only be defined or modified
// on the primary VM.
//
//
//
type AuthorizationManager struct {
	*ManagedObject

	description *AuthorizationDescription

	privilegeList []*AuthorizationPrivilege

	roleList []*AuthorizationRole
}

// Static, descriptive strings for system roles and privileges.
// Required Privilege: System.View
func (mo *AuthorizationManager) Description() (*AuthorizationDescription, error) {
	t, err := mo.currentProperty("description")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*AuthorizationDescription)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *AuthorizationDescription")
	}
	return v, nil
}

// The list of system-defined privileges.
// Required Privilege: System.View
func (mo *AuthorizationManager) PrivilegeList() ([]*AuthorizationPrivilege, error) {
	t, err := mo.currentProperty("privilegeList")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*AuthorizationPrivilege)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*AuthorizationPrivilege")
	}
	return v, nil
}

// The currently defined roles in the system, including
// static system-defined roles.
// Required Privilege: System.View
func (mo *AuthorizationManager) RoleList() ([]*AuthorizationRole, error) {
	t, err := mo.currentProperty("roleList")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*AuthorizationRole)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*AuthorizationRole")
	}
	return v, nil
}

//
// Adds a new role.
// This method will add a user-defined role with given list of privileges
// and three system-defined privileges, "System.Anonymous", "System.View",
// and "System.Read".
//
// Required Privileges
// Authorization.ModifyRoles
//
func (mo *AuthorizationManager) AddAuthorizationRole(
	_this *ManagedObjectReference, name string, privIds []string,
) (int32, error) {

	return int32(0), nil

}

//
// Check whether a session holds a set of privileges on a set of managed entities.
//
// If the session does not exist, false is returned for all privileges of
// all the entities.
//
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.5
//
func (mo *AuthorizationManager) HasPrivilegeOnEntities(
	_this *ManagedObjectReference, entity []*ManagedEntity, sessionId string, privId []string,
) ([]*EntityPrivilege, error) {

	return nil, nil

}

//
// Check whether a session holds a set of privileges on a managed entity.
//
// If the session does not exist, false is returned for all privileges.
//
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *AuthorizationManager) HasPrivilegeOnEntity(
	_this *ManagedObjectReference, entity *ManagedEntity, sessionId string, privId []string,
) ([]bool, error) {

	return nil, nil

}

//
// Reassigns all permissions of a role to another role.
//
// Required Privileges
// Authorization.ReassignRolePermissions
//
func (mo *AuthorizationManager) MergePermissions(
	_this *ManagedObjectReference, srcRoleId int32, dstRoleId int32,
) error {

	return nil

}

//
// Removes a role.
//
// Required Privileges
// Authorization.ModifyRoles
//
func (mo *AuthorizationManager) RemoveAuthorizationRole(
	_this *ManagedObjectReference, roleId int32, failIfUsed bool,
) error {

	return nil

}

//
// Removes a permission rule from an entity.
//
// This will fail with an InvalidArgument fault if called on:  the direct child
// folders of a datacenter managed object, the root resource pool of a
// ComputeResource or ClusterComputeResource, or a HostSystem that is part of
// a ComputeResource (Stand-alone Host). These objects always have the same
// permissions as their parent.
//
//
// This will fail with an InvalidArgument fault if called on a fault-tolerance (FT)
// secondary VirtualMachine. Such a VirtualMachine always has the same permissions
// as its FT primary VirtualMachine.
//
//
// Required Privileges
// None
//
func (mo *AuthorizationManager) RemoveEntityPermission(
	_this *ManagedObjectReference, entity *ManagedEntity, user string, isGroup bool,
) error {

	return nil

}

//
// Update the entire set of permissions defined on an entity.  Any
// existing permissions on the entity are removed and replaced with the
// provided set.
//
// If a permission is specified multiple times for the same user or group, the
// last permission specified takes effect.
//
//
// The operation is transactional per permission and could partially fail.  The
// updates are performed in the order of the permission array argument.  The first
// failed update will abort the operation and throw the appropriate exception. When
// the operation aborts, any permissions that have not yet been removed are left in
// their original state.
//
//
// After updates are applied, original permissions that are not in the new set
// are removed.  A failure to remove a permission, such as a violation of
// the minimum administrator permission rule, will abort the operation and could
// leave remaining original permissions still effective on the entity.
//
//
// This will fail with an InvalidArgument fault if called on: the direct child
// folders of a datacenter managed object, the root resource pool of a
// ComputeResource or ClusterComputeResource, or a HostSystem that is part of
// a ComputeResource (Stand-alone Host). These objects always have the same
// permissions as their parent.
//
//
// This will fail with an InvalidArgument fault if called on a fault-tolerance (FT)
// secondary VirtualMachine. Such a VirtualMachine always has the same permissions
// as its FT primary VirtualMachine.
//
//
// Required Privileges
// None
//
func (mo *AuthorizationManager) ResetEntityPermissions(
	_this *ManagedObjectReference, entity *ManagedEntity, permission []*Permission,
) error {

	return nil

}

//
// Finds all permissions defined in the system.
// The result is restricted to the managed entities visible to the
// user making the call.
//
// Required Privileges
// System.View
//
func (mo *AuthorizationManager) RetrieveAllPermissions(
	_this *ManagedObjectReference,
) ([]*Permission, error) {

	return nil, nil

}

//
// Gets permissions defined on or effective on a managed entity.
// This returns the actual permission objects defined in the system for all
// users and groups relative to the managed entity. The inherited
// flag specifies whether or not to include permissions defined by the
// parents of this entity that propagate to this entity.
//
// For complex entities, the entity reported as defining the permission may
// be either the parent or a child entity belonging to the complex entity.
//
//
// The purpose of this method is to discover permissions
// for administration purposes, not to determine the current
// permissions. The current user's permissions are found on the effectiveRole property of the user's ManagedEntity.
//
//
// Required Privileges
// None
//
func (mo *AuthorizationManager) RetrieveEntityPermissions(
	_this *ManagedObjectReference, entity *ManagedEntity, inherited bool,
) ([]*Permission, error) {

	return nil, nil

}

//
// Finds all the permissions that use a particular role.
// The result is restricted to managed entities that are visible to the
// user making the call.
//
// Required Privileges
// System.View
//
func (mo *AuthorizationManager) RetrieveRolePermissions(
	_this *ManagedObjectReference, roleId int32,
) ([]*Permission, error) {

	return nil, nil

}

//
// Defines one or more permission rules on an entity or updates rules if already
// present for the given user or group on the entity.
//
// If a permission is specified multiple times for the same user or group, then the
// last permission specified takes effect.
//
//
// The operation is applied transactionally per permission and is applied to the
// entity following the order of the elements in the permission array argument. This
// means that if a failure occurs, the method terminates at that point in the
// permission array with an exception, leaving at least one and as many as all
// permissions unapplied.
//
//
// This will fail with an InvalidArgument fault if called on: the direct child
// folders of a datacenter managed object, the root resource pool of a
// ComputeResource or ClusterComputeResource, or a HostSystem that is part of
// a ComputeResource (Stand-alone Host). These objects always have the same
// permissions as their parent.
//
//
// This will fail with an InvalidArgument fault if called on a fault-tolerance (FT)
// secondary VirtualMachine. Such a VirtualMachine always has the same permissions
// as its FT primary VirtualMachine.
//
//
// Required Privileges
// None
//
func (mo *AuthorizationManager) SetEntityPermissions(
	_this *ManagedObjectReference, entity *ManagedEntity, permission []*Permission,
) error {

	return nil

}

//
// Updates a role's name or privileges.
// If the new set of privileges are assigned to the role, the
// system-defined privileges, "System.Anonymous", "System.View",
// and "System.Read" will be assigned to the role too.
//
// Required Privileges
// Authorization.ModifyRoles
//
func (mo *AuthorizationManager) UpdateAuthorizationRole(
	_this *ManagedObjectReference, roleId int32, newName string, privIds []string,
) error {

	return nil

}

//
// This data object type provides access to some aspect of the system.
// Privileges are generally independent. This means a user with a privilege
// usually can perform an associated set of actions without needing any
// additional supporting privileges.
//
// Within each product version, privileges do not change.
//
// See AuthorizationDescription for
// detailed information on the privileges defined by the system.
//
//
//
type AuthorizationPrivilege struct {
	*DynamicData

	// Privilege name.
	Name string

	// Determines whether or not the privilege is applied on the parent entity.
	OnParent bool

	// Group name.
	PrivGroupName string

	// Unique identifier.
	PrivId string
}

//
// This data object type specifies a collection of privileges used
// to grant access to users on managed entities.
//
//
type AuthorizationRole struct {
	*DynamicData

	// Displayable role information.
	Info *Description

	// System-defined or user-defined role name.
	Name string

	// Privileges provided by this role, by privilege identifier.
	Privilege []string

	// Unique role identifier.
	RoleId int32

	// Whether or not the role is system-defined. System-defined roles cannot be
	// changed.
	System bool
}

type AutoStartAction struct {
}

//
// Defines the system default auto-start/auto-stop values.
//
//
type AutoStartDefaults struct {
	*DynamicData

	// Indicates whether or not auto-start manager is enabled.
	Enabled bool

	// System-default autoStart delay in seconds. The default is 120 seconds.
	StartDelay int32

	// System-default power-off action. Used if the stopAction string in the
	// AutoPowerInfo object for a particular machine is set to systemDefault.
	// If stopAction and startAction for a virtual machine are both set to none,
	// that virtual machine is removed from the AutoStart sequence.
	StopAction string

	// System-default autoStop delay in seconds. The default is 120 seconds.
	StopDelay int32

	// System-default waitForHeartbeat setting.
	WaitForHeartbeat bool
}

//
// This object type describes the power-on / power-off behavior for a given virtual
// machine. Virtual machines can be configured to wait for a period of time before
// starting or to wait to receive a successful heartbeat from a virtual machine
// before starting the next virtual machine in the sequence.
//
//
// • For a power-on operation, if waitForHeartbeat is true, then the power-on
// sequence continues after the first heartbeat has been received. If
// waitForHeartbeat is false, the system waits for the specified delay and
// then continues the power-on sequence.
//
// • For a power-off operation, if delay is non-zero, the requested power-off
// action is invoked (powerOff, suspend, guestShutdown) on the virtual
// machine and the system waits until the number of seconds specified in the
// delay have passed.
//
//
//
// If startAction and stopAction for a virtual machine are both set to none, that
// virtual machine is removed from the AutoStart sequence.
//
// Virtual machines can be configured both to wait for a period of time before
// starting and to wait for a heartbeat. In such a case, the waiting virtual machine
// only waits until either of these conditions are met. In other words, a virtual
// machine starts in either of the following cases:
//
//
// • After receiving a heartbeat but before the start delay has elapsed
//
// • After the start delay has elapsed but before receiving a heartbeat
//
//
//
// This provides a better experience since as soon as one virtual machine begins
// sending heartbeats, indicating it has successfully started up, the next machine
// will begin starting up. This happens even if the startDelay has not yet elapsed.
// Similarly, if one virtual machine fails to begin sending heartbeats, perhaps
// because it could not start up, other machines are not blocked from starting up
// since the startDelay eventually elapses.
//
//
type AutoStartPowerInfo struct {
	*DynamicData

	// Virtual machine to power on or power off.
	Key *VirtualMachine

	// How to start the virtual machine. Valid settings are none or powerOn.
	// If set to none, then the virtual machine does not participate in auto-start.
	StartAction string

	// Delay in seconds before continuing with the next virtual machine in the order
	// of machines to be started. If the delay is specified as -1, then the system
	// default is used.
	StartDelay int32

	// The autostart priority of this virtual machine. Virtual machines with a lower
	// number are powered on first. On host shutdown, the virtual machines are
	// shut down in reverse order, meaning those with a higher number are powered off
	// first.
	//
	// Positive values indicate a start order and -1 indicates the machine can be
	// powered on at any time. Machines with a -1 value are typically powered on and
	// off after all virtual machines with positive startOrder values. Failure to
	// meet the following requirements results in an InvalidArgument exception:
	//
	// startOrder must be set to -1 if startAction is set to none
	// startOrder must be -1 or positive integers. Values such as 0 or
	// -2 are not valid.
	// startOrder is relative to other virtual machines in the autostart
	// sequence. Hence specifying a startOrder of 4 when there are only 3
	// virtual machines in the Autostart sequence is not valid.
	//
	//
	// If a newly established or changed startOrder value for a virtual machine
	// matches an existing startOrder value, the newly applied value takes
	// precedence, and the existing value is incremented by one. The incremented
	// startOrder value is checked for collisions, and the same rule is applied if
	// one is found. This simple system ensures no two virtual machines ever have the
	// same order number.
	//
	// For example, consider the case where there are three virtual machines with
	// different startOrder values. Virtual machine A has not yet established a
	// startOrder, virtual machine B has a startOrder value of 1 and Virtual Machine
	// C has a startOrder value of 2. If virtual machine A's startOrder is set to 1,
	// then virtual machine B's startOrder is incremented to 2. This creates a
	// conflict with virtual machine C's startOrder value, which is also incremented,
	// this time to 3.
	StartOrder int32

	// Defines the stop action for the virtual machine. Can be set to none,
	// systemDefault, powerOff, or suspend. If set to none, then the virtual machine
	// does not participate in auto-stop.
	StopAction string

	// Delay in seconds before continuing with the next virtual machine in the order
	// sequence. If the delay is -1, then the system default is used.
	StopDelay int32

	WaitForHeartbeat *enum.AutoStartWaitHeartbeatSetting
}

//
// Determines if the virtual machine should start after receiving a heartbeat,
// ignore heartbeats and start after the startDelay has elapsed, or follow the
// system default before powering on. When a virtual machine is next in the start
// order, the system either waits a specified period of time for a virtual
// machine to power on or it waits until it receives a successful heartbeat from a
// powered on virtual machine. By default, this is set to no.
//
//
type AutoStartWaitHeartbeatSetting struct {
}

//
// Thrown if backupConfig blob is corrupted
//
//
type BackupBlobReadFailure struct {
	*DvsFault

	// The entity name on which backupConfig read failed
	EntityName string

	// The entity type on which backupConfig read failed
	EntityType string

	// The fault that occurred.
	Fault *LocalizedMethodFault
}

//
// Thrown if backupConfig blob write fails
//
//
type BackupBlobWriteFailure struct {
	*DvsFault

	// The entity name on which backupConfig write failed
	EntityName string

	// The entity type on which backupConfig write failed
	EntityType string

	// The fault that occurred.
	Fault *LocalizedMethodFault
}

//
// This event records a failed user logon. Failed logons are due to no match existing
// between the provided user name and password combination and the combinations
// stored for authentication.
//
//
type BadUsernameSessionEvent struct {
	*SessionEvent

	// The IP address of the peer that initiated the connection. This may
	// be the client that originated the session, or it may be an intervening
	// proxy if the binding uses a protocol that supports proxies, such as HTTP.
	IpAddress string
}

//
// Fault indicating that firewall configuration prevents
// an operation from completing successfully.
//
//
type BlockedByFirewall struct {
	*HostConfigFault
}

//
// The BoolOption data object type describes if an option
// is supported ("true") and if the option is set to "true" or
// "false" by default.
//
//
type BoolOption struct {
	*OptionType

	// The default value for the option.
	DefaultValue bool

	// The flag to indicate whether or not the
	// option is supported.
	Supported bool
}

//
// The boolean type of setting or configuration that may get an
// inherited value.
//
//
type BoolPolicy struct {
	*InheritablePolicy

	// The boolean value that is either set or inherited.
	Value bool
}

//
// Fault indicating that the CAM server
// cannot be connected.
//
//
type CAMServerRefusedConnection struct {
	*InvalidCAMServer
}

//
// An operation performed on the host was canceled. Typically,
// a previous event in the sequence of events contains more
// information about the cause of this cancellation.
//
//
type CanceledHostOperationEvent struct {
	*HostEvent
}

//
// This fault is thrown when an operation fails because of insufficient
// permissions to access a file.
//
//
type CannotAccessFile struct {
	*FileFault
}

//
// An CannotAccessLocalSourceFault exception is thrown when a
// an attempt is made to upload license content
// and the local source cannot be accesed.
//
//
type CannotAccessLocalSource struct {
	*VimFault
}

//
// A network associated with the virtual machine is not accessible. If returned as
// part of migration checks, this is an error if either of the following is true,
// a warning otherwise:
//
//
// • The virtual ethernet card device backing is a distributed virtual switch,
// of which the destination host is not a member
//
// • The virtual ethernet card device backing is a standard network and the
// the device is connected
//
//
//
//
//
type CannotAccessNetwork struct {
	*CannotAccessVmDevice
}

//
// One of the virtual machine's components is not accessible on the execution host.
// This is a base class. Subclasses will encode the type of component that is not
// accessible.
//
//
type CannotAccessVmComponent struct {
	*VmConfigFault
}

//
// One or more of the virtual machine's configuration files are not accessible.
//
//
type CannotAccessVmConfig struct {
	*CannotAccessVmComponent

	// Contains the reason why the VM file could not be found. This is typically
	// a FileFault.
	Reason *LocalizedMethodFault
}

//
// One of the virtual machine's devices uses a backing that is not accessible
// on the host.
//
// Following is a discussion of this fault's use in migration validation.
//
//
// This is an error if the device is currently connected  and a warning
// otherwise. Devices that can be disconnected can only be connected if the virtual
// machine is powered on.
//
// The usage of this fault is slightly different if the backing of a device is
// inherently host-local, and therefore not shared or globally named among
// hosts. (Examples of such backings: physical CD-ROM drive, physical serial
// port.) If a device with such a backing is currently connected, that will
// be a migration error. If the device is disconnected, there will be a
// warning if no backing with the same name exists on the destination host.
// If the device is disconnected and a backing with the same name exists on
// the destination host, this is neither a warning nor an error case, even
// though the destination host's backing is not the same instance as the
// source host's. It is assumed that use of the host-local backing is what is
// desired for the device.
//
//
//
type CannotAccessVmDevice struct {
	*CannotAccessVmComponent

	// The backing of the device.
	Backing string

	// The connected/disconnected state of the device.
	Connected bool

	// The label of the device.
	Device string
}

//
// One of the virtual machine's virtual disks is not accessible.
//
//
type CannotAccessVmDisk struct {
	*CannotAccessVmDevice

	// The reason why the disk could not be accessed
	Fault *LocalizedMethodFault
}

//
// Can not add a host with fault tolerance vms to be standalone
//
//
type CannotAddHostWithFTVmAsStandalone struct {
	*HostConnectFault
}

//
// Can not add a host with fault tolerance vms to a different cluster other
// than the one used other vms in the same fault tolerance group.
//
//
type CannotAddHostWithFTVmToDifferentCluster struct {
	*HostConnectFault
}

//
// Can not add a host with fault tolerance vms to a non HA enabled cluster
//
//
type CannotAddHostWithFTVmToNonHACluster struct {
	*HostConnectFault
}

//
// This fault is used to report that the DRS behavior cannot be modified
// for a FT secondary virtual machine
//
//
type CannotChangeDrsBehaviorForFtSecondary struct {
	*VmFaultToleranceIssue

	// The virtual machine whose behavior cannot be modified
	Vm *VirtualMachine

	// Name of the virtual machine
	VmName string
}

//
// This fault is used to report that the HA settings cannot be modified
// for a FT secondary virtual machine
//
//
type CannotChangeHaSettingsForFtSecondary struct {
	*VmFaultToleranceIssue

	// The FT secondary virtual machine whose behavior cannot be modified
	Vm *VirtualMachine

	// Name of the FT secondary virtual machine
	VmName string
}

//
// Fault thrown for cases that a VSAN cluster UUID may not be changed.
//
// For example, the VSAN cluster UUID for a host may not be changed so long
// as that host is enabled for VSAN.
//
// The VSAN cluster UUID for a given ClusterComputeResource may
// not be changed so long as that vim.ClusterComputeResource is enabled for
// VSAN.See UpdateVsan_TaskSee ReconfigureComputeResource_Task
//
//
type CannotChangeVsanClusterUuid struct {
	*VsanFault
}

//
// Fault thrown for cases that a VSAN node UUID may not be changed.
//
// For example, the VSAN node UUID for a host may not be changed so long as
// that host is enabled for VSAN.See UpdateVsan_TaskSee ReconfigureComputeResource_Task
//
//
type CannotChangeVsanNodeUuid struct {
	*VsanFault
}

//
// A CannotCreateFile exception is thrown if a file create
// operation fails.
//
//
type CannotCreateFile struct {
	*FileFault
}

//
// The VirtualCenter server is unable to decrypt passwords stored in
// the customization specification.
//
//
type CannotDecryptPasswords struct {
	*CustomizationFault
}

//
// A CannotDeleteFile exception is thrown if a file-deletion
// operation fails.
//
//
type CannotDeleteFile struct {
	*FileFault
}

//
// This fault is thrown when an attempt is made to disable DRS on a cluster,
// which contains a vApp.
//
//
type CannotDisableDrsOnClustersWithVApps struct {
	*RuntimeFault
}

//
// Fault thrown when an attempt is made to disable snapshots on a virtual
// machine which has a snapshot.  To disable the snapshot feature, the
// virtual machine must not currently have a snapshot.
//
//
type CannotDisableSnapshot struct {
	*VmConfigFault
}

//
// This fault is thrown when an attempt is made to disconnect a host, which
// has one or more fault tolerance vms and is not in maintenance mode.
//
//
type CannotDisconnectHostWithFaultToleranceVm struct {
	*VimFault

	// The name of the host to be disconnected
	HostName string
}

//
// A virtual machine's total CPU feature requirements are determined by
// overlaying the requirements specified in its configuration (if any) on top
// of the requirements specified in the descriptor for its guest OS.  It is
// therefore possible for a host change to implicitly change a virtual
// machine's CPU feature requirements.  The guest OS descriptor may have
// different requirements on the new host.  Or, if the virtual machine
// currently specifies requirements in its configuration, those requirements
// will be lost if the new host does not support this.
//
// This fault indicates that the virtual machine's CPU feature requirements
// would change because of a migration, and also that the destination host
// does not support storing CPU feature requirements in the virtual machine's
// configuration.  (If the destination host does support such an action,
// WillModifyConfigCpuRequirements is used instead of this fault.)
//
//
// For a powered-off virtual machine, this is a warning.  The migration may
// proceed, but the virtual machine will be operating under different
// CPU feature requirements if it is powered on after the migration.
//
//
// For a powered-on or suspended virtual machine, this is an error.
//
//
//
type CannotModifyConfigCpuRequirements struct {
	*MigrationFault
}

//
// This fault is thrown when an attempt is made to move a fault tolerance
// vm to a different resource pool or cluster.
//
//
type CannotMoveFaultToleranceVm struct {
	*VimFault

	// The type of the move
	MoveType string

	// The virtual machine name to be moved.
	VmName string
}

type CannotMoveFaultToleranceVmMoveType struct {
}

//
// This fault is thrown when an attempt is made to move a host which has
// one or more fault tolerance vms out of the current cluster.
//
//
type CannotMoveHostWithFaultToleranceVm struct {
	*VimFault
}

//
// This fault is thrown when an attempt is made to relocate a virtual machine
// with virtual disk(s) having delta disk backing.
//
//
type CannotMoveVmWithDeltaDisk struct {
	*MigrationFault

	// The label of the delta disk device
	Device string
}

//
// This fault is thrown when an attempt is made to migrate a virtual machine
// with native delta disks to different datastores.
//
//
type CannotMoveVmWithNativeDeltaDisk struct {
	*MigrationFault
}

//
// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into an unsuitable ClusterComputeResource.
//
// The destination vim.ClusterComputeResource may be disabled for VSAN, or
// may be using VSAN with a different cluster UUID.See AddHost_TaskSee MoveHostInto_TaskSee MoveInto_TaskSee VsanClusterUuidMismatchSee DestinationVsanDisabled
//
//
type CannotMoveVsanEnabledHost struct {
	*VsanFault
}

//
// This fault is thrown when Storage DRS cannot recommend to place disks of
// a virtual machine without moving existing virtual disks in a
// datastore cluster.
//
//
type CannotPlaceWithoutPrerequisiteMoves struct {
	*VimFault
}

//
// This fault is reported when a user attempts to power off or
// suspend a VM when the HA master agent to which vCenter Server is
// connected does not manage the VM.
//
//
type CannotPowerOffVmInCluster struct {
	*InvalidState

	// The operation being performed. Values come from
	// Operation.
	Operation string

	// The Virtual Machine
	Vm *VirtualMachine

	// Name of the Virtual Machine
	VmName string
}

type CannotPowerOffVmInClusterOperation struct {
}

//
// Fault thrown for the case that an attempt is made to reconfigure VSAN
// when HA is currently enabled for a given ClusterComputeResource.See ReconfigureComputeResource_Task
//
//
type CannotReconfigureVsanWhenHaEnabled struct {
	*VsanFault
}

//
// A network associated with the virtual machine is accessible, but it
// cannot be used for some reason.
//
//
type CannotUseNetwork struct {
	*VmConfigFault

	// The backing of the network device.
	Backing string

	// The connected/disconnected state of the device.
	Connected bool

	// The label of the network device.
	Device string

	// Reason describing why the network cannot be used.
	Reason string
}

type CannotUseNetworkReason struct {
}

//
// A particular product may or may not support certain features. This data object
// indicates whether or not a service instance implements these features. This data
// object type indicates the circumstances under which an operation throws a
// NotSupported fault.
//
// Support for some features is indicated by the presence or absence of
// the manager object from the service instance. For example, the AlarmManager manager
// object indicates collecting alarms is supported.
// Other features indicate whether or not a given operation on an
// object throws a NotSupported fault.
//
//
// Some capabilities depend on the host or virtual machine
// version. These are specified by using the vim.host.Capability and
// vim.vm.Capability objects.
//
//
//
type Capability struct {
	*DynamicData

	// Indicates whether or not the service instance supports multiple hosts.
	MultiHostSupported bool

	// Indicates whether network backup and restore feature is supported.
	//
	// Since vSphere API 5.1
	NetworkBackupAndRestoreSupported bool

	// Indicates whether or not the service instance supports provisioning.
	// For example, the CloneVM operation.
	ProvisioningSupported bool

	// All supported Enhanced VMotion Compatibility modes.
	//
	// Since vSphere API 4.0
	SupportedEVCMode []*EVCMode

	// Flag indicating whether host user accounts should have the option to
	// be granted shell access
	//
	// Since VI API 2.5
	UserShellAccessSupported bool
}

//
// The result of a call to any of the methods in either
// VirtualMachineCompatibilityChecker or VirtualMachineProvisioningChecker.
//
//
type CheckResult struct {
	*DynamicData

	// A list of faults representing problems which are fatal
	// to the operation.
	//
	// For VirtualMachineProvisioningChecker an error means that the
	// given provisioning operation would fail.
	//
	// For VirtualMachineCompatibilityChecker an error means that either
	// a power-on of this virtual machine would fail, or that the
	// virtual machine would not run correctly once powered-on.
	Error []*LocalizedMethodFault

	// The host involved in the testing.
	Host *HostSystem

	// The virtual machine involved in the testing.
	Vm *VirtualMachine

	// A list of faults representing problems which may
	// require attention, but which are not fatal.
	Warning []*LocalizedMethodFault
}

//
// The types of tests which can requested by any of the methods in either
// VirtualMachineCompatibilityChecker or VirtualMachineProvisioningChecker.
//
//
type CheckTestType struct {
}

//
// The ChoiceOption data object type defines a set of
// supported string values, a localizable description for each value,
// and the default value.
//
//
type ChoiceOption struct {
	*OptionType

	// The set of possible selections and descriptions.
	ChoiceInfo []*ElementDescription

	// The index in ChoiceOption.value that serves as the default value.
	DefaultIndex int32
}

//
// Fault indicating that the clock skew in the system exceeds the limit.
//
//
type ClockSkew struct {
	*HostConfigFault
}

//
// An attempt is being made to clone a virtual machine from a snapshot
// point, and this is not supported.
// See snapshotSee snapshotConfigSupportedSee cloneFromSnapshotSupported
//
//
//
type CloneFromSnapshotNotSupported struct {
	*MigrationFault
}

//
// Base class for all action recommendations in VirtualCenter.
//
//
type ClusterAction struct {
	*DynamicData

	// The target object on which this action will be applied. For
	// instance, a migration action will have a virtual machine as its
	// target object, while a host power action will have a host as its
	// target action.
	Target *ManagedObjectReference

	// Type of the action. This is encoded to differentiate between
	// different types of actions aimed at achieving different goals.
	Type string
}

//
// Base class for all action history.
//
//
type ClusterActionHistory struct {
	*DynamicData

	// The action that was executed recently.
	Action *ClusterAction

	// The time when the action was executed.
	Time time.Time
}

//
// The ClusterAffinityRuleSpec data object defines a set
// of virtual machines. DRS will attempt to schedule the virtual machines
// to run on the same host.
//
//
type ClusterAffinityRuleSpec struct {
	*ClusterRuleInfo

	// List of virtual machine references.
	Vm []*VirtualMachine
}

//
// The ClusterAntiAffinityRuleSpec data object defines
// a set of virtual machines. DRS will attempt to schedule the virtual
// machines to run on different hosts.
//
//
type ClusterAntiAffinityRuleSpec struct {
	*ClusterRuleInfo

	// List of virtual machine references.
	Vm []*VirtualMachine
}

//
// This data class reports virtual machine powerOn information.
//
//
type ClusterAttemptedVmInfo struct {
	*DynamicData

	// The ID of the task, which monitors powering on.
	Task *Task

	// The virtual machine being powered on.
	Vm *VirtualMachine
}

//
// This event records that a compliance check was triggered
// on the cluster.
//
//
type ClusterComplianceCheckedEvent struct {
	*ClusterEvent

	Profile *ProfileEventArgument
}

//
// The ClusterComputeResource data object aggregates the compute
// resources of associated HostSystem objects into a single
// compute resource for use by virtual machines. The cluster services
// such as HA (High Availability), DRS (Distributed Resource Scheduling),
// and EVC (Enhanced vMotion Compatibility), enhance the utility of this
// single compute resource.
//
// Use the Folder.CreateClusterEx method
// to create an instance of this object.
//
//
//
type ClusterComputeResource struct {
	*ManagedObject
	*ComputeResource

	actionHistory []*ClusterActionHistory

	configuration *ClusterConfigInfo

	drsFault []*ClusterDrsFaults

	drsRecommendation []*ClusterDrsRecommendation

	migrationHistory []*ClusterDrsMigration

	recommendation []*ClusterRecommendation
}

// The set of actions that have been performed recently.
//
// Since VI API 2.5
func (mo *ClusterComputeResource) ActionHistory() ([]*ClusterActionHistory, error) {
	t, err := mo.currentProperty("actionHistory")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ClusterActionHistory)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ClusterActionHistory")
	}
	return v, nil
}

// Deprecated.
// As of VI API 2.5, use configurationEx,
// which is a ClusterConfigInfoEx data object..
//
//
// Configuration of the cluster.
func (mo *ClusterComputeResource) Configuration() (*ClusterConfigInfo, error) {
	t, err := mo.currentProperty("configuration")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ClusterConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ClusterConfigInfo")
	}
	return v, nil
}

// A collection of the DRS faults generated in the last DRS invocation.
// Each element of the collection is the set of faults generated in one
// recommendation.
//
// DRS faults are generated when DRS tries to make recommendations
// for rule enforcement, power management, etc., and indexed in a tree
// structure with reason for recommendations and VM to migrate (optional)
// as the index keys.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
//
// Since vSphere API 4.0
// Required Privilege: System.Read
func (mo *ClusterComputeResource) DrsFault() ([]*ClusterDrsFaults, error) {
	t, err := mo.currentProperty("drsFault")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ClusterDrsFaults)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ClusterDrsFaults")
	}
	return v, nil
}

// Deprecated.
// As of VI API 2.5, use
// recommendation.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
//
//
// If DRS is enabled, this returns the set of recommended
// migrations from the DRS module. The current set of
// recommendations may be empty, since there may be no recommended
// migrations at this time, or it is possible that DRS is not
// enabled.
func (mo *ClusterComputeResource) DrsRecommendation() ([]*ClusterDrsRecommendation, error) {
	t, err := mo.currentProperty("drsRecommendation")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ClusterDrsRecommendation)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ClusterDrsRecommendation")
	}
	return v, nil
}

// The set of migration decisions that have recently been performed.
//
// This list is populated only when DRS is in automatic mode.
func (mo *ClusterComputeResource) MigrationHistory() ([]*ClusterDrsMigration, error) {
	t, err := mo.currentProperty("migrationHistory")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ClusterDrsMigration)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ClusterDrsMigration")
	}
	return v, nil
}

// List of recommended actions for the cluster. It is
// possible that the current set of recommendations may be empty,
// either due to not having any running dynamic recommendation
// generation module, or since there may be no recommended actions
// at this time.
//
// Since VI API 2.5
// Required Privilege: System.Read
func (mo *ClusterComputeResource) Recommendation() ([]*ClusterRecommendation, error) {
	t, err := mo.currentProperty("recommendation")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ClusterRecommendation)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ClusterRecommendation")
	}
	return v, nil
}

//
// Adds a host to the cluster. The hostname must be either an IP address, such as
// 192.168.0.1, or a DNS resolvable name. DNS names may be fully qualified names,
// such as host1.domain1.com, or a short name such as host1, providing host1 resolves
// to host1.domain1.com. The system uses DNS to resolve short names to fully qualified
// names. If the cluster supports nested resource pools and the user specifies the
// optional ResourcePool argument, then the host's root resource pool becomes the
// specified resource pool. The stand-alone host resource hierarchy is imported into
// the new nested resource pool.
//
// If the cluster does not support nested resource pools, then the stand-alone host
// resource hierarchy is discarded and all virtual machines on the host are put
// under the cluster's root resource pool.
//
//
//
// In addition to the Host.Inventory.AddHostToCluster and
// Resource.AssignVMToPool privileges, it requires System.View privilege on
// the VM folder that the VMs of the host will be placed on.
//
//
// Required Privileges
// Host.Inventory.AddHostToCluster
//
func (mo *ClusterComputeResource) AddHost_Task(
	_this *ManagedObjectReference, spec *HostConnectSpec, asConnected bool, resourcePool *ResourcePool, license string,
) (*Task, error) {

	return nil, nil

}

//
// Applies a recommendation from the drsRecommendation or the
// recommendation list. Each recommendation can be applied only
// once.
//
// resource.applyRecommendation privilege is required if the recommendation
// is DRS migration or power management recommendations.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *ClusterComputeResource) ApplyRecommendation(
	_this *ManagedObjectReference, key string,
) error {

	return nil

}

//
// Cancels a recommendation. Currently only initial placement
// recommendations can be cancelled. Migration or power management
// recommendations cannot.
//
//
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.1
//
func (mo *ClusterComputeResource) CancelRecommendation(
	_this *ManagedObjectReference, key string,
) error {

	return nil

}

//
// The API takes a list of hosts in the cluster as input, and
// returns a list of hosts in "ClusterMaintenanceResult" that the
// server can successfully evacuate given the existing
// constraints in the cluster, such as HA, FT, Vmotion
// compatibility, reservations, affinity rules, etc.
//
// The client is allowed to pass all hosts in the cluster to the
// API, even though all of them cannot enter maintenance mode at
// the same time. The list returned from the API contains the
// largest number of hosts that the server can evacuate
// simultaneously. The client can then request to enter each host
// in the returned list into maintenance mode.
//
// The client can specify an integer "DemandCapacityRatioTarget"
// option in the "option" parameter. The allowed values of the
// option range from 40 to 200, and the default value is 100. This
// option controls how much resource overcommitment the server
// should make in consolidating the VMs onto fewer hosts. A value
// of 100 means the server will keep the same amount of powered-on
// capacity as the current VM demands. A value less than 100 means
// undercommitted resources. A value greater than 100 means
// overcommitted resources.
//
// The hosts are recommended based on the inventory at the time of
// the API invocation. It is not guaranteed that the actual
// enter-maintenance tasks on the hosts will succeed, if the
// inventory changes after the API returns, or if vmotions fail
// due to unexpected conditions.  For possible exceptions thrown
// by the necessary relocate operations, see
// MigrateVM_Task.
//
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *ClusterComputeResource) ClusterEnterMaintenanceMode(
	_this *ManagedObjectReference, host []*HostSystem, option []*OptionValue,
) (*ClusterEnterMaintenanceResult, error) {

	return nil, nil

}

//
// Moves an existing host into a cluster. The host must be part of the same
// datacenter, and if the host is part of a cluster, the host must be in maintenance
// mode.
//
// If the host is a stand-alone host, the stand-alone ComputeResource is removed
// as part of this operation.
//
//
// All virtual machines associated with the host, regardless of whether or not they
// are running, are moved with the host into the cluster. If there are virtual
// machines that should not be moved, then migrate those virtual machines off the
// host before initiating this operation.
//
//
// If the host is a stand-alone host, the cluster supports nested resource pools,
// and the user specifies the optional resourcePool argument, then the stand-alone
// host's root resource pool becomes the specified resource pool and the stand-alone
// host resource hierarchy is imported into the new nested resource pool. If the
// cluster does not support nested resource pools or the resourcePool argument is not
// specified, then the stand-alone host resource hierarchy is ignored.
//
//
//
//
// Required Privileges
// Host.Inventory.EditCluster
//
func (mo *ClusterComputeResource) MoveHostInto_Task(
	_this *ManagedObjectReference, host *HostSystem, resourcePool *ResourcePool,
) (*Task, error) {

	return nil, nil

}

//
// Moves an existing host into a cluster. The host must be part of the same
// datacenter, and if the host is part of a cluster, the host must be in maintenance
// mode.
//
// If the host is part of a stand-alone ComputeResource, then the stand-alone
// ComputeResource is removed as part of this operation.
//
//
// All virtual machines associated with a host, regardless of whether or not they
// are running, are moved with the host into the cluster. If there are virtual
// machines that should not be moved, then migrate those virtual machines off the
// host before initiating this operation.
//
//
// For stand-alone hosts, the host resource pool hierarchy is discarded in this call.
// To preserve a host resource pools from a stand-alone host, call moveHostInt,
// specifying an optional resource pool. This operation is transactional only with
// respect to each individual host. Hosts in the set are moved sequentially and are
// committed, one at a time. If a failure is detected, then the method terminates
// with an exception. Since hosts are moved one at a time, if this operation fails
// while in the process of moving multiple hosts, some hosts are left unmoved.
//
//
// In addition to the privileges mentioned, the user must also hold
// Host.Inventory.EditCluster on the host's source ComputeResource object.
//
//
// Required Privileges
// Host.Inventory.EditCluster
//
func (mo *ClusterComputeResource) MoveInto_Task(
	_this *ManagedObjectReference, host []*HostSystem,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of VI API 2.5, use PowerOnMultiVM_Task.
// RecommendHostsForVm cannot make  any recommendations if DRS cannot
// find the specified host in the cluster.
// With PowerOnMultiVM_Task, DRS attempts to migrate virtual machines
// and power on hosts in standby mode, given the same conditions.
//
//
//
//
// Gets a recommendation for where to power on, resume, revert
// from powered-off state to powered on state, or to migrate a
// specific virtual machine. If no host is found, an empty list is
// returned.
//
// The type of operation is implied by the state of the virtual machine. Returned
// hosts are intended for power-on or resume if the virtual machine is powered-off or
// suspended. However, if the virtual machine is powered-on, the request is assumed
// to be for migrating a virtual machine into a DRS enabled cluster. In that case,
// the ResourcePool argument should be specified and the ResourcePool and the virtual
// machine cannot be in the same cluster.
//
//
//
//
// Required Privileges
// System.Read
//
func (mo *ClusterComputeResource) RecommendHostsForVm(
	_this *ManagedObjectReference, vm *VirtualMachine, pool *ResourcePool,
) ([]*ClusterHostRecommendation, error) {

	return nil, nil

}

// Deprecated.
// As of VI API 2.5, use ReconfigureComputeResource_Task.
//
//
// Reconfigures a cluster.
//
// Required Privileges
// Host.Inventory.EditCluster
//
func (mo *ClusterComputeResource) ReconfigureCluster_Task(
	_this *ManagedObjectReference, spec *ClusterConfigSpec, modify bool,
) (*Task, error) {

	return nil, nil

}

//
// Make DRS invoke again and return a new list of recommendations.
// Concurrent "refresh" requests may be combined together and trigger only
// one DRS invocation.
//
//
// The recommendations generated is stored at recommendation.
//
//
// Required Privileges
// Host.Inventory.EditCluster
// Since
// VI API 2.5
//
func (mo *ClusterComputeResource) RefreshRecommendation(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Retrieve DAS advanced runtime info for this cluster.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *ClusterComputeResource) RetrieveDasAdvancedRuntimeInfo(
	_this *ManagedObjectReference,
) (*ClusterDasAdvancedRuntimeInfo, error) {

	return nil, nil

}

//
// The ClusterComputeResourceSummary data object
// encapsulates runtime properties of a ClusterComputeResource.
//
//
type ClusterComputeResourceSummary struct {
	*ComputeResourceSummary

	// Information about the current amount of resources available for a vSphere HA
	// cluster. The actual type of admissionControlInfo will depend on what kind of
	// ClusterDasAdmissionControlPolicy was used to configure the cluster.
	//
	// Since vSphere API 4.0
	AdmissionControlInfo *ClusterDasAdmissionControlInfo

	// The current balance, in terms of standard deviation, for a DRS cluster.
	// Units are thousandths. For example, 12 represents 0.012.
	//
	// Since vSphere API 4.0
	CurrentBalance int32

	// The Enhanced VMotion Compatibility mode that is currently in effect
	// for all hosts in this cluster; unset if no EVC mode is active.See supportedEVCMode
	//
	// Since vSphere API 4.0
	CurrentEVCModeKey string

	// Deprecated.
	// As of vSphere API 4.0, use
	// currentFailoverLevel
	//
	//
	// Current failover level. This is the number of physical host failures that can
	// be tolerated without impacting the ability to satisfy the minimums for all
	// running virtual machines. This represents the current value, as opposed to
	// desired value configured by the user.
	CurrentFailoverLevel int32

	// Data pertaining to DAS.
	//
	// Since vSphere API 5.0
	DasData *ClusterDasData

	// Total number of migrations with VMotion that have been done internal to this
	// cluster.
	NumVmotions int32

	// The target balance, in terms of standard deviation, for a DRS cluster.
	// Units are thousandths. For example, 12 represents 0.012.
	//
	// Since vSphere API 4.0
	TargetBalance int32
}

// Deprecated.
// As of VI API 2.5, use ClusterConfigInfoEx.
//
//
// A complete cluster configuration.
//
//
type ClusterConfigInfo struct {
	*DynamicData

	// Cluster-wide configuration of the vSphere HA service.
	DasConfig *ClusterDasConfigInfo

	// List of virtual machine configurations for the vSphere HA
	// service. Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	DasVmConfig []*ClusterDasVmConfigInfo

	// Cluster-wide configuration of the VMware DRS service.
	DrsConfig *ClusterDrsConfigInfo

	// List of virtual machine configurations for the VMware DRS
	// service. Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	DrsVmConfig []*ClusterDrsVmConfigInfo

	// Cluster-wide rules.
	Rule []*ClusterRuleInfo
}

//
// The ClusterConfigInfoEx data object describes a complete cluster
// configuration. For information about configuring a cluster, see
// ClusterConfigSpecEx.
//
//
type ClusterConfigInfoEx struct {
	*ComputeResourceConfigInfo

	// Cluster-wide configuration of the vSphere HA service.
	DasConfig *ClusterDasConfigInfo

	// List of virtual machine configurations for the vSphere HA
	// service. Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	DasVmConfig []*ClusterDasVmConfigInfo

	// Cluster-wide configuration of the VMware DPM service.
	DpmConfigInfo *ClusterDpmConfigInfo

	// List of host configurations for the VMware DPM
	// service. Each entry applies to one host.
	//
	// If a host is not specified in this array, the service uses
	// the cluster default settings for that host.
	DpmHostConfig []*ClusterDpmHostConfigInfo

	// Cluster-wide configuration of the VMware DRS service.
	DrsConfig *ClusterDrsConfigInfo

	// List of virtual machine configurations for the VMware DRS
	// service. Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	DrsVmConfig []*ClusterDrsVmConfigInfo

	// Cluster-wide groups.
	//
	// Since vSphere API 4.1
	Group []*ClusterGroupInfo

	// Cluster-wide rules.
	Rule []*ClusterRuleInfo

	// Cluster-wide configuration of the VMware VSAN service.
	//
	// Since vSphere API 5.5
	VsanConfigInfo *VsanClusterConfigInfo

	// List of host configurations for the VMware VSAN service.
	// Each entry applies to one host.
	//
	// If a host is not specified in this array, the service uses
	// the cluster default settings for that host.
	//
	// Since vSphere API 5.5
	VsanHostConfig []*VsanHostConfigInfo
}

// Deprecated.
// As of VI API 2.5, use ClusterConfigSpecEx.
//
//
// A complete cluster configuration. All fields are defined as
// optional. In case of a reconfiguration, unset fields are
// unchanged.
//
//
type ClusterConfigSpec struct {
	*DynamicData

	// Changes to the configuration of vSphere HA.
	DasConfig *ClusterDasConfigInfo

	// Changes to the per-virtual-machine vSphere HA settings.
	DasVmConfigSpec []*ClusterDasVmConfigSpec

	// Changes to the configuration of the VMware DRS service.
	DrsConfig *ClusterDrsConfigInfo

	// Changes to the per-virtual-machine DRS settings.
	DrsVmConfigSpec []*ClusterDrsVmConfigSpec

	// Changes to the set of rules.
	RulesSpec []*ClusterRuleSpec
}

//
// The ClusterConfigSpecEx data object provides a set of update
// specifications for complete cluster configuration.
// You can configure a cluster when you create a new cluster
// (the CreateClusterEx method) or when you
// reconfigure an existing cluster
// (the ReconfigureComputeResource_Task method).
//
// All fields are optional. If you set the modify
// parameter to true when you call
// ReconfigureComputeResource_Task, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the modify parameter to false when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
//
//
// Use the properties defined for this object to configure
// the following services:
//
//
//
// • HA (High Availability) -
// provides failover protection for virtual machines
// running in a cluster of ESX Server hosts.
// The virtual machines are located in a Datastore, which
// provides shared storage for the cluster.
// When a failure occurs that affects a protected virtual machine,
// HA will restart the virtual machine on another host.
// When HA detects a host failure, either the host has failed or it may be
// isolated from the network. The HA agent on an isolated host will power off
// or shutdown the virtual machines running on that host so that they
// can be restarted elsewhere.
// See ClusterDasVmSettingsIsolationResponse for information
// about how a host handles network isolation.
//
// When it chooses a failover host, HA selects a host that is compatible
// with the virtual machine and that can support resource allocation for
// that virtual machine so that service level guarantees remain intact.
// HA does not consider hosts that are in maintenance mode, standby mode,
// or which are disconnected from the vCenter Server. When a host powers
// on or becomes available again, HA is reenabled on that host,
// so it becomes available for failover again.
// VMware recommends that you configure hosts and virtual machines
// so that all virtual machines can run on all hosts in the cluster.
// This will maximize the chances of restarting a VM after a failure.
//
//
// HA also restarts a virtual machine after a guest operating system failure.
// In this case, the virtual machine health monitoring service detects
// the guest failure, and HA restarts the virtual machine on the same host.
// The service monitors heartbeats from the VmTools service and optionally
// heartbeats that are generated by a third-party application monitor.
// See ClusterVmToolsMonitoringSettings and
// ClusterDasConfigInfo.vmMonitoring.
//
//
// To enable HA for a cluster, set the
// ClusterDasConfigInfo.enabled
// property to true and the
// ClusterDasConfigInfo.hostMonitoring
// property to enabled.
// (The vSphere API uses the substring "das" in object, property,
// and method names for HA.1)
//
//
//
// • DRS (Distributed Resource Scheduling) - provides automatic initial
// virtual machine placement on any of the hosts in the cluster. DRS
// also makes automatic resource relocation and optimization decisions
// as hosts or virtual machines are added or removed from the cluster.
// You can also configure DRS for manual control, so that it only makes
// recommendations that you can review and carry out.
//
// To enable DRS for a cluster, set the
// ClusterDrsConfigInfo.enabled
// property to true.
//
//
//
// • DPM (Distributed Power Management) - supports optimized power
// consumption on the cluster. When virtual machines in a DRS
// cluster require fewer resources, DPM consolidates workloads
// onto fewer servers while maintaining quality of service guarantees
// and powers off the rest to reduce power consumption.
// When more resources are required, DPM brings the powered-down hosts online.
//
// To enable DPM for a cluster, set the
// ClusterDpmConfigInfo.enabled
// property to true.
//
//
//
// • VSAN - aggregrates hosts' local disks to present a single
// shared datastore to the cluster.
//
// To enable VSAN for a cluster, set the
// enabled property to
// true for vsanConfig.
//
//
//
//
//
//
// The HA, DRS, and DPM services are integrated with the FT (Fault Tolerance)
// and EVC (Enhanced vMotion Compatibility) services.
// Use the CreateSecondaryVM_Task method to establish
// fault tolerance for a virtual machine. Use the vSphere Client to configure EVC.
// The HA, DRS, DPM, FT, and EVC services interact under
// the following circumstances.
//
//
//
// • To determine initial placement of a virtual machine, DRS
// checks to see if the HA admission control policy on a
// potential host supports the addition of the powered on
// virtual machine. With the default setting, DRS will not
// power on more than four FT virtual machines per host.
// You can use the configuration editor in the vSphere Client
// to set the HA advanced option das.maxFtVmsPerHost
// to the desired number or to zero to disable.
//
// • When a host fails, HA determines placement within
// the cluster when it restarts the virtual machines.
// If there is insufficient capacity, and DPM has put one or more
// compatible hosts into standby, HA relies on DPM to bring more
// capacity online.
//
//
// • To use FT in a cluster, the cluster must be HA-enabled.
//
// • You can disable HA in a cluster while there are FT virtual
// machines registered on hosts in the cluster.
// While HA is disabled, powered on FT virtual machines will continue
// to run, but HA will not restart any virtual machines after a failure.
// When HA is disabled, you cannot use the following FT operations:
//
//
// • Turn on FT (CreateSecondaryVM_Task)
//
// • Enable FT (EnableSecondaryVM_Task)
//
// • Power on an FT virtual machine
// (PowerOnVM_Task)
//
// • Test failover and test secondary restart
// (TerminateFaultTolerantVM_Task)
//
//
//
//
//
// • In a cluster using DRS and HA with admission control turned on
// (ClusterDasConfigInfo.admissionControlEnabled),
// the vCenter Server might not migrate virtual machines from hosts
// entering maintenance mode. This is because resources are reserved
// to maintain the failover level. You must use vMotion to manually
// migrate the virtual machines off the hosts.
//
// When admission control is disabled, failover resource constraints
// are not passed on to DRS and DPM. The constraints are not enforced.
//
//
//
// • DRS determines virtual machine placement and status
// (maintenance mode, standby mode) regardless of the impact
// this might have on failover requirements.
//
//
// • DPM powers off hosts (places them in standby mode)
// even if doing so violates failover requirements.
// If there is insufficient capacity when a failover
// occurs, DPM will attempt to bring more capacity online
// in order to correct the situation.
//
//
//
//
//
//
// • You must enable EVC in a cluster to enable DRS to manage FT primary
// and secondary virtual machine pairs in the cluster.
// For information about EVC clusters, see EVCMode.
//
// If EVC is disabled, vCenter automatically creates overrides
// to disable DRS for FT primary/secondary pairs in the cluster.
// vCenter will still use DRS to place a secondary virtual machine
// when it powers on.
// Attempts to remove the overrides or to enable DRS operations
// will fail.
//
//
//
// • EVC clusters support load balancing of powered on FT primary
// and secondary virtual machines. DRS behavior
// is governed by the overrides defined for the primary virtual
// machine. The secondary inherits DRS behavior from its primary.
// If you do not configure a DRS override for an FT virtual
// machine, DRS uses the cluster default
// (defaultVmBehavior).
//
//
//
//
//
// 1High Availability was previously called Distributed
// Availability Services.
//
//
type ClusterConfigSpecEx struct {
	*ComputeResourceConfigSpec

	// HA configuration; includes default settings for virtual machines.
	DasConfig *ClusterDasConfigInfo

	// HA configuration for individual virtual machines.
	// The entries in this array override the cluster default
	// settings
	// (ClusterDasConfigInfo.defaultVmSettings).
	// You cannot specify an HA override for a secondary FT virtual
	// machine. The secondary virtual machine will inherit whatever
	// settings apply to its primary virtual machine. If you
	// include an entry for a secondary, the reconfigure method
	// will throw the fault
	// CannotChangeHaSettingsForFtSecondary.
	DasVmConfigSpec []*ClusterDasVmConfigSpec

	// DPM configuration; includes default settings for hosts.
	DpmConfig *ClusterDpmConfigInfo

	// DPM configuration for individual hosts.
	// The entries in this array override the cluster default
	// settings
	// (ClusterDpmConfigInfo.defaultDpmBehavior).
	DpmHostConfigSpec []*ClusterDpmHostConfigSpec

	// DRS configuration; includes default settings for virtual machines.
	DrsConfig *ClusterDrsConfigInfo

	// DRS configuration for individual virtual machines.
	// The entries in this array override the cluster default
	// settings
	// (ClusterDrsConfigInfo.defaultVmBehavior).
	// You cannot specify a DRS override for a secondary FT virtual
	// machine. The secondary virtual machine will inherit whatever
	// setting applies to its primary virtual machine. If you
	// include an entry for a secondary, the reconfigure method
	// will throw the fault
	// CannotChangeDrsBehaviorForFtSecondary.
	DrsVmConfigSpec []*ClusterDrsVmConfigSpec

	// Cluster-wide group configuration.
	// The array contains one or more group specification objects.
	// A group specification object contains a virtual machine group
	// (ClusterVmGroup) or a host group (ClusterHostGroup).
	// Groups can be related; see ClusterVmHostRuleInfo.
	//
	// Since vSphere API 4.1
	GroupSpec []*ClusterGroupSpec

	// Cluster affinity and anti-affinity rule configuration.
	RulesSpec []*ClusterRuleSpec

	// VSAN configuration; includes default settings for hosts.
	//
	// Since vSphere API 5.5
	VsanConfig *VsanClusterConfigInfo

	// VSAN configuration for individual hosts.
	// The entries in this array override the cluster default settings
	// as specified in VsanClusterConfigInfo.
	//
	// Since vSphere API 5.5
	VsanHostConfigSpec []*VsanHostConfigInfo
}

//
// This event records when a cluster is created.
//
//
type ClusterCreatedEvent struct {
	*ClusterEvent

	// The folder where the cluster is created.
	Parent *FolderEventArgument
}

// Deprecated.
// As of vSphere API 5.0, this object is no longer returned by
// vCenter Server. Availability information is now reported using
// dasHostState.
//
//
// The ClusterDasAamHostInfo object contains a list of the ESX hosts
// in an HA cluster and a list that identifies the primary hosts.
// (AAM is a component of the HA service.)
// The primary hosts share the joint responsibility of maintaining all cluster
// state and one will initiate failover actions should a failure occur.
//
// When you add an ESX host to a vSphere HA cluster, the host
// downloads HA agent components from the vCenter Server.
// The HA agent maintains communication with the vCenter Server.
//
//
// When the host downloads the HA agent, the host configures the agent
// to communicate with other agents in the cluster. A host that joins
// the cluster communicates with an existing primary host to complete
// its configuration (except when you are adding the first host to the cluster).
//
//
//
// • The first five hosts added to the cluster are designated
// as primary hosts. All subsequent hosts are designated as secondary hosts.
//
// • If a primary host is removed from the cluster,
// the vCenter Server promotes another host to primary status.
//
// • There must be at least one functional primary host for vSphere HA
// to operate correctly. If there is not an available primary host
// (no response), host configuration for HA will fail.
// If there is a total cluster failure, HA will begin restarting virtual
// machines as soon as one host recovers and its HA agent is up and running.
//
//
//
//
// One of the primary hosts assumes the role of the active primary host.
// The active primary host responsibilities include the following activities:
//
//
//
// • Decides where to restart virtual machines.
//
// • Tracks failed restart attempts.
//
// • Determines when it is appropriate to continue attempts to restart
// a virtual machine.
//
//
//
//
// If the active primary host fails, another primary host replaces it.
//
//
//
type ClusterDasAamHostInfo struct {
	*ClusterDasHostInfo

	// The state of HA on the hosts.
	HostDasState []*ClusterDasAamNodeState

	// The list of primary hosts.
	PrimaryHosts []string
}

// Deprecated.
// As of vSphere API 5.0, this object is no longer returned by
// vCenter Server. See dasHostState for a
// description of the objects now used.
//
//
// The ClusterDasAamNodeState data object represents the state
// of the HA service on an ESX host. (AAM is a component of this service.)
//
//
type ClusterDasAamNodeState struct {
	*DynamicData

	// Configuration state of the HA agent on the host.
	// The property can be one of the following values:
	//
	// configuring
	// error
	// unconfiguring
	// running
	//
	// configState represents setting or resetting the HA
	// configuration on the host. If the configuration operation is
	// successful, the value of configState changes
	// to running. See ClusterDasAamNodeStateDasState.
	ConfigState string

	// Reference to the host.
	Host *HostSystem

	// Name of the host
	// (HostSystem.name).
	Name string

	// The runtime state of the HA agent on the node.
	// The property can be one of the following values:
	//
	// uninitialized
	// initialized
	// running
	// error
	// agentShutdown
	// nodeFailed
	//
	// See ClusterDasAamNodeStateDasState.
	RuntimeState string
}

//
// The ClusterDasAamNodeStateDasState enumerated type defines
// values for host HA configuration and runtime state properties
// (configState and
// runtimeState).
//
//
type ClusterDasAamNodeStateDasState struct {
}

//
// Base class for admission control related information of a vSphere HA cluster.
//
//
type ClusterDasAdmissionControlInfo struct {
	*DynamicData
}

//
// Base class for specifying how admission control should be done for vSphere HA.
//
//
type ClusterDasAdmissionControlPolicy struct {
	*DynamicData
}

//
// Base class for advanced runtime information related to the high
// availability service for a cluster.
//
//
type ClusterDasAdvancedRuntimeInfo struct {
	*DynamicData

	// The information pertaining to the HA agents on the hosts
	DasHostInfo *ClusterDasHostInfo

	// The map of a datastore to the set of hosts that are using
	// the datastore for storage heartbeating.
	//
	// Since vSphere API 5.0
	HeartbeatDatastoreInfo []*DasHeartbeatDatastoreInfo
}

//
// The ClusterDasConfigInfo data object contains configuration data
// about the HA service on a cluster.
//
// All fields are optional. If you set the modify
// parameter to true when you call
// ReconfigureComputeResource_Task, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the modify parameter to false when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
//
//
//
type ClusterDasConfigInfo struct {
	*DynamicData

	// Flag that determines whether strict admission control is enabled.
	// When you use admission control, the following operations are
	// prevented, if doing so would violate the admissionControlPolicy.
	//
	// Powering on a virtual machine in the cluster.
	// Migrating a virtual machine into the cluster.
	// Increasing the CPU or memory reservation of powered-on
	// virtual machines in the cluster.
	//
	//
	// With admission control disabled, there is no assurance that
	// all virtual machines in the HA cluster can be restarted after
	// a host failure. VMware recommends that you do not disable
	// admission control, but you might need to do so temporarily,
	// for the following reasons:
	//
	// If you need to violate the failover constraints when there
	// are not enough resources to support them (for example,
	// if you are placing hosts in standby mode to test them
	// for use with DPM).
	//
	// If an automated process needs to take actions that might
	// temporarily violate the failover constraints (for example,
	// as part of an upgrade directed by VMware Update Manager).
	//
	// If you need to perform testing or maintenance operations.
	AdmissionControlEnabled bool

	// Virtual machine admission control policy for vSphere HA.
	// The policies specify resource availability for failover support.
	//
	// Failover host admission policy
	// ClusterFailoverHostAdmissionControlPolicy -
	// currently you can specify only one failover host.
	// Failover level policy
	// ClusterFailoverLevelAdmissionControlPolicy -
	// the limit of host failures for which resources are reserved.
	// When you use the failover level policy,
	// HA partitions resources into slots. A slot represents the minimum
	// CPU and memory resources that are required to support
	// any powered on virtual machine in the cluster.
	// To retrieve information about partitioned resources, use the
	// RetrieveDasAdvancedRuntimeInfo
	// method.
	// Resources admission policy
	// ClusterFailoverResourcesAdmissionControlPolicy -
	// CPU and memory resources reserved for failover support.
	// When you use the resources policy, you can reserve
	// a percentage of the aggregate cluster resource for failover.
	//
	//
	//
	// Since vSphere API 4.0
	AdmissionControlPolicy *ClusterDasAdmissionControlPolicy

	// Cluster-wide defaults for virtual machine HA settings.
	// When a virtual machine has no HA configuration
	// (ClusterDasVmConfigSpec), it uses the values
	// specified here.
	//
	// Since VI API 2.5
	DefaultVmSettings *ClusterDasVmSettings

	// Flag to indicate whether or not vSphere HA feature is enabled.
	Enabled bool

	// Deprecated.
	// As of vSphere API 4.0, use
	// ClusterFailoverLevelAdmissionControlPolicy to set
	// admissionControlPolicy.
	//
	//
	// Configured failover level. This is the number of physical host failures
	// that can be tolerated without impacting the ability to satisfy the
	// minimums for all running virtual machines. Acceptable values range from one to
	// four.
	FailoverLevel int32

	// The policy on what datastores will be used by vCenter Server to choose
	// heartbeat datastores.
	// See ClusterDasConfigInfoHBDatastoreCandidate for all options.
	// The default value is
	// allFeasibleDsWithUserPreference.
	//
	// Since vSphere API 5.0
	HBDatastoreCandidatePolicy string

	// The list of preferred datastores to use for storage heartbeating.
	// Each of the specified datastores should be active and mounted
	// by more than one host. There is no limit on the number of specified
	// datastores and no priority among them.
	// The specified datastores will replace those previously specified and
	// an empty list will delete all such earlier specified ones.
	//
	// vCenter Server chooses the heartbeat datastores for a host from the
	// set specified by hBDatastoreCandidatePolicy.
	// The choice is made based on datastore connectivity and storage array
	// redundancy (in case of VMFS).
	//
	// The final set of selected heartbeat datastores is reported via
	// heartbeatDatastoreInfo.
	//
	// Since vSphere API 5.0
	HeartbeatDatastore []*Datastore

	// Determines whether HA restarts virtual machines after a host fails.
	// The default value is
	// ClusterDasConfigInfoServiceState.enabled.
	// This property is meaningful only when
	// ClusterDasConfigInfo.enabled is true.
	//
	// When hostMonitoring is
	// enabled, HA restarts virtual machines
	// after a host fails.
	//
	// When hostMonitoring is
	// disabled, HA does not restart
	// virtual machines after a host fails.
	// The status of Host Monitoring does not affect other services such
	// as virtual machine Health Monitoring or Fault Tolerance.
	// The rest of the cluster operations follow normal processing.
	// No configuration information is lost and re-enabling the service
	// is a quick operation.
	//
	// Since vSphere API 4.0
	HostMonitoring string

	// Advanced settings.
	Option []*OptionValue

	// Level of HA Virtual Machine Health Monitoring Service.
	// You can monitor both guest and application heartbeats, guest heartbeats only,
	// or you can disable the service. See ClusterDasConfigInfoVmMonitoringState.
	// The default value is vmMonitoringDisabled.
	//
	// The Service level specified for the cluster determines
	// the possible monitoring settings that you can use for individual virtual machines.
	// See ClusterVmToolsMonitoringSettings.vmMonitoring.
	//
	// Since vSphere API 4.0
	VmMonitoring string
}

//
// The policy to determine the candidates from which vCenter Server can
// choose heartbeat datastores.
//
//
type ClusterDasConfigInfoHBDatastoreCandidate struct {
}

//
// Possible states of an HA service. All services support the
// disabled and enabled states.
//
//
type ClusterDasConfigInfoServiceState struct {
}

//
// The ClusterDasConfigInfoVmMonitoringState enum defines values that indicate
// the state of Virtual Machine Health Monitoring. Health Monitoring
// uses the vmTools (guest) and application agent heartbeat modules.
// You can configure HA to respond to heartbeat failures of either one
// or both modules. You can also disable the HA response to heartbeat failures.
//
//
// •
// To set the cluster default for health monitoring, use the
// ClusterConfigSpecEx.dasConfig.vmMonitoring property.
//
//
// •
// To set health monitoring for a virtual machine, use the
// ClusterConfigSpecEx.dasVmConfigSpec.info.dasSettings.vmToolsMonitoringSettings property.
//
//
// •
// To retrieve the current state of health monitoring (cluster setting), use the
// ClusterConfigInfoEx.dasConfig.vmMonitoring
// property.
//
//
// •
// To retrieve the current state of health monitoring for a virtual machine, use the
// ClusterConfigInfoEx.dasVmConfig[].dasSettings.vmToolsMonitoringSettings.vmMonitoring
// property.
//
//
//
//
//
//
type ClusterDasConfigInfoVmMonitoringState struct {
}

//
// Base class for DAS data for high availability service for a cluster.
//
//
type ClusterDasData struct {
	*DynamicData
}

//
// This class contains the summary of the data that DAS needs/uses.
// The actual data is available in ClusterDasDataDetails and can be retrieved
// using the RetrieveDasData method.
//
// This class is meant for VMware internal use only.
//
//
type ClusterDasDataSummary struct {
	*ClusterDasData

	// The version corresponding to the clusterConfig
	ClusterConfigVersion int64

	// The version corresponding to the compatList
	CompatListVersion int64

	// The version corresponding to the hostList
	HostListVersion int64
}

//
// Advanced runtime information related to the high availability service
// for a cluster that has been configured with a failover level admission control
// policy. See ClusterFailoverLevelAdmissionControlPolicy.
//
//
type ClusterDasFailoverLevelAdvancedRuntimeInfo struct {
	*ClusterDasAdvancedRuntimeInfo

	HostSlots []*ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots

	// Slot information for this cluster.
	SlotInfo *ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo

	// The total number of connected hosts that are not in maintance mode and that
	// do not have any DAS-related config issues on them.
	TotalGoodHosts int32

	// The total number of hosts in the cluster.
	TotalHosts int32

	// The total number of slots available in the cluster.See SlotInfo
	TotalSlots int32

	// The total number of powered on vms in the cluster.
	TotalVms int32

	// The number of slots that are not used by currently powered on virtual machines
	// and not reserved to satisfy the configured failover level. This number gives
	// an indication of how many additional virtual machines can be powered on in
	// this cluster without violating the failover level (assuming the new virtual
	// machine's reservations are satisfied by the current slot size).
	//
	// This value is computed as follows (where m is the configured failover level):
	// Remove the m largest hosts (ie. the ones with the most slots) from the list
	// of "good" hosts (see totalGoodHosts). Sum up the number of slots on
	// the remaining hosts and deduct the number of currently used slots
	// (see usedSlots). If this number is negative, use zero instead.See SlotInfo
	UnreservedSlots int32

	// The number of slots currently being used.See SlotInfo
	UsedSlots int32

	// The list of virtual machines whose reservations and memory overhead are not
	// satisfied by a single slot.
	//
	// Since vSphere API 5.1
	VmsRequiringMultipleSlots []*ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots
}

type ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots struct {
	*DynamicData

	// The reference to the host.
	Host *HostSystem

	// The number of slots in this host.
	Slots int32
}

//
// A slot represents an amount of memory and cpu resources on a physical host for use
// by a virtual machine. It is used in computing the resources to be reserved for
// failover.
//
//
type ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo struct {
	*DynamicData

	// The cpu speed of a slot is defined as the maximum cpu reservation of any
	// powered on virtual machine in the cluster, or any otherwise defined minimum,
	// whichever is larger.
	CpuMHz int32

	// The memory size of a slot is defined as the maximum memory reservation plus
	// memory overhead of any powered on virtual machine in the cluster, or any
	// otherwise defined minimum, whichever is larger.
	MemoryMB int32

	// Deprecated.
	// As of vSphere API 5.0, the number of vcpus is no longer used
	// for slot calculations
	//
	//
	// The number of virtual cpus of a slot is defined as the maximum number of
	// virtual cpus any powered on virtual machine has.
	NumVcpus int32
}

type ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots struct {
	*DynamicData

	// The number of slots required by this virtual machine
	Slots int32

	// The reference to the virtual machine
	Vm *VirtualMachine
}

//
// The ClusterDasFdmAvailabilityState enumeration describes the
// availability states of hosts in a vSphere HA cluster. In the HA
// architecture, a agent called the Fault Domain Manager runs on
// each active host. These agents elect a master and the others become
// its slaves. The availability state assigned to a given host is
// determined from information reported by the Fault Domain Manager
// running on the host, by a Fault Domain Manager that has been elected
// master, and by vCenter Server. See ClusterDasFdmHostState
// for more information about the vSphere HA architecture.
//
//
type ClusterDasFdmAvailabilityState struct {
}

//
// The ClusterDasFdmHostState data object
// describes the availability state of each active host in a
// vSphere HA enabled cluster.
//
// In a vSphere HA cluster, the active hosts form a fault domain.
// A host is inactive if it is in standby or maintenance mode, or
// it has been disconnected from vCenter Server. A vSphere HA
// agent, called the Fault Domain Manager (FDM), runs on each host in the
// fault domain.
//
//
// One FDM serves as the master and the remaining FDMs as its slaves.
// The master is responsible for monitoring the availability of the hosts
// and VMs in the cluster, and restarting any VMs that fail due to a
// host failure or non-user-initiated power offs. The master is also
// responsible for reporting fault-domain state to vCenter Server.
//
//
// The master FDM is determined through election by the FDMs that are
// alive at the time. An election occurs in the following circumstances:
//
//
//
// •  When the vSphere HA feature is enabled for the cluster.
//
// •  When the master's host fails.
//
// •  When the management network is partitioned. In a network partition
// there will be a master for each partition. However, only one master
// will be responsible for a given VM. When the partition is
// resolved, all but one of the masters will abdicate.
//
// •  After a host in a vSphere HA cluster powers back up following a failure
// that caused all hosts in the cluster to power off.
//
//
//
//
// The slaves are responsible for reporting state updates to the master and
// restarting VMs as required. All FDMs provide the VM/Application Health
// Monitoring Service.
//
//
//
type ClusterDasFdmHostState struct {
	*DynamicData

	// The Availability State of a host based on information
	// reported by the entity given by the
	// stateReporter property. See
	// ClusterDasFdmAvailabilityState for the set of
	// states.
	State string

	// The entity reporting the state of the host. If the reporter is a host,
	// the property reports which host, whereas if the reporter is vCenter Server,
	// the property is unset.
	StateReporter *HostSystem
}

//
// HA specific advanced information pertaining to the hosts in the cluster.
//
//
type ClusterDasHostInfo struct {
	*DynamicData
}

//
// A host recommendation for a virtual machine managed by the VMware
// HA Service.
//
//
type ClusterDasHostRecommendation struct {
	*DynamicData

	// Rating as computed by DRS for a DRS-enabled cluster. Rating
	// range from 1 to 5, and the higher the rating, the stronger DRS
	// suggests this host is picked for the operation.
	DrsRating int32

	// The recommended host.
	Host *HostSystem
}

//
// The ClusterDasVmConfigInfo data object contains
// the HA configuration for a single virtual machine.
//
// All fields are optional. If you set the modify
// parameter to true when you call
// ReconfigureComputeResource_Task, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the modify parameter to false when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
//
//
//
type ClusterDasVmConfigInfo struct {
	*DynamicData

	// HA settings that apply to this virtual machine.
	//
	// Values specified in this object override the cluster-wide
	// defaults for virtual machines (defaultVmSettings).
	//
	// Since VI API 2.5
	DasSettings *ClusterDasVmSettings

	// Reference to the virtual machine.
	Key *VirtualMachine

	// Deprecated.
	// As of VI API 2.5, use
	// dasSettings.isolationResponse.
	// If you specify both powerOffOnIsolation and
	// isolationResponse, the value in
	// isolationResponse has precedence.
	//
	//
	// Flag to indicate whether or not the virtual machine should be powered off if a
	// host determines that it is isolated from the rest of the compute resource.
	//
	// If there is nothing specified here, then the defaults are picked up from
	// defaultVmSettings.
	PowerOffOnIsolation bool

	// Deprecated.
	// As of VI API 2.5, use
	// dasSettings.restartPriority.
	// If you specify restartPriority here and in
	// ClusterDasVmSettings, the value in ClusterDasVmSettings
	// has precedence.
	//
	//
	// Restart priority for a virtual machine.
	//
	// If there is nothing specified here, then the defaults are picked up from
	// defaultVmSettings.
	RestartPriority *enum.DasVmPriority
}

//
// An incremental update to the per-virtual-machine vSphere HA configuration.
//
//
type ClusterDasVmConfigSpec struct {
	*ArrayUpdateSpec

	Info *ClusterDasVmConfigInfo
}

//
// The ClusterDasVmSettings data object contains the HA configuration
// settings specified for a single virtual machine (identified by
// ClusterDasVmConfigInfo.key)
// or as cluster-wide defaults
// (ClusterDasConfigInfo.defaultVmSettings).
//
// All fields are optional. If you set the modify
// parameter to true when you call
// ReconfigureComputeResource_Task, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the modify parameter to false when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
//
//
//
type ClusterDasVmSettings struct {
	*DynamicData

	// Indicates whether or not the virtual machine should be powered off if a
	// host determines that it is isolated from the rest of the compute resource.
	//
	// If not specified at either the cluster level or
	// the virtual machine level, this will default to powerOff.
	// See ClusterDasVmSettingsIsolationResponse
	IsolationResponse string

	// Restart priority for a virtual machine.
	//
	// If not specified at either the cluster level or
	// the virtual machine level, this will default to medium.
	// See ClusterDasVmSettingsRestartPriority
	RestartPriority string

	// Configuration for the VM Health Monitoring Service.
	//
	// Since vSphere API 4.0
	VmToolsMonitoringSettings *ClusterVmToolsMonitoringSettings
}

//
// The ClusterDasVmSettingsIsolationResponse enum defines
// values that indicate whether or not the virtual machine should be
// powered off if a host determines that it is isolated from
// the rest of the cluster.
//
// Host network isolation occurs when a host is still running
// but it can no longer communicate with other hosts in the cluster
// and it cannot ping the configured isolation address(es).
// When the HA agent on a host loses contact with the other hosts,
// it will ping the isolation addresses. If the pings fail, the host
// will declare itself isolated.
//
//
// Once the HA agent declares the host isolated, it will
// initiate the isolation response workflow after a 30 second delay. You can use
// the FDM advanced option fdm.isolationPolicyDelaySec to increase the delay.
// For each virtual machine, the HA agent attempts to determine if a master is
// responsible for restarting the virtual machine. If it cannot make the determination,
// or there is a master that is responsible, the agent will apply the configured
// isolation response. This workflow will continue until the configuration policy,
// has been applied to all virtual machines, the agent reconnects to another HA agent
// in the cluster, or the isolation address pings start succeeding. If there is a
// master agent in the cluster, it will attempt to restart the virtual machines
// that were powered off during isolation.
//
//
// By default, the isolated host leaves its virtual machines powered on.
// You can override the isolation response default with a cluster-wide setting
// (defaultVmSettings)
// or a virtual machine setting
// (isolationResponse).
//
//
//
// • All isolation response values are valid for the
// isolationResponse
// property specified in a single virtual machine HA configuration.
//
// • All values except for clusterIsolationResponse are valid
// for the cluster-wide default HA configuration for virtual machines
// (defaultVmSettings).
//
//
//
//
// If you ensure that your network infrastructure is sufficiently redundant
// and that at least one network path is available at all times, host network
// isolation should be a rare occurrence.
//
//
//
type ClusterDasVmSettingsIsolationResponse struct {
}

//
// The ClusterDasVmSettingsRestartPriority enum
// defines virtual machine restart priority values to resolve
// resource contention.
// The priority determines the preference that HA gives
// to a virtual machine if sufficient capacity is not available
// to power on all failed virtual machines. For example, high priority
// virtual machines on a host get preference over low priority
// virtual machines.
//
// All priority values are valid for the restart priority
// specified in a single virtual machine HA configuration
// (dasSettings).
// All values except for clusterRestartPriority
// are valid for the cluster-wide default HA configuration
// for virtual machines (defaultVmSettings).
//
//
//
type ClusterDasVmSettingsRestartPriority struct {
}

//
// This event records when a cluster is destroyed.
//
//
type ClusterDestroyedEvent struct {
	*ClusterEvent
}

//
// Configuration of the VMware DPM service.
//
// All fields are defined as optional. In case of a reconfiguration,
// unset fields are not changed.
//
//
//
type ClusterDpmConfigInfo struct {
	*DynamicData

	// Specifies the default VMware DPM behavior for
	// hosts. This default behavior can be overridden on a per host
	// basis using the ClusterDpmHostConfigInfo object.
	DefaultDpmBehavior *enum.DpmBehavior

	// Flag indicating whether or not the service is enabled. This
	// service can not be enabled, unless DRS is enabled as well.
	Enabled bool

	// DPM generates only those recommendations that are above the
	// specified rating. Ratings vary from 1 to 5. This setting applies
	// to both manual and automated (@link DpmBehavior) DPM clusters.
	//
	// Since vSphere API 4.0
	HostPowerActionRate int32

	// Deprecated.
	// as of vSphere API 4.1, use
	// option.
	//
	//
	// Advanced settings.
	Option []*OptionValue
}

//
// DPM configuration for a single host. This makes
// it possible to override the default behavior for an individual
// host.
//
//
type ClusterDpmHostConfigInfo struct {
	*DynamicData

	// Specifies the particular DPM behavior for this host.See ClusterDpmConfigInfo
	Behavior *enum.DpmBehavior

	// Flag to indicate whether or not VirtualCenter is allowed to perform any
	// power related operations or recommendations for this host.
	//
	// If this flag is false, the host is effectively excluded from
	// DPM service.
	//
	// If no individual DPM specification exists for a host,
	// this property defaults to true.
	Enabled bool

	// Reference to the host.
	Key *HostSystem
}

//
// The ClusterDpmHostConfigSpec data object provides information
// that the Server uses to update the DPM configuration for a
// single host (identified by the
// key property).
// The host DPM configuration overrides the cluster
// default DPM setting
// (ClusterConfigSpecEx.dpmConfig).
//
// The vSphere API defines three update operations
// (ArrayUpdateSpec.operation).
//
//
//
// •  add: Define DPM behavior for a host. If the cluster
// configuration already includes a DPM behavior override
// for the specified host, this operation
// removes the existing override and adds the new one.
// The new DPM override will use the cluster default value
// if you do not specify the behavior property
// (defaultDpmBehavior).
//
//
// •  edit: Perform an incremental update to an existing
// DPM configuration entry for a host.
// The reconfigure method changes only the properties
// that you set in the data object. The entry must exist
// in the
// ClusterConfigSpecEx.dpmHostConfigSpec array.
//
//
// •  remove: Remove the DPM override for the specified
// host. To identify the host to delete, use the
// removeKey property
// to specify the key
// in the host override.
//
//
//
//
//
// Use the ReconfigureComputeResource_Task method
// to update the DPM configuration. If you set the modify parameter
// to true, you can use any of the three operations (add, edit, or remove).
// If you set the modify parameter to false, you can use only the
// add operation.
//
//
//
type ClusterDpmHostConfigSpec struct {
	*ArrayUpdateSpec

	Info *ClusterDpmHostConfigInfo
}

//
// The ClusterDrsConfigInfo data object contains configuration information
// for the VMware DRS service.
//
// All fields are optional. If you set the modify
// parameter to true when you call
// ReconfigureComputeResource_Task, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the modify parameter to false when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
//
//
//
type ClusterDrsConfigInfo struct {
	*DynamicData

	// Specifies the cluster-wide default DRS behavior for virtual machines.
	// You can override the default behavior for a virtual machine
	// by using the ClusterDrsVmConfigInfo object.
	DefaultVmBehavior *enum.DrsBehavior

	// Flag indicating whether or not the service is enabled.
	Enabled bool

	// Flag that dictates whether DRS Behavior overrides for individual
	// virtual machines (ClusterDrsVmConfigInfo) are enabled. The default
	// value is true.
	//
	// When this flag is true, the
	// ClusterConfigSpecEx.drsVmConfigSpec
	// values override the defaultVmBehavior.
	//
	// When this flag is false, the
	// defaultVmBehavior value applies to all virtual
	// machines, with the following exception: in a cluster that has EVC disabled,
	// you cannot override the virtual machine setting
	// (drsVmConfigSpec)
	// for Fault Tolerance virtual machines.
	//
	// Since vSphere API 4.0
	EnableVmBehaviorOverrides bool

	// Advanced settings.
	Option []*OptionValue

	// Threshold for generated ClusterRecommendations.
	// DRS generates only those recommendations that are above the
	// specified vmotionRate. Ratings vary from 1 to 5. This setting applies
	// to manual, partiallyAutomated, and fullyAutomated
	// DRS clusters. See DrsBehavior.
	VmotionRate int32
}

//
// The faults generated by DRS when it tries to make recommendations
// for rule enforcement, power management, etc., and indexed in a tree
// structure with reason for recommendations and VM to migrate (optional)
// as the index keys.
//
//
type ClusterDrsFaults struct {
	*DynamicData

	// The faults grouped by VMs that DRS was trying to migrate.
	FaultsByVm []*ClusterDrsFaultsFaultsByVm

	// A reason code explaining why this set of recommendations were attempted
	// by DRS when it generated the faults.
	Reason string
}

//
// The faults generated by storage DRS when it tries to move a virtual disk.
//
//
//
//
type ClusterDrsFaultsFaultsByVirtualDisk struct {
	*ClusterDrsFaultsFaultsByVm

	// The virtual disk that storage DRS was trying to migrate when it
	// generated the faults. If this property is NULL, the fault is not
	// associated with a particular virtual disk.
	Disk *VirtualDiskId
}

//
// FaultsByVm is the faults generated by DRS when it tries to
// move a VM.
//
//
type ClusterDrsFaultsFaultsByVm struct {
	*DynamicData

	// The faults generated by DRS when it was trying to move the given VM.
	Fault []*LocalizedMethodFault

	// The VM that DRS was trying to migrate when it generated the faults.
	// If this property is NULL, the fault is not associated with a particular VM.
	Vm *VirtualMachine
}

//
// Describes a single virtual machine migration.
//
//
type ClusterDrsMigration struct {
	*DynamicData

	// Current CPU load for the virtual machine, in MHz.
	// This property is only populated for recommendations.
	CpuLoad int32

	// Destination host.
	Destination *HostSystem

	// Current CPU load on the destination host, in MHz.
	DestinationCpuLoad int32

	// Current memory usage on the destination host, in bytes.
	DestinationMemoryLoad int64

	// A unique key that identifies this recommendation. This
	// is used as an argument to
	// ComputeResource.applyRecommendation.
	Key string

	// Current memory load for the virtual machine, in bytes.
	// This field is only populated for recommendations.
	MemoryLoad int64

	// Source host.
	Source *HostSystem

	// Current CPU load on the source host, in MHz.
	SourceCpuLoad int32

	// Current memory usage on the source host, in bytes.
	SourceMemoryLoad int64

	// The time this recommendation was computed.
	Time time.Time

	// The virtual machine selected for migration.
	Vm *VirtualMachine
}

// Deprecated.
// As of VI API 2.5 use ClusterRecommendation.
//
//
// DrsRecommendation describes a recommendation to migrate
// one or more virtual machines.
//
//
type ClusterDrsRecommendation struct {
	*DynamicData

	// Key to identify the recommendation when calling applyRecommendation.
	Key string

	// Deprecated.
	// A more general recommendation list should be used. This recommendation type
	// and the migrationList is kept for backward compatibility.
	//
	// List of migrations in this recommendation and all the parent
	// recommendations on which this recommendation depends. All the
	// migrations in this list can be constructed from prerequisite and action.
	MigrationList []*ClusterDrsMigration

	// A rating of the recommendation.
	// Valid values range from 1 (lowest confidence) to 5 (highest confidence).
	Rating int32

	// A reason code explaining why this set of migrations is being suggested.
	Reason string

	// Text that provides more information about the reason code for the suggested
	// set of migrations.
	ReasonText string
}

//
// DRS configuration for a single virtual machine. This makes it possible
// to override the default behavior for an individual virtual machine.
//
//
type ClusterDrsVmConfigInfo struct {
	*DynamicData

	// Specifies the particular DRS behavior for this virtual machine.See ClusterDrsConfigInfo
	Behavior *enum.DrsBehavior

	// Flag to indicate whether or not VirtualCenter is allowed to perform any
	// DRS migration or initial placement recommendations for this virtual
	// machine.
	// If this flag is false, the virtual machine is effectively excluded from
	// DRS.
	//
	// If no individual DRS specification exists for a virtual machine,
	// this property defaults to true.
	Enabled bool

	// Reference to the virtual machine.
	Key *VirtualMachine
}

//
// Updates the per-virtual-machine DRS configuration.
//
// To update the DRS configuration of a virtual machine, a copy of this object
// is included in the ClusterConfigSpecEx object passed to the method
// ReconfigureComputeResource_Task.
//
//
// If reconfigureEx is used to
// incrementally update the cluster configuration (i.e., the parameter modify is true),
// then three operations are provided for updating the DRS configuration for a virtual machine.
// These operations are listed below (see ArrayUpdateSpec for more
// information on these operations).
//
//
//
// •  add: add a configuration for the virtual machine, overwritting the existing
// configuration if one exists
//
// •  edit: incrmentally update the existing configuration; an existing configuration
// must exist
//
// •  remove: remove the existing configuration; an existing configuration must exist
//
//
//
//
// If, instead, this method is used to overwrite the cluster configuration (i.e., the parameter
// modify is false) thereby creating a new configuration, only the add operation is allowed.
// In this case, add creates a DRS configuration for a virtual machine in the new cluster
// configuration.
//
//
type ClusterDrsVmConfigSpec struct {
	*ArrayUpdateSpec

	Info *ClusterDrsVmConfigInfo
}

//
// EnterMaintenanceResult is the base class of the result returned to the
// ClusterEnterMaintenanceMode method.
//
//
type ClusterEnterMaintenanceResult struct {
	*DynamicData

	// The faults that explain why the Virtual Center cannot evacuate
	// some hosts.
	Fault *ClusterDrsFaults

	// The list of recommendations for hosts that Virtual Center will
	// be able to evacuate. Each recommendation consists of a host
	// maintenance action ClusterAction for a host, along
	// with zero or more vmotions for evacuation. Application of the
	// recommendations is not supported currently. The client will have
	// to put the hosts into maintenance mode by calling the separate
	// method EnterMaintenanceMode_Task.
	Recommendations []*ClusterRecommendation
}

//
// These are cluster events.
//
//
type ClusterEvent struct {
	*Event
}

//
// The current admission control related information if the cluster was configured
// with a FailoverHostAdmissionControlPolicy.
//
//
type ClusterFailoverHostAdmissionControlInfo struct {
	*ClusterDasAdmissionControlInfo

	// Status of the failover hosts in the cluster.
	HostStatus []*ClusterFailoverHostAdmissionControlInfoHostStatus
}

//
// Data object containing the status of a failover host.
//
//
type ClusterFailoverHostAdmissionControlInfoHostStatus struct {
	*DynamicData

	// The failover host.
	Host *HostSystem

	// The status of the failover host.
	//
	// The status is green for a connected host with no vSphere HA errors and
	// no virtual machines running on it.
	// The status is yellow for a connected host with no vSphere HA errors and
	// some virtual machines running on it.
	// The status red for a disconnected or not responding host, a host that
	// is in maintenance or standby mode or that has a vSphere HA error on it.
	Status *enum.ManagedEntityStatus
}

//
// The ClusterFailoverHostAdmissionControlPolicy dedicates
// one or more hosts for use during failover.
// When a host fails with this policy in place, vSphere HA attempts
// to restart its virtual machines on a dedicated failover host.
// If this is not possible, for example the failover host itself has failed
// or it has insufficient resources, HA attempts to restart those virtual
// machines on another host in the cluster.
//
// To support the availabilty of a failover host,
// the vCenter Server will prevent users from powering on virtual machines
// on that host, or from using vMotion to migrate virtual machines to the host.
// Also, DRS does not use the failover host for load balancing.
//
//
// To obtain the status of a failover host, use the
// hostStatus
// property
// (ClusterComputeResourceSummary.admissionControlInfo.hostStatus).
//
//
//
type ClusterFailoverHostAdmissionControlPolicy struct {
	*ClusterDasAdmissionControlPolicy

	// List of managed object references to failover hosts.
	FailoverHosts []*HostSystem
}

//
// The current admission control related information if the cluster was configured
// with a FailoverLevelAdmissionControlPolicy.
//
//
type ClusterFailoverLevelAdmissionControlInfo struct {
	*ClusterDasAdmissionControlInfo

	// Current failover level. This is the number of physical host failures that can
	// be tolerated without impacting the ability to satisfy the minimums for all
	// running virtual machines. This represents the current value, as opposed to
	// desired value configured by the user.
	CurrentFailoverLevel int32
}

//
// The ClusterFailoverLevelAdmissionControlPolicy
// defines the number of host failures that should be tolerated and still
// guarantee enough unfragmented resources to failover all powered on virtual
// machines on those failed hosts.
//
// When you use the failover level policy, vSphere HA partitions resources
// into slots. A slot represents the minimum CPU and memory resources
// that are required to support any powered-on virtual machine in the cluster.
//
//
// With the failover level policy in place, HA uses the following slot
// calculations to control virtual machine migration within the cluster:
//
//
// • Calculate the slot size from CPU and memory reservations.
// The CPU value is the largest CPU reservation for all powered-on
// virtual machines in the cluster. The memory value is the largest
// memory reservation (plus memory overhead).
//
// If your cluster contains any virtual machines that have much larger
// reservations than the others, they will distort slot size calculation.
// To avoid this, you can specify an upper bound for slot sizes;
// use the configuration editor in the vSphere Client to set the
// das.slotCpuInMHz and das.slotMemInMB attributes. When you use these
// attributes, there is a risk that resource fragmentation will cause
// virtual machines with resource requirements larger than the slot size
// to be assigned multiple slots. In a cluster that is close to capacity,
// there might be enough slots in aggregate for HA to successfully
// failover a virtual machine. However, if those slots are located
// on multiple hosts, a virtual machine assigned multiple slots cannot
// use them because a virtual machine can run on only a single host
// at a time.
//
//
// • Determine how many slots each host in the cluster can hold.
// HA uses the CPU and memory resources in a host's root resource pool
// to determine host slot capacity, not the total physical resources
// of the host. Resources used for virtualization purposes are not
// included. HA uses connected hosts that are not in maintenance mode
// and that do not have any HA errors.
//
// The CPU slot resource is the host CPU resource amount divided
// by the CPU component of the slot size; the result is rounded down.
// HA makes the same calculation for host memory resource amount.
// HA compares the results; the lower of the two numbers is the
// host slot capacity.
//
//
// • Determine the current failover capacity of the cluster. This is the
// number of hosts (starting from the largest) that can fail and still
// leave enough slots to satisfy all of the powered-on virtual machines.
//
//
// • Compare the current failover capacity to the configured
// failoverLevel.
// If the current failover capacity is less than the configured
// failover level, HA disallows the operation.
//
//
//
//
type ClusterFailoverLevelAdmissionControlPolicy struct {
	*ClusterDasAdmissionControlPolicy

	// Number of host failures that should be tolerated, still guaranteeing
	// sufficient resources to restart virtual machines on available hosts.
	FailoverLevel int32

	// A policy for how to compute the slot size. If left unset, the slot is
	// computed using the maximum reservations and memory overhead of any
	// powered on virtual machine in the cluster.
	//
	// Since vSphere API 5.1
	SlotPolicy *ClusterSlotPolicy
}

//
// The current admission control related information if the cluster was configured
// with a FailoverResourcesAdmissionControlPolicy.
//
//
type ClusterFailoverResourcesAdmissionControlInfo struct {
	*ClusterDasAdmissionControlInfo

	// The percentage of cpu resources in the cluster available for failover.
	CurrentCpuFailoverResourcesPercent int32

	// The percentage of memory resources in the cluster available for failover.
	CurrentMemoryFailoverResourcesPercent int32
}

//
// The ClusterFailoverResourcesAdmissionControlPolicy
// reserves a specified percentage of aggregate cluster resources for failover.
// With the resources failover policy in place, vSphere HA uses the following
// calculations to control virtual machine migration in the cluster.
//
// • Calculate the total resource requirements for all powered-on
// virtual machines in the cluster.
//
// • Calculate the total host resources available for virtual machines.
//
// • Calculate the Current CPU failover capacity and current memory failover
// capacity for the cluster.
//
// • Compare the current CPU failover capacity and current memory failover
// capacity with the configured resource percentages
// (cpuFailoverResourcesPercent
// and
// memoryFailoverResourcesPercent).
// If either current capacity is less than the corresponding configured
// capacity, HA does not allow the operation.
//
//
//
// HA uses the actual reservations of the virtual machines. If a virtual machine
// does not have reservations, meaning that the reservation is 0, a default
// of 0MB memory and 256MHz CPU is applied. This is controlled by the same
// HA advanced options used for the failover level policy
// (ClusterFailoverLevelAdmissionControlPolicy).
//
//
//
type ClusterFailoverResourcesAdmissionControlPolicy struct {
	*ClusterDasAdmissionControlPolicy

	// Percentage of CPU resources in the cluster to reserve for failover.
	// You can specify up to 100% of CPU resources for failover.
	CpuFailoverResourcesPercent int32

	// Percentage of memory resources in the cluster to reserve for failover.
	// You can specify up to 100% of memory resources for failover.
	MemoryFailoverResourcesPercent int32
}

//
// This policy allows setting a fixed slot size
//
//
type ClusterFixedSizeSlotPolicy struct {
	*ClusterSlotPolicy

	// The cpu component of the slot size (in MHz)
	Cpu int32

	// The memory component of the slot size (in megabytes)
	Memory int32
}

//
// ClusterGroupInfo is the base type for all virtual machine
// and host groups. All virtual machines and hosts that are part of a group
// must be part of the same cluster.
//
//
type ClusterGroupInfo struct {
	*DynamicData

	// Unique name of the group.
	Name string

	// Flag to indicate whether the group is created by the user or the system.
	//
	// Since vSphere API 5.0
	UserCreated bool
}

//
// An incremental update to the cluster-wide groups.
//
//
type ClusterGroupSpec struct {
	*ArrayUpdateSpec

	Info *ClusterGroupInfo
}

//
// The ClusterHostGroup data object identifies hosts for VM-Host rules.
// VM-Host rules determine placement of virtual machines on hosts in a cluster.
// The logic specified in a ClusterVmHostRuleInfo object
// determines where virtual machines can be powered-on.
//
//
type ClusterHostGroup struct {
	*ClusterGroupInfo

	// List of hosts that are part of this group.
	// A host group can contain zero or more hosts.
	Host []*HostSystem
}

//
// Describes a single host power action.
//
//
type ClusterHostPowerAction struct {
	*ClusterAction

	// CPU capacity of the host in units of MHz. In case of power-on
	// action, this is the projected increase in the cluster's CPU
	// capacity. In case of power off, this is the projected decrease
	// in the cluster's CPU capacity.
	CpuCapacityMHz int32

	// Memory capacity of the host in units of MM. In case of power-on
	// action, this is the projected increase in the cluster's memory
	// capacity. In case of power off, this is the projected decrease
	// in the cluster's memory capacity.
	MemCapacityMB int32

	// Specify whether the action is power on or power off
	OperationType *enum.HostPowerOperationType

	// Estimated power consumption of the host. In case of power-on,
	// this is the projected increase in the cluster's power
	// consumption. In case of power off, this is the projected
	// decrease in the cluster's power consumption
	PowerConsumptionWatt int32
}

//
// A DRS recommended host for either powering on, resuming or
// reverting a virtual machine, or migrating a virtual machine from
// outside the cluster.
//
//
type ClusterHostRecommendation struct {
	*DynamicData

	// The recommended host.
	Host *HostSystem

	// Rating for the recommendation. Ratings range from 1 to 5, and
	// the higher the rating, the stronger DRS suggests this host is
	// picked for the operation.
	Rating int32
}

//
// Describes an initial placement of a single virtual machine
//
//
type ClusterInitialPlacementAction struct {
	*ClusterAction

	// The resource pool to place the virtual machine into in case this
	// action is for migrating from outside cluster.
	Pool *ResourcePool

	// The host where the virtual machine should be initially placed.
	TargetHost *HostSystem
}

//
// Describes a single VM migration action.
//
//
type ClusterMigrationAction struct {
	*ClusterAction

	// The details of the migration action
	DrsMigration *ClusterDrsMigration
}

//
// This data class reports one virtual machine powerOn failure.
//
//
type ClusterNotAttemptedVmInfo struct {
	*DynamicData

	// The exception returned.
	Fault *LocalizedMethodFault

	// The virtual machine that can not be powered on.
	Vm *VirtualMachine
}

//
// This event records when a cluster's host capacity cannot satisfy resource
// configuration constraints.
//
//
type ClusterOvercommittedEvent struct {
	*ClusterEvent
}

//
// Defines the options for a Datacenter::powerOnVm() invocation.
//
//
type ClusterPowerOnVmOption struct {
}

//
// PowerOnVmResult is the base class of the result returned to the
// PowerOnMultiVM_Task method.
//
//
type ClusterPowerOnVmResult struct {
	*DynamicData

	// The list of virtual machines the Virtual Center has attempted to power on.
	// For a virtual machine not managed by DRS, a task ID is also returned.
	Attempted []*ClusterAttemptedVmInfo

	// The list of virtual machines DRS can not find suitable hosts for powering on.
	// There is one fault associated with each virtual machine.
	NotAttempted []*ClusterNotAttemptedVmInfo

	// The list of recommendations that need the client to approve manually.
	Recommendations []*ClusterRecommendation
}

type ClusterProfile struct {
	*ManagedObject
	*Profile
}

//
// Update the ClusterProfile with the specified config.
//
// Required Privileges
// Profile.Edit
//
func (mo *ClusterProfile) UpdateClusterProfile(
	_this *ManagedObjectReference, config *ClusterProfileConfigSpec,
) error {

	return nil

}

//
// DataObject completely specifying the configuration of
// the profile.
//
//
type ClusterProfileCompleteConfigSpec struct {
	*ClusterProfileConfigSpec

	// User defined compliance profile for the cluster.
	// If unset, clear the complyProfile.
	ComplyProfile *ComplianceProfile
}

type ClusterProfileConfigInfo struct {
	*ProfileConfigInfo

	// Compliance profile for the cluster
	ComplyProfile *ComplianceProfile
}

//
// DataObject which allows reconfiguration of a profile
// based on services that will be available on the cluster.
//
//
type ClusterProfileConfigServiceCreateSpec struct {
	*ClusterProfileConfigSpec

	// Type of the service for which the ClusterProfile is being requested.
	// If more than one service is specified, the created ClusterProfile
	// will cater for all the services.
	// Possible values are specified by
	// ClusterProfileServiceType.
	// If unset, clear the compliance expressions on the profile.
	ServiceType []string
}

//
// DataObject which is a baseclass for other configuration
// specifications.
//
//
type ClusterProfileConfigSpec struct {
	*ClusterProfileCreateSpec
}

//
// Base class for Cluster CreateSpecs
//
//
type ClusterProfileCreateSpec struct {
	*ProfileCreateSpec
}

type ClusterProfileManager struct {
	*ManagedObject
	*ProfileManager
}

//
// Type of services for which Profile can be requested for
//
//
type ClusterProfileServiceType struct {
}

//
// Recommendation is the base class for any packaged group of
// actions that are intended to take the system from one
// state to another one.
//
//
type ClusterRecommendation struct {
	*DynamicData

	// List of actions that are executed as part of this recommendation
	Action []*ClusterAction

	// Key to identify the recommendation when calling applyRecommendation.
	Key string

	// This recommendation may depend on some other recommendations.
	// The prerequisite recommendations are listed by their keys.
	Prerequisite []string

	// A rating of the recommendation.
	// Valid values range from 1 (lowest confidence) to 5 (highest confidence).
	Rating int32

	// A reason code explaining why this set of migrations is being suggested.
	Reason string

	// Text that provides more information about the reason code for the suggested
	// set of migrations.
	ReasonText string

	// The target object of this recommendation.
	Target *ManagedObjectReference

	// The time this recommendation was computed.
	Time time.Time

	// Type of the recommendation. This differentiates between various
	// of recommendations aimed at achieving different goals.
	Type string
}

//
// This event records when a cluster is reconfigured.
//
//
type ClusterReconfiguredEvent struct {
	*ClusterEvent
}

//
// The ClusterRuleInfo data object is the base type for affinity
// and anti-affinity rules. The affinity and anti-affinity rules
// are DRS (Distributed Resource Scheduling) rules that affect the placement
// of virtual machines in a cluster. Hosts and virtual machines referenced
// in a DRS rule must be in the same cluster.
//
// Note: DRS rules are different than an individual host's CPU affinity rules
// (VirtualMachineAffinityInfo).
//
//
// The Server uses DRS rule objects to describe the current rule configuration
// (ClusterConfigInfoEx.rule).
// Your client application uses rule objects to configure the affinity and
// anti-affinity rules
// (ClusterConfigSpecEx.rulesSpec).
//
//
// You can create the following types of rules:
//
//
//
// • An affinity rule defines a set of virtual machines that should run
// on the same host.
// The ClusterAffinityRuleSpec object describes a rule that
// identifies virtual machines, but does not identify any specific host.
//
// • An anti-affinity rule defines a set of virtual machines that should run
// on different hosts.
// The ClusterAntiAffinityRuleSpec object describes a rule that
// identifies virtual machines, but does not identify any specific host.
//
// • A VM-Host rule defines affinity and anti-affinity relationships between
// virtual machines and hosts.
// The ClusterVmHostRuleInfo object describes a rule that identifies
// a virtual machine group (ClusterVmGroup) and affinity and
// anti-affinity host groups (ClusterHostGroup).
//
//
//
//
// Rule configuration is a dynamic process. When you create or modify a DRS rule,
// the Server applies the rule to the cluster. If the existing cluster configuration
// violates the rule, the Server attempts to correct the situation. If that is not
// possible, the Server generates a fault and produces a log event.
// DRS rules do not have precedence; all rules are applied equally.
// DRS does not validate one rule against another. If you create conflicting
// rules, the older rule takes precedence and DRS disables the newer rule.
//
//
// Improperly used, DRS rules can fragment the cluster and inhibit the proper
// functioning of DRS, HA, and DPM services. vSphere services never
// take any actions that would result in the violation of mandatory DRS rules.
// An operation that violates a mandatory rule would produce the following
// consequences.
//
//
//
// • DRS does not evacuate virtual machines to place a host in maintenance
// mode.
//
// • DRS does not place virtual machines for power-on or load balance virtual
// machines.
//
// • HA does not perform failovers.
//
// • DPM does not optimize power management by placing hosts into standby
// mode.
//
//
//
//
// To avoid these situations, exercise caution when creating more than one
// mandatory rule, or consider using only optional rules. Make sure that
// the number of hosts with which a virtual machine is related by affinity rule
// is large enough that losing a host does not prevent the virtual machine
// from running.
//
//
// For manual and partially automated DRS clusters, the Server produces migration
// recommendations to satisfy the DRS rules. You are not required to act on the
// recommendations, but the Server maintains the recommendations until the rules
// are satisfied.
//
//
//
type ClusterRuleInfo struct {
	*DynamicData

	// Flag to indicate whether or not the rule is enabled. Set this property
	// when you configure the rule. The default value is false (disabled).
	// If there is a rule conflict, the Server can override the setting to disable
	// a rule.
	Enabled bool

	// Flag to indicate whether or not the placement of Virtual Machines is currently
	// in compliance with this rule. The Server does not currently use this property.
	//
	// Since vSphere API 4.1
	InCompliance bool

	// Unique ID for rules. When adding a new rule, do not specify this property.
	// The Server will assign the key.
	Key int32

	// Flag to indicate whether compliance with this rule is mandatory or optional.
	// The default value is false (optional).
	//
	// A mandatory rule will prevent a virtual machine from being powered on
	// or migrated to a host that does not satisfy the rule.
	// An optional rule specifies a preference. DRS takes an optional rule
	// into consideration when it places a virtual machine in the cluster.
	// DRS will act on an optional rule as long as it does not impact
	// the ability of the host to satisfy current CPU or memory requirements
	// for virtual machines on the system. (As long as the operation does not
	// cause any host to be more than 100% utilized.)
	//
	//
	// Since vSphere API 4.1
	Mandatory bool

	// Name of the rule.
	Name string

	// Flag to indicate whether or not the rule is currently satisfied.
	Status *enum.ManagedEntityStatus

	// Flag to indicate whether the rule is created by the user or the system.
	//
	// Since vSphere API 4.1
	UserCreated bool
}

//
// An incremental update to the cluster rules.
//
//
type ClusterRuleSpec struct {
	*ArrayUpdateSpec

	Info *ClusterRuleInfo
}

//
// The base class ClusterSlotPolicy is used for specifying how
// the slot size is to be computed for the failover level HA admission control
// policy. By default, vSphere HA defines the slot size using the largest memory
// and cpu reservations of any powered on virtual machine in the cluster.
// Subclasses of this class define various policies to modify how the slot size
// is chosen to prevent outlier virtual machines (i.e. those with much larger
// reservations than the average) from skewing the slot size. If such a policy is chosen,
// outlier virtual machines will use multiple slots. Using such a policy introduces
// a risk that vSphere HA will be unable to failover these virtual machines because
// of resource fragmentation.
//
//
type ClusterSlotPolicy struct {
	*DynamicData
}

//
// This event records when a cluster's overall status changed.
//
//
type ClusterStatusChangedEvent struct {
	*ClusterEvent

	// The new (status).
	NewStatus string

	// The old (status).
	OldStatus string
}

//
// The ClusterVmGroup data object identifies virtual machines
// for VM-Host rules. VM-Host rules determine placement of virtual machines
// on hosts in a cluster.
// The logic specified in a ClusterVmHostRuleInfo object
// determines where virtual machines can be powered-on.
//
// If a virtual machine is removed from the cluster, it loses its DRS group
// affiliation. The Server does not restore any group affiliations if the
// virtual machine is returned to the cluster.
//
//
//
type ClusterVmGroup struct {
	*ClusterGroupInfo

	// List of virtual machines that are part of this group.
	// A virtual machine group can contain zero or more virtual machines.
	Vm []*VirtualMachine
}

//
//
// A ClusterVmHostRuleInfo object identifies virtual machines
// and host groups that determine virtual machine placement. The virtual
// machines and hosts referenced by a VM-Host rule must be in the same cluster.
//
//
// A VM-Host rule identifies the following groups.
//
//
//
// • A virtual machine group (ClusterVmGroup).
//
// • Two host groups - an affine host group and an anti-affine host group
// (ClusterHostGroup).
// At least one of the groups must contain one or more hosts.
//
//
//
//
// ClusterVmHostRuleInfo stores only the names of the relevant
// virtual machine and host groups. The group contents are stored in
// the virtual machine and host group objects.
//
//
// When you modify a VM-Host rule, only the fields that are specified are set.
//
//
//
type ClusterVmHostRuleInfo struct {
	*ClusterRuleInfo

	// Name of the affine host group
	// (ClusterHostGroup.name).
	// The affine host group identifies hosts on which
	// vmGroupName virtual machines can be powered-on.
	// The value of the mandatory property
	// determines how the Server interprets the rule.
	AffineHostGroupName string

	// Name of the anti-affine host group
	// (ClusterHostGroup.name).
	// The anti-affine host group identifies hosts on which
	// vmGroupName virtual machines should not
	// be powered-on.
	// The value of the mandatory property
	// determines how the Server interprets the rule.
	AntiAffineHostGroupName string

	// Virtual group name (ClusterVmGroup.name).
	// The virtual group may contain one or more virtual machines.
	VmGroupName string
}

//
// The ClusterVmToolsMonitoringSettings data object contains
// virtual machine monitoring settings that are used by the Virtual Machine Health Monitoring Service.
// The Service checks the VMware Tools heartbeat of a virtual machine.
// If heartbeats have not been received within a specified time interval, the Service
// declares the virtual machine as failed and resets the virtual machine.
//
// These settings are applied to individual virtual machines during cluster reconfiguration
// (ClusterDasVmConfigInfo.dasSettings.vmToolsMonitoringSettings). You can also specify them as default values
// (ClusterDasConfigInfo.defaultVmSettings).
//
//
//
// All fields are optional. In case of a reconfiguration, fields left unset are not changed.
//
//
//
type ClusterVmToolsMonitoringSettings struct {
	*DynamicData

	// Flag indicating whether to use the cluster settings or the per VM settings.
	//
	// The default value is true.
	ClusterSettings bool

	// Deprecated.
	// As of vSphere API 4.1, use vmMonitoring
	//
	//
	// Flag indicating whether or not the Virtual Machine Health Monitoring
	// service is enabled.
	//
	// The Server does not use this property.
	Enabled bool

	// If no heartbeat has been received for at least the specified number of seconds,
	// the virtual machine is declared as failed.
	//
	// The default value is 30.
	FailureInterval int32

	// Maximum number of failures and automated resets allowed during the time that
	// maxFailureWindow specifies. If maxFailureWindow is -1
	// (no window), this represents the absolute number of failures after which
	// automated response is stopped.
	//
	// If a virtual machine exceeds this threshold, in-depth problem analysis is
	// usually needed.
	//
	// The default value is 3.
	MaxFailures int32

	// The number of seconds for the window during which up to maxFailures
	// resets can occur before automated responses stop.
	//
	// If set to -1, no failure window is specified.
	//
	// The default value is -1.
	MaxFailureWindow int32

	// The number of seconds for the virtual machine's heartbeats to stabilize
	// after the virtual machine has been powered on. This time should include
	// the guest operating system boot-up time. The virtual machine monitoring
	// will begin only after this period.
	//
	// The default value is 120.
	MinUpTime int32

	// Indicates the type of virtual machine monitoring.
	// Specify a string value corresponding to one of the
	// following ClusterDasConfigInfoVmMonitoringState values:
	//
	// vmMonitoringDisabled (the default value)
	// vmMonitoringOnly
	// vmAndAppMonitoring
	//
	//
	// The individual VMware Tools setting for virtual machine monitoring depends on
	// the HA Virtual Machine Health Monitoring Service level that is
	// defined for the cluster
	// (ClusterDasConfigInfo.vmMonitoring).
	// The following list indicates the supported VMware Tools vmMonitoring values
	// according to the cluster configuration.
	//
	//
	// If the cluster configuration specifies vmMonitoringDisabled,
	// the Service is disabled and the HA Service ignores the VMware Tools monitoring setting.
	// If the cluster configuration specifies vmMonitoringOnly,
	// the Service supports vmMonitoringOnly or vmMonitoringDisabled only.
	// If the cluster configuration specifies vmAndAppMonitoring,
	// you can use any of the ClusterDasConfigInfoVmMonitoringState values.
	//
	//
	//
	// The clusterSettings value has no
	// effect on the constraint imposed by the HA Virtual Machine Health Monitoring Service
	// level that is defined for the cluster
	// (ClusterDasConfigInfo.vmMonitoring).
	//
	// Application monitoring events are generated regardless of the
	// currently configured type of virtual machine monitoring.
	// You can use these events even if monitoring is being disabled
	// or set to vmMonitoringOnly.
	//
	//
	// Since vSphere API 4.1
	VmMonitoring string
}

//
// The distributed virtual switch received a reconfiguration request to
// activate ipfix monitoring of the switch traffic. However, the address
// and/or the port of the ipfix collector has not been specified.
//
//
type CollectorAddressUnset struct {
	*DvsFault
}

type ComplianceFailure struct {
	*DynamicData

	// Name of the Expression which generated the ComplianceFailure
	ExpressionName string

	// String uniquely identifying the failure.
	FailureType string

	// Message which describes the compliance failures
	//
	// message.key serves as a key to the localized
	// message catalog.
	Message *LocalizableMessage
}

//
// This dataObject contains information about location of applyProfile
// which was responsible for generation of a particular ComplianceExpression.
//
//
type ComplianceLocator struct {
	*DynamicData

	// Complete path to the profile/policy which was responsible for the
	// generation of the ComplianceExpression.
	// [ProfilePath + policyId] will uniquely identify a Policy.
	ApplyPath *ProfilePropertyPath

	// Exression for which the Locator corresponds to
	ExpressionName string
}

//
// DataObject contains the verifications that need to be done
// to make sure the entity is in compliance.
//
//
type ComplianceProfile struct {
	*DynamicData

	// List of expressions that make up the ComplianceChecks.
	Expression []*ProfileExpression

	// Name of the Expression which is the root of the expression tree.
	RootExpression string
}

//
// DataObject representing the result from a ComplianceCheck
//
//
type ComplianceResult struct {
	*DynamicData

	// Time at which compliance check was last run on the entity
	CheckTime time.Time

	// Indicates the compliance status of the entity.
	// See
	ComplianceStatus string

	// Entity on which the compliance check was carried out.
	// Entity can be a Cluster, Host and so on.
	Entity *ManagedEntity

	// If complianceStatus is non-compliant, failure will
	// contain additional information about the compliance errors.
	Failure []*ComplianceFailure

	// Profile for which the ComplianceResult applies
	Profile *Profile
}

type ComplianceResultStatus struct {
}

//
// DataObject represents a composite Policy that is created by the user
// using different PolicyOptions. The options set in the CompositePolicyOption
// should be derived from the possible options as indicated by the
// CompositePolicyOptionMetadata.
//
//
type CompositePolicyOption struct {
	*PolicyOption

	// List of policy options that are composed and applicable for
	// this composite policy option.
	//
	// The selected PolicyOptions in a CompositePolicyOption will be used in the
	// policy.  PolicyOptions need not be specified if they are not desired for
	// the CompositePolicyOption.
	//
	// Order of PolicyOptions in the PolicyOption array is not significant.
	// The host profile policy engine will not respect order of PolicyOptions.
	// It will apply PolicyOptions in a pre-determined order.
	//
	// Clients of the API must produce PolicyOption in the same order as specified
	// in the metadata.
	Option []*PolicyOption
}

//
// Represents a set of physical compute resources for a set of virtual machines.
//
// The base type ComputeResource, when instantiated by calling
// AddStandaloneHost_Task, represents a single host. The subclass
// ClusterComputeResource represents a cluster of hosts and adds distributed management
// features such as availability and resource scheduling.
//
//
// A ComputeResource always has a root ResourcePool associated with it.
// Certain types of  clusters such as those with VMware DRS enabled and standalone hosts
// (ESX Server 3) support the creation of ResourcePool hierarchies.
//
//
//
type ComputeResource struct {
	*ManagedEntity

	configurationEx *ComputeResourceConfigInfo

	datastore []*Datastore

	environmentBrowser *EnvironmentBrowser

	host []*HostSystem

	network []*Network

	resourcePool *ResourcePool

	summary *ComputeResourceSummary
}

// Configuration of the compute resource; applies to both standalone hosts
// and clusters. For a cluster this property will return a
// ClusterConfigInfoEx object.
//
// Since VI API 2.5
func (mo *ComputeResource) ConfigurationEx() (*ComputeResourceConfigInfo, error) {
	t, err := mo.currentProperty("configurationEx")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ComputeResourceConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ComputeResourceConfigInfo")
	}
	return v, nil
}

// The datastore property is the subset of datastore objects in the datacenter
// available in this ComputeResource.
//
// This property is computed as the aggregate set of datastores available from all
// the hosts that are part of this compute resource.
// Required Privilege: System.View
func (mo *ComputeResource) Datastore() ([]*Datastore, error) {
	t, err := mo.currentProperty("datastore")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Datastore)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Datastore")
	}
	return v, nil
}

// The environment browser object that identifies the environments that are supported
// on this compute resource.
// Required Privilege: System.View
func (mo *ComputeResource) EnvironmentBrowser() (*EnvironmentBrowser, error) {
	t, err := mo.currentProperty("environmentBrowser")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*EnvironmentBrowser)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *EnvironmentBrowser")
	}
	return v, nil
}

// List of hosts that are part of this compute resource. If the compute resource is a
// standalone type, then this list contains just one element.
// Required Privilege: System.View
func (mo *ComputeResource) Host() ([]*HostSystem, error) {
	t, err := mo.currentProperty("host")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*HostSystem)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*HostSystem")
	}
	return v, nil
}

// The subset of network objects available in the datacenter that is available in
// this ComputeResource.
//
// This property is computed as the aggregate set of networks available from all the
// hosts that are part of this compute resource.
// Required Privilege: System.View
func (mo *ComputeResource) Network() ([]*Network, error) {
	t, err := mo.currentProperty("network")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Network)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Network")
	}
	return v, nil
}

// Reference to root resource pool.
// Required Privilege: System.View
func (mo *ComputeResource) ResourcePool() (*ResourcePool, error) {
	t, err := mo.currentProperty("resourcePool")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ResourcePool)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ResourcePool")
	}
	return v, nil
}

// Basic runtime information about a compute resource. This information is used on
// summary screens and in list views.
func (mo *ComputeResource) Summary() (*ComputeResourceSummary, error) {
	t, err := mo.currentProperty("summary")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ComputeResourceSummary)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ComputeResourceSummary")
	}
	return v, nil
}

//
// Change the compute resource configuration.
//
// Required Privileges
// Host.Inventory.EditCluster
// Since
// VI API 2.5
//
func (mo *ComputeResource) ReconfigureComputeResource_Task(
	_this *ManagedObjectReference, spec *ComputeResourceConfigSpec, modify bool,
) (*Task, error) {

	return nil, nil

}

//
// Configuration of the compute resource; applies to both standalone hosts
// and clusters.
//
//
type ComputeResourceConfigInfo struct {
	*DynamicData

	// Key for Default Hardware Version used on this compute resource
	// in the format of key.
	//
	// This field affects
	// defaultConfigOption returned
	// by environmentBrowser of this object and all its children
	// with this field unset.
	//
	// Since vSphere API 5.1
	DefaultHardwareVersionKey string

	// Flag indicating whether or not the SPBM(Storage Policy Based Management)
	// feature is enabled on this compute resource
	//
	// Since vSphere API 5.0
	SpbmEnabled bool

	// Swapfile placement policy for virtual machines within this compute
	// resource. Any policy except for "inherit" is a valid value for this
	// property; the default is "vmDirectory". This setting will be honored
	// for each virtual machine within the compute resource for which the
	// following is true:
	//
	// The virtual machine is executing on a host that has the
	// perVmSwapFiles capability.
	// The virtual machine configuration's
	// swapPlacement property is set
	// to "inherit".
	// See VirtualMachineConfigInfoSwapPlacementType
	VmSwapPlacement string
}

//
// Changes to apply to the compute resource configuration.
//
//
type ComputeResourceConfigSpec struct {
	*DynamicData

	// Key for Default Hardware Version to be used on this compute resource
	// in the format of key.
	//
	// Setting this field affects
	// defaultConfigOption returned
	// by environmentBrowser of this object and all its children
	// with this field unset.
	//
	// Since vSphere API 5.1
	DefaultHardwareVersionKey string

	// Flag indicating whether or not the SPBM(Storage Policy Based Management)
	// feature is enabled on this compute resource
	//
	// Since vSphere API 5.0
	SpbmEnabled bool

	// New setting for the swapfile placement policy. Any change to this
	// policy will affect virtual machines that subsequently power on or
	// resume from a suspended state in this compute resource, or that
	// migrate to a host in this compute resource while powered on; virtual
	// machines that are currently powered on in this compute resource will
	// not yet be affected.See VirtualMachineConfigInfoSwapPlacementType
	VmSwapPlacement string
}

//
// The event argument is a ComputeResource object.
//
//
type ComputeResourceEventArgument struct {
	*EntityEventArgument

	// The ComputeResource object.
	ComputeResource *ComputeResource
}

//
// The ComputeResourceHostSPBMLicenseInfo data object
// encapsulates the SPBM(Storage Policy Based Management) license
// information for a host.
//
//
type ComputeResourceHostSPBMLicenseInfo struct {
	*DynamicData

	Host *HostSystem

	LicenseState *enum.ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState
}

//
// The SPBM(Storage Policy Based Management) license state for a host
//
//
type ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState struct {
}

//
// This data object type encapsulates a typical set of ComputeResource information
// that is useful for list views and summary pages.
//
//
type ComputeResourceSummary struct {
	*DynamicData

	// Effective CPU resources (in MHz) available to run virtual machines. This is the
	// aggregated effective resource level from all running hosts. Hosts that are in
	// maintenance mode or are unresponsive are not counted. Resources used by the
	// VMware Service Console are not included in the aggregate. This value represents
	// the amount of resources available for the root resource pool for running
	// virtual machines.
	EffectiveCpu int32

	// Effective memory resources (in MB) available to run virtual machines.
	// This is the aggregated effective resource level from all running hosts. Hosts
	// that are in maintenance mode or are unresponsive are not counted.
	// Resources used by the VMware Service Console are not included in the aggregate.
	// This value represents the amount of resources available for the root
	// resource pool for running virtual machines.
	EffectiveMemory int64

	// Number of physical CPU cores. Physical CPU cores are the processors contained
	// by a CPU package.
	NumCpuCores int16

	// Aggregated number of CPU threads.
	NumCpuThreads int16

	// Total number of effective hosts.
	NumEffectiveHosts int32

	// Total number of hosts.
	NumHosts int32

	// Overall alarm status.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	OverallStatus *enum.ManagedEntityStatus

	// Aggregated CPU resources of all hosts, in MHz.
	TotalCpu int32

	// Aggregated memory resources of all hosts, in bytes.
	TotalMemory int64
}

//
// A ConcurrentAccess fault is thrown when an operation
// fails because another operation has modified the
// datastructure.
//
// For non-transactional operations, such as a recursive
// delete of a subtree of the inventory, the operation might
// fail with ConcurrentAccess if another thread has added
// a new entity to the hierarchy.
//
//
//
type ConcurrentAccess struct {
	*VimFault
}

//
// Config spec operation type.
//
//
type ConfigSpecOperation struct {
}

//
// The ConfigTarget class contains information about "physical" devices that can
// be used to back virtual devices.
//
//
type ConfigTarget struct {
	*DynamicData

	// Information whether a virtual machine with this ConfigTarget can auto vmotion.
	// This field is only populated from an Environment browser obtained from a
	// virtual machine.
	AutoVmotion bool

	// List of CD-ROM devices available for use by virtual CD-ROMs.
	// Used for
	// VirtualCdromAtapiBackingInfo.
	CdRom []*VirtualMachineCdromInfo

	// List of datastores available for virtual disks and associated storage.
	Datastore []*VirtualMachineDatastoreInfo

	// List of networks available from DistributedVirtualSwitch for virtual
	// network adapters.
	//
	// Since vSphere API 4.0
	DistributedVirtualPortgroup []*DistributedVirtualPortgroupInfo

	// List of distributed virtual switch available for virtual network
	// adapters.
	//
	// Since vSphere API 4.0
	DistributedVirtualSwitch []*DistributedVirtualSwitchInfo

	// List of floppy devices available for use by virtual floppies.
	// Used for
	// VirtualFloppyDeviceBackingInfo.
	Floppy []*VirtualMachineFloppyInfo

	// List of physical IDE disks that can be used as targets for raw disk backings.
	IdeDisk []*VirtualMachineIdeDiskDeviceInfo

	// Legacy switch names when using the LegacyNetworkBacking types.
	LegacyNetworkInfo []*VirtualMachineLegacyNetworkSwitchInfo

	// Maximum recommended memory size, in MB, for creating a new virtual machine.
	MaxMemMBOptimalPerf int32

	// List of networks available for virtual network adapters.
	Network []*VirtualMachineNetworkInfo

	// Number of physical CPU cores that are available to run virtual machines.
	NumCpuCores int32

	// Number of logical CPUs that can be used to run virtual machines.
	NumCpus int32

	// Number of NUMA nodes.
	NumNumaNodes int32

	// List of opaque networks available for virtual network adapters.
	//
	// Since vSphere API 5.5
	OpaqueNetwork []*OpaqueNetworkTargetInfo

	// List of parallel devices available to support virtualization.
	// Used for
	// VirtualParallelPortDeviceBackingInfo.
	Parallel []*VirtualMachineParallelInfo

	// List of generic PCI devices.
	//
	// Since vSphere API 4.0
	PciPassthrough []*VirtualMachinePciPassthroughInfo

	// Information about the current available resources on the current resource pool
	// for a virtual machine. This field is only populated from an Environment browser
	// obtained from a virtual machine.
	ResourcePool *ResourcePoolRuntimeInfo

	// List of physical SCSI disks that can be used as targets for raw disk mapping
	// backings.
	ScsiDisk []*VirtualMachineScsiDiskDeviceInfo

	// List of generic SCSI devices.
	ScsiPassthrough []*VirtualMachineScsiPassthroughInfo

	// List of serial devices available to support virtualization.
	// Used for
	// VirtualSerialPortDeviceBackingInfo.
	Serial []*VirtualMachineSerialInfo

	// Presence of System Management Controller, indicates the host is
	// Apple hardware, and thus capable of running Mac OS guest as VM.
	//
	// Since vSphere API 5.0
	SmcPresent bool

	// List of sound devices available to support virtualization.
	// Used for
	// VirtualSoundCardDeviceBackingInfo.
	//
	// Since VI API 2.5
	Sound []*VirtualMachineSoundInfo

	// List of SRIOV devices.
	//
	// Since vSphere API 5.5
	Sriov []*VirtualMachineSriovInfo

	// List of USB devices on the host that are available to support
	// virtualization.
	// Used for
	// VirtualUSBUSBBackingInfo.
	//
	// Since VI API 2.5
	Usb []*VirtualMachineUsbInfo

	// List of vFlash modules.
	//
	// Since vSphere API 5.5
	VFlashModule []*VirtualMachineVFlashModuleInfo
}

//
// Thrown if the configurations of the objects are in conflict.
//
//
type ConflictingConfiguration struct {
	*DvsFault

	// The configurations that are in conflict.
	ConfigInConflict []*ConflictingConfigurationConfig
}

//
// This class defines the configuration that is in conflict.
//
//
type ConflictingConfigurationConfig struct {
	*DynamicData

	// The entity on which the configuration is in conflict.
	Entity *ManagedEntity

	// The property paths that are in conflict.
	PropertyPath string
}

//
// ConflictingDatastoreFound is thrown when the conflicting datastores
// with the same url but backed by different disks are found in the host
// and the target datacenter.
//
//
type ConflictingDatastoreFound struct {
	*RuntimeFault

	// The name of the datastore.
	Name string

	// The unique locator for the datastore.
	Url string
}

type ConnectedIso struct {
	*OvfExport

	// The CD-ROM drive that caused the event.
	Cdrom *VirtualCdrom

	// The filename of the ISO
	Filename string
}

//
// The ContainerView managed object provides a means of monitoring the contents of
// a single container and, optionally, other containers.
// You can use a ContainerView with a PropertyCollector method
// to retrieve data or receive notification of changes. For information about using views
// with the PropertyCollector, see the description of ViewManager.
//
// When you invoke the CreateContainerView method, you specify
// a managed object instance that provides the starting point for object selection.
// You can use the following managed objects as the basis of a container view:
//
//
//
// •  Folder
//
// •  Datacenter
//
// •  ComputeResource
//
// •  ResourcePool
//
// •  HostSystem
//
//
//
//
// Once you have created the view, the view list
// always represents the current configuration of the virtual environment and reflects
// any subsequent changes that occur.
//
//
//
type ContainerView struct {
	*ManagedObject
	*ManagedObjectView

	container *ManagedEntity

	recursive bool

	type_ []string
}

// The Folder, Datacenter, ComputeResource, ResourcePool, or HostSystem instance
// that provides the objects that the view presents.
func (mo *ContainerView) Container() (*ManagedEntity, error) {
	t, err := mo.currentProperty("container")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ManagedEntity)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ManagedEntity")
	}
	return v, nil
}

// Whether to include only the immediate children of the container instance,
// or to include additional objects by following the paths beyond the
// immediate children.
//
// For information about recursive behavior, see the description of
// CreateContainerView.
func (mo *ContainerView) Recursive() (bool, error) {
	t, err := mo.currentProperty("recursive")
	if err != nil {
		return false, err
	}

	v, ok := t.(bool)
	if !ok {
		return false, errors.New("Unable to make type assertion to: bool")
	}
	return v, nil
}

// An optional list of types to be applied to the set of objects in the view.
// The list of types indicates objects that are included in the view.
// If empty, all types are included.
func (mo *ContainerView) Type() ([]string, error) {
	t, err := mo.currentProperty("type")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]string)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []string")
	}
	return v, nil
}

// Deprecated.
// As of VI API 2.5, use CpuIncompatible and its other subclasses,
// not this one.
//
//
// Compatibility between the virtual machine's host and its CPU
// feature requirements cannot be determined, because not enough information
// is available about the CPU features of the host.
//
//
type CpuCompatibilityUnknown struct {
	*CpuIncompatible
}

//
// Thrown when virtual CPUs cannot be hot-added or hot-removed from
// the virtual machine.
//
//
type CpuHotPlugNotSupported struct {
	*VmConfigFault
}

//
// The host is not compatible with the CPU feature requirements of the
// virtual machine, for a particular CPUID register. A subclass of this fault
// may be used to express the incompatibilities in a more easily
// understandable format.
//
//
type CpuIncompatible struct {
	*VirtualHardwareCompatibilityIssue

	// The desired values for the register's bits.  The 'x' character indicates
	// don't-care.
	//
	// Since VI API 2.5
	DesiredBits string

	// The host that is not compatible with the requirements.
	//
	// Since VI API 2.5
	Host *HostSystem

	// The CpuIdInfo level where a problem was detected. Other levels may
	// also have problems.
	Level int32

	// The contents of the register on the target host, in CpuIdInfo register
	// format.  The '-' character indicates an unknown value.
	//
	// Since VI API 2.5
	RegisterBits string

	// The CpuIdInfo register where a problem was detected. Other registers
	// may also have problems. Possible register names are eax, ebx, ecx, or edx.
	RegisterName string
}

//
// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 1 register ecx.
//
//
type CpuIncompatible1ECX struct {
	*CpuIncompatible

	// Flag to indicate bit 25 is incompatible.
	//
	// Since vSphere API 5.0
	Aes bool

	// Flag to indicate that bits other than 0/1/9/19/20/25 are incompatible.
	// I.e. the detected incompatibilities cannot be completely described by
	// the sse3, pclmulqdq, ssse3, sse41, sse42, and/or aes flags.
	Other bool

	// Flag to indicate that the sse3, pclmulqdq, ssse3, sse41, sse42, and aes
	// flags are all false, and the "other" flag is true. Purely a convenience
	// property for the client processing this fault.
	OtherOnly bool

	// Flag to indicate bit 1 is incompatible.
	//
	// Since vSphere API 5.0
	Pclmulqdq bool

	// Flag to indicate bit 0 is incompatible.
	Sse3 bool

	// Flag to indicate bit 19 is incompatible.
	Sse41 bool

	// Flag to indicate bit 20 is incompatible.
	Sse42 bool

	// Flag to indicate bit 9 is incompatible.
	Ssse3 bool
}

//
// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 0x80000001 register edx.
//
//
type CpuIncompatible81EDX struct {
	*CpuIncompatible

	// Flag to indicate bit 25 is incompatible.
	Ffxsr bool

	// Flag to indicate bit 29 is incompatible.
	Lm bool

	// Flag to indicate bit 20 is incompatible.
	Nx bool

	// Flag to indicate that bits other than 20/25/27/29 are incompatible.
	// I.e. the detected incompatibilities cannot be completely described by
	// the nx, ffxsr, rdtscp, and/or lm flags.
	Other bool

	// Flag to indicate that the nx, ffxsr, rdtscp, and lm flags are all false,
	// and the "other" flag is true. Purely a convenience property for the
	// client processing this fault.
	OtherOnly bool

	// Flag to indicate bit 27 is incompatible.
	Rdtscp bool
}

//
// This data object type specifies the type of task to be created
// when this action is triggered.
//
//
type CreateTaskAction struct {
	*Action

	// Whether the task should be cancelable.
	Cancelable bool

	// Extension registered task type identifier
	// for type of task being created.
	TaskTypeId string
}

//
// Describes a custom field.
//
//
type CustomFieldDef struct {
	*DynamicData

	// The set of privileges to apply on this field definition
	//
	// Since VI API 2.5
	FieldDefPrivileges *PrivilegePolicyDef

	// The set of privileges to apply on instances of this field
	//
	// Since VI API 2.5
	FieldInstancePrivileges *PrivilegePolicyDef

	// A unique ID used to reference this custom field in assignments. This
	// ID is unique for the lifetime of the field (even across
	// rename operations).
	Key int32

	// Type of object for which the field is valid. If not specified,
	// the field is valid for all managed objects.
	//
	// Since VI API 2.5
	ManagedObjectType string

	// Name of the field.
	Name string

	// Type of the field.
	Type string
}

//
// This event records the addition of a custom field definition.
//
//
type CustomFieldDefAddedEvent struct {
	*CustomFieldDefEvent
}

//
// This event records a custom field definition event.
//
//
type CustomFieldDefEvent struct {
	*CustomFieldEvent

	// The unique identifier of the custom field definition.
	FieldKey int32

	// The name of the custom field.
	Name string
}

//
// This event records the removal of a custom field definition.
//
//
type CustomFieldDefRemovedEvent struct {
	*CustomFieldDefEvent
}

//
// This event records the renaming of a custom field definition.
//
//
type CustomFieldDefRenamedEvent struct {
	*CustomFieldDefEvent

	NewName string
}

//
// These are custom field events.
//
//
type CustomFieldEvent struct {
	*Event
}

//
// Subtype for string values (currently the only supported type).
//
//
type CustomFieldStringValue struct {
	*CustomFieldValue

	// Value assigned to the custom field.
	Value string
}

//
// Base type for storing values.
//
//
type CustomFieldValue struct {
	*DynamicData

	// The ID of the field to which this value belongs.
	Key int32
}

//
// This event records a change to a custom field value for a particular entity.
//
//
type CustomFieldValueChangedEvent struct {
	*CustomFieldEvent

	// The entity on which the field value was changed.
	Entity *ManagedEntityEventArgument

	// The custom field whose value was changed for the entity.
	FieldKey int32

	// The name of the custom field at the time the value was changed.
	Name string

	// The new value that was set.
	Value string
}

//
// The CustomFieldsManager object is used to add and remove custom fields
// to managed entities.
//
// The custom fields values set on managed entities are available through the
// customValue property and through the summary objects
// for VirtualMachine and HostSystem. They are not available
// directly through this managed object.
//
//
// This functionality is only available through VirtualCenter.
//
//
//
type CustomFieldsManager struct {
	*ManagedObject

	field []*CustomFieldDef
}

// List of custom fields defined on this server. The fields are
// sorted by name.
// Required Privilege: System.View
func (mo *CustomFieldsManager) Field() ([]*CustomFieldDef, error) {
	t, err := mo.currentProperty("field")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*CustomFieldDef)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*CustomFieldDef")
	}
	return v, nil
}

//
// Creates a new custom field. If the moType is specified, the
// field will only be available for that type of managed object.
//
// Required Privileges
// Global.ManageCustomFields
//
func (mo *CustomFieldsManager) AddCustomFieldDef(
	_this *ManagedObjectReference, name string, moType string, fieldDefPolicy *PrivilegePolicyDef, fieldPolicy *PrivilegePolicyDef,
) (*CustomFieldDef, error) {

	return nil, nil

}

//
// Removes a custom field. This also removes all values assigned
// to this custom field.
//
// Required Privileges
// Global.ManageCustomFields
//
func (mo *CustomFieldsManager) RemoveCustomFieldDef(
	_this *ManagedObjectReference, key int32,
) error {

	return nil

}

//
// Renames a custom field.
//
// Required Privileges
// Global.ManageCustomFields
//
func (mo *CustomFieldsManager) RenameCustomFieldDef(
	_this *ManagedObjectReference, key int32, name string,
) error {

	return nil

}

//
// Assigns a value to a custom field on an entity.
//
// Required Privileges
// None
//
func (mo *CustomFieldsManager) SetField(
	_this *ManagedObjectReference, entity *ManagedEntity, key int32, value string,
) error {

	return nil

}

//
// Data object type to associate a virtual network adapter with its IP settings.
//
//
type CustomizationAdapterMapping struct {
	*DynamicData

	// The IP settings for the associated virtual network adapter.
	Adapter *CustomizationIPSettings

	// The MAC address of a network adapter being customized. The client cannot change
	// this value because the guest operating system has no control over the MAC
	// address of a virtual network adapter.
	//
	// This property is optional. If it is not included, the customization process maps
	// the settings from the list of AdapterMappings.IPSettings in the
	// Specification.nicSettingMap to the virtual machine's network adapters, in PCI
	// slot order. The first virtual network adapter on the PCI bus is assigned
	// nicSettingMap[0].IPSettings, the second adapter is assigned
	// nicSettingMap[1].IPSettings, and so on.
	MacAddress string
}

//
// Use automatic address configuration to generate linklocal ipv6 addresses
//
//
type CustomizationAutoIpV6Generator struct {
	*CustomizationIpV6Generator
}

//
// Use a command-line program configured with the VirtualCenter server.
//
//
type CustomizationCustomIpGenerator struct {
	*CustomizationIpGenerator

	// An optional argument that is passed to the utility for this IP address. The
	// meaning of this field is user-defined, in the script.
	Argument string
}

//
// Use a command-line program configured with the VirtualCenter server.
//
//
type CustomizationCustomIpV6Generator struct {
	*CustomizationIpV6Generator

	// An optional argument that is passed to the utility for this ipv6 address. The
	// meaning of this field is user-defined, in the script.
	Argument string
}

//
// Specifies that the VirtualCenter server will launch an external application to
// generate the (hostname/IP). The command line for this application must be specified
// in the server configuration file (vpxd.cfg) in the vpxd/name-ip-generator key.
//
//
type CustomizationCustomName struct {
	*CustomizationName

	// An optional argument that is passed to the utility for this IP address. The
	// meaning of this field is user-defined in the script.
	Argument string
}

//
// Use a DHCP server to configure the virtual network adapter.
//
//
type CustomizationDhcpIpGenerator struct {
	*CustomizationIpGenerator
}

//
// Use a DHCP server to configure ipv6 address
//
//
type CustomizationDhcpIpV6Generator struct {
	*CustomizationIpV6Generator
}

//
// Base for customization events.
//
//
type CustomizationEvent struct {
	*VmEvent

	// The location of the in-guest customization log which will contain
	// details of the customization operation.
	LogLocation string
}

//
// The customization sequence in the guest failed.
//
//
type CustomizationFailed struct {
	*CustomizationEvent
}

//
// Base for exceptions that can be thrown from the customizer.
//
//
type CustomizationFault struct {
	*VimFault
}

//
// Use a static IP Address for the virtual network adapter.
//
//
type CustomizationFixedIp struct {
	*CustomizationIpGenerator

	IpAddress string
}

//
// Use a static ipv6 address for the virtual network adapter
//
//
type CustomizationFixedIpV6 struct {
	*CustomizationIpV6Generator

	IpAddress string

	SubnetMask int32
}

//
// A fixed name.
//
//
type CustomizationFixedName struct {
	*CustomizationName

	// The virtual machine name specified by the client.
	Name string
}

//
// A collection of global IP settings for a virtual network adapter. In Linux, DNS
// server settings are global. The settings can either be statically set or supplied
// by a DHCP server.
//
//
type CustomizationGlobalIPSettings struct {
	*DynamicData

	// List of DNS servers, for a virtual network adapter with a static IP address. If
	// this list is empty, then the guest operating system is expected to use a DHCP
	// server to get its DNS server settings. These settings configure the virtual
	// machine to use the specified DNS servers. These DNS server settings are listed
	// in order of preference.
	DnsServerList []string

	// List of name resolution suffixes for the virtual network adapter. This list
	// applies to both Windows and Linux guest customization. For Linux, this setting
	// is global, whereas in Windows, this setting is listed on a per-adapter basis,
	// even though the setting is global in Windows.
	DnsSuffixList []string
}

//
// The commands listed in the GuiRunOnce data object type are executed when a user
// logs on the first time after customization completes. The logon may be driven by
// the AutoLogon setting.
//
// The GuiRunOnce data object type maps to the GuiRunOnce key in the
// sysprep.inf answer file. These values are transferred into the
// sysprep.inf file that VirtualCenter stores on the target virtual disk. For
// more detailed information, see the document Windows 2000 Unattended Setup Guide.
//
//
//
type CustomizationGuiRunOnce struct {
	*DynamicData

	// A list of commands to run at first user logon, after guest customization.
	CommandList []string
}

//
// The GuiUnattended type maps to the GuiUnattended key in the sysprep.inf
// answer file. These values are plugged directly into the sysprep.inf file
// that VirtualCenter stores on the target virtual disk. For more detailed
// information, see the document Windows 2000 Unattended Setup Guide.
//
//
type CustomizationGuiUnattended struct {
	*DynamicData

	// Flag to determine whether or not the machine automatically logs on as
	// Administrator.  See also the password property.
	AutoLogon bool

	// If the AutoLogon flag is set, then the AutoLogonCount property specifies the
	// number of times the machine should automatically log on as Administrator.
	// Generally it should be 1, but if your setup requires a number of reboots, you
	// may want to increase it. This number may be determined by the list of commands
	// executed by the GuiRunOnce command.
	AutoLogonCount int32

	// The new administrator password for the machine. To specify that the password
	// should be set to blank (that is, no password), set the password value to NULL.
	// Because of encryption, "" is NOT a valid value.
	//
	// If the XML file is generated by the VirtualCenter Customization Wizard, then the
	// password is encrypted. Otherwise, the client should set the plainText attribute
	// to true, so that the customization process does not attempt to decrypt the
	// string.
	Password *CustomizationPassword

	// The time zone for the new virtual machine. Numbers correspond to time zones
	// listed in sysprep documentation at  in Microsoft Technet.
	TimeZone int32
}

//
// IP settings for a virtual network adapter.
//
//
type CustomizationIPSettings struct {
	*DynamicData

	// A DNS domain suffix such as vmware.com.
	DnsDomain string

	// A list of server IP addresses to use for DNS lookup in a Windows guest operating
	// system. In Windows, these settings are adapter-specific, whereas in Linux, they
	// are global. As a result, the Linux guest customization process ignores this
	// setting and looks for its DNS servers in the globalIPSettings object.
	//
	// Specify these servers in order of preference. If this list is not empty, and if
	// a DHCP IpGenerator is used, then these settings override the DHCP settings.
	DnsServerList []string

	// For a virtual network adapter with a static IP address, this data object type
	// contains a list of gateways, in order of preference.
	Gateway []string

	// Specification to obtain a unique IP address for this virtual network adapter.
	Ip *CustomizationIpGenerator

	// This contains the IpGenerator, subnet mask and gateway info for all
	// the ipv6 addresses associated with the virtual network adapter.
	//
	// Since vSphere API 4.0
	IpV6Spec *CustomizationIPSettingsIpV6AddressSpec

	// NetBIOS setting for Windows.
	NetBIOS *enum.CustomizationNetBIOSMode

	// The IP address of the primary WINS server. This property is ignored for Linux
	// guest operating systems.
	PrimaryWINS string

	// The IP address of the secondary WINS server. This property is ignored for Linux
	// guest operating systems.
	SecondaryWINS string

	// Subnet mask for this virtual network adapter.
	SubnetMask string
}

//
// IPv6 settings
//
//
type CustomizationIPSettingsIpV6AddressSpec struct {
	*DynamicData

	// gateways
	Gateway []string

	// ipv6 address generators
	Ip []*CustomizationIpV6Generator
}

//
// The Identification data object type provides information needed to join a workgroup
// or domain.
//
// The Identification data object type maps to the Identification key in the
// sysprep.inf answer file. These values are transferred into the
// sysprep.inf file that VirtualCenter stores on the target virtual disk. For
// more detailed information, see the document Windows 2000 Unattended Setup Guide.
//
//
//
type CustomizationIdentification struct {
	*DynamicData

	// This is the domain user account used for authentication if the virtual machine
	// is joining a domain. The user does not need to be a domain administrator, but
	// the account must have the privileges required to add computers to the domain.
	DomainAdmin string

	// This is the password for the domain user account used for authentication if the
	// virtual machine is joining a domain.
	DomainAdminPassword *CustomizationPassword

	// The domain that the virtual machine should join. If this value is supplied, then
	// domainAdmin and domainAdminPassword must also be supplied, and the workgroup
	// name must be empty.
	JoinDomain string

	// The workgroup that the virtual machine should join. If this value is supplied,
	// then the domain name and authentication fields must be empty.
	JoinWorkgroup string
}

//
// Base type for sysprep, sysprepText, or linuxPrep object type.
//
//
type CustomizationIdentitySettings struct {
	*DynamicData
}

//
// Base type for the various IP specification possibilities.
//
//
type CustomizationIpGenerator struct {
	*DynamicData
}

//
// Base type for the various IpV6 specification possibilities
//
//
type CustomizationIpV6Generator struct {
	*DynamicData
}

//
// Enumeration of AutoMode values.
//
//
type CustomizationLicenseDataMode struct {
}

//
// The LicenseFilePrintData type maps directly to the LicenseFilePrintData key in the
// sysprep.inf answer file. These values are transferred into the
// sysprep.inf file that VirtualCenter stores on the target virtual disk. For
// more detailed information, see the document Windows 2000 Unattended Setup Guide.
//
// LicenseFilePrintData provides licensing information for Windows server operating
// systems.
//
//
type CustomizationLicenseFilePrintData struct {
	*DynamicData

	// Server licensing mode
	AutoMode *enum.CustomizationLicenseDataMode

	// This key is valid only if AutoMode = PerServer. The integer value indicates the
	// number of client licenses purchased for the VirtualCenter server being
	// installed.
	AutoUsers int32
}

//
// Failed to set Linux identity.
//
//
type CustomizationLinuxIdentityFailed struct {
	*CustomizationFailed
}

//
// Base object type for optional operations supported by the customization process for
// Linux.
//
//
type CustomizationLinuxOptions struct {
	*CustomizationOptions
}

//
// This is the Linux counterpart to the Windows Sysprep object. LinuxPrep contains
// machine-wide settings that identify a Linux machine in the same way that the
// Sysprep type identifies a Windows machine.
//
//
type CustomizationLinuxPrep struct {
	*CustomizationIdentitySettings

	// The fully qualified domain name.
	Domain string

	// The network host name of the (Linux) virtual machine.
	HostName *CustomizationName

	// Specifies whether the hardware clock is in UTC or local time.
	//
	// True when the hardware clock is in UTC.
	// False when the hardware clock is in local time.
	//
	//
	// Since vSphere API 4.0
	HwClockUTC bool

	// The case-sensitive timezone, such as Europe/Sofia.
	//
	// Valid timeZone values are based on the tz (timezone)
	// database used by Linux and other Unix systems.
	// The values are strings (xsd:string) in the form "Area/Location," in which
	// Area is a continent or ocean name, and Location is the city, island, or
	// other regional designation.
	//
	// Since vSphere API 4.0
	TimeZone string
}

//
// A base object type for a virtual machine name that can be either fixed or
// auto-generated.
//
//
type CustomizationName struct {
	*DynamicData
}

//
// NetBIOS setting for Windows.
//
//
type CustomizationNetBIOSMode struct {
}

//
// Network setup failed in the guest during customization.
//
//
type CustomizationNetworkSetupFailed struct {
	*CustomizationFailed
}

//
// Base object type for optional operations supported by the customization process.
//
//
type CustomizationOptions struct {
	*DynamicData
}

//
// Contains a password string and a flag that specifies whether the string is in plain
// text or encrypted.
//
//
type CustomizationPassword struct {
	*DynamicData

	// Flag to specify whether or not the password is in plain text, rather than
	// encrypted.
	PlainText bool

	// The password string. It is encrypted if the associated plainText flag is false.
	Value string
}

//
// A customization operation is already pending on this virtual
// machine and is awaiting power-up to complete.
//
//
type CustomizationPending struct {
	*CustomizationFault
}

//
// Specifies that a unique name should be generated by concatenating the base string
// with a number.
//
// Virtual machine names are unique across the set of hosts and virtual machines known
// to the VirtualCenter instance. VirtualCenter tracks the network names of virtual
// machines as well as hosts. VMware Tools runs in a guest operating system and
// reports information to VirtualCenter, including the network name of the guest.
//
//
//
type CustomizationPrefixName struct {
	*CustomizationName

	// Base prefix, to which a unique number is appended.
	Base string
}

//
// The Specification data object type contains information required to customize a
// virtual machine when deploying it or migrating it to a new  host.
//
//
type CustomizationSpec struct {
	*DynamicData

	// Byte array containing the public key used to encrypt any passwords stored in the
	// specification. Both the client and the server can use this to determine if
	// stored passwords can be decrypted by the server or if the passwords need to be
	// re-entered and re-encrypted before the specification can be used.
	EncryptionKey []int8

	// Global IP settings constitute the IP settings that are not specific to a
	// particular virtual network adapter.
	GlobalIPSettings *CustomizationGlobalIPSettings

	// Network identity and settings, similar to Microsoft's Sysprep tool. This is a
	// Sysprep, LinuxPrep, or SysprepText object.
	Identity *CustomizationIdentitySettings

	// IP settings that are specific to a particular virtual network adapter. The
	// AdapterMapping object maps a network adapter's MAC address to its Adapter
	// settings object. May be empty if there are no network adapters, else should
	// match number of network adapters in the VM.
	NicSettingMap []*CustomizationAdapterMapping

	// Optional operations (either LinuxOptions or WinOptions).
	Options *CustomizationOptions
}

//
// Information about a specification.
//
//
type CustomizationSpecInfo struct {
	*DynamicData

	// The changeVersion is a unique identifier for a given version
	// of the configuration. Each change to the configuration will
	// update this value. This is typically implemented as an ever
	// increasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	//
	// If specified when updating a specification, the changes will only be
	// applied if the current changeVersion matches the specified changeVersion. This
	// field can be used to guard against updates that has happened
	// between the configInfo was read and until it is applied.
	ChangeVersion string

	// Description of the specification.
	Description string

	// Time when the specification was last modified. This time is ignored when
	// the CustomizationSpecItem containing this is used as an input to
	// CustomizationSpecManager.create.
	LastUpdateTime time.Time

	// Unique name of the specification.
	Name string

	// Guest operating system for this specification (Linux or Windows).
	Type string
}

//
// Specification information and the Specification object.
//
//
type CustomizationSpecItem struct {
	*DynamicData

	// Information about the specification - name, description, and so on.
	Info *CustomizationSpecInfo

	// The customization specification.
	Spec *CustomizationSpec
}

//
// The CustomizationSpecManager managed object is used to manage
// customization specifications stored on the VirtualCenter server.
//
type CustomizationSpecManager struct {
	*ManagedObject

	encryptionKey []int8

	info []*CustomizationSpecInfo
}

// Gets a binary public encryption key that can be used to encrypt
// passwords in stored specifications.
// Required Privilege: System.View
func (mo *CustomizationSpecManager) EncryptionKey() ([]int8, error) {
	t, err := mo.currentProperty("encryptionKey")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]int8)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []int8")
	}
	return v, nil
}

// Gets a list of information on available specifications.
// Required Privilege: VirtualMachine.Provisioning.ReadCustSpecs
func (mo *CustomizationSpecManager) Info() ([]*CustomizationSpecInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*CustomizationSpecInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*CustomizationSpecInfo")
	}
	return v, nil
}

//
// Validate that required resources are available on the server to customize a
// particular guest operating system. These would include sysprep for Windows
// and the debugfs and changefs volume editors for Linux guests.
//
// Required Privileges
// System.View
//
func (mo *CustomizationSpecManager) CheckCustomizationResources(
	_this *ManagedObjectReference, guestOs string,
) error {

	return nil

}

//
// Creates a new specification.
//
// Required Privileges
// VirtualMachine.Provisioning.ModifyCustSpecs
//
func (mo *CustomizationSpecManager) CreateCustomizationSpec(
	_this *ManagedObjectReference, item *CustomizationSpecItem,
) error {

	return nil

}

//
// Converts a specification item to XML text
//
// Required Privileges
// System.View
//
func (mo *CustomizationSpecManager) CustomizationSpecItemToXml(
	_this *ManagedObjectReference, item *CustomizationSpecItem,
) (string, error) {

	return "", nil

}

//
// Deletes a specification.
//
// Required Privileges
// VirtualMachine.Provisioning.ModifyCustSpecs
//
func (mo *CustomizationSpecManager) DeleteCustomizationSpec(
	_this *ManagedObjectReference, name string,
) error {

	return nil

}

//
// Whether or not a specification exists.
//
// Required Privileges
// VirtualMachine.Provisioning.ReadCustSpecs
//
func (mo *CustomizationSpecManager) DoesCustomizationSpecExist(
	_this *ManagedObjectReference, name string,
) (bool, error) {

	return false, nil

}

//
// Duplicates a specification.
//
// Required Privileges
// VirtualMachine.Provisioning.ModifyCustSpecs
//
func (mo *CustomizationSpecManager) DuplicateCustomizationSpec(
	_this *ManagedObjectReference, name string, newName string,
) error {

	return nil

}

//
// Obtains a specification for the given name.
//
// Required Privileges
// VirtualMachine.Provisioning.ReadCustSpecs
//
func (mo *CustomizationSpecManager) GetCustomizationSpec(
	_this *ManagedObjectReference, name string,
) (*CustomizationSpecItem, error) {

	return nil, nil

}

//
// Overwrites an existing specification, possibly after retrieving
// (by using 'get') and editing it. If, based on the item's changeVersion
// value, the overwrite process detects that the specification has changed
// since its retrieval, then the API uses the SpecModified exception to
// warn the client that he might overwrite another client's change.
//
// Required Privileges
// VirtualMachine.Provisioning.ModifyCustSpecs
//
func (mo *CustomizationSpecManager) OverwriteCustomizationSpec(
	_this *ManagedObjectReference, item *CustomizationSpecItem,
) error {

	return nil

}

//
// Renames a specification.
//
// Required Privileges
// VirtualMachine.Provisioning.ModifyCustSpecs
//
func (mo *CustomizationSpecManager) RenameCustomizationSpec(
	_this *ManagedObjectReference, name string, newName string,
) error {

	return nil

}

//
// Converts an XML string to a specification item
//
// Required Privileges
// System.View
//
func (mo *CustomizationSpecManager) XmlToCustomizationSpecItem(
	_this *ManagedObjectReference, specItemXml string,
) (*CustomizationSpecItem, error) {

	return nil, nil

}

//
// The customization sequence has started in the VM guest.
//
//
type CustomizationStartedEvent struct {
	*CustomizationEvent
}

//
// Use stateless autoconfiguration to configure to ipv6 address
//
//
type CustomizationStatelessIpV6Generator struct {
	*CustomizationIpV6Generator
}

//
// The customization sequence completed successfully in the guest.
//
//
type CustomizationSucceeded struct {
	*CustomizationEvent
}

//
// An object representation of a Windows sysprep.inf answer file. The sysprep
// type encloses all the individual keys listed in a sysprep.inf file. For
// more detailed information, see the document Windows 2000 Unattended Setup Guide.
//
//
type CustomizationSysprep struct {
	*CustomizationIdentitySettings

	// An object representation of the sysprep GuiRunOnce key.
	GuiRunOnce *CustomizationGuiRunOnce

	// An object representation of the sysprep GuiUnattended key.
	GuiUnattended *CustomizationGuiUnattended

	// An object representation of the sysprep Identification key.
	Identification *CustomizationIdentification

	// An object representation of the sysprep LicenseFilePrintData key. Required only
	// for Windows 2000 Server and Windows Server 2003.
	LicenseFilePrintData *CustomizationLicenseFilePrintData

	// An object representation of the sysprep UserData key.
	UserData *CustomizationUserData
}

//
// Sysprep failed to run in the guest during customization. This will most like
// have been caused by the fact that the wrong sysprep was used for the guest,
// so we include the version information in the event.
//
//
type CustomizationSysprepFailed struct {
	*CustomizationFailed

	// The version string for the sysprep files that were included in the
	// customization package.
	SysprepVersion string

	// The version string for the system
	SystemVersion string
}

//
// A enum constant specifying what should be done to the guest vm after running
// sysprep.
//
//
type CustomizationSysprepRebootOption struct {
}

//
// An alternate way to specify the sysprep.inf answer file. This string is
// more or less written exactly to the sysprep.inf answer file on the target
// virtual disk.
//
//
type CustomizationSysprepText struct {
	*CustomizationIdentitySettings

	// Text for the sysprep.inf answer file.
	Value string
}

//
// The customization sequence failed unexpectedly in the guest.
//
//
type CustomizationUnknownFailure struct {
	*CustomizationFailed
}

//
// The IP address is left unspecified. The user must be prompted to supply an IP
// address.
//
//
type CustomizationUnknownIpGenerator struct {
	*CustomizationIpGenerator
}

//
// The ipv6 address is left unspecified. The user must be prompted to supply an ipv6
// address.
//
//
type CustomizationUnknownIpV6Generator struct {
	*CustomizationIpV6Generator
}

//
// Indicates that the name is not specified in advance. The client should prompt the
// user for the value to complete the specification.
//
//
type CustomizationUnknownName struct {
	*CustomizationName
}

//
// Personal data pertaining to the owner of the virtual machine.
//
// The UserData data object type maps to the UserData key in the sysprep.inf
// answer file. These values are transferred directly into the sysprep.inf
// file that VirtualCenter stores on the target virtual disk. For more detailed
// information, see the document Windows 2000 Unattended Setup Guide.
//
//
//
type CustomizationUserData struct {
	*DynamicData

	// The computer name of the (Windows) virtual machine. Computer name may contain
	// letters (A-Z), numbers(0-9) and hyphens (-) but no spaces or periods (.).
	// The name may not consists entirely of digits.
	//
	// On Vista computer name is restricted to 15 characters in length. If the computer
	// name is longer than 15 characters, it will be truncated to 15 characters.
	ComputerName *CustomizationName

	// User's full name.
	FullName string

	// User's organization.
	OrgName string

	// Microsoft Sysprep requires that a valid serial number be included in the answer
	// file when mini-setup runs. This serial number is ignored if the original guest
	// operating system was installed using a volume-licensed CD.
	ProductId string
}

//
// Specifies that VirtualCenter should generate a virtual machine name from a base
// prefix comprising the virtual machine entity name. A number is appended, if
// necessary, to make it unique.
//
// Virtual machine names are unique across the set of hosts and virtual machines known
// to the VirtualCenter instance. VMware Tools reports the names of existing virtual
// machines.
//
//
//
type CustomizationVirtualMachineName struct {
	*CustomizationName
}

//
// Optional operations supported by the customization process for Windows.
//
//
type CustomizationWinOptions struct {
	*CustomizationOptions

	// The customization process should modify the machine's security identifier (SID).
	// For Vista OS, SID will always be modified.
	ChangeSID bool

	// Deprecated.
	// As of VI API 2.5, this value is ignored. Removing user accounts
	// during customization is no longer supported. To change the
	// administrator password, set the administrator password to
	// blank in the master vm. Sysprep will then be able to change the
	// password to the one specified by the password.
	//
	//
	// If deleteAccounts is true, then all user accounts are removed from the system as
	// part of the customization. Mini-setup creates a new Administrator account with a
	// blank password.
	DeleteAccounts bool

	// A value of type SysprepRebootOption specifying the action that should be
	// taken after running sysprep. Defaults to "reboot".
	//
	// Since VI API 2.5
	Reboot *enum.CustomizationSysprepRebootOption
}

//
// Management related configuration of a DistributedVirtualPort.
//
//
type DVPortConfigInfo struct {
	*DynamicData

	// The version string of the configuration.
	ConfigVersion string

	// A description string of the port.
	Description string

	// The name of the port.
	Name string

	// Deprecated.
	// as of vSphere API 5.5
	//
	//
	// The eligible entities that can connect to the port. If unset, there
	// is no restriction on which entity can connect to the port. If set,
	// only the entities in the specified list or their child entities are
	// allowed to connect to the port. If scopes are defined at both port
	// and portgroup level, they are taken as an "AND" relationship. If such
	// a relationship doesn't make sense, the reconfigure operation will
	// raise an exception.
	Scope []*ManagedEntity

	// The network configuration of the port.
	Setting *DVPortSetting
}

//
// Specification to reconfigure a DistributedVirtualPort.
//
//
type DVPortConfigSpec struct {
	*DynamicData

	// The version string of the configuration.
	ConfigVersion string

	// The description string of the port.
	Description string

	// Key of the port to be reconfigured.
	Key string

	// The name of the port.
	Name string

	// The operation to remove or modify the existing ports. The valid values
	// are:
	//
	// edit
	// remove
	Operation string

	// Deprecated.
	// as of vSphere API 5.5
	//
	//
	// The eligible entities that can connect to the port, for detail see
	// scope.
	Scope []*ManagedEntity

	// The network setting of the port.
	Setting *DVPortSetting
}

//
// The virtual machine is configured to use a DVPort, which is not
// supported on the host.  This could be because the host
// does not support VDS at all, or because the host has not
// joined a VDS.
//
//
type DVPortNotSupported struct {
	*DeviceBackingNotSupported
}

//
// The DVPortSetting data object
// describes the network configuration of a DistributedVirtualPort.
//
//
type DVPortSetting struct {
	*DynamicData

	// Indicates whether this port is blocked. If a port is blocked,
	// packet forwarding is stopped.
	Blocked *BoolPolicy

	// Configuration for Network Filter Policy.
	//
	// Since vSphere API 5.5
	FilterPolicy *DvsFilterPolicy

	// Network shaping policy for controlling throughput of inbound traffic.
	InShapingPolicy *DVSTrafficShapingPolicy

	// The key of user defined network resource pool to be associated with a port.
	// The default value for this property is "-1", indicating that
	// this port is not associated with any network resource pool.
	//
	// Since vSphere API 5.0
	NetworkResourcePoolKey *StringPolicy

	// Network shaping policy for controlling throughput of outbound traffic.
	OutShapingPolicy *DVSTrafficShapingPolicy

	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig *DVSVendorSpecificConfig

	// Indicates whether this port is allowed to do VMDirectPath Gen2 network passthrough.
	// Direct path capability is defined at host, switch, and device levels.
	// See the vmDirectPathGen2Supported properties on the
	// DVSFeatureCapability,
	// HostCapability, PhysicalNic,
	// and VirtualEthernetCardOption objects.
	//
	// Since vSphere API 4.1
	VmDirectPathGen2Allowed *BoolPolicy
}

//
// The state of a DistributedVirtualPort.
//
//
type DVPortState struct {
	*DynamicData

	// Run time information of the port.
	// This property is set only when the port is running.
	RuntimeInfo *DVPortStatus

	// Statistics of the port.
	Stats *DistributedVirtualSwitchPortStatistics

	// Opaque binary blob that stores vendor-specific runtime state data.
	VendorSpecificState []*DistributedVirtualSwitchKeyedOpaqueBlob
}

//
// The DVPortStatus data object
// contains runtime information about a DistributedVirtualPort.
//
//
type DVPortStatus struct {
	*DynamicData

	// Indicates whether the port is blocked by switch implementation.
	Blocked bool

	// Name of the connected entity.
	LinkPeer string

	// Indicates whether the port is in linkUp status.
	LinkUp bool

	// The MAC address that is used at this port.
	MacAddress string

	// Maximum transmission unit (MTU) of the port. You can set the MTU only
	// at the switch level
	// (VMwareDVSConfigSpec).
	// If you attempt to change it at the portgroup or port level,
	// the Server throws an exception.
	Mtu int32

	// Additional information regarding the current status of the port.
	//
	// Since vSphere API 4.1
	StatusDetail string

	// True if the port VLAN tagging/stripping is disabled.
	TrunkingMode bool

	// VLAN ID of the port.
	VlanIds []*NumericRange

	// Indicates whether VMDirectPath Gen 2 is active on this port.
	// If false, the reason(s) for inactivity will be provided in one or
	// more of vmDirectPathGen2InactiveReasonNetwork,
	// vmDirectPathGen2InactiveReasonOther,
	// and vmDirectPathGen2InactiveReasonExtended.
	//
	// If the host software is not capable of VMDirectPath Gen 2,
	// this property will be unset. See
	// HostCapability.vmDirectPathGen2Supported.
	//
	// Since vSphere API 4.1
	VmDirectPathGen2Active bool

	// If vmDirectPathGen2Active is false, this property may
	// contain an explanation provided by the platform, beyond the reasons
	// (if any) listed in vmDirectPathGen2InactiveReasonNetwork
	// and/or vmDirectPathGen2InactiveReasonOther.
	//
	// Since vSphere API 4.1
	VmDirectPathGen2InactiveReasonExtended string

	// If vmDirectPathGen2Active is false, this array will be
	// populated with reasons for the inactivity that are related to network
	// state or configuration. The reasons are chosen from the
	// DVPortStatusVmDirectPathGen2InactiveReasonNetwork
	// values.
	//
	// Other reasons for inactivity will be provided in
	// vmDirectPathGen2InactiveReasonOther. If there is a reason
	// for inactivity that cannot be described by the available constants,
	// vmDirectPathGen2InactiveReasonExtended will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.
	//
	// Since vSphere API 4.1
	VmDirectPathGen2InactiveReasonNetwork []string

	// If vmDirectPathGen2Active is false, this array will be
	// populated with reasons for the inactivity that are not related to
	// network state or configuration. The reasons are chosen from the
	// DVPortStatusVmDirectPathGen2InactiveReasonOther
	// values.
	//
	// Network-related reasons for inactivity will be provided in
	// vmDirectPathGen2InactiveReasonNetwork. If there is a reason
	// for inactivity that cannot be described by the available constants,
	// vmDirectPathGen2InactiveReasonExtended will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.See vmDirectPathGen2Supported
	//
	// Since vSphere API 4.1
	VmDirectPathGen2InactiveReasonOther []string
}

//
// Set of possible values for
// DVPortStatus.vmDirectPathGen2InactiveReasonNetwork.
//
//
type DVPortStatusVmDirectPathGen2InactiveReasonNetwork struct {
}

//
// Set of possible values for
// DVPortStatus.vmDirectPathGen2InactiveReasonOther.
//
//
type DVPortStatusVmDirectPathGen2InactiveReasonOther struct {
}

//
// The DVPortgroupConfigInfo data object defines
// the configuration of a DistributedVirtualPortgroup.
// .
//
//
type DVPortgroupConfigInfo struct {
	*DynamicData

	// If set to true, this property ignores the limit on the number of ports in the
	// portgroup. When a Virtual Machine/Host tries to connect to the portgroup and there
	// are no free ports available in the portgroup, new ports will be automatically
	// added to the portgroup. The flag is currently supported only for static portgroups.
	//
	// When this property is set to true, the portgroup becomes a potential candidate for
	// auto-shrink. Once the portgroup has auto-expanded then its disconnected ports are
	// likely to be deleted automatically, as a part of auto-shrink step, if there are more
	// than certain number of free ports. If the portgroup never auto-expanded, then it will
	// never lose any free ports.
	//
	// Since vSphere API 5.0
	AutoExpand bool

	// Configuration version number.
	ConfigVersion string

	// Common network setting for all the ports in the portgroup.
	DefaultPortConfig *DVPortSetting

	// Description of the portgroup.
	Description string

	// Distributed virtual switch that the portgroup is defined on.
	// This property should always be set unless the user's setting
	// does not have System.Read privilege on the object referred to
	// by this property.
	DistributedVirtualSwitch *DistributedVirtualSwitch

	// Key of the portgroup.
	Key string

	// Name of the portgroup.
	Name string

	// Number of ports in the portgroup.
	NumPorts int32

	// Portgroup policy.
	Policy *DVPortgroupPolicy

	// If set, a name will be automatically generated based on this format
	// string for a port when it is created in or moved into the portgroup.
	// The format string can contain meta tags that will be resolved
	// to the corresponding values in generating a name, if applicable for
	// the port at the time of name generation.
	//
	// To insert a meta tag in the format string,
	// enclose the names defined as meta tag names inside angle brackets.
	// See DistributedVirtualPortgroupMetaTagName for a list of
	// currently available meta tags.  For example,
	// "redNetwork-<portIndex>" and "<dvsName>-pnic<portIndex>"
	// result in generated port names like "redNetwork-2" and "switch-pnic3".
	//
	// If a meta tag is recognized, but there is no applicable value, the tag
	// will be expanded to empty string. If an arbitrary name appears inside
	// a "<>" pair and is not recognized as one of the defined meta tags,
	// the substring is treated as-is and appear unchanged in the generated name.
	//
	// To prevent a meta tag from being expanded, prefix the meta tag with a
	// '\' (backslash). For example, the format string "abc\<portIndex>def"
	// results in the generated port name "abc<portIndex>def".
	PortNameFormat string

	// Deprecated.
	// as of vSphere API 5.5
	//
	//
	// Eligible entities that can connect to the portgroup. If unset,
	// there is no restriction on which entity can connect to the portgroup.
	// If set, only the entities in the specified list or their child
	// entities are allowed to connect to the portgroup. If scopes are
	// defined at both port and portgroup level, they are taken as an "AND"
	// relationship. If such a relationship doesn't make sense, the
	// reconfigure operation will raise an exception.
	Scope []*ManagedEntity

	// Type of portgroup. See
	// DistributedVirtualPortgroup.DistributedVirtualPortgroupPortgroupType
	// for possible values.
	Type string

	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob
}

//
// The DVPortgroupConfigSpec
// data object contains configuration data for a
// DistributedVirtualPortgroup. Use the
// ReconfigureDVPortgroup_Task
// method to apply the configuration to the portgroup.
//
//
type DVPortgroupConfigSpec struct {
	*DynamicData

	// If set to true, this property ignores the limit on the number of ports in the
	// portgroup. When a Virtual Machine/Host tries to connect to the portgroup and there
	// are no free ports available in the portgroup, new ports will be automatically
	// added to the portgroup. The flag is currently supported only for static portgroups.
	//
	// Setting this property to true makes the portgroup a potential candidate for
	// auto-shrink. Once the portgroup has auto-expanded then its disconnected ports are
	// likely to be deleted automatically, as a part of auto-shrink step, if there are more
	// than certain number of free ports. If the portgroup never auto-expanded, then it will
	// never lose any free ports.
	//
	// Since vSphere API 5.0
	AutoExpand bool

	// Version string of the configuration that this spec is trying to
	// change. This property is required in reconfiguring a portgroup and
	// should be set to the same value as the
	// configVersion.
	// This property is ignored in creating a portgroup if set.
	ConfigVersion string

	// Default network setting for all the ports in the portgroup.
	DefaultPortConfig *DVPortSetting

	// Description of the portgroup.
	Description string

	// Name of the portgroup.
	Name string

	// Number of ports in the portgroup. Setting this number larger than the
	// number of existing ports in the portgroup causes new ports to
	// be added to the portgroup to meet the number. Setting this property
	// smaller than the number of existing ports deletes the free ports
	// from the portgroup. If the number cannot be met by deleting free ports,
	// a fault is raised.  If new ports are added to the portgroup, they
	// are also added to the switch. For portgroups of type ephemeral this
	// property is ignored.
	NumPorts int32

	// Portgroup policy.
	Policy *DVPortgroupPolicy

	// Format of the name of the ports when ports are created in the portgroup.
	// For details see portNameFormat.
	PortNameFormat string

	// Deprecated.
	// as of vSphere API 5.5
	//
	//
	// Eligible entities that can connect to the port. See
	// DVPortgroupConfigInfo.scope.
	Scope []*ManagedEntity

	// Type of portgroup.
	// See
	// DistributedVirtualPortgroup.DistributedVirtualPortgroupPortgroupType
	// for possible values.
	Type string

	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob
}

//
// Two distributed virtual portgroup was created.
//
//
type DVPortgroupCreatedEvent struct {
	*DVPortgroupEvent
}

//
// Two distributed virtual portgroup was destroyed.
//
//
type DVPortgroupDestroyedEvent struct {
	*DVPortgroupEvent
}

//
// DVPortgroup related events.
//
//
type DVPortgroupEvent struct {
	*Event
}

//
// The DistributedVirtualPortgroup policies. This field is not applicable
// when queried directly against an ESX host.
//
//
type DVPortgroupPolicy struct {
	*DynamicData

	// Allow the blocked setting
	// of an individual port to override the setting in
	// defaultPortConfig of
	// a portgroup.
	BlockOverrideAllowed bool

	// Allow a live port to be moved in and out of the portgroup.
	LivePortMovingAllowed bool

	// Allow the setting of
	// networkResourcePoolKey of an
	// individual port to override the setting in
	// defaultPortConfig
	// of a portgroup.
	//
	// Since vSphere API 5.0
	NetworkResourcePoolOverrideAllowed bool

	// If true, reset the port network setting back to the portgroup setting
	// (thus removing the per-port setting) when the port is disconnected from
	// the connectee.
	PortConfigResetAtDisconnect bool

	// Allow the inShapingPolicy or
	// outShapingPolicy settings
	// of an individual port to override the setting in
	// defaultPortConfig of
	// a portgroup.
	ShapingOverrideAllowed bool

	// Allow the setting of
	// filterPolicy,
	// for an individual port to override the setting in
	// defaultPortConfig of
	// a portgroup.
	//
	// Since vSphere API 5.5
	TrafficFilterOverrideAllowed bool

	// Allow the vendorSpecificConfig
	// setting of an individual port to override the setting in
	// defaultPortConfig of
	// a portgroup.
	VendorConfigOverrideAllowed bool
}

//
// Two distributed virtual portgroup was reconfigured.
//
//
type DVPortgroupReconfiguredEvent struct {
	*DVPortgroupEvent

	// The reconfiguration spec.
	ConfigSpec *DVPortgroupConfigSpec
}

//
// Two distributed virtual portgroup was renamed.
//
//
type DVPortgroupRenamedEvent struct {
	*DVPortgroupEvent

	// The new portgroup name.
	NewName string

	// The old portgroup name.
	OldName string
}

//
// Class to specify selection criteria of list of vNetwork Distributed Portgroups.
//
//
type DVPortgroupSelection struct {
	*SelectionSet

	// vSphere Distributed Switch uuid
	DvsUuid string

	// List of vNetwork Distributed Portgroup keys
	PortgroupKey []string
}

//
// The DVSBackupRestoreCapability data object
// describes backup, restore, and rollback capabilities for distributed virtual
// switches and distributed virtual portgroups.
// Backup and restore capabilities are indicated for DistributedVirtualSwitch.
// Rollback capability is indicated for DistributedVirtualSwitch
// and DistributedVirtualPortgroup.
//
//
type DVSBackupRestoreCapability struct {
	*DynamicData

	// Indicates whether backup, restore, and rollback are supported.
	BackupRestoreSupported bool
}

//
// The DVSCapability data object
// describes the distributed virtual switch features and indicates
// the level of configuration that is allowed.
//
//
type DVSCapability struct {
	*DynamicData

	// List of host component product information that is compatible
	// with the current switch implementation.
	CompatibleHostComponentProductInfo []*DistributedVirtualSwitchHostProductSpec

	// Indicates whether this switch allows vCenter users to modify
	// the switch configuration at the portgroup level,
	// except for host member, policy, and scope operations.
	DvPortGroupOperationSupported bool

	// Indicates whether this switch allows vCenter users to modify
	// the switch configuration at the port level,
	// except for host member, policy, and scope operations.
	DvPortOperationSupported bool

	// Indicates whether this switch allows vCenter users to modify
	// the switch configuration at the switch level,
	// except for host member, policy, and scope operations.
	DvsOperationSupported bool

	// Indicators for which version-specific distributed virtual switch
	// features are available on this switch.
	//
	// This information is read-only, with the following exception.
	// For a third-party distributed switch implementation, you can
	// set the property
	// DVSFeatureCapability.vmDirectPathGen2Supported
	// during switch creation or when you call the
	// UpdateDvsCapability method.
	//
	// Since vSphere API 4.1
	FeaturesSupported *DVSFeatureCapability
}

//
// Configuration of a DistributedVirtualSwitch.
//
//
type DVSConfigInfo struct {
	*DynamicData

	// Version string of the configuration.
	ConfigVersion string

	// Human operator contact information.
	Contact *DVSContactInfo

	// Create time of the switch.
	CreateTime time.Time

	// Default configuration for the ports in the switch, if the port
	// does not inherit configuration from the parent portgroup or has
	// its own configuration.
	DefaultPortConfig *DVPortSetting

	// Default host proxy switch maximum port number
	//
	// Since vSphere API 5.1
	DefaultProxySwitchMaxNumPorts int32

	// Description string for the switch.
	Description string

	// Key of the extension registered by the remote server that
	// controls the switch.
	ExtensionKey string

	// VDS health check configuration.
	//
	// Since vSphere API 5.1
	HealthCheckConfig []*DVSHealthCheckConfig

	// Hosts that join the switch.
	Host []*DistributedVirtualSwitchHostMember

	// Maximum number of ports allowed in the switch,
	// not including conflict ports.
	MaxPorts int32

	// Name of the switch.
	Name string

	// Boolean to indicate if network I/O control is enabled on the
	// switch.
	//
	// Since vSphere API 4.1
	NetworkResourceManagementEnabled bool

	// Current number of ports, not including conflict ports.
	NumPorts int32

	// Number of standalone ports in the switch. Standalone ports are
	// ports that do not belong to any portgroup.
	NumStandalonePorts int32

	// Usage policy of the switch.
	Policy *DVSPolicy

	// Vendor, product, and version information for the implementation
	// module of the switch.
	ProductInfo *DistributedVirtualSwitchProductSpec

	// IP address for the switch, specified using IPv4 dot notation. The
	// utility of this address is defined by other switch features.
	//
	// Since vSphere API 5.0
	SwitchIpAddress string

	// Intended vendor, product, and version information for the
	// implementation module of the switch.
	TargetInfo *DistributedVirtualSwitchProductSpec

	// List of uplink portgroups. When adding host members, the server
	// uses the uplinkPortPolicy to create a number of
	// uplink ports for the host. If portgroups are shown here,
	// those uplink ports will be added to the portgroups, with uplink ports
	// evenly spread among the portgroups.
	UplinkPortgroup []*DistributedVirtualPortgroup

	// Uplink port policy.
	UplinkPortPolicy *DVSUplinkPortPolicy

	// Generated UUID of the switch. Unique across vCenter Server
	// inventory and instances.
	Uuid string

	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob
}

//
// The DVSConfigSpec
// data object contains configuration data for a
// DistributedVirtualSwitch.
// Use the ReconfigureDvs_Task
// method to apply the configuration to the
// switch.
//
//
type DVSConfigSpec struct {
	*DynamicData

	// The version string of the configuration that this spec is trying to
	// change. This property is required in reconfiguring a switch
	// and should be set to the same value as
	// configVersion.
	// This property is ignored during switch creation.
	ConfigVersion string

	// Set the human operator contact information.
	Contact *DVSContactInfo

	// The default configuration for ports.
	DefaultPortConfig *DVPortSetting

	// The default host proxy switch maximum port number
	//
	// Since vSphere API 5.1
	DefaultProxySwitchMaxNumPorts int32

	// Set the description string of the switch.
	Description string

	// The key of the extension registered by a remote server that
	// controls the switch.
	ExtensionKey string

	// The host member specification. A particular host should have only one entry
	// in this array. Duplicate entries for the same host will raise a fault.
	// The host version should be compatible with the version of
	// DistributedVirtualSwitch. Use
	// QueryDvsCheckCompatibility
	// to check for compatibility.
	Host []*DistributedVirtualSwitchHostMemberConfigSpec

	// Deprecated.
	// As of vSphere API 5.0
	// The default value of this propoerty is maxint and there is no reason
	// for users to change it to a lower value
	//
	//
	// The maximum number of DistributedVirtualPorts allowed in the switch.
	// If specified in a reconfigure operation, this number cannot be smaller
	// than the number of existing DistributedVirtualPorts.
	MaxPorts int32

	// The name of the switch. Must be unique in the parent folder.
	Name string

	// The number of standalone ports in the switch. Standalone ports are
	// ports that do not belong to any portgroup. If set to a number larger
	// than number of existing standalone ports in the switch, new ports get
	// created to meet the number. If set to a number smaller than the number
	// of existing standalone ports, free ports (uplink ports excluded) are
	// deleted to meet the number. If the set number cannot be met by
	// deleting free standalone ports, a fault is raised.
	NumStandalonePorts int32

	// The usage policy of the switch.
	Policy *DVSPolicy

	// IP address for the switch, specified using IPv4 dot notation. The
	// utility of this address is defined by other switch features.
	//
	// Since vSphere API 5.0
	SwitchIpAddress string

	// The uplink portgroups.
	UplinkPortgroup []*DistributedVirtualPortgroup

	// The uplink port policy.
	UplinkPortPolicy *DVSUplinkPortPolicy

	// Set the opaque blob that stores vendor specific configuration.
	VendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob
}

//
// Contact information of a human operator.
//
//
type DVSContactInfo struct {
	*DynamicData

	// The contact information for the person.
	Contact string

	// The name of the person who is responsible for the switch.
	Name string
}

//
// Specification to create a DistributedVirtualSwitch.
//
//
type DVSCreateSpec struct {
	*DynamicData

	// Capability of the switch.
	Capability *DVSCapability

	// Configuration data.
	ConfigSpec *DVSConfigSpec

	// Product information for this switch implementation. If you
	// do not specify this property, the Server will use the latest
	// version to create the DistributedVirtualSwitch.
	ProductInfo *DistributedVirtualSwitchProductSpec
}

//
// This data object type describes the network adapter failover
// detection algorithm for a network adapter team.
//
//
type DVSFailureCriteria struct {
	*InheritablePolicy

	// The flag to indicate whether or not to enable this property to
	// enable beacon probing as a method to validate
	// the link status of a physical network adapter.
	//
	// checkBeacon can be enabled only if the VirtualSwitch has been
	// configured to use the beacon.  Attempting to set checkBeacon
	// on a PortGroup or VirtualSwitch that does not have beacon probing
	// configured for the applicable VirtualSwitch results in an error.
	CheckBeacon *BoolPolicy

	// The flag to indicate whether or not to use the link duplex reported
	// by the driver as link selection criteria.
	//
	// If checkDuplex is true, then fullDuplex is the configured
	// duplex mode.  The link is considered bad if the link duplex reported
	// by driver is not the same as fullDuplex.
	//
	//
	// If checkDuplex is false, then fullDuplex is unused, and
	// link duplexity is not used as a detection method.
	CheckDuplex *BoolPolicy

	// The flag to indicate whether or not to use link error percentage
	// to detect failure.
	//
	// If checkErrorPercent is true, then percentage is the configured
	// error percentage that is tolerated.  The link is considered bad
	// if error rate exceeds percentage.
	//
	// If checkErrorPercent is false, percentage is unused, and
	// error percentage is not used as a detection method.
	CheckErrorPercent *BoolPolicy

	// To use link speed as the criteria, checkSpeed must be one of
	// the following values:
	//
	//
	// exact: Use exact speed to detect link failure.
	// speed is the configured exact speed in megabits per second.
	// minimum: Use minimum speed to detect failure.
	// speed is the configured minimum speed in megabits per second.
	// empty string: Do not use link speed to detect failure.
	// speed is unused in this case.
	CheckSpeed *StringPolicy

	// See checkDuplex
	FullDuplex *BoolPolicy

	// See checkErrorPercent
	Percentage *IntPolicy

	// See checkSpeed
	Speed *IntPolicy
}

//
// The DVSFeatureCapability data object
// represents the capabilities supported by a
// DistributedVirtualSwitch. These properties are read-only with
// the exception of
// vmDirectPathGen2Supported.
//
//
type DVSFeatureCapability struct {
	*DynamicData

	// Backup, restore, and rollback capabilities. Backup and restore
	// are supported only for VmwareDistributedVirtualSwitch.
	// Rollback is supported for VmwareDistributedVirtualSwitch
	// and DistributedVirtualPortgroup.
	// For information about backup and restore, see the
	// DistributedVirtualSwitchManager methods
	// DVSManagerExportEntity_Task and
	// DVSManagerImportEntity_Task.
	// For information about rollback, see the
	// DistributedVirtualSwitch.DVSRollback_Task
	// and DistributedVirtualPortgroup.DVPortgroupRollback_Task
	// methods.
	//
	// Since vSphere API 5.1
	BackupRestoreCapability *DVSBackupRestoreCapability

	// Health check capabilities supported by a VmwareDistributedVirtualSwitch.
	//
	// Since vSphere API 5.1
	HealthCheckCapability *DVSHealthCheckCapability

	// Indicates whether Network Filter feature is
	// supported in vSphere Distributed Switch.
	//
	// Since vSphere API 5.5
	NetworkFilterSupported bool

	// Network resource management capabilities supported by a
	// distributed virtual switch.
	//
	// Since vSphere API 5.0
	NetworkResourceManagementCapability *DVSNetworkResourceManagementCapability

	// Deprecated.
	// As of vSphere API 5.0, use
	// networkResourceManagementCapability.networkResourceManagementSupported.
	//
	//
	// Indicates whether network I/O control is
	// supported on the vSphere Distributed Switch.
	NetworkResourceManagementSupported bool

	// Deprecated.
	// As of vSphere API 5.0, use
	// networkResourceManagementCapability.networkResourcePoolHighShareValue.
	//
	//
	// This is the value for high
	// in shares. This
	// implicitly defines the legal range of share values to be between 1 and this.
	// This also defines values for other level types, such as
	// normal  being one half of this value and
	// low being one fourth of this value.
	NetworkResourcePoolHighShareValue int32

	// The available teaming modes for the vSphere Distributed Switch. The
	// value can be one or more of
	// DistributedVirtualSwitchNicTeamingPolicyMode.
	NicTeamingPolicy []string

	// Host rollback capability.
	// If rollbackCapability.rollbackSupported
	// is true, network operations that disconnect the the host are rolled back.
	//
	// Since vSphere API 5.1
	RollbackCapability *DVSRollbackCapability

	// Indicates whether VMDirectPath Gen 2 is supported on the
	// distributed virtual switch. See
	// HostCapability.vmDirectPathGen2Supported
	// and PhysicalNic.vmDirectPathGen2Supported.
	//
	// For a third-party distributed switch implementation, you can
	// specify this property during switch creation or when you call the
	// UpdateDvsCapability method.
	//
	// VMDirectPath Gen 2 is supported in
	// vSphere Distributed Switch Version 4.1 or later.
	VmDirectPathGen2Supported bool
}

//
// Health check capabilities of health check supported by the
// vSphere Distributed Switch
//
//
type DVSHealthCheckCapability struct {
	*DynamicData
}

//
// The DVSHealthCheckConfig data object
// defines vSphere Distributed Switch health check configuration.
//
//
type DVSHealthCheckConfig struct {
	*DynamicData

	// True if enable health check.
	Enable bool

	// Interval of health check, in minutes.
	Interval int32
}

//
// This data object type describes the information about the host local port.
// A host local port is  created to resurrect the management network connection
// on a VMkernel Virtual NIC.
//
//
type DVSHostLocalPortInfo struct {
	*DynamicData

	// Portkey of the DVPort that management interface is now connected to.
	PortKey string

	// The configuration of the new host local port.
	Setting *DVPortSetting

	// UUID of the vSphere Distributed Switch that management interface is connected to.
	SwitchUuid string

	// The Virtual NIC device connected to this port
	Vnic string
}

//
// Configuration specification for a DistributedVirtualSwitch or
// DistributedVirtualPortgroup.
//
//
type DVSManagerDvsConfigTarget struct {
	*DynamicData

	// List of any DistributedVirtualPortgroup available for host Virtual NIC connection.
	DistributedVirtualPortgroup []*DistributedVirtualPortgroupInfo

	// List of any DistributedVirtualSwitch available for host Virtual NIC connection.
	DistributedVirtualSwitch []*DistributedVirtualSwitchInfo
}

//
// The uplink port policy specifies an array of uniform names
// for the uplink ports across the hosts. The size of the array indicates
// the number of uplink ports that will be created for each host in the
// switch.
//
// When the names in this array change, the uplink ports on all the
// hosts are automatically renamed accordingly. Increasing the number
// of names in the array automatically creates additional uplink ports
// bearing the added name on each host. Decreasing the number of name
// automatically deletes the unused uplink ports on each host. Decreasing
// beyond the number of unused uplink port raises a fault.
//
//
// This policy overrides the portgroup port naming format
// (DVPortgroupConfigSpec.portNameFormat),
// if both are defined and the uplink ports are created in a uplink portgroup.
//
//
//
type DVSNameArrayUplinkPortPolicy struct {
	*DVSUplinkPortPolicy

	// The uniform name of uplink ports on each host.
	UplinkPortName []string
}

//
// Dataobject representing the feature capabilities of network resource management
// supported by the vSphere Distributed Switch.
//
//
type DVSNetworkResourceManagementCapability struct {
	*DynamicData

	// Indicates whether network I/O control is
	// supported on the vSphere Distributed Switch. Network I/O control
	// is supported in vSphere Distributed Switch Version 4.1 or later.
	NetworkResourceManagementSupported bool

	// High share level (SharesLevel.high)
	// for DVSNetworkResourcePoolAllocationInfo.shares.
	//
	// The networkResourcePoolHighshareValue property implicitly defines
	// the legal range of share values to be between 1 and this value.
	// This property also defines values for other level types, such as
	// normal being one half of this value and
	// low being one fourth of this value.
	// This feature is supported in vSphere Distributed
	// Switch Version 4.1 or later.
	NetworkResourcePoolHighShareValue int32

	// Indicates whether Qos Tag(802.1p priority tag)is supported on the
	// vSphere Distributed Switch. Qos Tag is supported in vSphere
	// Distributed Switch Version 5.0 or later.
	QosSupported bool

	// Indicates whether the switch supports creating user defined resource
	// pools. This feature is supported in vSphere Distributed
	// Switch Version 5.0 or later.
	UserDefinedNetworkResourcePoolsSupported bool
}

//
// The DVSNetworkResourcePool data object
// describes the resource configuration and management
// of network resource pools.
//
//
type DVSNetworkResourcePool struct {
	*DynamicData

	// Resource settings of the resource pool.
	AllocationInfo *DVSNetworkResourcePoolAllocationInfo

	// Configuration version for the network resource pool.
	ConfigVersion string

	// Description of the network resource pool.
	Description string

	// Key of the network resource pool.
	Key string

	// Name of the network resource pool.
	Name string
}

//
// Resource allocation information for a network resource pool.
//
//
type DVSNetworkResourcePoolAllocationInfo struct {
	*DynamicData

	// Maximum allowed usage for network clients belonging to
	// this resource pool per host.
	// The utilization of network clients belonging to this resource pool
	// will not exceed the specified limit even if there are available
	// network resources. If set to -1, then there is no limit on the network
	// resource usage for clients belonging to this resource pool. Units are
	// in Mbits/sec. When setting the allocation of a particular resource
	// pool, if the property is unset, it is treated as no change and the
	// property is not updated. An unset limit value while reading back the
	// allocation information of a network resource pool indicates that
	// there is no limit on the network resource usage for the clients
	// belonging to this resource group.
	Limit int64

	// 802.1p tag to be used for this resource pool. The tag is a priority value
	// in the range 0..7 for Quality of Service operations on network traffic.
	//
	// Since vSphere API 5.0
	PriorityTag int32

	// Share settings associated with the network resource pool to
	// facilitate proportional sharing of the physical network resources.
	// If the property is unset when setting the allocation of a particular
	// resource pool, it is treated as unset and the property is not updated.
	// The property is always set when reading back the allocation
	// information of a network resource pool.
	Shares *SharesInfo
}

//
// The DVSNetworkResourcePoolConfigSpec data object
// contains properties to create or update a network resource pool
// for a distributed virtual switch.
//
//
type DVSNetworkResourcePoolConfigSpec struct {
	*DynamicData

	// Network resource allocation for the network resource pool.
	AllocationInfo *DVSNetworkResourcePoolAllocationInfo

	// Unique identifier for a given version
	// of the configuration. Each change to the configuration will
	// update this value. This is typically implemented as a
	// non-decreasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	//
	// If you specify the configuration version when you update
	// the resource configuration, the Server will apply the changes
	// only if the specified identifier matches the current
	// DVSNetworkResourcePool.configVersion
	// value. You can use this field to guard against updates
	// that may have occurred between the time when the client
	// reads configVersion
	// and when the configuration is applied.
	ConfigVersion string

	// User-defined description for the resource pool.
	//
	// Since vSphere API 5.0
	Description string

	// Key of the network resource pool. The property is ignored for
	// DistributedVirtualSwitch.AddNetworkResourcePool
	// operations.
	Key string

	// User defined name for the resource pool.
	// The property is required for
	// DistributedVirtualSwitch.AddNetworkResourcePool
	// operations.
	//
	// Since vSphere API 5.0
	Name string
}

//
// The switch usage policy types
//
//
type DVSPolicy struct {
	*DynamicData

	// Whether downloading a new proxy VirtualSwitch module to the host is
	// allowed to be automatically executed by the switch.
	AutoPreInstallAllowed bool

	// Whether upgrading of the switch is allowed to be automatically
	// executed by the switch.
	AutoUpgradeAllowed bool

	// Whether to allow upgrading a switch when some of the hosts failed to
	// install the needed module. The vCenter Server will reattempt the
	// pre-install operation of the host module on those failed hosts,
	// whenever they reconnect to vCenter.
	PartialUpgradeAllowed bool
}

//
// The DVSRollbackCapability data object
// describes the rollback capabilities for a DistributedVirtualSwitch.
//
//
type DVSRollbackCapability struct {
	*DynamicData

	// Indicates whether rollback is supported on the distributed switch.
	RollbackSupported bool
}

//
// The DVSRuntimeInfo data object defines
// runtime information for a vSphere Distributed Switch.
//
//
type DVSRuntimeInfo struct {
	*DynamicData

	// Runtime information of the hosts that joined the switch.
	HostMemberRuntime []*HostMemberRuntimeInfo
}

//
// This data object type describes security policy governing ports.
//
//
type DVSSecurityPolicy struct {
	*InheritablePolicy

	// The flag to indicate whether or not all traffic is seen
	// on the port.
	AllowPromiscuous *BoolPolicy

	// The flag to indicate whether or not the virtual network adapter
	// should be allowed to send network traffic with a different MAC
	// address than that of the virtual network adapter.
	ForgedTransmits *BoolPolicy

	// The flag to indicate whether or not the Media Access
	// Control (MAC) address can be changed.
	MacChanges *BoolPolicy
}

//
// Class to specify selection criteria of vSphere Distributed Switch.
//
//
type DVSSelection struct {
	*SelectionSet

	// vSphere Distributed Switch uuid
	DvsUuid string
}

//
// Summary of the distributed switch configuration.
//
//
type DVSSummary struct {
	*DynamicData

	// The human operator contact information.
	Contact *DVSContactInfo

	// A description string of the switch.
	Description string

	// The hosts with Virtual NICs that connect to the switch.
	Host []*HostSystem

	// The names of the hosts that join the switch.
	HostMember []*HostSystem

	// The name of the switch.
	Name string

	// The number of hosts in the switch. The value of this property
	// is not affected by the privileges granted to the current user.
	//
	// Since vSphere API 5.5
	NumHosts int32

	// Current number of ports, not including conflict ports.
	NumPorts int32

	// The names of the portgroups that are defined on the switch.
	PortgroupName []string

	// The product information for the implementation of the switch.
	ProductInfo *DistributedVirtualSwitchProductSpec

	// The generated UUID of the switch.
	Uuid string

	// The Virtual Machines with Virtual NICs that connect to the switch.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	Vm []*VirtualMachine
}

//
// This data object type describes traffic shaping policy.
//
//
type DVSTrafficShapingPolicy struct {
	*InheritablePolicy

	// The average bandwidth in bits per second if shaping is enabled on
	// the port.
	AverageBandwidth *LongPolicy

	// The maximum burst size allowed in bytes if shaping is enabled on
	// the port.
	BurstSize *LongPolicy

	// The flag to indicate whether or not traffic shaper is enabled on
	// the port.
	Enabled *BoolPolicy

	// The peak bandwidth during bursts in bits per second if traffic
	// shaping is enabled on the port.
	PeakBandwidth *LongPolicy
}

//
// The base class for uplink port policy.
//
//
type DVSUplinkPortPolicy struct {
	*DynamicData
}

//
// This data object type describes vendor specific configuration.
//
//
type DVSVendorSpecificConfig struct {
	*InheritablePolicy

	// An opaque binary blob that stores vendor specific configuration.
	KeyValue []*DistributedVirtualSwitchKeyedOpaqueBlob
}

//
// The DailyTaskScheduler data object sets the time for daily
// task execution. You set the hour and the inherited minute
// property to complete the schedule. By default, the scheduled task
// will run once every day at the specified hour and minute.
//
// If you set the interval to a value greater than 1, the task will
// execute at the specified daily interval. (For example, an interval
// of 2 will cause the task to execute at the specified hour and minute
// every 2 days.)
//
//
//
type DailyTaskScheduler struct {
	*HourlyTaskScheduler

	// The hour at which the RecurrentTaskScheduler runs the task.
	// Use UTC (Coordinated Universal Time) values in the range
	// 0 to 23, where 0 = 12:00 a.m. (UTC) and 12 = 12:00 p.m. (UTC).
	//
	// For vCenter 2.x and prior releases, use the server's local time.
	// For example, use Eastern Standard Time (EST) or Pacific Daylight Time (PDT),
	// rather than UTC.
	Hour int32
}

//
// This event records when admission control checks have been disabled in a HA
// cluster.
//
//
type DasAdmissionControlDisabledEvent struct {
	*ClusterEvent
}

//
// This event records when admission control checks have been enabled in a HA cluster.
//
//
type DasAdmissionControlEnabledEvent struct {
	*ClusterEvent
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that VirtualCenter has re-established contact with a
// primary host in this HA cluster.
//
//
type DasAgentFoundEvent struct {
	*ClusterEvent
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that VirtualCenter cannot contact any primary host
// in this HA cluster. HA designates some hosts as primary hosts in the HA
// cluster. When adding a new host to an existing cluster, HA needs to
// contact one of the primary hosts to finish the configuration. VirtualCenter
// has lost contact with all primary nodes in the connected state. Attempts
// to configure HA on a host in this cluster will fail until a
// DasAgentFoundEvent is logged or unless this is the first node to be
// configured. For example, if all the other hosts are disconnected first.
//
//
type DasAgentUnavailableEvent struct {
	*ClusterEvent
}

//
// This event records that all hosts have been isolated from the network in a
// HA cluster.
//
//
type DasClusterIsolatedEvent struct {
	*ClusterEvent
}

//
// This fault indicates that some error has occurred during the
// configuration of the host for HA. This may be subclassed by a more specific fault.
//
//
type DasConfigFault struct {
	*VimFault

	// The list of events containing details why the configuration failed, if known.
	//
	// Since vSphere API 4.0
	Event []*Event

	// The output (stdout/stderr) from executing the configuration.
	//
	// Since vSphere API 4.0
	Output string

	// The reason why the HA configuration failed, if known.
	// Values should come from DasConfigFaultReason.
	//
	// Since vSphere API 4.0
	Reason string
}

type DasConfigFaultDasConfigFaultReason struct {
}

//
// This event records when a cluster has been disabled for HA.
//
//
type DasDisabledEvent struct {
	*ClusterEvent
}

//
// This event records when a cluster has been enabled for HA.
//
//
type DasEnabledEvent struct {
	*ClusterEvent
}

//
// Class for the selection of heartbeat datastores
//
//
type DasHeartbeatDatastoreInfo struct {
	*DynamicData

	Datastore *Datastore

	Hosts []*HostSystem
}

//
// This event records when a host failure has been detected by HA.
//
//
type DasHostFailedEvent struct {
	*ClusterEvent

	// The host that failed.
	FailedHost *HostEventArgument
}

//
// This event records that a host has been isolated from the network in a
// HA cluster. Since an isolated host cannot be distinguished from a failed
// host except by the isolated host itself, this event is logged when the
// isolated host regains network connectivity.
//
//
type DasHostIsolatedEvent struct {
	*ClusterEvent

	// The host that was isolated.
	IsolatedHost *HostEventArgument
}

// Deprecated.
// As of VI API 2.5, use ClusterDasVmSettingsRestartPriority.
//
//
// The priority of the virtual machine determines the preference
// given to it if sufficient capacity is not available to power
// on all failed virtual machines. For example, high priority
// virtual machines on a host get preference over low priority
// virtual machines.
//
//
type DasVmPriority struct {
}

//
// A DatabaseError exception is thrown if an
// operation failed when accessing the external
// database. This typically is because
// the database is (temporarily) unavailable or
// because of network problems.
//
//
type DatabaseError struct {
	*RuntimeFault
}

//
// DatabaseSizeEstimate contains information about the size
// required to by the database.
//
//
type DatabaseSizeEstimate struct {
	*DynamicData

	// The estimated size required in MB
	Size int64
}

//
// DatabaseSizeParam contains information about a sample inventory. Using this
// information, database size requirements for that sample inventory can be computed.
// Depending on the accuracy of estimate desired, users can choose to specify
// the number of different types of managed entities. The numHosts and
// numVirtualMachines are the only two required fields. Rest are all optional
// fields filled up by Virtual Center based on some heuristics.
//
// These parameters need not represent a real inventory. The user can use these
// parameters to estimate the database size required by a hypothetical
// VirtualCenter setup.
//
//
type DatabaseSizeParam struct {
	*DynamicData

	// Object to capture inventory description
	InventoryDesc *InventoryDescription

	// Object to capture performance statistics
	// related parameters
	PerfStatsDesc *PerformanceStatisticsDescription
}

//
// The Datacenter managed object provides the interface to the common container
// object for hosts, virtual machines, networks, and datastores. These entities
// must be under a distinct datacenter in the inventory, and datacenters may not
// be nested under other datacenters.
//
// Every Datacenter has the following set of dedicated folders. These folders are empty
// until you create entities for the Datacenter.
//
//
//
// •  A folder for VirtualMachine, template, and
// VirtualApp objects.
//
// •  A folder for a ComputeResource hierarchy.
//
// •  A folder for Network, DistributedVirtualSwitch,
// and DistributedVirtualPortgroup objects.
//
// •  A folder for Datastore objects.
//
//
//
//
// For a visual representation of the organization of objects in a vCenter
// hierarchy, see the description of the ServiceInstance object.
//
//
//
type Datacenter struct {
	*ManagedEntity

	configuration *DatacenterConfigInfo

	datastore []*Datastore

	datastoreFolder *Folder

	hostFolder *Folder

	network []*Network

	networkFolder *Folder

	vmFolder *Folder
}

// Configuration of the datacenter.
//
// Since vSphere API 5.1
// Required Privilege: System.View
func (mo *Datacenter) Configuration() (*DatacenterConfigInfo, error) {
	t, err := mo.currentProperty("configuration")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DatacenterConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DatacenterConfigInfo")
	}
	return v, nil
}

// A collection of references to the datastore objects
// available in this datacenter.
func (mo *Datacenter) Datastore() ([]*Datastore, error) {
	t, err := mo.currentProperty("datastore")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Datastore)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Datastore")
	}
	return v, nil
}

// A reference to the folder hierarchy that contains
// the datastores for this datacenter.
//
// This folder is guaranteed to exist.
//
// Since vSphere API 4.0
// Required Privilege: System.View
func (mo *Datacenter) DatastoreFolder() (*Folder, error) {
	t, err := mo.currentProperty("datastoreFolder")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*Folder)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *Folder")
	}
	return v, nil
}

// A reference to the folder hierarchy that contains
// the compute resources, including hosts and clusters, for this datacenter.
//
// This folder is guaranteed to exist.
// Required Privilege: System.View
func (mo *Datacenter) HostFolder() (*Folder, error) {
	t, err := mo.currentProperty("hostFolder")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*Folder)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *Folder")
	}
	return v, nil
}

// A collection of references to the network objects
// available in this datacenter.
func (mo *Datacenter) Network() ([]*Network, error) {
	t, err := mo.currentProperty("network")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Network)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Network")
	}
	return v, nil
}

// A reference to the folder hierarchy that contains the network entities
// for this datacenter. The folder can include Network,
// DistributedVirtualSwitch, and
// DistributedVirtualPortgroup objects.
//
// This folder is guaranteed to exist.
//
// Since vSphere API 4.0
// Required Privilege: System.View
func (mo *Datacenter) NetworkFolder() (*Folder, error) {
	t, err := mo.currentProperty("networkFolder")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*Folder)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *Folder")
	}
	return v, nil
}

// A reference to the folder hierarchy that contains VirtualMachine
// virtual machine templates (identified by the template
// property, and VirtualApp objects for this datacenter.
//
// Note that a VirtualApp that is a child of a ResourcePool
// may also be visible in this folder. VirtualApp objects can be nested,
// but only the parent VirtualApp can be visible in the folder.
//
// This folder is guaranteed to exist.
// Required Privilege: System.View
func (mo *Datacenter) VmFolder() (*Folder, error) {
	t, err := mo.currentProperty("vmFolder")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*Folder)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *Folder")
	}
	return v, nil
}

//
// Powers on multiple virtual machines in a data center. If the virtual
// machines are suspended, this method resumes execution from the suspend
// point.
//
// The virtual machines can belong to different clusters in the data center.
//
//
// If any virtual machine in the list is manually managed by DRS, or DRS
// has to migrate any manually managed virtual machine or power on any manually
// managed host in order to power on these virtual machines, a DRS recommendation
// will be generated, and the users need to manually apply the recommendation
// for actually powering on these virtual machines.
//
// Otherwise, all the virtual machine will be automatically powered on. The
// virtual machines on stand alone hosts or DRS disabled will be powered-on
// on the current host. The DRS automatically managed virtual machines will
// be powered-on on the recommended hosts.
//
//
//
// When powering on a virtual machine in a cluster, the system
// might do an implicit relocation of the virtual machine to
// another host.
//
//
//
//
//
// Required Privileges
// System.View
// Since
// VI API 2.5
//
func (mo *Datacenter) PowerOnMultiVM_Task(
	_this *ManagedObjectReference, vm []*VirtualMachine, option []*OptionValue,
) (*Task, error) {

	return nil, nil

}

//
// This method provides a way of getting basic information about a host without
// adding it to a datacenter. Connection wizards typically use this method to show
// information about a host so a user can confirm a set of changes before applying
// them.
//
// Required Privileges
// System.View
//
func (mo *Datacenter) QueryConnectionInfo(
	_this *ManagedObjectReference, hostname string, port int32, username string, password string, sslThumbprint string,
) (*HostConnectInfo, error) {

	return nil, nil

}

//
// The list of possible choices for
// defaultHardwareVersionKey.
// Descriptors returned by the vCenter implementation do not have
// host field populated.
//
// Required Privileges
// System.View
// Since
// vSphere API 5.1
//
func (mo *Datacenter) QueryDatacenterConfigOptionDescriptor(
	_this *ManagedObjectReference,
) ([]*VirtualMachineConfigOptionDescriptor, error) {

	return nil, nil

}

//
// Change the datacenter configuration.
//
// Required Privileges
// Datacenter.Reconfigure
// Since
// vSphere API 5.1
//
func (mo *Datacenter) ReconfigureDatacenter_Task(
	_this *ManagedObjectReference, spec *DatacenterConfigSpec, modify bool,
) (*Task, error) {

	return nil, nil

}

//
// Configuration of the datacenter.
//
//
type DatacenterConfigInfo struct {
	*DynamicData

	// Key for Default Hardware Version used on this datacenter
	// in the format of key.
	//
	// This field affects
	// defaultConfigOption returned
	// by environmentBrowser of all its children
	// with this field unset.
	DefaultHardwareVersionKey string
}

//
// Changes to apply to the datacenter configuration.
//
//
type DatacenterConfigSpec struct {
	*DynamicData

	// Key for Default Hardware Version to be used on this datacenter
	// in the format of key.
	//
	// Setting this field affects
	// defaultConfigOption returned
	// by environmentBrowser of all its children
	// with this field unset.
	DefaultHardwareVersionKey string
}

type DatacenterCreatedEvent struct {
	*DatacenterEvent

	// The folder where the datacenter is created.
	Parent *FolderEventArgument
}

//
// These are datacenter events.
//
//
type DatacenterEvent struct {
	*Event
}

//
// The event argument is a Datacenter object.
//
//
type DatacenterEventArgument struct {
	*EntityEventArgument

	// The Datacenter object.
	Datacenter *Datacenter
}

//
// The input arguments had entities that did not belong to the same
// datacenter.
//
//
type DatacenterMismatch struct {
	*MigrationFault

	// The expected datacenter for the arguments.
	ExpectedDatacenter *Datacenter

	// The list of invalid arguments.
	InvalidArgument []*DatacenterMismatchArgument
}

//
// An input entity argument that belongs to a mismatched datacenter.
//
//
type DatacenterMismatchArgument struct {
	*DynamicData

	// The invalid input entity.
	Entity *ManagedEntity

	// The datacenter for this entity.
	InputDatacenter *Datacenter
}

type DatacenterRenamedEvent struct {
	*DatacenterEvent

	// The new datacenter name.
	NewName string

	// The old datacenter name.
	OldName string
}

//
// Represents a storage location for virtual machine files. A storage location can be a
// VMFS volume, a directory on Network Attached Storage, or a local file system path.
//
// A datastore is platform-independent and host-independent. Therefore, datastores do
// not change when the virtual machines they contain are moved between hosts. The scope
// of a datastore is a datacenter; the datastore is uniquely named within the
// datacenter.
//
//
// Any reference to a virtual machine or file accessed by any host within the
// datacenter must use a datastore path. A datastore path has the form
// "[&lt;datastore&gt;] &lt;path&gt;", where &lt;datastore&gt; is the datastore name,
// and &lt;path&gt; is a slash-delimited path from the root of the datastore. An
// example datastore path is "[storage] path/to/config.vmx".
//
//
// You may use the following characters in a path, but not in a datastore name:
// slash (/), backslash (\), and percent (%).
//
//
// All references to files in the VIM API are implicitly done using datastore paths.
//
//
// When a client creates a virtual machine, it may specify the name of
// the datastore, omitting the path; the system, meaning VirtualCenter or the host,
// automatically assigns filenames and creates directories on the given datastore. For
// example, specifying My_Datastore as a location for a virtual machine called MyVm
// results in a datastore location of My_Datastore\MyVm\MyVm.vmx.
//
//
// Datastores are configured per host. As part of host configuration, a HostSystem can
// be configured to mount a set of network drives. Multiple hosts
// may be configured to point to the same storage location. There exists only one
// Datastore object per Datacenter, for each such shared location. Each Datastore
// object keeps a reference to the set of hosts that have mounted the datastore. A
// Datastore object can be removed only if no hosts currently have the datastore
// mounted.
//
//
// Thus, managing datastores is done both at the host level and the datacenter level.
// Each host is configured explicitly with the set of datastores it can access. At the
// datacenter, a view of the datastores across the datacenter is shown.
//
//
//
type Datastore struct {
	*ManagedEntity

	browser *HostDatastoreBrowser

	capability *DatastoreCapability

	host []*DatastoreHostMount

	info *DatastoreInfo

	iormConfiguration *StorageIORMInfo

	summary *DatastoreSummary

	vm []*VirtualMachine
}

// DatastoreBrowser used to browse this datastore.
func (mo *Datastore) Browser() (*HostDatastoreBrowser, error) {
	t, err := mo.currentProperty("browser")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostDatastoreBrowser)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostDatastoreBrowser")
	}
	return v, nil
}

// Capabilities of this datastore.
func (mo *Datastore) Capability() (*DatastoreCapability, error) {
	t, err := mo.currentProperty("capability")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DatastoreCapability)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DatastoreCapability")
	}
	return v, nil
}

// Hosts attached to this datastore.
func (mo *Datastore) Host() ([]*DatastoreHostMount, error) {
	t, err := mo.currentProperty("host")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*DatastoreHostMount)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*DatastoreHostMount")
	}
	return v, nil
}

// Specific information about the datastore.
func (mo *Datastore) Info() (*DatastoreInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DatastoreInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DatastoreInfo")
	}
	return v, nil
}

// Configuration of storage I/O resource management for the datastore.
// Currently we only support storage I/O resource management on VMFS volumes
// of a datastore.
//
// This configuration may not be available if the datastore is not accessible
// from any host, or if the datastore does not have VMFS volume.
// The configuration can be modified using the method
// ConfigureDatastoreIORM_Task
//
// Since vSphere API 4.1
func (mo *Datastore) IormConfiguration() (*StorageIORMInfo, error) {
	t, err := mo.currentProperty("iormConfiguration")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*StorageIORMInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *StorageIORMInfo")
	}
	return v, nil
}

// Global properties of the datastore.
func (mo *Datastore) Summary() (*DatastoreSummary, error) {
	t, err := mo.currentProperty("summary")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DatastoreSummary)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DatastoreSummary")
	}
	return v, nil
}

// Virtual machines stored on this datastore.
func (mo *Datastore) Vm() ([]*VirtualMachine, error) {
	t, err := mo.currentProperty("vm")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*VirtualMachine)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*VirtualMachine")
	}
	return v, nil
}

//
// Puts the datastore in maintenance mode. While this task is running and when the
// datastore is in maintenance mode, no virtual machines can be powered on and no
// provisioning operations can be performed on the datastore. Once the call
// completes, it is safe to remove datastore without disrupting any virtual machines.
//
// The task completes once there are no virtual machines on the datastore
// and no provisioning operations in progress on the datastore. The operation does not
// directly initiate any operations to evacuate or power-down powered-on virtual machines.
// However, if the datastore is part of a storage pod with VMware Storage DRS enabled,
// Storage DRS provides migration recommendations to evacuate the virtual
// machines. If Storage DRS is in fully-automatic mode, these are automatically scheduled.
//
// The task is cancellable.
//
// This method returns a StoragePlacementResult object, which includes
// a Task object with which to monitor the operation, and a list of recommendations
// and faults generated by Storage DRS when it tries to evacuate the virtual machines
// on the datastore. The recommendations and faults fields are set only if the datastore is
// a part of a storage pod with Storage DRS enabled.
//
//
// Required Privileges
// Datastore.Config
// Since
// vSphere API 5.0
//
func (mo *Datastore) DatastoreEnterMaintenanceMode(
	_this *ManagedObjectReference,
) (*StoragePlacementResult, error) {

	return nil, nil

}

//
// Takes the datastore out of maintenance mode.
//
// The task is cancellable.
//
//
//
//
// Required Privileges
// Datastore.Config
// Since
// vSphere API 5.0
//
func (mo *Datastore) DatastoreExitMaintenanceMode_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of VI API 2.5 do not use this method. This method throws
// ResourceInUse.  Datastores are automatically
// removed when no longer in use, so this method is unnecessary.
//
//
// Removes a datastore. A datastore can be removed only if it is not currently used
// by any host or virtual machine.
//
// Required Privileges
// Datastore.Delete
//
func (mo *Datastore) DestroyDatastore(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Explicitly refreshes free-space and capacity values in summary
// and info.
//
// Required Privileges
// System.Read
//
func (mo *Datastore) RefreshDatastore(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Refreshes all storage related information including free-space, capacity,
// and detailed usage of virtual machines. Updated values are available
// in summary and info.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *Datastore) RefreshDatastoreStorageInfo(
	_this *ManagedObjectReference,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 4.0, use Rename_Task.
//
//
// Renames a datastore.
//
// Required Privileges
// Datastore.Rename
//
func (mo *Datastore) RenameDatastore(
	_this *ManagedObjectReference, newName string,
) error {

	return nil

}

//
// Update file paths embedded in virtual machine files on the datastore.
// This can be called after the file system corresponding to the datastore
// has been resignatured or remounted.  Any MountPathDatastorePairs
// where the new path is the same as the original file path will be ignored.
//
// This method is only supported by vCenter server.  Also, this method requires
// that the datastore is accessible from
// at least one host (ESX version 4.1 or above) in vCenter server.
//
//
// While this operation is in progress, it is important that users do not
// initiate any operations that might read or write to any files on the
// datastore, such as registering a virtual machine with files residing
// on the datastore, or performing any virtual disk operations on any files
// in the datastore. These operations can potentially cause spurious file
// update failures, while at the same time they can prevent virtual machine
// files from being updated correctly.
//
//
// If users intend to update multiple datastores using this method, it is
// strongly advised that the users do not initiate any operations that
// might read or write to files on any of the datastores, until all of
// them have been updated. The files of a single virtual machine can
// reside on multiple datastores, and thus all the involved datastores
// should be updated, before the virtual machine is considered updated
// completely.
//
//
// Required Privileges
// Datastore.UpdateVirtualMachineFiles
// Since
// vSphere API 4.1
//
func (mo *Datastore) UpdateVirtualMachineFiles_Task(
	_this *ManagedObjectReference, mountPathDatastoreMapping []*DatastoreMountPathDatastorePair,
) (*Task, error) {

	return nil, nil

}

type DatastoreAccessible struct {
}

//
// Information about the capabilities of this datastore.
//
//
type DatastoreCapability struct {
	*DynamicData

	// Indicates whether or not directories can be created on this datastore.
	DirectoryHierarchySupported bool

	// Indicates whether the datastore supports native snapshot feature which is
	// based on Copy-On-Write.
	//
	// Since vSphere API 5.1
	NativeSnapshotSupported bool

	// Indicates whether or not the datastore supports thin provisioning on a per file
	// basis. When thin provisioning is used, backing storage is lazily allocated.
	//
	// This is supported by VMFS3. VMFS2 always allocates storage eagerly. Thus, this
	// value is false for VMFS2. Most NAS systems always use thin provisioning.
	// They do not support configuring this on a per file basis, so for NAS systems
	// this value is also false.
	PerFileThinProvisioningSupported bool

	// Indicates whether or not raw disk mappings can be created on this datastore.
	RawDiskMappingsSupported bool

	// Indicates whether the datastore supports the Flex-SE(SeSparse) feature.
	//
	// Since vSphere API 5.5
	SeSparseSupported bool

	// Indicates whether the datastore supports Storage I/O Resource Management.
	//
	// Since vSphere API 4.1
	StorageIORMSupported bool

	// Indicates whether the datastore supports traditional top-level
	// directory creation.See DatastoreNamespaceManager
	//
	// Since vSphere API 5.5
	TopLevelDirectoryCreateSupported bool
}

//
// This event records when increase in a datastore's capacity is observed.
// It may happen due to different reasons, like extending or expanding a
// datastore.
//
//
type DatastoreCapacityIncreasedEvent struct {
	*DatastoreEvent

	// The new datastore capacity.
	NewCapacity int64

	// The old datastore capacity.
	OldCapacity int64
}

//
// This event records when a datastore is removed from VirtualCenter.
//
//
type DatastoreDestroyedEvent struct {
	*DatastoreEvent
}

//
// This event records when a host is added to VirtualCenter
// and datastores are discovered.
//
//
type DatastoreDiscoveredEvent struct {
	*HostEvent

	// The associated datastore.
	Datastore *DatastoreEventArgument
}

//
// This event records when a duplicate datastore name is found.
// This event is used in VirtualCenter 1.x and is included for
// backward compatibility.
//
//
type DatastoreDuplicatedEvent struct {
	*DatastoreEvent
}

//
// These are datastore events.
//
//
type DatastoreEvent struct {
	*Event

	// The associated datastore.
	Datastore *DatastoreEventArgument
}

//
// The event argument is a Datastore object.
//
//
type DatastoreEventArgument struct {
	*EntityEventArgument

	// The Datastore object.
	Datastore *Datastore
}

//
// This event records copy of a file or directory.
//
//
type DatastoreFileCopiedEvent struct {
	*DatastoreFileEvent

	// Source datastore.
	SourceDatastore *DatastoreEventArgument

	// Datastore path of the source file or directory.
	SourceFile string
}

//
// This event records deletion of a file or directory.
//
//
type DatastoreFileDeletedEvent struct {
	*DatastoreFileEvent
}

//
// Base class for events related to datastore file and directory
// operations.
//
// Property datastore inherited from DatastoreEvent refers
// to the destination datastore in case there is more than datastore
// involved in the operation.
//
//
//
type DatastoreFileEvent struct {
	*DatastoreEvent

	// Datastore path of the target file or directory.
	TargetFile string
}

//
// This event records move of a file or directory.
//
//
type DatastoreFileMovedEvent struct {
	*DatastoreFileEvent

	// Source datastore.
	SourceDatastore *DatastoreEventArgument

	// Datastore path of the source file or directory.
	SourceFile string
}

//
// Host-specific datastore information.
//
//
type DatastoreHostMount struct {
	*DynamicData

	// The host associated with this datastore.
	Key *HostSystem

	// Host-specific information about the mount.
	MountInfo *HostMountInfo
}

//
// This event records that the configuration of storage I/O
// resource management for a datastore has changed.
//
//
type DatastoreIORMReconfiguredEvent struct {
	*DatastoreEvent
}

//
// Detailed information about a datastore.  This is a base type for derived types
// that have more specific details about a datastore.See HostVmfsVolumeSee HostNasVolumeSee HostLocalFileSystemVolume
//
//
type DatastoreInfo struct {
	*DynamicData

	// The unique container ID of the datastore, if applicable.
	//
	// Since vSphere API 5.5
	ContainerId string

	// Free space of this datastore, in bytes. The server periodically updates this
	// value. It can be explicitly refreshed with the Refresh operation.
	FreeSpace int64

	// The maximum size of a file that can reside on this file system volume.
	MaxFileSize int64

	// The maximum capacity of a virtual disk which can be created on this volume.
	//
	// Since vSphere API 5.5
	MaxVirtualDiskCapacity int64

	// The name of the datastore.
	Name string

	// Time when the free-space and capacity values in DatastoreInfo and
	// DatastoreSummary were updated.
	//
	// Since vSphere API 4.0
	Timestamp time.Time

	// The unique locator for the datastore.
	Url string
}

//
// Contains a mapping of an old mount path and its corresponding
// resignatured or remounted datastore
//
//
type DatastoreMountPathDatastorePair struct {
	*DynamicData

	// The resignatured or remounted datastore corresponding to the oldMountPath
	Datastore *Datastore

	// Old file path where file system volume is mounted, which
	// should be path value in
	// HostMountInfo
	OldMountPath string
}

//
// The DatastoreNamespaceManager managed object exposes APIs for
// manipulating top-level directories of datastores which do not
// support the traditional top-level directory creation.See topLevelDirectoryCreateSupported
//
type DatastoreNamespaceManager struct {
	*ManagedObject
}

//
// Creates a top-level directory on the given datastore, using the given
// user display name hint and opaque storage policy.
//
// The optional given display name hint may be used by the underlying
// storage system for user display purposes, but it may not be relied
// upon for future directory references.
//
//
// Clients must use the returned stable path for future directory
// references.See DeleteDirectory
//
//
// Required Privileges
// Datastore.Config
//
func (mo *DatastoreNamespaceManager) CreateDirectory(
	_this *ManagedObjectReference, datastore *Datastore, displayName string, policy string,
) (string, error) {

	return "", nil

}

//
// Deletes the given top-level directory from a datastore.
//
// The top-level directory must be a full path of the form
//
//
// /vmfs/volumes/[datastore-uuid]/[directory-uuid]
// as returned by
// CreateDirectory.See CreateDirectory
//
// Required Privileges
// Datastore.Config
//
func (mo *DatastoreNamespaceManager) DeleteDirectory(
	_this *ManagedObjectReference, datacenter *Datacenter, datastorePath string,
) error {

	return nil

}

//
// This exception is thrown if a datastore is not
// writable on the target host.
//
//
type DatastoreNotWritableOnHost struct {
	*InvalidDatastore

	// The target host on which the datastore is not writable.
	Host *HostSystem
}

//
// The DatastoreOption data object describes datastore options
// for a virtual machine.
//
//
type DatastoreOption struct {
	*DynamicData

	// The type of file system volumes on which this virtual machine cannot have
	// its disk and configuration files.
	UnsupportedVolumes []*VirtualMachineDatastoreVolumeOption
}

//
// This event records that a datastore principal was configured on a host.
//
//
type DatastorePrincipalConfigured struct {
	*HostEvent

	DatastorePrincipal string
}

//
// This event records when a datastore is removed from a host
// but not from VirtualCenter.
//
//
type DatastoreRemovedOnHostEvent struct {
	*HostEvent

	// The associated datastore.
	Datastore *DatastoreEventArgument
}

//
// This event records the renaming of a datastore.
//
//
type DatastoreRenamedEvent struct {
	*DatastoreEvent

	// The new datastore name.
	NewName string

	// The old datastore name.
	OldName string
}

//
// This event records when a datastore is added to VirtualCenter
// and is renamed by VirtualCenter because this datastore already
// exists in VirtualCenter with a different name, or because the
// name conflicts with another datastore in VirtualCenter.
//
//
type DatastoreRenamedOnHostEvent struct {
	*HostEvent

	// The new datastore name.
	NewName string

	// The old datastore name.
	OldName string
}

//
// Summary information about the datastore. The status fields and managed object
// reference is not set when an object of this type is created. These fields and
// references are typically set later when these objects are associated with a host.
//
//
type DatastoreSummary struct {
	*DynamicData

	// The connectivity status of this datastore. If this is set to false, meaning the
	// datastore is not accessible, this datastore's capacity and freespace properties
	// cannot be validated. Furthermore, if this property is set to false, some of the
	// properties in this summary and in DatastoreInfo should not be
	// used. Refer to the documentation for the property of your interest.
	//
	// For datastores accessed from multiple hosts, vCenter Server reports
	// accessible as an aggregated value of the
	// properties reported in MountInfo. For instance,
	// if a datastore is accessible through a subset of hosts, then the value of
	// accessible will be reported as true by
	// vCenter Server. And the reason for a daastore being inaccessible from a host
	// will be reported in inaccessibleReason
	Accessible bool

	// Maximum capacity of this datastore, in bytes. This value is updated
	// periodically by the server. It can be explicitly refreshed with the Refresh
	// operation. This property is guaranteed to be valid only if accessible
	// is true.
	Capacity int64

	// The reference to the managed object.
	Datastore *Datastore

	// Available space of this datastore, in bytes. The server periodically
	// updates this value. It can be explicitly refreshed with the Refresh operation.
	// This property is guaranteed to be valid only if accessible is true.
	FreeSpace int64

	// The current maintenance mode state of the datastore. The set of
	// possible values is described in DatastoreSummaryMaintenanceModeState.
	//
	// Since vSphere API 5.0
	MaintenanceMode string

	// More than one host in the datacenter has been configured with access to the
	// datastore. This is only provided by VirtualCenter.
	MultipleHostAccess bool

	// The name of the datastore.
	Name string

	// Type of file system volume, such as VMFS or NFS.See type
	Type string

	// Total additional storage space, in bytes, potentially used by all
	// virtual machines on this datastore. The server periodically updates this
	// value.
	// It can be explicitly refreshed with the RefreshDatastoreStorageInfo operation.
	// This property is valid only if accessible is true.
	//
	// Since vSphere API 4.0
	Uncommitted int64

	// The unique locator for the datastore. This property is guaranteed to be valid
	// only if accessible is true.
	Url string
}

//
// Defines the current maintenance mode state of the datastore.
//
//
type DatastoreSummaryMaintenanceModeState struct {
}

//
// The DateTimeProfile data object represents host date and time configuration.
// Use the policy list for access to configuration data
// for the date and time profile. Use the property list
// for access to subprofiles, if any.
//
//
type DateTimeProfile struct {
	*ApplyProfile
}

type DayOfWeek struct {
}

//
// Thrown on an attempt to use an unsupported delta disk format.
//
//
type DeltaDiskFormatNotSupported struct {
	*VmConfigFault

	// The datastores which do not support the specified format.
	Datastore []*Datastore

	// The format not supported.
	//
	// See DeltaDiskFormat.
	DeltaDiskFormat string
}

//
// Static strings used for describing an object or property.
//
//
type Description struct {
	*DynamicData

	// Display label.
	Label string

	// Summary description.
	Summary string
}

//
// For one of the networks that the virtual machine is using, the corresponding
// switch on the host is full. If returned as part of migration checks, this is an error
// if either of the following is true, a warning otherwise:
//
//
// • The virtual ethernet card device backing is a distributed virtual switch
//
// • The virtual ethernet card device backing is a standard network and the
// the device is connected
//
//
//
//
//
type DestinationSwitchFull struct {
	*CannotAccessNetwork
}

//
// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into a ClusterComputeResource which is
// disabled for VSAN.See CannotMoveVsanEnabledHost
//
//
type DestinationVsanDisabled struct {
	*CannotMoveVsanEnabledHost

	// Name of the disabled destination ClusterComputeResource.See vim.ClusterComputeResource#name
	DestinationCluster string
}

//
// Specification used to create a host device backed virtual disk
//
//
type DeviceBackedVirtualDiskSpec struct {
	*VirtualDiskSpec

	// The deviceName of the backing deviceSee ScsiLun
	Device string
}

//
// The device is backed by a backing type which is not supported
// for this particular device.
//
// If this fault is returned as a subfault of
// DisallowedMigrationDeviceAttached, this indicates that although
// this backing for the device may be supported on the destination
// host, the hosts do not support the requested migration of the
// virtual machine while using this device with this backing.
//
//
//
//
//
type DeviceBackingNotSupported struct {
	*DeviceNotSupported

	// The type of the backing.
	Backing string
}

//
// The device in question is supported, but the device-controller
// combination is not supported.
//
// If this fault is returned as a subfault of
// DisallowedMigrationDeviceAttached, this indicates that although
// this device-controller combination may be supported on the
// destination host, the hosts do not support the requested migration
// of the virtual machine while using this device and controller.
//
//
//
//
//
type DeviceControllerNotSupported struct {
	*DeviceNotSupported

	// The type of the controller.
	Controller string
}

//
// A DeviceHotPlugNotSupported exception is thrown if the specified device
// cannot be hot-added or hot-removed from the virtual machine
// at this time.
//
//
type DeviceHotPlugNotSupported struct {
	*InvalidDeviceSpec
}

//
// A DeviceNotFound exception is thrown if
// a device to be edited or removed
// cannot be found. Most likely, the client incorrectly passed
// the device key.
//
//
type DeviceNotFound struct {
	*InvalidDeviceSpec
}

//
// The virtual machine uses a device type that is not supported on the
// host.
//
// If this fault is returned as a subfault of
// DisallowedMigrationDeviceAttached, this indicates that although
// this device may be supported on the destination host, the hosts do
// not support the requested migration of the virtual machine while
// using this device.
//
//
//
type DeviceNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The label of the device.
	Device string

	// The specific reason why the device is not supported.
	// Values should come from DeviceNotSupportedReason.
	// This might not be set if we're not sure of the reason, or
	// if this doesn't make sense in the context.  For example,
	// in the DisallowedMigrationDeviceAttached context
	// we already know the problem.
	//
	// Since VI API 2.5
	Reason string
}

//
// Reasons why a virtual device would not be supported on a host.
//
//
type DeviceNotSupportedReason struct {
}

//
// A DeviceUnsupportedForVmPlatform exception is thrown if the specified device
// is not supported on the platform on which the virtual machine is being
// created/configured. For example, this exception might be thrown if a client
// incorrectly attempts to add a device supported only on ESX Server to a
// virtual machine on a hosted product.
//
//
type DeviceUnsupportedForVmPlatform struct {
	*InvalidDeviceSpec
}

//
// A DeviceUnsupportedForVmVersion exception is thrown if a specific device
// is not supported for a given version of the virtual machine.
//
//
type DeviceUnsupportedForVmVersion struct {
	*InvalidDeviceSpec

	// The current version of the virtual machine.
	CurrentVersion string

	// The minimum expected virtual mahcine version needed to
	// support this device.
	ExpectedVersion string
}

//
// Provides an interface to get low-level debugging logs or diagnostic bundles
// for a server. For VirtualCenter, this includes the log files
// for the server daemon. For an ESX Server host, this includes detailed
// log files for the VMkernel.
//
type DiagnosticManager struct {
	*ManagedObject
}

//
// Returns part of a log file. Log entries are always returned
// chronologically, typically with the newest event last.
//
// Required Privileges
// Global.Diagnostics
//
func (mo *DiagnosticManager) BrowseDiagnosticLog(
	_this *ManagedObjectReference, host *HostSystem, key string, start int32, lines int32,
) (*DiagnosticManagerLogHeader, error) {

	return nil, nil

}

//
// Instructs the server to generate diagnostic bundles. A diagnostic bundle
// includes log files and other configuration information that can be used
// to investigate potential server issues. Virtual machine and guest
// operation system state is excluded from diagnostic bundles.
//
//
//
// Required Privileges
// Global.Diagnostics
//
func (mo *DiagnosticManager) GenerateLogBundles_Task(
	_this *ManagedObjectReference, includeDefault bool, host []*HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Returns a list of diagnostic files for a given system.
//
// Required Privileges
// Global.Diagnostics
//
func (mo *DiagnosticManager) QueryDescriptions(
	_this *ManagedObjectReference, host *HostSystem,
) ([]*DiagnosticManagerLogDescriptor, error) {

	return nil, nil

}

//
// Describes a location of a diagnostic bundle and the server to which it belongs.
// This is a return type for the generateLogBundles operation.
//
//
type DiagnosticManagerBundleInfo struct {
	*DynamicData

	// The host to which this diagnostic bundle belongs. If this is for the default
	// server, then it is not set.
	System *HostSystem

	// The location from which the diagnostic bundle can be downloaded. The host part
	// of the URL is returned as '*' if the hostname to be used is the name of the
	// server to which the call was made. For example, if the call is made to
	// vcsrv1.domain1.com, and the bundle is available for download from
	// http://vcsrv1.domain1.com/diagnostics/bundle.zip, the URL returned may be
	// http:// * /diagnostics/bundle.zip. The client replaces the asterisk with the
	// server name on which it invoked the call.
	Url string
}

//
// Pre-defined constants for possible creators of log files.
//
//
type DiagnosticManagerLogCreator struct {
}

//
// Describes a log file that is available on a server.
//
//
type DiagnosticManagerLogDescriptor struct {
	*DynamicData

	// The application that generated the log file. For more information on currently
	// supported creators, see DiagnosticManagerLogCreator.
	Creator string

	// The filename of the log.
	FileName string

	// Describes the format of the log file. For more information on currently
	// supported formats, see DiagnosticManagerLogFormat.
	Format string

	// Localized description of log file.
	Info *Description

	// A key to identify the log file for browsing and download operations.
	Key string

	// Describes the mime-type of the returned file. Typical
	// mime-types include:
	//
	// text/plain - for a plain log file
	MimeType string
}

//
// Constants for defined formats. For more information, see the comment for the
// format property.
//
//
type DiagnosticManagerLogFormat struct {
}

//
// A header that is returned with a set of log entries. This header
// describes where entries are located in the log file. Log files typically
// grow dynamically, so indexes based on line numbers may become inaccurate.
//
//
type DiagnosticManagerLogHeader struct {
	*DynamicData

	// The last line of this log segment.
	LineEnd int32

	// The first line of this log segment.
	LineStart int32

	// Log entries, listed by line, for this log segment.
	LineText []string
}

//
// Type of partition indicating the type of storage on which the partition
// resides.  If the diagnostic partition is local only, it will only need
// one slot.  If the diagnostic partition is on shared storage, it could
// be used by multiple hosts.  As a result, it will need multiple slots.
//
//
type DiagnosticPartitionStorageType struct {
}

//
// The type of diagnostic partition. Private diagnostic partition has one
// slot, so can only be used by one host. Shared diagnostic parititon
// needs multiple slots so to be usable by multiple hosts.
//
//
type DiagnosticPartitionType struct {
}

//
// This fault is thrown when an operation fails because the specified
// directory is not empty.
//
//
type DirectoryNotEmpty struct {
	*FileFault
}

//
// Fault thrown when an attempt is made to move a disk with associated snapshots to a destination host.
// If such a move were to occur, snapshots associated with the disk would be irrevocably
// lost.  This is always an error.
//
//
type DisableAdminNotSupported struct {
	*HostConfigFault
}

//
// Fault thrown if the disallowed operation is invoked by the client. The
// change is disallowed because it conflicts with target state maintained
// by a service. The corresponding method is usually not disabled because
// only a subset of changes carried out by the method is disallowed. For
// example, an online extend executed via virtual machine reconfigure
// method is not allowed if replication is enabled on a virtual machine.
//
//
type DisallowedChangeByService struct {
	*RuntimeFault

	// The change this is not allowed, the set of possible values is
	// described in DisallowedChangeByServiceDisallowedChange.
	DisallowedChange string

	// The service that has disallowed the change.
	ServiceName string
}

//
// The disallowed change type.
//
//
type DisallowedChangeByServiceDisallowedChange struct {
}

//
// Thrown when the ReconfigVM_Task operation
// includes a change to the VirtualDiskMode
// property. This property cannot be changed as long as a virtual machine
// has an existing snapshot.
//
//
type DisallowedDiskModeChange struct {
	*InvalidDeviceSpec
}

//
// The virtual machine is using a type of device that prevents migration.
//
//
type DisallowedMigrationDeviceAttached struct {
	*MigrationFault

	// A fault specifies the particular device issue. This is typically
	// a subclass of VirtualHardwareCompatibilityIssue, such as
	// RawDiskNotSupported, RemoteDeviceNotSupported, or SharedBusControllerNotSupported
	Fault *LocalizedMethodFault
}

//
// Fault thrown when an attempt is made to perform a disallowed operation on a
// host that has been configured as a failover host in an cluster that has High
// Availability enabled. See ClusterFailoverHostAdmissionControlPolicy.
// Examples of such operations are destroying a host, moving a host out of a cluster,
// or powering on a virtual machine on a specific host.
//
//
type DisallowedOperationOnFailoverHost struct {
	*RuntimeFault

	// The failover host.
	Host *HostSystem

	// Name of the failover host.
	Hostname string
}

//
// An area of the disk flagged as modified
//
//
type DiskChangeExtent struct {
	*DynamicData

	// Length (in bytes) of modified area
	Length int64

	// Start offset (in bytes) of modified area
	Start int64
}

//
// Data structure to describe areas in a disk associated with this VM that have
// been modified since a well-defined point in the past. Returned by
// QueryChangedDiskAreas. This data structure describes
// a subset of the disk identified by startOffset and length. All areas that
// have been modified within this interval are listed under changedArea.
//
//
type DiskChangeInfo struct {
	*DynamicData

	// Modified disk areas. Might be empty if no parts of the disk between
	// startOffset and startOffset + length were modified.
	ChangedArea []*DiskChangeExtent

	// Length (in bytes) of disk area described by this data structure.
	Length int64

	// Start offset (in bytes) of disk area described by this data structure.
	StartOffset int64
}

//
// Fault used for disks which have existing, non-VSAN partitions.See UpdateDiskPartitionsSee QueryDisksForVsan
//
//
type DiskHasPartitions struct {
	*VsanDiskFault
}

//
// Fault thrown for the case that an attempt is made to delete the last
// DiskMapping#nonSsd from a DiskMapping.See RemoveDisk_TaskSee RemoveDiskMapping_Task
//
//
type DiskIsLastRemainingNonSSD struct {
	*VsanDiskFault
}

//
// Fault used for disks which are ineligible for VSAN because they are
// considered non-local.See QueryDisksForVsan
//
//
type DiskIsNonLocal struct {
	*VsanDiskFault
}

//
// Fault used for disks which are ineligible for VSAN because they are USB
// disks.See QueryDisksForVsan
//
//
type DiskIsUSB struct {
	*VsanDiskFault
}

//
// Specifying non-standard disk movement types is not supported.
// See diskMoveTypeSee diskMoveType
//
//
//
type DiskMoveTypeNotSupported struct {
	*MigrationFault
}

//
// The host does not support the backings for the disks specified by the virtual
// machine. For example, this fault is thrown if a virtual machine is created from
// a template that specifies backings that the host does not have. Similarly, this fault
// is thrown if a virtual machine is registered on a host that does not support the
// specified backings.
//
//
type DiskNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The ID of disk that is not supported.
	Disk int32
}

//
// Fault used for disks which are too small for usage by VSAN.
//
//
type DiskTooSmall struct {
	*VsanDiskFault
}

//
// The DistributedVirtualPort data object represents a port in a
// DistributedVirtualSwitch. Virtual ports are part of a distributed
// virtual portgroup. Servers create virtual ports according to the portgroup type
// (DistributedVirtualPortgroup.config.type).
// See DistributedVirtualPortgroupPortgroupType.
//
//
// • To configure host network access by port, set the distributed virtual port
// in the host virtual NIC specification
// (HostVirtualNicSpec.distributedVirtualPort.portKey).
//
//
// • To configure virtual machine network access by port, set the port
// in the virtual Ethernet card backing
// (VirtualEthernetCard.backing.port.portKey).
//
//
//
//
//
//
type DistributedVirtualPort struct {
	*DynamicData

	// Port configuration, including identifying information, network
	// settings, and the set of entities that can connect to the port.
	Config *DVPortConfigInfo

	// Specifies whether the port is a conflict port. A port could be marked
	// as conflict if an entity is discovered connecting to a port that is
	// already occupied, or if the host creates a port without conferring
	// with vCenter Server.
	//
	// The distributed virtual switch does not persist the runtime state
	// of a conflict port. Also, the port cannot move away from the host.
	// vCenter Server will not move a virtual machine (VMotion) that is
	// using a conflict port.
	Conflict bool

	// If the port is marked conflict in the case of two entities connecting to
	// the same port (see
	// conflict), this is the
	// key of the port which the connected entity is contending for.
	ConflictPortKey string

	// Entity that connects to the port.
	Connectee *DistributedVirtualSwitchPortConnectee

	// Cookie representing the current instance of association between a
	// port and a virtual or physical NIC. See DistributedVirtualSwitchPortConnection.
	// The same cookie is present in the physical or virtual NIC configuration
	// (DistributedVirtualSwitchPortConnection.connectionCookie)
	// so that the Server can verify that the entity is the rightful
	// connectee of the port.
	ConnectionCookie int32

	// UUID of the DistributedVirtualSwitch to which the port belongs.
	DvsUuid string

	// Specifies whether the port is a host local port. A host local port is  created
	// to resurrect the management network connection on a VMkernel virtual NIC.
	// You cannot use vCenter Server to reconfigure this port and you cannot
	// reassign the port.
	//
	// Since vSphere API 5.1
	HostLocalPort bool

	// Port key.
	Key string

	// The last time the
	// state.runtimeInfo
	// value was changed.
	LastStatusChange time.Time

	// Key of the portgroup DistributedVirtualPortgroup to which
	// the port belongs, if any.
	PortgroupKey string

	// HostSystem that services this port.
	ProxyHost *HostSystem

	// Runtime state of the port.
	State *DVPortState
}

//
// The DistributedVirtualPortgroup managed object
// defines how hosts and virtual machines connect to a network.
// A distributed virtual portgroup specifies DistributedVirtualPort
// configuration options for the ports on a DistributedVirtualSwitch.
// A portgroup also represents a Network entity in the datacenter.
//
//
//
// • To configure host access by portgroup, set the portgroup in the host virtual NIC specification
// (HostVirtualNicSpec.portgroup).
//
//
// • To configure virtual machine access by portgroup, set the portgroup
// in the virtual Ethernet card backing
// (VirtualEthernetCard.backing.port.portgroupKey).
//
//
//
//
//
// When you use a portgroup for network access, the Server will create a port according
// to config.type.
//
//
//
type DistributedVirtualPortgroup struct {
	*ManagedObject
	*Network

	config *DVPortgroupConfigInfo

	key string

	portKeys []string
}

// Configuration of the portgroup.
func (mo *DistributedVirtualPortgroup) Config() (*DVPortgroupConfigInfo, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DVPortgroupConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DVPortgroupConfigInfo")
	}
	return v, nil
}

// Generated UUID of the portgroup.
func (mo *DistributedVirtualPortgroup) Key() (string, error) {
	t, err := mo.currentProperty("key")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

// Port keys for the set of ports in the portgroup.
func (mo *DistributedVirtualPortgroup) PortKeys() ([]string, error) {
	t, err := mo.currentProperty("portKeys")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]string)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []string")
	}
	return v, nil
}

//
// This method determines if the portgroup configuration has changed.
// If it has changed, the method returns a
// DVPortgroupConfigSpec.
// Use the ReconfigureDVPortgroup_Task method
// to apply the rollback configuration to the portgroup. You can use the
// rollback method only on a portgroup that is associated with a
// VmwareDistributedVirtualSwitch.
//
//
//
//
// • If you specify the entityBackup parameter, the returned
// configuration specification represents the exported portgroup configuration.
// If the entityBackup matches the current portgroup
// configuration, the method does not return a configuration specification.
//
//
// • If entityBackup is not specified, the returned configuration
// specification represents a previous state of the portgroup, if available.
// When you use a VMware distributed virtual switch, each time you reconfigure
// the switch, the Server saves the switch configuration before applying the updates.
// If the vCenter Server is restarted, the saved configuration is not preserved
// and the method does not return a configuration specification.
//
//
//
//
//
// To use the rollback method, you must have the DVPortgroup.Read privilege.
//
//
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 5.1
//
func (mo *DistributedVirtualPortgroup) DVPortgroupRollback_Task(
	_this *ManagedObjectReference, entityBackup *EntityBackupConfig,
) (*Task, error) {

	return nil, nil

}

//
// Reconfigures one or more distributed virtual portgroups.
// You can use this method to set portgroup properties or
// to reset the portgroup to a previous state.
// Reconfiguring a Standard Distributed Virtual Portgroup
//
// To reconfigure a DistributedVirtualPortgroup,
// use a DVPortgroupConfigSpec
// to set the portgroup properties.
//
//
// Reconfiguring a Portgroup Associated With a VMware Distributed Virtual Switch
//
// If you use a VmwareDistributedVirtualSwitch,
// you can perform the following portgroup reconfiguration:
//
//
//
// • Use a DVPortgroupConfigSpec
// to set the portgroup properties.
//
// • Use the DVPortgroupConfigSpec
// returned by DVPortgroupRollback_Task
// to reset the portgroup to a previous state.
//
//
//
//
// The following privileges are required to reconfigure a portgroup.
//
//
//
// • DVPortgroup.PolicyOp if you are changing the policy of the portgroup.
//
// • DVPortgroup.ScopeOp if you are changing the scope of the portgroup.
//
// • DVPortgroup.Modify for anything else.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *DistributedVirtualPortgroup) ReconfigureDVPortgroup_Task(
	_this *ManagedObjectReference, spec *DVPortgroupConfigSpec,
) (*Task, error) {

	return nil, nil

}

//
// This class describes a DistributedVirtualPortgroup that a device backing
// can be attached to.
//
//
type DistributedVirtualPortgroupInfo struct {
	*DynamicData

	// The portgroup.
	Portgroup *DistributedVirtualPortgroup

	// The key of the portgroup.
	PortgroupKey string

	// The name of the portgroup.
	PortgroupName string

	// The type of portgroup.
	// See DistributedVirtualPortgroupPortgroupType
	PortgroupType string

	// The name of the switch.
	SwitchName string

	// The UUID of the switch.
	SwitchUuid string

	// Whether this portgroup is an uplink portgroup.
	UplinkPortgroup bool
}

//
// The meta tag names recognizable in the
// portNameFormat string.
//
//
type DistributedVirtualPortgroupMetaTagName struct {
}

//
// The DistributedVirtualPortgroupPortgroupType enum defines
// the distributed virtual portgroup types
// (DistributedVirtualPortgroup.config.type). Early binding specifies a static set of ports that are created
// when you create the distributed virtual portgroup. An ephemeral portgroup uses dynamic
// ports that are created when you power on a virtual machine.
//
//
type DistributedVirtualPortgroupPortgroupType struct {
}

//
// A DistributedVirtualSwitch managed object is a virtual network
// switch that is located on a vCenter Server. A distributed virtual switch
// manages configuration for proxy switches (HostProxySwitch).
// A proxy switch is located on an ESXi host that is managed by the vCenter
// Server and is a member of the switch.
// A distributed switch also provides virtual port state management
// so that port state is maintained when vCenter Server operations
// move a virtual machine from one host to another.
//
// A proxy switch performs network I/O to support the following network traffic
// and operations:
//
//
//
// • Network traffic between virtual machines on any hosts that are members
// of the distributed virtual switch.
//
// • Network traffic between virtual machines that uses a distributed switch
// and a virtual machine that uses a VMware standard switch.
//
// • Network traffic between a virtual machine and a remote system
// on a physical network connected to the ESXi host.
//
// • vSphere system operations to support capabilities
// such as VMotion or High Availability.
//
//
//
//
// A DistributedVirtualSwitch is the base distributed
// switch implementation. It supports a VMware distributed virtual
// switch implementation and it supports third party distributed
// switch implementations. The base implementation provides
// the following capabilities
// (DVSFeatureCapability):
//
//
//
//
// • NIC teaming
//
// • Network I/O control
//
// • Network resource allocation
//
// • Quality of service tag support
//
// • User-defined resource pools
//
// • I/O passthrough (VMDirectPath Gen2)
//
//
//
//
// A VmwareDistributedVirtualSwitch
// supports the following additional capabilities
// (DVSFeatureCapability and
// VMwareDVSFeatureCapability):
//
//
//
//
// • Backup, restore, and rollback for a VMware distributed virtual switch
// and its associated portgroups.
//
// • Maximum Transmission Unit (MTU) configuration.
//
// • Health check operations for NIC teaming and VLAN/MTU support.
//
// • Monitoring switch traffic using Internet Protocol Flow Information Export (IPFIX).
//
// • Link Layer Discovery Protocol (LLDP).
//
// • Virtual network segmentation using a Private VLAN (PVLAN).
//
// • VLAN-based SPAN (VSPAN) for virtual distributed port mirroring.
//
// • Link Aggregation Control Protocol (LACP) defined for uplink portgroups.
//
//
//
// Distributed Virtual Switch Configuration
//
// To use a distributed virtual switch, you create a switch and portgroups
// on a vCenter Server, and add hosts as members of the switch.
//
//
//
// • Create a distributed virtual switch
// (Folder.CreateDVS_Task).
// Use a DVSConfigSpec to create a switch
// for a third-party implementation. Use a
// VMwareDVSConfigSpec to create
// a VMware distributed virtual switch.
//
//
// • Create portgroups (CreateDVPortgroup_Task)
// for host and virtual machine network connections and for the connection between
// proxy switches and physical NICs.
// A DistributedVirtualPortgroup specifies how
// virtual ports (DistributedVirtualPort) will be used.
// When you create a distributed virtual switch, the vCenter Server
// automatically creates one uplink portgroup
// (config.uplinkPortgroup).
// Uplink portgroups are distributed virtual portgroups that support
// the connection between proxy switches and physical NICs.
//
// Port creation on a distributed switch is determined by the
// portgroup type
// (DVPortgroupConfigSpec.type):
//
//
//
//
// • If a portgroup is early binding (static), then
// DVPortgroupConfigSpec.numPorts
// determines the number of ports that get created when the portgroup is created.
// This number can be increased if
// DVPortgroupConfigSpec.autoExpand
// is true.
//
//
// • If a portgroup is ephemeral (dynamic), then
// numPorts
// is ignored and ports are created as needed.
//
//
//
//
//
// You can also specify standalone ports that are not associated with
// a port group and uplink ports that are created on ESXi hosts
// (DVSConfigSpec.numStandalonePorts).
//
//
//
// The DVPortgroupConfigInfo.numPorts
// property is the total number of ports for a distributed virtual switch.
// This total includes the ports generated by the static and dynamic portgroups
// and the standalone ports.
//
//
//
//
// • If you have created additional uplink portgroups, use the
// ReconfigureDvs_Task method
// to add the portgroup(s) to the
// DVSConfigSpec.uplinkPortgroup
// array.
//
//
// • Retrieve physical NIC device names from the host
// (HostSystem.config.network.pnic[].device).
//
// • Add host member(s) to the distributed virtual switch. To configure host members:
//
//
//
// • Specify hosts
// (DVSConfigSpec.host[]).
//
// • For each host, specify one or more physical NIC device names
// to identify the pNIC(s) for the host proxy connection to the network
// (DistributedVirtualSwitchHostMemberConfigSpec.backing.pnicSpec[].pnicDevice)
//
//
// • Use the
// DistributedVirtualSwitch.ReconfigureDvs_Task
// method to update the switch configuration.
//
//
//
//
//
// When you add a host to a distributed virtual switch
// (DistributedVirtualSwitch.config.host),
// the host automatically creates a proxy switch. The proxy switch is removed automatically
// when the host is removed from the distributed virtual switch.
//
//
//
// • Connect hosts and virtual machines to the distributed virtual switch.
//
//
//
// Host connection
// Specify port or portgroup connections in the host virtual NIC spec
// (HostVirtualNicSpec.distributedVirtualPort
// or HostVirtualNicSpec.portgroup).
//
//
// Virtual machine connection
// Specify port or portgroup connections in the distributed virtual port backing
// (VirtualEthernetCardDistributedVirtualPortBackingInfo)
// for the virtual Ethernet cards on the virtual machine
// (VirtualEthernetCard.backing).
//
//
//
//
//
//
// Backup, Rollback, and Query Operations
//
// If you are using a VmwareDistributedVirtualSwitch,
// you can perform backup and rollback operations on the switch
// and its associated distributed virtual portgroups.
//
//
// When you reconfigure a VMware distributed virtual switch
// (ReconfigureDvs_Task), the Server
// saves the current switch configuration before applying the
// configuration updates. The saved switch configuration includes
// portgroup configuration data. The Server uses the saved switch
// configuration as a checkpoint for rollback operations.
// You can rollback the switch or portgroup configuration
// to the saved configuration, or you can rollback to a backup
// configuration (EntityBackupConfig).
//
//
//
// • To backup the switch and portgroup configuration, use the
// DistributedVirtualSwitchManager.DVSManagerExportEntity_Task
// method. The export method produces a
// EntityBackupConfig object. The backup configuration
// contains the switch and/or portgroups specified in the
// SelectionSet parameter.
// To backup the complete configuration you must select the
// distributed virtual switch and all of its portgroups.
//
//
// • To rollback the switch configuration, use the
// DVSRollback_Task method
// to determine if the switch configuration has changed.
// If it has changed, use the
// ReconfigureDvs_Task
// method to complete the rollback operation.
//
// • To rollback the portgroup configuration, use the
// DistributedVirtualPortgroup.DVPortgroupRollback_Task
// method to determine if the portgroup configuration
// has changed. If it has changed, use the
// ReconfigureDVPortgroup_Task
// method to complete the rollback operation.
//
//
//
//
// To perform query operations on a distributed virtual switch,
// use the DistributedVirtualSwitchManager methods.
//
//
//
type DistributedVirtualSwitch struct {
	*ManagedEntity

	capability *DVSCapability

	config *DVSConfigInfo

	networkResourcePool []*DVSNetworkResourcePool

	portgroup []*DistributedVirtualPortgroup

	runtime *DVSRuntimeInfo

	summary *DVSSummary

	uuid string
}

// Capability of the switch. Capabilities are indicated at the port,
// portgroup and switch levels, and for version-specific features.
// When you retrieve this property from an ESXi host,
// capability.dvsOperationSupported
// should always be set to false.
func (mo *DistributedVirtualSwitch) Capability() (*DVSCapability, error) {
	t, err := mo.currentProperty("capability")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DVSCapability)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DVSCapability")
	}
	return v, nil
}

// Switch configuration data.
func (mo *DistributedVirtualSwitch) Config() (*DVSConfigInfo, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DVSConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DVSConfigInfo")
	}
	return v, nil
}

// Network resource pool information for the switch.
//
// Since vSphere API 4.1
func (mo *DistributedVirtualSwitch) NetworkResourcePool() ([]*DVSNetworkResourcePool, error) {
	t, err := mo.currentProperty("networkResourcePool")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*DVSNetworkResourcePool)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*DVSNetworkResourcePool")
	}
	return v, nil
}

// Portgroups that are defined on the switch.
func (mo *DistributedVirtualSwitch) Portgroup() ([]*DistributedVirtualPortgroup, error) {
	t, err := mo.currentProperty("portgroup")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*DistributedVirtualPortgroup)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*DistributedVirtualPortgroup")
	}
	return v, nil
}

// Runtime information of the distributed virtual switch.
//
// Since vSphere API 5.1
func (mo *DistributedVirtualSwitch) Runtime() (*DVSRuntimeInfo, error) {
	t, err := mo.currentProperty("runtime")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DVSRuntimeInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DVSRuntimeInfo")
	}
	return v, nil
}

// Summary of the switch.
func (mo *DistributedVirtualSwitch) Summary() (*DVSSummary, error) {
	t, err := mo.currentProperty("summary")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*DVSSummary)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *DVSSummary")
	}
	return v, nil
}

// Generated UUID of the switch. Unique across vCenter Server
// inventory and instances.
func (mo *DistributedVirtualSwitch) Uuid() (string, error) {
	t, err := mo.currentProperty("uuid")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

//
// Creates one or more DistributedVirtualPortgroups and adds them to
// the distributed virtual switch.
//
// Required Privileges
// DVPortgroup.Create
//
func (mo *DistributedVirtualSwitch) AddDVPortgroup_Task(
	_this *ManagedObjectReference, spec []*DVPortgroupConfigSpec,
) (*Task, error) {

	return nil, nil

}

//
// Add a network resource pool.
//
// Required Privileges
// DVSwitch.ResourceManagement
// Since
// vSphere API 5.0
//
func (mo *DistributedVirtualSwitch) AddNetworkResourcePool(
	_this *ManagedObjectReference, configSpec []*DVSNetworkResourcePoolConfigSpec,
) error {

	return nil

}

//
// Creates a single DistributedVirtualPortgroup and adds it
// to the distributed virtual switch.
//
// Required Privileges
// DVPortgroup.Create
// Since
// vSphere API 5.1
//
func (mo *DistributedVirtualSwitch) CreateDVPortgroup_Task(
	_this *ManagedObjectReference, spec *DVPortgroupConfigSpec,
) (*Task, error) {

	return nil, nil

}

//
// This method determines if the distributed virtual switch configuration
// has changed. If it has changed, the method returns a
// VMwareDVSConfigSpec.
// Use the ReconfigureDvs_Task method to apply
// the rollback configuration to the switch.
// You can use the rollback method only on a VmwareDistributedVirtualSwitch.
//
//
//
//
// • If you specify the entityBackup parameter, the returned
// configuration specification represents the exported switch configuration.
// If the entityBackup matches the current switch
// configuration, the method does not return a configuration specification.
//
//
// • If entityBackup is not specified, the returned configuration
// specification represents a previous state of the switch, if available.
// When you use a VMware distributed virtual switch, each time you reconfigure
// the switch, the Server saves the switch configuration before applying the updates.
// If the vCenter Server is restarted, the saved configuration is not preserved
// and the method does not return a configuration specification.
//
//
//
//
//
// To use the rollback method, you must have the DVSwitch.Read privilege.
//
//
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 5.1
//
func (mo *DistributedVirtualSwitch) DVSRollback_Task(
	_this *ManagedObjectReference, entityBackup *EntityBackupConfig,
) (*Task, error) {

	return nil, nil

}

//
// Enable/Disable network I/O control on the vSphere Distributed Switch.
//
// Required Privileges
// DVSwitch.ResourceManagement
// Since
// vSphere API 4.1
//
func (mo *DistributedVirtualSwitch) EnableNetworkResourceManagement(
	_this *ManagedObjectReference, enable bool,
) error {

	return nil

}

//
// Return the keys of ports that meet the criteria. On an ESXi host,
// the property shows only the connected ports currently on the host.
//
// Required Privileges
// System.Read
//
func (mo *DistributedVirtualSwitch) FetchDVPortKeys(
	_this *ManagedObjectReference, criteria *DistributedVirtualSwitchPortCriteria,
) ([]string, error) {

	return nil, nil

}

//
// Return the ports that meet the criteria.
//
// Required Privileges
// System.Read
//
func (mo *DistributedVirtualSwitch) FetchDVPorts(
	_this *ManagedObjectReference, criteria *DistributedVirtualSwitchPortCriteria,
) ([]*DistributedVirtualPort, error) {

	return nil, nil

}

//
// Returns the portgroup identified by the key within this VDS.
//
// Required Privileges
// System.Read
// Since
// vSphere API 5.1
//
func (mo *DistributedVirtualSwitch) LookupDvPortGroup(
	_this *ManagedObjectReference, portgroupKey string,
) (*DistributedVirtualPortgroup, error) {

	return nil, nil

}

// Deprecated.
// as of vSphere API 5.5
//
//
// Merge an existing DistributedVirtualSwitch (source) to this switch
// (destination). The host members and the connected entity of the source
// switch will be transferred to the destination switch. This operation
// disconnects the entities from the source switch, tears down its host
// proxy switches, creates new proxies for the destination switch,
// and reconnects the entities to the destination switch.
//
// In summary, this operation does the following:
//
//
//
// • Adds the
// config.maxPorts
// of the source switch to the maxPorts of the
// destination switch.
//
// • The host members of the source switch leave the source switch
// and join the destination switch with the same Physical NIC and
// VirtualSwitch (if applicable). A set of new uplink ports,
// compliant with the
// uplinkPortPolicy,
// is created as the hosts join the destination switch.
//
// • The portgroups on the source switch are copied over to destination
// switch, by calculating the effective default port config and
// creating a portgroup of the same name in the destination switch. If
// the name already exists, the copied portgroup uses names following a
// "Copy of switch-portgroup-name" scheme to avoid conflict. The same
// number of ports are created inside each copied portgroup.
//
// • The standalone distributed virtual ports are not copied,
// unless there is a virtual
// machine or host virtual NIC connecting to it. In that case, the
// operation calculates the effective port config and creates a port
// in the destination switch with the same name. Name conflict is
// resolved using numbers like "original-port-name(1)". The uplink ports
// are not copied over.
//
// • The virtual machine and host virtual NICs are disconnected from the source
// switch and reconnected with the destination switch, to the
// copied standalone port or portgroup.
//
// • If you are using a VmwareDistributedVirtualSwitch -
// Unless the PVLAN map contains exactly the same entries between
// the source and destination VMware distributed virtual switches,
// the method raises a fault if
// pvlanId
// is set in any port, portgroup, or switch that will be copied.
//
//
//
//
//
// Required Privileges
// DVSwitch.Modify
//
func (mo *DistributedVirtualSwitch) MergeDvs_Task(
	_this *ManagedObjectReference, dvs *DistributedVirtualSwitch,
) (*Task, error) {

	return nil, nil

}

//
// Move the ports out of their current portgroup into the specified portgroup.
// If the moving of any of the ports results in a violation of the portgroup
// policy, or type of the source or destination portgroup, the operation
// raises a fault. A conflict port cannot be moved.
//
// Required Privileges
// DVSwitch.Modify
//
func (mo *DistributedVirtualSwitch) MoveDVPort_Task(
	_this *ManagedObjectReference, portKey []string, destinationPortgroupKey string,
) (*Task, error) {

	return nil, nil

}

//
// This method updates the DistributedVirtualSwitch product specifications.
//
// Required Privileges
// DVSwitch.Modify
//
func (mo *DistributedVirtualSwitch) PerformDvsProductSpecOperation_Task(
	_this *ManagedObjectReference, operation string, productSpec *DistributedVirtualSwitchProductSpec,
) (*Task, error) {

	return nil, nil

}

//
// Return the used VLAN ID (PVLAN excluded) in the switch.
//
// Required Privileges
// System.Read
//
func (mo *DistributedVirtualSwitch) QueryUsedVlanIdInDvs(
	_this *ManagedObjectReference,
) ([]int32, error) {

	return nil, nil

}

//
// Reconfigure individual ports.
//
// Required Privileges
// DVSwitch.PortConfig
//
func (mo *DistributedVirtualSwitch) ReconfigureDVPort_Task(
	_this *ManagedObjectReference, port []*DVPortConfigSpec,
) (*Task, error) {

	return nil, nil

}

//
// Reconfigures a distributed virtual switch. You can use this method
// to set switch properties or to reset the switch to a previous state.
//
//
// Reconfiguring a Standard Distributed Virtual Switch
//
// To reconfigure a DistributedVirtualSwitch,
// use a DVSConfigSpec
// to set the switch properties.
//
//
//
// Reconfiguring a VMware Distributed Virtual Switch
//
// If you use a VmwareDistributedVirtualSwitch,
// you can perform the following switch reconfiguration:
//
//
//
// • Use a VMwareDVSConfigSpec
// to set the switch properties.
//
// • Use the VMwareDVSConfigSpec
// returned by DVSRollback_Task
// to reset the switch to a previous state.
//
//
//
//
// Reconfiguring the switch may require any of the following privileges,
// depending on what is being changed:
//
//
//
// • DVSwitch.PolicyOp if policy
// is set.
//
// • DVSwitch.PortSetting if defaultPortConfig
// is set.
//
// • DVSwitch.HostOp if policy
// is set. The
// user will also need the Host.Config.Network
// privilege on the host.
//
// • DVSwitch.Vspan if vspanConfigSpec
// is set.
//
// • DVSwitch.Modify for anything else.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *DistributedVirtualSwitch) ReconfigureDvs_Task(
	_this *ManagedObjectReference, spec *DVSConfigSpec,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// as of vSphere API 5.0.
// Use
// DistributedVirtualSwitchManager.RectifyDvsOnHost_Task instead.
//
//
// Update the switch configuration on the host to bring them in sync with the
// current configuration in vCenter Server.
//
// Required Privileges
// System.Read
//
func (mo *DistributedVirtualSwitch) RectifyDvsHost_Task(
	_this *ManagedObjectReference, hosts []*HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Refresh port states.
//
// Required Privileges
// System.Read
//
func (mo *DistributedVirtualSwitch) RefreshDVPortState(
	_this *ManagedObjectReference, portKeys []string,
) error {

	return nil

}

//
// Remove a network resource pool.
//
// Required Privileges
// DVSwitch.ResourceManagement
// Since
// vSphere API 5.0
//
func (mo *DistributedVirtualSwitch) RemoveNetworkResourcePool(
	_this *ManagedObjectReference, key []string,
) error {

	return nil

}

//
// Set the capability of the switch.
//
// Required Privileges
// DVSwitch.Modify
//
func (mo *DistributedVirtualSwitch) UpdateDvsCapability(
	_this *ManagedObjectReference, capability *DVSCapability,
) error {

	return nil

}

//
// Update health check configuration.
//
// Required Privileges
// DVSwitch.Modify
// Since
// vSphere API 5.1
//
func (mo *DistributedVirtualSwitch) UpdateDVSHealthCheckConfig_Task(
	_this *ManagedObjectReference, healthCheckConfig []*DVSHealthCheckConfig,
) (*Task, error) {

	return nil, nil

}

//
// Update the network resource pool configuration.
//
// Required Privileges
// DVSwitch.ResourceManagement
// Since
// vSphere API 4.1
//
func (mo *DistributedVirtualSwitch) UpdateNetworkResourcePool(
	_this *ManagedObjectReference, configSpec []*DVSNetworkResourcePoolConfigSpec,
) error {

	return nil

}

//
// List of possible host infrastructure traffic classes
//
//
type DistributedVirtualSwitchHostInfrastructureTrafficClass struct {
}

//
// The DistributedVirtualSwitchHostMember data object represents an ESXi host that
// is a member of a distributed virtual switch. When you add a host to a switch
// (DistributedVirtualSwitchHostMemberConfigSpec.host),
// the Server creates a proxy switch (HostProxySwitch).
// The host member object contains information about the configuration
// and state of the proxy.
//
//
type DistributedVirtualSwitchHostMember struct {
	*DynamicData

	// Host member configuration.
	Config *DistributedVirtualSwitchHostMemberConfigInfo

	// Vendor, product and version information for the proxy switch
	// module.
	ProductInfo *DistributedVirtualSwitchProductSpec

	// Host member runtime state.
	//
	// Since vSphere API 5.0
	RuntimeState *DistributedVirtualSwitchHostMemberRuntimeState

	// Deprecated.
	// As of vSphere API 5.1, use
	// HostMemberRuntimeInfo.status instead.
	//
	//
	// The host DistributedVirtualSwitch component status. See
	// HostComponentState for valid values.
	Status string

	// Deprecated.
	// As of vSphere API 5.1, use
	// HostMemberRuntimeInfo.statusDetail instead.
	//
	//
	// Additional information regarding the host's current status.
	//
	// Since vSphere API 4.1
	StatusDetail string

	// Port keys of the uplink ports created for the host member. These ports
	// will be deleted after the host leaves the switch.
	UplinkPortKey []string
}

//
// Base class.
//
//
type DistributedVirtualSwitchHostMemberBacking struct {
	*DynamicData
}

//
// The DistributedVirtualSwitchHostMemberConfigInfo data object
// contains membership configuration information for the ESXi host.
//
//
type DistributedVirtualSwitchHostMemberConfigInfo struct {
	*DynamicData

	// Host membership backing, specifying physical NIC, portgroup, and port
	// bindings for the proxy switch.
	Backing *DistributedVirtualSwitchHostMemberBacking

	// ESXi host.
	// This property should always be set unless the user's setting
	// does not have System.Read privilege on the object referred to
	// by this property.
	Host *HostSystem

	// Maximum number of ports than can be created in the proxy switch.
	//
	// ESXi 5.0 and earlier hosts:
	// If you change the maximum number of ports, you must reboot
	// the host for the new value to take effect.
	MaxProxySwitchPorts int32

	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob
}

//
// Specification to create or reconfigure ESXi host membership
// in a DistributedVirtualSwitch.
//
//
type DistributedVirtualSwitchHostMemberConfigSpec struct {
	*DynamicData

	// Specifies the physical NICs to use as backing for the proxy switch
	// on the host.
	Backing *DistributedVirtualSwitchHostMemberBacking

	// Identifies a host member of a DistributedVirtualSwitch
	// for a CreateDVS_Task or
	// DistributedVirtualSwitch.ReconfigureDvs_Task operation.
	Host *HostSystem

	// Maximum number of ports allowed in the HostProxySwitch.
	//
	// ESXi 5.0 and earlier hosts: If you are reconfiguring an existing
	// host membership, that is, the proxy switch already exists, you must reboot
	// the host for the new setting to take effect.
	MaxProxySwitchPorts int32

	// Host member operation type. See
	// ConfigSpecOperation for valid values.
	Operation string

	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []*DistributedVirtualSwitchKeyedOpaqueBlob
}

//
// Describes the state of the host proxy switch.
//
//
type DistributedVirtualSwitchHostMemberHostComponentState struct {
}

//
// The DistributedVirtualSwitchHostMemberPnicBacking data object
// specifies a set of physical NICs to use for a proxy switch.
// When you add a host to a distributed virtual switch
// (DistributedVirtualSwitchHostMemberConfigSpec.host),
// the host creates a proxy switch that will use the pNICs as uplinks.
//
//
type DistributedVirtualSwitchHostMemberPnicBacking struct {
	*DistributedVirtualSwitchHostMemberBacking

	// List of physical NIC specifications. Each entry identifies
	// a pNIC to the proxy switch and optionally specifies uplink
	// portgroup and port connections for the pNIC.
	PnicSpec []*DistributedVirtualSwitchHostMemberPnicSpec
}

//
// Specification for an individual physical NIC.
//
//
type DistributedVirtualSwitchHostMemberPnicSpec struct {
	*DynamicData

	// Cookie that represents this DistributedVirtualSwitchPortConnection
	// instance for the port. The cookie value is generated by the
	// Server. The Server ignores any value set by an SDK client.
	//
	// The same cookie is present in the distributed virtual port configuration
	// (DistributedVirtualPort.connectionCookie)
	// so that the Server can verify that the entity is the rightful
	// connectee of the port.
	ConnectionCookie int32

	// Name of the physical NIC to be added to the proxy switch.
	// See PhysicalNic.device.
	PnicDevice string

	// Key of the portgroup to be connected to the physical NIC.
	UplinkPortgroupKey string

	// Key of the port to be connected to the physical NIC.
	UplinkPortKey string
}

//
// Runtime state of a host member.
//
//
type DistributedVirtualSwitchHostMemberRuntimeState struct {
	*DynamicData

	// Current maximum number of ports allowed to be created in the
	// proxy switch.
	CurrentMaxProxySwitchPorts int32
}

//
// This data object type is a subset of AboutInfo. An object of
// this type can be used to describe the specification for a host.
//
//
type DistributedVirtualSwitchHostProductSpec struct {
	*DynamicData

	// The product-line name.
	ProductLineId string

	// Dot-separated version string. For example, "1.2".
	Version string
}

//
// This class describes a DistributedVirtualSwitch that a device backing
// can attached to its ports.
//
//
type DistributedVirtualSwitchInfo struct {
	*DynamicData

	// The switch.
	DistributedVirtualSwitch *DistributedVirtualSwitch

	// The name of the switch.
	SwitchName string

	// The UUID of the switch.
	SwitchUuid string
}

//
// This class defines a data structure to hold opaque binary data
// identified by a key.
//
//
type DistributedVirtualSwitchKeyedOpaqueBlob struct {
	*DynamicData

	// A key that identifies the opaque binary blob.
	Key string

	// The opaque data. It is recommended that base64 encoding be used for binary
	// data.
	OpaqueData string
}

//
// The DistributedVirtualSwitchManager provides methods
// that support the following operations:
//
//
// • Backup and restore operations for VmwareDistributedVirtualSwitch
// and associated DistributedVirtualPortgroup managed objects.
//
// • Query operations for information about portgroups and distributed
// virtual switches.
//
// • Distributed virtual switch configuration update operations.
//
//
//
//
type DistributedVirtualSwitchManager struct {
	*ManagedObject
}

//
// Export the configuration for entities specified in the
// selectionSet parameter. You can use this method only
// for a VmwareDistributedVirtualSwitch and its
// associated DistributedVirtualPortgroup objects.
//
// Use the DVSManagerImportEntity_Task method to restore the entity
// to the state represented by the exported configuration.
// You can also use the exported configuration to create
// a new switch or portgroup.
//
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 5.1
//
func (mo *DistributedVirtualSwitchManager) DVSManagerExportEntity_Task(
	_this *ManagedObjectReference, selectionSet []*SelectionSet,
) (*Task, error) {

	return nil, nil

}

//
// Import the configuration of entities specified in
// EntityBackupConfig. You can restore the
// existing configuration to the state represented by the
// backup configuration. You can also use the backup
// configuration to create a new switch or portgroup.
// See EntityImportType.
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 5.1
//
func (mo *DistributedVirtualSwitchManager) DVSManagerImportEntity_Task(
	_this *ManagedObjectReference, entityBackup []*EntityBackupConfig, importType string,
) (*Task, error) {

	return nil, nil

}

//
// Returns the portgroup identified by the key within the specified VDS
// identified by its UUID.
//
// Required Privileges
// System.View
// Since
// vSphere API 5.1
//
func (mo *DistributedVirtualSwitchManager) DVSManagerLookupDvPortGroup(
	_this *ManagedObjectReference, switchUuid string, portgroupKey string,
) (*DistributedVirtualPortgroup, error) {

	return nil, nil

}

//
// This operation returns a list of switch product specifications that
// are supported by the vCenter Server.
//
// Required Privileges
// System.View
//
func (mo *DistributedVirtualSwitchManager) QueryAvailableDvsSpec(
	_this *ManagedObjectReference,
) ([]*DistributedVirtualSwitchProductSpec, error) {

	return nil, nil

}

//
// This operation returns a list of hosts that are compatible with
// the given DistributedVirtualSwitch product specification.
//
// Required Privileges
// System.View
//
func (mo *DistributedVirtualSwitchManager) QueryCompatibleHostForExistingDvs(
	_this *ManagedObjectReference, container *ManagedEntity, recursive bool, dvs *DistributedVirtualSwitch,
) ([]*HostSystem, error) {

	return nil, nil

}

//
// This operation returns a list of hosts that are compatible with
// the given DistributedVirtualSwitch product specification.
//
// Required Privileges
// System.View
//
func (mo *DistributedVirtualSwitchManager) QueryCompatibleHostForNewDvs(
	_this *ManagedObjectReference, container *ManagedEntity, recursive bool, switchProductSpec *DistributedVirtualSwitchProductSpec,
) ([]*HostSystem, error) {

	return nil, nil

}

//
// This operation returns a DistributedVirtualSwitch given a UUID.
//
// Required Privileges
// System.View
//
func (mo *DistributedVirtualSwitchManager) QueryDvsByUuid(
	_this *ManagedObjectReference, uuid string,
) (*DistributedVirtualSwitch, error) {

	return nil, nil

}

//
// This operation returns a list of compatibility results. Each compatibility result
// is an object that has a host property and optionally a fault which would
// be populated only if that host is not compatible with a given dvsProductSpec.
// All filters in hostFilerSpecs are ANDed to derive the intersection of hosts against
// which compatibility is checked. If caller did not have view privileges on the
// host entity in an element of the CompatibilityResult array, then that entire
// element would be removed from the CompatibilityResult array.
// Typical uses:
//
//
// •
// For the createDVS situation, hostFilterSpec is of type HostDvsFilterSpec and DvsProductSpec
// will have newSwitchProductSpec set.
//
// •
// For the Add-Host-To-DVS situation, you can use either HostDvsFilterSpec or
// HostDvsMembershipFilter with inclusive being false, and pass the DVS in DvsProductSpec.
//
// •
// For the Upgrade-DVS situation, you can use either HostDvsFilterSpec or
// HostDvsMembershipFilter with inclusive being true, and pass the new desired ProductSpec
// for DVS in newSwitchProductSpec.
//
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 4.1
//
func (mo *DistributedVirtualSwitchManager) QueryDvsCheckCompatibility(
	_this *ManagedObjectReference, hostContainer *DistributedVirtualSwitchManagerHostContainer, dvsProductSpec *DistributedVirtualSwitchManagerDvsProductSpec, hostFilterSpec []*DistributedVirtualSwitchManagerHostDvsFilterSpec,
) ([]*DistributedVirtualSwitchManagerCompatibilityResult, error) {

	return nil, nil

}

//
// This operation returns a list of host product specifications that
// are compatible with the given DistributedVirtualSwitch product
// specification.
//
// Required Privileges
// System.View
//
func (mo *DistributedVirtualSwitchManager) QueryDvsCompatibleHostSpec(
	_this *ManagedObjectReference, switchProductSpec *DistributedVirtualSwitchProductSpec,
) ([]*DistributedVirtualSwitchHostProductSpec, error) {

	return nil, nil

}

//
// This operation returns the DistributedVirtualSwitch or
// DistributedVirtualPortgroup configuration target on a host.
//
// Required Privileges
// System.View
//
func (mo *DistributedVirtualSwitchManager) QueryDvsConfigTarget(
	_this *ManagedObjectReference, host *HostSystem, dvs *DistributedVirtualSwitch,
) (*DVSManagerDvsConfigTarget, error) {

	return nil, nil

}

//
// This operation indicates which version-specific DVS features are
// available for the given DistributedVirtualSwitch product specification.
//
// Required Privileges
// System.View
// Since
// vSphere API 4.1
//
func (mo *DistributedVirtualSwitchManager) QueryDvsFeatureCapability(
	_this *ManagedObjectReference, switchProductSpec *DistributedVirtualSwitchProductSpec,
) (*DVSFeatureCapability, error) {

	return nil, nil

}

//
// Update the Distributed Switch configuration on the hosts to bring them in sync with the
// current configuration in vCenter Server.
//
// Required Privileges
// System.Read
// Since
// vSphere API 5.0
//
func (mo *DistributedVirtualSwitchManager) RectifyDvsOnHost_Task(
	_this *ManagedObjectReference, hosts []*HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// This is the return type for the checkCompatibility method. This object
// has a host property and optionally a fault which would
// be populated only if that host is not compatible with a given dvsProductSpec.
// If the host is compatible then the error property would be unset.
//
//
type DistributedVirtualSwitchManagerCompatibilityResult struct {
	*DynamicData

	// This property contains the faults that makes the host not compatible
	// with a given DvsProductSpec. For example, a host might not be compatible
	// because it's an older version of ESX that doesn't support DVS.
	Error []*LocalizedMethodFault

	// The host for which results are annotated. The whole object will be
	// filtered out if the caller did not have view permissions on the
	// host entity.
	Host *HostSystem
}

//
// This class is used to specify ProductSpec for the DVS. The two properties are
// strictly mutually exclusive. If both properties are set, then
// an InvalidArgument fault would be thrown.
//
//
type DistributedVirtualSwitchManagerDvsProductSpec struct {
	*DynamicData

	// Get ProductSpec from the existing DVS
	DistributedVirtualSwitch *DistributedVirtualSwitch

	// The ProductSpec for new DVS
	NewSwitchProductSpec *DistributedVirtualSwitchProductSpec
}

//
// Check host compatibility against all hosts specified in the array.
//
//
type DistributedVirtualSwitchManagerHostArrayFilter struct {
	*DistributedVirtualSwitchManagerHostDvsFilterSpec

	// List of hosts to consider.
	Host []*HostSystem
}

//
// Check host compatibility for all hosts in the container. If the recursive
// flag is true, then check hosts at all levels within this container, otherwise
// check only at the container level. In case of container being a Datacenter,
// the recursive flag is applied to its HostFolder.
//
//
type DistributedVirtualSwitchManagerHostContainer struct {
	*DynamicData

	// Check compatibility of hosts in this container. The supported container
	// types are Datacenter, Folder, and ComputeResource.
	Container *ManagedEntity

	// If true, include hosts of all levels in the hierarchy with
	// container as root of the tree. In case of container being a Datacenter,
	// the recursive flag is applied to its HostFolder.
	Recursive bool
}

//
// Check host compatibility against all hosts in this
// DistributedVirtualSwitchManagerHostContainer
//
//
type DistributedVirtualSwitchManagerHostContainerFilter struct {
	*DistributedVirtualSwitchManagerHostDvsFilterSpec

	// Container of hosts that are part of the filter.
	HostContainer *DistributedVirtualSwitchManagerHostContainer
}

//
// Base class for filters to check host compatibility.
//
//
type DistributedVirtualSwitchManagerHostDvsFilterSpec struct {
	*DynamicData

	// If this flag is true, then the filter returns the hosts in the
	// DistributedVirtualSwitchManagerHostContainer
	// that satisfy the criteria specified by this filter, otherwise
	// it returns hosts that don't meet the criteria.
	Inclusive bool
}

//
// Check host compatibility against all hosts in the DVS (or not in the DVS if
// inclusive flag in base class is false)
//
//
type DistributedVirtualSwitchManagerHostDvsMembershipFilter struct {
	*DistributedVirtualSwitchManagerHostDvsFilterSpec

	DistributedVirtualSwitch *DistributedVirtualSwitch
}

//
// The DistributedVirtualSwitchManagerImportResult
// data object represents the results of a
// DVSManagerImportEntity_Task
// operation. It contains lists of the switches and portgroups
// that were created. It also contains a list of faults
// that occurred during the operation.
//
//
type DistributedVirtualSwitchManagerImportResult struct {
	*DynamicData

	// List of distributed virtual portgroups.
	DistributedVirtualPortgroup []*DistributedVirtualPortgroup

	// List of distributed virtual switches.
	DistributedVirtualSwitch []*DistributedVirtualSwitch

	// Faults that occurred on the entities during the import operation.
	ImportFault []*ImportOperationBulkFaultFaultOnImport
}

//
// List of possible teaming modes supported by the vNetwork Distributed
// Switch. The different policy modes define the way traffic is routed
// through the different uplink ports in a team.
//
//
type DistributedVirtualSwitchNicTeamingPolicyMode struct {
}

//
// Information about the entity that connects to a DistributedVirtualPort.
//
//
type DistributedVirtualSwitchPortConnectee struct {
	*DynamicData

	// A hint on address information of the NIC that connects to this port.
	AddressHint string

	// The connected entity.
	// This property should always be set unless the user's setting
	// does not have System.Read privilege on the object referred to
	// by this property.
	ConnectedEntity *ManagedEntity

	// The key of the virtual NIC that connects to this port.
	NicKey string

	// The type of the connectee.
	// See ConnecteeType for valid values.
	Type string
}

//
// The connectee types.
//
//
type DistributedVirtualSwitchPortConnecteeConnecteeType struct {
}

//
// The DistributedVirtualSwitchPortConnection data object represents a connection
// or association between a DistributedVirtualPortgroup or a
// DistributedVirtualPort and one of the following entities:
//
//
// • Virtual machine virtual NIC
// (VirtualEthernetCardDistributedVirtualPortBackingInfo)
//
// • Host virtual NIC (HostVirtualNic)
//
// • Physical NIC (HostNetworkInfo.pnic)
//
//
//
//
//
type DistributedVirtualSwitchPortConnection struct {
	*DynamicData

	// Cookie that represents this DistributedVirtualSwitchPortConnection
	// instance for the port. The cookie value is generated by the
	// Server. The Server ignores any value set by an SDK client.
	//
	// The same cookie is present in the distributed virtual port configuration
	// (DistributedVirtualPort.connectionCookie)
	// so that the Server can verify that the entity is the rightful
	// connectee of the port.
	ConnectionCookie int32

	// Key of the portgroup. If specified, the connection object represents a connection
	// or an association between a DistributedVirtualPortgroup
	// and a Virtual NIC or physical NIC.
	// In this case, setting the portKey is not necessary for a
	// early-binding portgroup and is not allowed for a late-binding portgroup.
	// The portKey property will be populated by the implementation
	// at the time of port binding.
	PortgroupKey string

	// Key of the port. If specified, this object represents a connection
	// or an association between an individual DistributedVirtualPort
	// and a Virtual NIC or physical NIC. See portgroupKey for more information on populating
	// this property.
	PortKey string

	// UUID of the switch (DistributedVirtualSwitch.uuid).
	SwitchUuid string
}

//
// The criteria specification for selecting ports.
//
//
type DistributedVirtualSwitchPortCriteria struct {
	*DynamicData

	// If set, only the active ports are qualified.
	Active bool

	// If set, only the connected ports are qualified.
	Connected bool

	// If unset, all ports in the switch are qualified.
	// If set to true, only ports inside portgroupKey or any
	// portgroup, if not set, are qualified.
	// If set to false, only ports outside portgroupKey or any
	// portgroup, if not set, are qualified.
	Inside bool

	// The keys of the portgroup that is used for the scope of inside.
	// If this property is unset, it means any portgroup. If inside
	// is unset, this property is ignored.
	PortgroupKey []string

	// If set, only the ports of which the key is in the array are
	// qualified.
	PortKey []string

	// Deprecated.
	// as of vSphere API 5.5
	//
	//
	// If set, only the ports of which the scope covers the entity are
	// qualified.
	Scope *ManagedEntity

	// If set to true, only the uplink ports are qualified. If set to false, only
	// non-uplink ports are qualified.
	UplinkPort bool
}

//
// Statistic data of a DistributedVirtualPort.
//
//
type DistributedVirtualSwitchPortStatistics struct {
	*DynamicData

	// The number of bytes received from broadcast packets.
	BytesInBroadcast int64

	// The number of bytes received from multicast packets.
	BytesInMulticast int64

	// The number of bytes received from unicast packets.
	BytesInUnicast int64

	// The number of bytes forwarded from broadcast packets.
	BytesOutBroadcast int64

	// The number of bytes forwarded from multicast packets.
	BytesOutMulticast int64

	// The number of bytes forwarded from unicast packets.
	BytesOutUnicast int64

	// The number of broadcast packets received.
	PacketsInBroadcast int64

	// The number of received packets dropped.
	PacketsInDropped int64

	// The number of packets received that cause an exception.
	PacketsInException int64

	// The number of multicast packets received.
	PacketsInMulticast int64

	// The number of unicast packets received.
	PacketsInUnicast int64

	// The number of broadcast packets forwarded.
	PacketsOutBroadcast int64

	// The number of packets to be forwarded dropped.
	PacketsOutDropped int64

	// The number of packets to be forwarded that cause an exception.
	PacketsOutException int64

	// The number of multicast packets forwarded.
	PacketsOutMulticast int64

	// The number of unicast packets forwarded.
	PacketsOutUnicast int64
}

//
// This data object type is a subset of AboutInfo. An object of
// this type can be used to describe the specification for a proxy switch module
// of a DistributedVirtualSwitch.
//
//
type DistributedVirtualSwitchProductSpec struct {
	*DynamicData

	// Build string for the server on which this call is made. For example, x.y.z-num.
	// This string does not apply to the API.
	Build string

	// The ID of the bundle if a host component bundle needs to be installed on
	// the host members to support the functionality of the switch.
	BundleId string

	// The URL of the bundle that VMware Update Manager will use to install
	// the bundle on the host members, if bundleId is set.
	BundleUrl string

	// Forwarding class of the distributed virtual switch.
	ForwardingClass string

	// Short form of the product name.
	Name string

	// Name of the vendor of this product.
	Vendor string

	// Dot-separated version string. For example, "1.2".
	Version string
}

//
// The product spec operation types.
//
//
type DistributedVirtualSwitchProductSpecOperationType struct {
}

//
// Fault indicating that the domain controller
// for domainName cannot be reached.
//
//
type DomainNotFound struct {
	*ActiveDirectoryFault

	// The domain that cannot be accessed.
	DomainName string
}

type DpmBehavior struct {
}

type DrsBehavior struct {
}

//
// This event records when DRS is disabled on a cluster.
//
//
type DrsDisabledEvent struct {
	*ClusterEvent
}

//
// This fault is thrown when DRS cannot move a virtual machine because
// DRS is disabled on it (i.e., it is pinned on its registered host).
//
//
type DrsDisabledOnVm struct {
	*VimFault
}

//
// This event records when DRS is enabled on a cluster.
//
//
type DrsEnabledEvent struct {
	*ClusterEvent

	// The DRS automation level in (DrsBehavior)
	Behavior string
}

//
// This event records that the host has successfully entered standby mode initiated by
// Distributed Power Management. A host in this mode has no running virtual
// machines and no provisioning operations are occurring.
//
//
type DrsEnteredStandbyModeEvent struct {
	*EnteredStandbyModeEvent
}

//
// This event records that a host has begun the process of
// entering standby mode initiated by Distributed Power Management.
//
//
type DrsEnteringStandbyModeEvent struct {
	*EnteringStandbyModeEvent
}

//
// This event records that Distributed Power Managment tried to bring a host out
// from standby mode, but the host failed to exit standby mode.
//
//
type DrsExitStandbyModeFailedEvent struct {
	*ExitStandbyModeFailedEvent
}

//
// This event records that Distributed Power Management brings this host
// out from standby mode.
//
//
type DrsExitedStandbyModeEvent struct {
	*ExitedStandbyModeEvent
}

//
// This event records that a host has begun the process of
// exiting standby mode initiated by Distributed Power Management.
//
//
type DrsExitingStandbyModeEvent struct {
	*ExitingStandbyModeEvent
}

//
// Correlation state as computed by storageRM
// module on host.
//
//
type DrsInjectorWorkloadCorrelationState struct {
}

//
// This event records DRS invocation failure.
//
//
type DrsInvocationFailedEvent struct {
	*ClusterEvent
}

// Deprecated.
// As of VI API 2.5 use RecommendationReasonCode.
//
//
// List of defined migration reason codes:
//
//
type DrsRecommendationReasonCode struct {
}

//
// This event records that DRS has recovered from failure.
// It is triggered by a successful DRS invocation after repeated failure.
//
//
type DrsRecoveredFromFailureEvent struct {
	*ClusterEvent
}

//
// This event records when resource configuration
// specification synchronization fails on a host.
//
//
type DrsResourceConfigureFailedEvent struct {
	*HostEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records when resource configuration
// specification returns to synchronized from previous failure.
//
//
type DrsResourceConfigureSyncedEvent struct {
	*HostEvent
}

//
// This event records when a virtual machine comes into compliance with DRS rules.
//
//
type DrsRuleComplianceEvent struct {
	*VmEvent
}

//
// This event records when a virtual machine violates a DRS rule.
//
//
type DrsRuleViolationEvent struct {
	*VmEvent
}

//
// This event records a virtual machine migration that was recommended by DRS.
//
//
type DrsVmMigratedEvent struct {
	*VmMigratedEvent
}

//
// This event records when a virtual machine is powered on by DRS.
//
//
type DrsVmPoweredOnEvent struct {
	*VmPoweredOnEvent
}

//
// This fault is thrown when DRS tries to migrate a virtual machine to a host,
// but finds that the host is incompatible with the given virtual machine.
//
//
type DrsVmotionIncompatibleFault struct {
	*VirtualHardwareCompatibilityIssue

	// The host that is incompatible with a given virtual machine.
	Host *HostSystem
}

//
// Fault used to denote a duplicate set of disks were incorrectly specified
// for a given operation.See AddDisks_TaskSee InitializeDisks_Task
//
//
type DuplicateDisks struct {
	*VsanDiskFault
}

//
// This event records that a duplicate IP address has been observed in
// conflict with the vmotion or IP storage interface configured on the
// host.
//
//
type DuplicateIpDetectedEvent struct {
	*HostEvent

	// The Duplicate IP address detected.
	DuplicateIP string

	// The MAC associated with duplicate IP.
	MacAddress string
}

//
// A DuplicateName exception is thrown because a name already exists
// in the same name space.
//
//
type DuplicateName struct {
	*VimFault

	// The name that is already bound in the name space.
	Name string

	// Managed object that already holds the name.
	Object *ManagedObjectReference
}

//
// Fault thrown for cases that duplicate network interface names are
// incorrectly specified for a VSAN operation.See UpdateVsan_TaskSee ReconfigureComputeResource_Task
//
//
type DuplicateVsanNetworkInterface struct {
	*VsanFault

	// The network interface name found to be duplicated.
	Device string
}

//
// This event is generated when an import operation is
// performed on a distributed virtual portgroup
//
//
type DvpgImportEvent struct {
	*DVPortgroupEvent

	// The type of restore operation. See  EntityImportType for valid values
	ImportType string
}

//
// This event is generated when a restore operation is
// performed on a distributed virtual portgroup
//
//
type DvpgRestoreEvent struct {
	*DVPortgroupEvent
}

//
// This class defines network rule action to accept packets.
//
//
type DvsAcceptNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

//
// Thrown if a vSphere Distributed Switch apply operation failed to set or remove
// some of the specified objects.
//
//
type DvsApplyOperationFault struct {
	*DvsFault

	// Faults occured on the host during a DistributedVirtualSwitch operation.
	ObjectFault []*DvsApplyOperationFaultFaultOnObject
}

//
// The fault occured during an apply operation.
//
//
type DvsApplyOperationFaultFaultOnObject struct {
	*DynamicData

	// The fault that occured.
	Fault *LocalizedMethodFault

	// The object identifier. It should be UUID for vSphere Distributed Switches,
	// keys for vNetwork distributed portgroups and ports.
	ObjectId string

	// The Type of the objects.
	Type string
}

//
// This class defines network rule action to copy the packet to an
//
// associated slow-path service Virtual Machine and let the original
//
// frame continue.
//
//
type DvsCopyNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

//
// A distributed virtual switch was created.
//
//
type DvsCreatedEvent struct {
	*DvsEvent

	// The folder where the DistributedVirtualSwitch is created.
	Parent *FolderEventArgument
}

//
// A distributed virtual switch was destroyed.
//
//
type DvsDestroyedEvent struct {
	*DvsEvent
}

//
// This class defines network rule action to drop packets.
//
//
type DvsDropNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

//
// These are dvs-related events.
//
//
type DvsEvent struct {
	*Event
}

//
// The event argument is a Host object.
//
//
type DvsEventArgument struct {
	*EntityEventArgument

	// The distributed virtual switch object.
	Dvs *DistributedVirtualSwitch
}

//
// Base class for faults that can be thrown while invoking a distributed virtual switch
// operation.
//
//
type DvsFault struct {
	*VimFault
}

//
// This class defines Network Filter configuration.
// Supported Qualifier and Actions
//
type DvsFilterConfig struct {
	*InheritablePolicy
}

//
// The specification to reconfigure Network Filter.
// This specification allows the user to do fine-grained updates for the
// Filter in the port settings.
// If the operation is remove, only the
// FilterConfigSpec#key needs to be specified.
// If other fields are specified, they will be ignored. We cannot remove
// an inherited element. Only when the inherited flag is set to false and
// parent does not have an element with same key this operation succeeds.
// If the operation is add, then
// FilterConfigSpec#key should not be specified and
// other fields need to be specified. The inherited flag should be set to
// false.
// If the operation is edit, then
// FilterConfigSpec#key needs be specified and
// specify the other properties that need modification. If the inherited
// flag is set to true, a FilterConfig object of same
// key must exist at the parent's level. The property values in the spec
// object will be ignored and use the values from the parent's
// FilterConfig object instead. If inherited
// flag is set to false, then the new modifications will be applied.
//
//
type DvsFilterConfigSpec struct {
	*DvsFilterConfig

	// Operation type. See ConfigSpecOperation for valid values.
	Operation string
}

//
// Network Filter on Failure Type. It specifies whether all the
// packets will be allowed or all the packets will be denied when
// Filter fails to configure.
//
//
type DvsFilterOnFailure struct {
}

//
// This class defines Network Filter parameter.
//
//
type DvsFilterParameter struct {
	*DynamicData

	// List of parameters for a Network Filter.
	Parameters []string
}

//
// This class defines Network Filter Policy.
//
//
type DvsFilterPolicy struct {
	*InheritablePolicy

	// List of Network Filter Configurations.
	// In an update operation, the array can contain all
	// DvsTrafficFilterConfigSpec objects
	// or all DvsFilterConfig and
	// DvsTrafficFilterConfig
	// object, but not mixed of Config and Spec objects. If array of
	// FilterConfigSpec and TrafficFilterConfigSpec is used
	// for updating Network Filter then only the Network Filters
	// matching key /
	// key
	// is updated.
	// If array of DvsFilterConfig and
	// DvsTrafficFilterConfig
	// is used for updating port settings, the Network Filter
	// settings will be overridden with the new array specified. The
	// specified array should only contain FilterConfig and
	// TrafficFilterConfig objects with FilterConfig#inherited /
	// TrafficFilterConfig#inherited set to false.
	// FilterConfig/TrafficFilterConfig  objects with
	// FilterConfig#inherited/TrafficFilterConfig#inherited as
	// true in the specified array will be ignored. The updated result will
	// include FilterConfig/TrafficFilterConfig objects
	// inherited from parent, if any.
	FilterConfig []*DvsFilterConfig
}

//
// This class defines network rule action to GRE Encapsulate a packet.
//
//
type DvsGreEncapNetworkRuleAction struct {
	*DvsNetworkRuleAction

	// Single IP address. Only IPv4 is supported for vSphere API 5.5.
	EncapsulationIp *SingleIp
}

//
// Health check status of an switch is changed.
//
//
type DvsHealthStatusChangeEvent struct {
	*HostEvent

	// Health check status.
	HealthResult *HostMemberHealthCheckResult

	// UUID of the DVS the host is connected to.
	SwitchUuid string
}

//
// The DVS configuration on the host was synchronized with that of
// the Virtual Center Server and the configuration is the same on
// the host and Virtual Center Server.
//
//
type DvsHostBackInSyncEvent struct {
	*DvsEvent

	// The host that was synchronized.
	HostBackInSync *HostEventArgument
}

//
// A host joined the distributed virtual switch.
//
//
type DvsHostJoinedEvent struct {
	*DvsEvent

	// The host that joined DVS.
	HostJoined *HostEventArgument
}

//
// A host left the distributed virtual switch.
//
//
type DvsHostLeftEvent struct {
	*DvsEvent

	// The host that left DVS.
	HostLeft *HostEventArgument
}

//
// A host has it's status or statusDetail updated.
//
//
type DvsHostStatusUpdated struct {
	*DvsEvent

	// The host.
	HostMember *HostEventArgument

	// Host's new status.
	NewStatus string

	// Comments regarding host's new status.
	NewStatusDetail string

	// Host's old status.
	OldStatus string

	// Comments regarding host's old status.
	OldStatusDetail string
}

//
// The DvsHostVNicProfile data object describes the IP configuration
// for a host Virtual NIC connected to a distributed virtual switch.
// The ipConfig property contains the Virtual NIC IP address.
// If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type DvsHostVNicProfile struct {
	*DvsVNicProfile
}

//
// The DVS configuration on the host diverged from that of
// the Virtual Center Server.
//
//
type DvsHostWentOutOfSyncEvent struct {
	*DvsEvent

	// The host that went out of sync.
	HostOutOfSync *DvsOutOfSyncHostArgument
}

//
// This event is generated when a import operation is
// performed on a distributed virtual switch
//
//
type DvsImportEvent struct {
	*DvsEvent

	// The type of restore operation. See  EntityImportType for valid values
	ImportType string
}

//
// This class defines the IP Rule Qualifier. Here IP addresses of source
//
// and destination will be used for classifying packets.
//
//
type DvsIpNetworkRuleQualifier struct {
	*DvsNetworkRuleQualifier

	// IP qualifier for destination.
	//
	// If this property is NULL, it will match "any IPv4 or any IPv6 address".
	DestinationAddress *IpAddress

	// Destination IP Port.
	DestinationIpPort *DvsIpPort

	// Protocols like TCP, UDP, ICMP etc. The valid value for a protocol
	//
	// is got from IANA assigned value for the protocol. This can be got
	//
	// from RFC 5237 and IANA website section related to protocol numbers.
	Protocol *IntExpression

	// IP qualifier for source.
	//
	// If this property is NULL, it will match "any IPv4 or any IPv6 address".
	SourceAddress *IpAddress

	// Source IP Port.
	SourceIpPort *DvsIpPort

	// TCP flags. The valid values can be found at RFC 3168.
	TcpFlags *IntExpression
}

//
// Base class for specifying Ports.
//
// Objects of the base class represent any port (single/range/list).
//
//
type DvsIpPort struct {
	*NegatableExpression
}

//
// This class defines a range of Ports.
//
//
type DvsIpPortRange struct {
	*DvsIpPort

	// Ending port number of the ports range.
	EndPortNumber int32

	// Starting port number of the ports range.
	StartPortNumber int32
}

//
// This class defines network rule action to just log the rule.
//
//
type DvsLogNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

//
// This class defines the MAC Rule Qualifier. Here MAC addresses of source
//
// and destination will be used for classifying packets.
//
//
type DvsMacNetworkRuleQualifier struct {
	*DvsNetworkRuleQualifier

	// MAC address for destination.
	//
	// If this property is NULL, it will match "any MAC address".
	DestinationAddress *MacAddress

	// Protocol used. This corresponds to the EtherType field in Ethernet
	//
	// frame. The valid values can be found from IEEE list at:
	//
	// http://standards.ieee.org/regauth/ as mentioned in RFC 5342.
	Protocol *IntExpression

	// MAC address for source.
	//
	// If this property is NULL, it will match "any MAC address".
	SourceAddress *MacAddress

	// vlan id.
	VlanId *IntExpression
}

//
// This class defines network rule action to MAC Rewrite.
//
//
type DvsMacRewriteNetworkRuleAction struct {
	*DvsNetworkRuleAction

	// Rewrite Destination MAC with this MAC address.
	RewriteMac string
}

//
// Two distributed virtual switches was merged.
//
//
type DvsMergedEvent struct {
	*DvsEvent

	// The destination DVS.
	DestinationDvs *DvsEventArgument

	// The source DVS.
	SourceDvs *DvsEventArgument
}

//
// This class is the base class for network rule action.
//
//
type DvsNetworkRuleAction struct {
	*DynamicData
}

//
// Network Traffic Rule direction types. It specifies whether rule
//
// needs to be applied for packets which are incoming/outgoing or both.
//
//
type DvsNetworkRuleDirectionType struct {
}

//
// This class is the base class for identifying network traffic.
//
//
type DvsNetworkRuleQualifier struct {
	*DynamicData

	// The key of the Qualifier
	Key string
}

//
// Thrown if
// dvsOperationSupported
// is false and extensionKey is not same
// as the extension key of the login-session.
//
//
type DvsNotAuthorized struct {
	*DvsFault

	// The value of extensionKey.
	DvsExtensionKey string

	// The extension key associated with the user-session.
	SessionExtensionKey string
}

//
// Thrown if a DistributedVirtualSwitch operation failed on some of the host members.
//
//
type DvsOperationBulkFault struct {
	*DvsFault

	// Faults occured on the host during a DistributedVirtualSwitch operation.
	HostFault []*DvsOperationBulkFaultFaultOnHost
}

//
// The fault occured on the host during an operation.
//
//
type DvsOperationBulkFaultFaultOnHost struct {
	*DynamicData

	// The fault that occured.
	Fault *LocalizedMethodFault

	Host *HostSystem
}

//
// The host on which the DVS configuration is different from that
// of Virtual Center server.
//
//
type DvsOutOfSyncHostArgument struct {
	*DynamicData

	// The DVS configuration parameters that are different between
	// Virtual Center server and the host.
	ConfigParamters []string

	// The host.
	OutOfSyncHost *HostEventArgument
}

//
// A port is blocked in the distributed virtual switch.
//
//
type DvsPortBlockedEvent struct {
	*DvsEvent

	// The port key.
	PortKey string

	// The port runtime information.
	//
	// Since vSphere API 5.1
	RuntimeInfo *DVPortStatus

	// Reason for port's current status
	//
	// Since vSphere API 4.1
	StatusDetail string
}

//
// A port is connected in the distributed virtual switch.
//
//
type DvsPortConnectedEvent struct {
	*DvsEvent

	// The port's connectee.
	Connectee *DistributedVirtualSwitchPortConnectee

	// The port key.
	PortKey string
}

//
// New ports are created in the distributed virtual switch.
//
//
type DvsPortCreatedEvent struct {
	*DvsEvent

	// The key of the ports that are created.
	PortKey []string
}

//
// Existing ports are deleted in the distributed virtual switch.
//
//
type DvsPortDeletedEvent struct {
	*DvsEvent

	// The key of the ports that are deleted.
	PortKey []string
}

//
// A port is disconnected in the distributed virtual switch.
//
//
type DvsPortDisconnectedEvent struct {
	*DvsEvent

	// The port's formal connectee.
	Connectee *DistributedVirtualSwitchPortConnectee

	// The port key.
	PortKey string
}

//
// A port has entered passthrough mode on the distributed virtual switch.
//
//
type DvsPortEnteredPassthruEvent struct {
	*DvsEvent

	// The port key.
	PortKey string

	// The port runtime information.
	//
	// Since vSphere API 5.1
	RuntimeInfo *DVPortStatus
}

//
// A port has exited passthrough mode on the distributed virtual switch.
//
//
type DvsPortExitedPassthruEvent struct {
	*DvsEvent

	// The port key.
	PortKey string

	// The port runtime information.
	//
	// Since vSphere API 5.1
	RuntimeInfo *DVPortStatus
}

//
// A port was moved into the distributed virtual portgroup.
//
//
type DvsPortJoinPortgroupEvent struct {
	*DvsEvent

	// The portgroup key.
	PortgroupKey string

	// The portgroup name.
	PortgroupName string

	// The port key.
	PortKey string
}

//
// A port was moved out of the distributed virtual portgroup.
//
//
type DvsPortLeavePortgroupEvent struct {
	*DvsEvent

	// The portgroup key.
	PortgroupKey string

	// The portgroup name.
	PortgroupName string

	// The port key.
	PortKey string
}

//
// A port of which link status is changed to down in the distributed
// virtual switch.
//
//
type DvsPortLinkDownEvent struct {
	*DvsEvent

	// The port key.
	PortKey string

	// The port runtime information.
	//
	// Since vSphere API 5.1
	RuntimeInfo *DVPortStatus
}

//
// A port of which link status is changed to up in the distributed
// virtual switch.
//
//
type DvsPortLinkUpEvent struct {
	*DvsEvent

	// The port key.
	PortKey string

	// The port runtime information.
	//
	// Since vSphere API 5.1
	RuntimeInfo *DVPortStatus
}

//
// Existing ports are reconfigured in the distributed virtual switch.
//
//
type DvsPortReconfiguredEvent struct {
	*DvsEvent

	// The key of the ports that are reconfigured.
	PortKey []string
}

//
// A port of which runtime information is changed in the vNetwork Distributed
// Switch.
//
//
type DvsPortRuntimeChangeEvent struct {
	*DvsEvent

	// The port key.
	PortKey string

	// The new port runtime information.
	RuntimeInfo *DVPortStatus
}

//
// A port is blocked in the distributed virtual switch.
//
//
type DvsPortUnblockedEvent struct {
	*DvsEvent

	// The port key.
	PortKey string

	// The port runtime information.
	//
	// Since vSphere API 5.1
	RuntimeInfo *DVPortStatus
}

//
// A port of which vendor specific state is changed in the vNetwork Distributed
// Switch.
//
//
type DvsPortVendorSpecificStateChangeEvent struct {
	*DvsEvent

	// The port key.
	PortKey string
}

//
// The DvsProfile data object represents the distributed virtual switch
// to which this host is connected. If a profile plug-in defines policies or subprofiles,
// use the policy or property
// list to access the additional configuration data.
//
//
type DvsProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string

	// Unique identifier for the distributed virtual switch.
	Name string

	// List of subprofiles that map physical NICs to uplink ports.
	// Use the key property to access
	// subprofiles in the list.
	Uplink []*PnicUplinkProfile
}

//
// This class defines network rule action to punt. i.e, forward packets
//
// to an associated slow-path service Virtual Machine.
//
//
type DvsPuntNetworkRuleAction struct {
	*DvsNetworkRuleAction
}

//
// This class defines network rule action to ratelimit packets.
//
//
type DvsRateLimitNetworkRuleAction struct {
	*DvsNetworkRuleAction

	// Rate limit value specified in packets per second.
	PacketsPerSecond int32
}

//
// A distributed virtual switch was reconfigured.
//
//
type DvsReconfiguredEvent struct {
	*DvsEvent

	// The reconfiguration spec.
	ConfigSpec *DVSConfigSpec
}

//
// A distributed virtual switch was renamed.
//
//
type DvsRenamedEvent struct {
	*DvsEvent

	// The new DistributedVirtualSwitch name.
	NewName string

	// The old DistributedVirtualSwitch name.
	OldName string
}

//
// This event is generated when a restore operation is
// performed on a distributed virtual switch
//
//
type DvsRestoreEvent struct {
	*DvsEvent
}

// Deprecated.
// as of vSphere API 5.5
//
//
// Thrown if a entity trying to connect to a port or portgroup but it is not in the
// port or portgroup's scope.
//
//
type DvsScopeViolated struct {
	*DvsFault

	// The entity that violates the scope.
	Entity *ManagedEntity

	// The configured scope.
	Scope []*ManagedEntity
}

//
// The DvsServiceConsoleVNicProfile data object describes the IP configuration
// for a service console Virtual NIC connected to a distributed virtual switch.
// The ipConfig property contains the Virtual NIC IP address.
// If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type DvsServiceConsoleVNicProfile struct {
	*DvsVNicProfile
}

//
// This class defines a Single Port
//
//
type DvsSingleIpPort struct {
	*DvsIpPort

	// The IP port number.
	PortNumber int32
}

//
// This class defines the System Traffic Qualifier. Here the type of
//
// traffic will be used for classifying packets.
//
//
type DvsSystemTrafficNetworkRuleQualifier struct {
	*DvsNetworkRuleQualifier

	// Type of system traffic.
	//
	// See DistributedVirtualSwitchHostInfrastructureTrafficClass
	//
	// for valid values.
	TypeOfSystemTraffic *StringExpression
}

//
// This class defines Traffic Filter configuration.
// Supported Qualifier and Actions
//
type DvsTrafficFilterConfig struct {
	*DvsFilterConfig
}

//
// The specification to reconfigure Traffic Filter.
// This specification allows the user to do fine-grained updates for the
// Traffic Filter in the port settings.
// If the operation is remove, only the
// TrafficFilterConfigSpec#key needs to be specified.
// If other fields are specified, they will be ignored. We cannot remove
// an inherited element. Only when the inherited flag is set to false and
// parent does not have an element with same key this operation succeeds.
// If the operation is add, then
// TrafficFilterConfigSpec#key should not be specified and
// other fields need to be specified. The inherited flag should be set to
// false.
// If the operation is edit, then
// TrafficFilterConfigSpec#key needs be specified and
// specify the other properties that need modification. If the inherited
// flag is set to true, a TrafficFilterConfig object of same
// key must exist at the parent's level. The property values in the spec
// object will be ignored and use the values from the parent's
// TrafficFilterConfig object instead. If inherited
// flag is set to false, then the new modifications will be applied.
//
//
type DvsTrafficFilterConfigSpec struct {
	*DvsTrafficFilterConfig

	// Operation type. See ConfigSpecOperation for valid values.
	Operation string
}

//
// This class defines a single rule that will be applied to network traffic.
//
//
type DvsTrafficRule struct {
	*DynamicData

	// Action to be applied for this rule.
	Action *DvsNetworkRuleAction

	// Description of the rule
	Description string

	// Whether this rule needs to be applied to incoming packets,
	//
	// to outgoing packets or both.
	//
	// See RuleDirectionType for valid values.
	Direction string

	// The key of the rule
	Key string

	// List of Network rule qualifiers. 'AND' of this array of
	//
	// network rule qualifiers is applied as one network traffic rule.
	//
	// If the TrafficRule belongs to
	//
	// DvsFilterPolicy :
	//
	// There can be a maximum of 1 DvsIpNetworkRuleQualifier,
	//
	// 1 DvsMacNetworkRuleQualifier and
	//
	// 1 DvsSystemTrafficNetworkRuleQualifier for a total of
	//
	// 3 qualifier
	//
	// If the TrafficRule belongs to
	//
	// DvsStatefulFirewallPolicy :
	//
	// There can be only 1 DvsNetworkRuleQualifier in
	//
	// qualifier
	Qualifier []*DvsNetworkRuleQualifier

	// Sequence of this rule. i.e, the order in which this rule appears
	//
	// in the ruleset.
	Sequence int32
}

//
// This class defines a ruleset(set of rules) that will be
//
// applied to network traffic.
//
//
type DvsTrafficRuleset struct {
	*DynamicData

	// Whether ruleset is enabled or not.
	Enabled bool

	// The key of the ruleset.
	Key string

	// Precedence of the ruleset. Rulesets for a port will be executed
	//
	// in the order of their precedence.
	Precedence int32

	// List of rules belonging to this ruleset.
	Rules []*DvsTrafficRule
}

//
// This class defines network rule action to tag packets(qos,dscp) or
//
// clear tags(clear qos, dscp tags) on packets.
//
// One or both of qos and dscp may be specified.
//
//
type DvsUpdateTagNetworkRuleAction struct {
	*DvsNetworkRuleAction

	// DSCP tag. The valid values for DSCP tag can be found in
	//
	// 'Differentiated Services Field Codepoints' section of IANA website.
	//
	// The information can also be got from reading all of the below RFC:
	//
	// RFC 2474, RFC 2597, RFC 3246, RFC 5865.
	//
	// If the dscpTag is set to 0 then the dscp tag on packets will be cleared.
	DscpTag int32

	// QOS tag. IEEE 802.1p supports 3 bit Priority Code Point (PCP).
	//
	// The valid values are between 0-7. Please refer the IEEE 802.1p
	//
	// documentation for more details about what each value represents.
	//
	// If qosTag is set to 0 then the tag on the packets will be cleared.
	QosTag int32
}

//
// An upgrade for the distributed virtual switch is available.
//
//
type DvsUpgradeAvailableEvent struct {
	*DvsEvent

	// The product info of the upgrade.
	ProductInfo *DistributedVirtualSwitchProductSpec
}

//
// An upgrade for the distributed virtual switch is in progress.
//
//
type DvsUpgradeInProgressEvent struct {
	*DvsEvent

	// The product info of the upgrade.
	ProductInfo *DistributedVirtualSwitchProductSpec
}

//
// An upgrade for the distributed virtual switch is rejected.
//
//
type DvsUpgradeRejectedEvent struct {
	*DvsEvent

	// The product info of the upgrade.
	ProductInfo *DistributedVirtualSwitchProductSpec
}

//
// The distributed virtual switch was upgraded.
//
//
type DvsUpgradedEvent struct {
	*DvsEvent

	// The product info of the upgrade.
	ProductInfo *DistributedVirtualSwitchProductSpec
}

//
// The DvsVNicProfile data object is the base object
// for host and service console Virtual NIC subprofiles.
// If a profile plug-in defines additional policies or subprofiles, use the
// policy or property
// list to access the configuration data.
//
//
type DvsVNicProfile struct {
	*ApplyProfile

	// IP address for a distributed virtual switch Virtual NIC.
	IpConfig *IpAddressProfile

	// Linkable identifier.
	Key string
}

//
// DynamicArray is a data object type that represents an array of dynamically-typed
// objects. A client should only see a DynamicArray object when the element type
// is unknown (meaning the type is newer than the client). Otherwise, a client would
// see the type as T[] where T is known.
//
//
type DynamicArray struct {

	// Reserved.
	DynamicType string

	// Array of dynamic values.
	Val []interface{}
}

//
// DynamicData is a builtin object model data object type for manipulating data
// properties dynamically. The primary usage is as a base class for types that may
// be extended with subtypes in the future, where new properties should be sent to
// old clients as a set of dynamic properties.
//
//
type DynamicData struct {

	// Deprecated.
	// As of vSphere 5.5, this field is deprecated.  This field was reserved
	// for future use but was never implemented for use in the general case for all data
	// objects.  In the future, the web services API will continue to accept and produce
	// this property in a small number of specific cases where the field is being used.
	// At that time, the documentation may change to reflect that this property is only
	// accepted in the specific web service API calls that use this field.
	//
	//
	// Set of dynamic properties. This property is optional because only the
	// properties of an object that are unknown to a client will be part of this set.
	// This property is not readonly just in case we want to send such properties
	// from a client in the future.
	DynamicProperty []*DynamicProperty

	// Deprecated.
	// As of vSphere 5.5, this field is deprecated.  This field was reserved
	// for future use but was never implemented for use in the general case for all data
	// objects.  In the future, the web services API will continue to accept and produce
	// this property in a small number of specific cases where the field is being used.
	// At that time, the documentation may change to reflect that this property is only
	// accepted in the specific web service API calls that use this field.
	//
	//
	// Reserved.
	DynamicType string
}

//
// The DynamicProperty data object type represents a name-value pair.
//
//
type DynamicProperty struct {

	// Path to the property.
	Name string

	// Value of the property.
	Val interface{}
}

//
// The host does not satisfy the admission requirements for the Enhanced
// VMotion Compatibility mode of the cluster.
//
//
type EVCAdmissionFailed struct {
	*NotSupportedHostInCluster

	// The faults that caused this EVC test to fail
	// (e.g. FeatureRequirementsNotMet faults).
	//
	// Since vSphere API 5.1
	Faults []*LocalizedMethodFault
}

//
// The host's CPU hardware is a family/model that should support the
// Enhanced VMotion Compatibility mode of the cluster, but some necessary
// CPU features are not present.
//
//
type EVCAdmissionFailedCPUFeaturesForMode struct {
	*EVCAdmissionFailed

	// The Enhanced VMotion Compatibility mode that is currently in effect for
	// the cluster.
	CurrentEVCModeKey string
}

//
// The host's CPU hardware is a family/model that does not support any
// Enhanced VMotion Compatibility mode.
//
//
type EVCAdmissionFailedCPUModel struct {
	*EVCAdmissionFailed
}

//
// The host's CPU hardware is a family/model that does not support the Enhanced
// VMotion Compatibility mode of the cluster.
//
//
type EVCAdmissionFailedCPUModelForMode struct {
	*EVCAdmissionFailed

	// The Enhanced VMotion Compatibility mode that is currently in effect for
	// the cluster.
	CurrentEVCModeKey string
}

//
// The host's CPU vendor does not match the required CPU vendor for the
// Enhanced VMotion Compatibility mode of the cluster.
//
//
type EVCAdmissionFailedCPUVendor struct {
	*EVCAdmissionFailed

	// The CPU vendor required for entering the cluster.
	ClusterCPUVendor string

	// The CPU vendor of the host.
	HostCPUVendor string
}

//
// The host's CPU vendor is unknown, which prevents admission into an Enhanced
// VMotion Compatibility cluster.
//
//
type EVCAdmissionFailedCPUVendorUnknown struct {
	*EVCAdmissionFailed
}

//
// The host is not connected, which prevents admission into an Enhanced
// VMotion Compatibility cluster.
//
//
type EVCAdmissionFailedHostDisconnected struct {
	*EVCAdmissionFailed
}

//
// The host's software does not support any Enhanced VMotion Compatibility mode.
//
//
type EVCAdmissionFailedHostSoftware struct {
	*EVCAdmissionFailed
}

//
// The host's software does not support the Enhanced VMotion Compatibility
// mode of the cluster.
//
//
type EVCAdmissionFailedHostSoftwareForMode struct {
	*EVCAdmissionFailed
}

//
// An attempt to move or add a host into an Enhanced VMotion Compatibility
// cluster has failed for the following reason:
//
//
// • The host exposes additional compatibility-relevant CPU features beyond
// those present in the baseline mandated by the cluster's EVC mode.
//
// • The host has powered-on or suspended virtual machines.
//
//
//
// Therefore the host may not be admitted into the cluster, since its virtual
// machines may be using CPU features suppressed in the cluster.
//
// Note that in rare cases, this may occur even if the host's
// maxEVCModeKey corresponds to the EVC
// mode of the cluster.  This means that even though that EVC mode is the best
// match for the host's hardware, the host still has some features beyond
// those present in the baseline for that EVC mode.
//
//
//
type EVCAdmissionFailedVmActive struct {
	*EVCAdmissionFailed
}

//
// The EVCMode data object describes an Enhanced vMotion Compatibility mode.
// An EVC mode is associated with a set of CPU features. A vCenter Server defines
// the available EVC modes. You use them to establish a common set of features
// for compatibility between hosts in a cluster. An EVC-enabled cluster supports
// safe vMotion of virtual machines across a range of CPU generations.
// You must use the vSphere Client to configure EVC.
//
// When you add a host to an EVC-enabled cluster, the vCenter Server determines
// the CPU compatibility to preserve vMotion compatibility within the cluster.
// If the host CPU is compatible with those already in the cluster, the Server
// adds the host to the cluster and configures it for compatible operation.
// Hosts that are not compatible are not allowed to join the cluster.
//
//
// The inherited key property is a string value
// that uniquely identifies an EVC mode. The vCenter Server assigns
// the key value; the vSphere API uses the key to identify modes
// in summary and information objects:
//
//
//
// • ClusterComputeResourceSummary.currentEVCModeKey
//
// • HostListSummary.currentEVCModeKey
//
// • HostListSummary.maxEVCModeKey
//
// • VirtualMachineRuntimeInfo.minRequiredEVCModeKey
//
//
//
//
// The inherited label and summary
// properties are human-readable strings.
//
//
// You can use the track and vendorTier properties to determine
// feature-superset relationships between modes without examining the
// individual feature bits in guaranteedCPUFeatures.
// The CPU feature baseline of mode A is a superset of mode B's baseline
// if and only if:
//
//
//
// • modeA.track is the same as or a superset of modeB.track
//
// • modeA.vendorTier is equal to or greater than modeB.vendorTier
//
//
//
// Use the track and vendorTier properties only for the
// purpose of feature-superset calculations as described above. Do not use
// them to infer the presence or absence of specific features. The
// property values for a given mode may change across releases
// as the set of available EVC modes changes, to better represent mode
// relationships.
//
//
type EVCMode struct {
	*ElementDescription

	// Describes the feature capability baseline associated with the EVC mode.
	// On the cluster where a particular EVC mode is configured,
	// these features capabilities are guaranteed, either because the host
	// hardware naturally matches those features or because feature masks
	// are used to mask out differences and enforce a match.
	//
	// Since vSphere API 5.1
	FeatureCapability []*HostFeatureCapability

	// The masks (modifications to a host's feature capabilities) that limit a
	// host's capabilities to that of the EVC mode baseline.
	//
	// Since vSphere API 5.1
	FeatureMask []*HostFeatureMask

	// The conditions that must be true of a host's feature capabilities in order
	// for the host to meet the minimum requirements of the EVC mode baseline.
	//
	// Since vSphere API 5.1
	FeatureRequirement []*VirtualMachineFeatureRequirement

	// Describes the CPU feature baseline associated with the EVC mode.
	// On the cluster where a particular EVC mode is configured,
	// those CPU features are guaranteed, either because the host
	// hardware naturally matches those features or because CPU feature override
	// is used to mask out differences and enforce a match.
	//
	// Since vSphere API 4.1
	GuaranteedCPUFeatures []*HostCpuIdInfo

	// Identifiers for feature groups that are at least partially present in
	// the guaranteedCPUFeatures array for this mode.
	// Use this property to compare track values from two modes.
	// Do not use this property to determine the presence or absence of
	// specific features.
	//
	// Since vSphere API 4.1
	Track []string

	// CPU hardware vendor required for this mode.
	Vendor string

	// Index for ordering the set of modes that apply to a given CPU vendor.
	// Use this property to compare vendor tier values from two modes.
	// Do not use this property to determine the presence or absence
	// of specific features.
	VendorTier int32
}

//
// Only virtual machines on eight different hosts can have a single
// virtual disk backing opened for read at once.
//
// This fault occurs when moving or powering on this virtual
// machine would cause a violation of the above constraint.
// This only occurs when multiple virtual machines are sharing a
// single disk backing.
//
//
// Note that there is no limit on the number of virtual machines
// who share a disk backings, so long as they are running on
// eight or fewer hosts.
//
//
//
type EightHostLimitViolated struct {
	*VmConfigFault
}

//
// Static strings used for describing an object model string or enumeration.
//
//
type ElementDescription struct {
	*Description

	// Enumeration or literal ID being described.
	Key string
}

//
// This event records that the host has completely entered
// maintenance mode. A host in this mode has no running virtual machines and no
// provisioning operations are occuring.
//
//
type EnteredMaintenanceModeEvent struct {
	*HostEvent
}

//
// This event records that the host has successfully entered
// standby mode. A host in this mode has no running virtual machines and no
// provisioning operations are occurring.
//
//
type EnteredStandbyModeEvent struct {
	*HostEvent
}

//
// This event records that a host has begun the process of entering
// maintenance mode. All virtual machine operations
// are blocked, except the following:
//
//
// • MigrateVM
//
// • PowerOffVM
//
// • SuspendVM
//
// • ShutdownGuest
//
// • StandbyGuest
//
//
//
//
//
type EnteringMaintenanceModeEvent struct {
	*HostEvent
}

//
// This event records that a host has begun the process of entering
// standby mode. All virtual machine operations
// are blocked, except the following:
//
//
// • MigrateVM
//
// • PowerOffVM
//
// • SuspendVM
//
// • ShutdownGuest
//
// • StandbyGuest
//
//
//
//
//
type EnteringStandbyModeEvent struct {
	*HostEvent
}

//
// EntityBackup is an abstract data object that contains
// the related entity backup and restore elements for virtual distributed
// switches and virtual distributed portgroups. See the following elements:
//
//
// • EntityBackupConfig
//
// • EntityImportType
//
// • EntityType
//
//
//
//
//
type EntityBackup struct {
	*DynamicData
}

//
// The EntityBackupConfig data object
// contains VmwareDistributedVirtualSwitch
// or DistributedVirtualPortgroup backup
// configuration data produced by the
// DVSManagerExportEntity_Task
// method. It also contains properties that support
// DVSManagerImportEntity_Task
// operations.
//
// A DVSManagerExportEntity_Task operation
// sets properties that identify the entity instance
// (entityType,
// key, and
// name) and
// inventory location (container).
// When you import a backup configuration, you can set
// the key, name, and container
// properties in accordance with the importType
// specified in the call to
// DVSManagerImportEntity_Task.
// See EntityImportType.
//
//
//
type EntityBackupConfig struct {
	*DynamicData

	// Opaque blob that contains the configuration of the entity.
	ConfigBlob []byte

	// Configuration version.
	ConfigVersion string

	// Container for this entity.
	// If entityType is "distributedVirtualSwitch",
	// the container type is Folder. If entityType
	// is "distributedVirtualPortgroup", the container type is
	// DistributedVirtualSwitch.
	Container *ManagedEntity

	// Type of the exported entity
	// (DVSManagerExportEntity_Task).
	// See EntityType
	// for valid values.
	EntityType string

	// Unique identifier of the exported entity or the entity to be restored
	// through an import operation.
	//
	// If you are importing a virtual distributed switch and the import type is
	// applyToEntitySpecified,
	// set the key to
	// DistributedVirtualSwitch.uuid.
	//
	// If you are importing a virtual distributed portgroup and the import type is
	// applyToEntitySpecified,
	// set the key to
	// DistributedVirtualPortgroup.key.
	//
	//
	//
	// The Server ignores the key value when the import operation creates a new entity.
	Key string

	// Name of the exported entity or the entity to be restored with the backup configuration.
	// If you are importing an entity and the import type is
	// applyToEntitySpecified,
	// the Server will use this value to rename the existing entity.
	Name string
}

//
// The event argument is a managed entity object.
//
// Subclasses of this type distinguish the different managed entities
// referenced in event objects.
//
//
//
type EntityEventArgument struct {
	*EventArgument

	// Name of the entity, including its full path from the root of the inventory.
	Name string
}

//
// The EntityImportType enum defines the import type for a
// DistributedVirtualSwitchManager.DVSManagerImportEntity_Task
// operation.
//
//
type EntityImportType struct {
}

//
// This class defines whether a set of privileges are granted for a managed entity.
//
//
type EntityPrivilege struct {
	*DynamicData

	// The entity on which the privileges are checked.
	Entity *ManagedEntity

	// whether a set of privileges are granted for the managed entity.
	PrivAvailability []*PrivilegeAvailability
}

//
// The EntityType enum identifies
// the type of entity that was exported
// (DVSManagerExportEntity_Task).
//
//
type EntityType struct {
}

//
// Static strings used for describing an enumerated type.
//
//
type EnumDescription struct {
	*DynamicData

	// Type of enumeration being described.
	Key string

	// Element descriptions of all the tags for that enumerated type.
	Tags []*ElementDescription
}

//
// This managed object type provides access to the environment that a
// ComputeResource presents for creating and configuring a virtual machine.
//
// The environment consists of three main components:
//
//
//
// • The virtual machine configuration options. Each vim.vm.ConfigOption
// describes the execution environment for a virtual machine, the particular
// set of virtual hardware that is supported. A
// ComputeResource might support multiple sets. Access is provided
// through the configOptionDescriptor property and the
// QueryConfigOption operation.
//
// • The supported device targets. Each virtual device specified in the virtual
// machine needs to be hooked up to a "physical" counterpart. For networks,
// this means choosing a network name; for a virtual CD-rom this might be
// an ISO image, etc.  The environment browser provides access to the device
// targets through the
// QueryConfigTarget operation.
//
// • Storage locations and files. A selection of locations where the virtual machine
// files can be stored, and the possibility to browse for existing virtual disks
// and ISO images. The datastore browser, provided by the datastoreBrowser
// property, provides access to the contents of one or more datastores. The
// items in a datastore are files that contain configuration, virtual disk, and
// the other data associated with a virtual machine.
//
// • The capabilities supported by the ComputeResource to which the virtual
// machine belongs.
//
//
//
//
type EnvironmentBrowser struct {
	*ManagedObject

	datastoreBrowser *HostDatastoreBrowser
}

// DatastoreBrowser to browse datastores that are available on this entity.
// Required Privilege: System.View
func (mo *EnvironmentBrowser) DatastoreBrowser() (*HostDatastoreBrowser, error) {
	t, err := mo.currentProperty("datastoreBrowser")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostDatastoreBrowser)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostDatastoreBrowser")
	}
	return v, nil
}

//
// Query for a specific virtual machine configuration option (the ConfigOption).
//
// If the EnvironmentBrowser is from a ComputeResource or ClusterComputeResource,
// the key or host, or both arguments can be used to return the required config
// options. If a key is specified, then the ConfigOption corresponding to that key
// value is  returned. If a host is specified, then the default ConfigOption for
// that host is returned. If key and host both are specified, the ConfigOption
// corresponding to the given key for that host is returned. If neither is specified,
// then the default ConfigOption for this environment browser is returned. Typically,
// the default contains the options for the most recent virtual hardware
// supported.
//
//
// If the EnvironmentBrowser is from a VirtualMachine neither a host nor a
// key should be specified.
//
//
// Required Privileges
// System.View
//
func (mo *EnvironmentBrowser) QueryConfigOption(
	_this *ManagedObjectReference, key string, host *HostSystem,
) (*VirtualMachineConfigOption, error) {

	return nil, nil

}

//
// The list of ConfigOption keys available on this entity.
//
// Required Privileges
// System.View
//
func (mo *EnvironmentBrowser) QueryConfigOptionDescriptor(
	_this *ManagedObjectReference,
) ([]*VirtualMachineConfigOptionDescriptor, error) {

	return nil, nil

}

//
// Queries for information about a specific target, a "physical" device that
// can be used to back virtual devices. The ConfigTarget that is returned specifies
// the set of values that can be used in the device backings to connect the virtual
// machine to physical (or logical) host devices.
//
// If the EnvironmentBrowser is from a ComputeResource or ClusterComputeResource,
// the host argument can be used to return the ConfigTarget provided by a particular
// host in the compute resource or cluster. If host is specified and the
// EnvironmentBrowser is from a ComputeResource or ClusterComputeResource,
// then the union of all the devices is returned and the
// vim.vm.TargetInfo.configurationTag field indicates  how widely the device is
// available  across the compute resource or cluster.
//
//
// If the EnvironmentBrowser is from a VirtualMachine a host should not be specified.
//
//
// Required Privileges
// System.View
//
func (mo *EnvironmentBrowser) QueryConfigTarget(
	_this *ManagedObjectReference, host *HostSystem,
) (*ConfigTarget, error) {

	return nil, nil

}

//
// Queries for information on the capabilities supported by the ComputeResource
// associated with the EnvironmentBrowser.
//
// If the EnvironmentBrowser is from a ComputeResource or ClusterComputeResource,
// the host argument can be used to return the capabilities associated with a
// specific host in the compute resource or cluster. If the host argument is not
// specified and the EnvironmentBrowser is from a ComputeResource or
// ClusterComputeResource, then the intersection of the capabilities supported by
// all the hosts in the cluster is returned. If the EnvironmentBrowser is from
// a VirtualMachine, the compute resource associated with the virtual machine
// will be queried for its capabilities.
//
//
// If the EnvironmentBrowser is from a VirtualMachine a host should not be specified.
//
//
// Required Privileges
// System.View
// Since
// vSphere API 4.0
//
func (mo *EnvironmentBrowser) QueryTargetCapabilities(
	_this *ManagedObjectReference, host *HostSystem,
) (*HostCapability, error) {

	return nil, nil

}

//
// This event is a general error event from upgrade.
//
//
type ErrorUpgradeEvent struct {
	*UpgradeEvent
}

//
// Specify an evaluation license source.
// Feature licensing is not required while the remaining hours is greater than zero.
//
//
type EvaluationLicenseSource struct {
	*LicenseSource

	// The number of remaining hours before product evaluation expires
	RemainingHours int64
}

//
// This event is the base data object type from which all events inherit. All event
// objects are data structures that describe events. While event data objects are data
// structures that describe events, event data type documentation may describe what the
// event records, rather than the data structure, itself.
//
//
type Event struct {
	*DynamicData

	// The parent or group ID.
	ChainId int32

	// The user entered tag to identify the operations and their side effects
	//
	// Since vSphere API 4.0
	ChangeTag string

	// The ComputeResource object of the event.
	ComputeResource *ComputeResourceEventArgument

	// The time the event was created.
	CreatedTime time.Time

	// The Datacenter object of the event.
	Datacenter *DatacenterEventArgument

	// The Datastore object of the event.
	//
	// Since vSphere API 4.0
	Ds *DatastoreEventArgument

	// The DistributedVirtualSwitch object of the event.
	//
	// Since vSphere API 4.0
	Dvs *DvsEventArgument

	// A formatted text message describing the event. The message may be localized.
	FullFormattedMessage string

	// The Host object of the event.
	Host *HostEventArgument

	// The event ID.
	Key int32

	// The Network object of the event.
	//
	// Since vSphere API 4.0
	Net *NetworkEventArgument

	// The user who caused the event.
	UserName string

	// The VirtualMachine object of the event.
	Vm *VmEventArgument
}

//
// An alarm expression that uses the event stream to trigger the alarm.
//
// This alarm is triggered when an event matching this expression gets logged.
//
//
//
type EventAlarmExpression struct {
	*AlarmExpression

	// The attributes/values to compare.
	//
	// Since vSphere API 4.0
	Comparisons []*EventAlarmExpressionComparison

	// Deprecated.
	// use eventTypeId instead.
	//
	//
	// The type of the event to trigger the alarm on.
	EventType string

	// The eventTypeId of the event to match.
	//
	// The semantics of how eventTypeId matching is done is as follows:
	//
	// If the event being matched is of type EventEx
	// or ExtendedEvent, then we match this value
	// against the eventTypeId (for EventEx) or
	// eventId (for ExtendedEvent) member of the Event.
	// Otherwise, we match it against the type of the Event itself.
	//
	//
	// Either eventType or eventTypeId must
	// be set.
	EventTypeId string

	// Name of the type of managed object on which the event is logged.
	//
	// An event alarm defined on a ManagedEntity
	// is propagated to child entities in the VirtualCenter inventory depending
	// on the value of this attribute. If objectType is any of the following,
	// the alarm is propagated down to all children of that type:
	//
	// A datacenter: Datacenter.
	// A cluster of host systems: ClusterComputeResource.
	// A single host system: HostSystem.
	// A resource pool representing a set of physical resources on a single host:
	// ResourcePool.
	// A virtual machine: VirtualMachine.
	// A datastore: Datastore.
	// A network: Network.
	// A distributed virtual switch:  DistributedVirtualSwitch.
	//
	//
	// If objectType is unspecified or not contained in the above list,
	// the event alarm is not propagated down to child entities in the
	// VirtualCenter inventory.
	//
	// It is possible to specify an event alarm containing two (or more) different
	// EventAlarmExpression's which contain different objectTypes. In such a case,
	// the event is propagated to all child entities with specified type(s).
	//
	// Since vSphere API 4.0
	ObjectType string

	// The alarm's new state when this condition is evaluated and satisfied.
	// If not specified then there is no change to alarm status, and all
	// actions are fired (rather than those for the transition).
	//
	// Since vSphere API 4.0
	Status *enum.ManagedEntityStatus
}

//
// Encapsulates Comparison of an event's attribute to a value.
//
//
type EventAlarmExpressionComparison struct {
	*DynamicData

	// The attribute of the event to compare
	AttributeName string

	// An operator from the list above
	Operator string

	// The value to compare against
	Value string
}

//
// Basic Comparison operators
//
//
type EventAlarmExpressionComparisonOperator struct {
}

//
// Describes an available event argument name for an Event type, which
// can be used in EventAlarmExpression.
//
//
type EventArgDesc struct {
	*DynamicData

	// The localized description of the event argument. The key holds
	// the localization prefix for the argument, which is decided by
	// the Event type that it is actually declared in, which may be a
	// base type of this event type.
	Description *ElementDescription

	// The name of the argument
	Name string

	// The type of the argument.
	Type string
}

//
// This is the base type for event argument types.
//
// Event argument objects, which inherit from a common subtype,
// are used to manage supplementary properties of different kinds
// of event objects.
//
//
//
type EventArgument struct {
	*DynamicData
}

type EventCategory struct {
}

//
// This data object provides static, locale-specific strings for event objects.
//
//
type EventDescription struct {
	*DynamicData

	// Event Category enum
	Category []*ElementDescription

	// Localized descriptions of all enumerated types that are used for
	// member declarations in event classes.
	//
	// Since vSphere API 4.0
	EnumeratedTypes []*EnumDescription

	// The event class description details.
	EventInfo []*EventDescriptionEventDetail
}

//
// Each Event object provides an automatic event message string through
// its fullFormattedMessage
// property. However, you can use the EventDetail object's properties to
// format an event message string that is appropriate when viewed from
// a specific context. The variable information (vm.name, and so on) is
// derived from the Event object's event arguments
// (VmEventArgument, and so on).
//
//
type EventDescriptionEventDetail struct {
	*DynamicData

	// A category of events.
	Category string

	// A string that is a short human-parseable description of the event.
	//
	// This is not the full message string (which may contain details
	// of the arguments, etc.), but merely a more understandable, and
	// localized, description of what the event stands for. It is meant
	// for contexts where the name of the event has to be displayed
	// to end-users, e.g. when creating Event-based Alarms.
	// `     *
	// E.g., for VmPoweredOnEvent, the eventDescription
	// in English might say "VM Powered On".
	//
	// Since vSphere API 4.0
	Description string

	// A string that is appropriate in the context of a specific cluster.
	// For example, a powering on event in this context produces the
	// following string:
	//
	// "{vm.name} on {host.name} is powered on".
	FormatOnComputeResource string

	// A string that is appropriate in the context of a specific
	// Datacenter. For example, a renaming event in this context produces
	// the following string:
	//
	// "Renamed {vm.name} from {oldName} to {newName}"
	//
	// where oldName and
	// newName are properties of the
	// VmRenamedEvent object.
	FormatOnDatacenter string

	// A string that is appropriate in the context
	// of a specific Host. For example, a powering on event in this
	// context produces the following string:
	//
	// "{vm.name} is powered on"
	FormatOnHost string

	// A string that is appropriate for the context of a specific
	// virtual machine. For example, a powering on event in this context
	// produces the following string:
	//
	// "Virtual machine on {host.name} is powered on"
	FormatOnVm string

	// A string whose context is not entity-specific.  For example, a
	// powering on event produces the following string:
	//
	// "{vm.name} on  {host.name} in {datacenter.name} is powered on"
	FullFormat string

	// Type of event being described.
	Key string

	// A detailed description of the event.  It includes common causes
	// and actions to remediate them.  It may also include links to kb
	// articles and other diagnostic information.
	// For example, the BadUserNameSessionEvent may produce the
	// following string:
	//
	//
	//
	// The user could not be logged in because of an unknown or invalid
	// user name.
	//
	//
	// The user name was unknown to the system
	// Use a user name known to the system user directory
	// (On Linux) Check if the user directory is correctly
	// configured.
	// Check the health of the domain controller (if you are using
	// Active Directory)
	//
	//
	// The user provided an invalid password
	// Supply the correct password
	//
	//
	//
	// Since vSphere API 4.1
	LongDescription string
}

//
// Severity level constants.
//
//
type EventEventSeverity struct {
}

//
// EventEx is a dynamically typed Event class, whose type is indicated by its
// eventTypeId property.
//
// A collection of eventTypeIds is registered by Extensions, which can now
// pass in optional type information for each eventTypeId which indicates the
// applicable argument names and types, among other properties.
//
//
// EventEx allows event arguments of any type, though today, the system
// only supports "string" and "moid" (a string which can be interpreted as an
// object ID in the system) as argument types.  In the future, the system
// may optionally strongly check the types of the arguments in the event
// against the declared type information, based on how the event type is
// declared.
//
//
// EventEx also allows arbitrary "event object"s - the object which the
// event refers to. You can put in any object identifier as the objectId,
// but objectType should be filled in only if the object is actually present
// in the VC Server's ManagedEntity inventory.
//
//
//
type EventEx struct {
	*Event

	// The event arguments associated with the event
	Arguments []*KeyAnyValue

	// The type of the event.
	EventTypeId string

	// The fault that triggered the event, if any
	//
	// Since vSphere API 4.1
	Fault *LocalizedMethodFault

	// An arbitrary message string, not localized.
	Message string

	// The ID of the object (VM, Host, Folder..) which the event pertains to.
	// Federated or local inventory path.
	ObjectId string

	// The name of the object
	//
	// Since vSphere API 4.1
	ObjectName string

	// the type of the object, if known to the VirtualCenter inventory
	ObjectType string

	// The severity level of the message: null=>info.See EventEventSeverity
	Severity string
}

//
// Event filter used to query events in the history collector database.
// The client creates an event history collector with a filter specification,
// then retrieves the events from the event history collector.
//
//
type EventFilterSpec struct {
	*DynamicData

	// This property, if set, limits the set of collected events to those
	// associated with the specified alarm.
	// If the property is not set, events are collected regardless of their
	// association with alarms.
	Alarm *Alarm

	// This property, if set, limits the set of collected events to those
	// associated with the specified category.
	// If the property is not set, events are collected regardless of their
	// association with any category.
	//
	// "category" here is the same as Event.severity.
	Category []string

	// Flag to specify whether or not to prepare the full formatted message
	// for each event.
	// If the property is not set, the collected events do not include
	// the full formatted message.
	DisableFullMessage bool

	// The filter specification for retrieving events by managed entity.
	// If the property is not set, then events attached to all managed entities
	// are collected.
	Entity *EventFilterSpecByEntity

	// The filter specification for retrieving events by chain ID.
	// If the property is not set, events with any chain ID are collected.
	EventChainId int32

	// This property, if set, limits the set of collected events to those
	// specified types.
	//
	// Note: if both eventTypeId and type are specified, an
	// exception may be thrown by CreateCollectorForEvents.
	//
	// The semantics of how eventTypeId matching is done is as follows:
	//
	// If the event being collected is of type EventEx
	// or ExtendedEvent, then we match against the
	// eventTypeId (for EventEx) or
	// eventId (for ExtendedEvent) member of the Event.
	// Otherwise, we match against the type of the Event itself.
	//
	//
	// If neither this property, nor type, is set, events are
	// collected regardless of their types.
	//
	// Since vSphere API 4.0
	EventTypeId []string

	// This property, if set, limits the set of collected events to those
	// associated with the specified scheduled task.
	// If the property is not set, events are collected regardless of their
	// association with any scheduled task.
	ScheduledTask *ScheduledTask

	// This property, if set, limits the set of filtered events to those that
	// have it. If not set, or the size of it 0, the tag of an event is
	// disregarded. A blank string indicates events without tags.
	//
	// Since vSphere API 4.0
	Tag []string

	// The filter specification for retrieving tasks by time.
	// If the property is not set, then events with any time stamp are collected.
	Time *EventFilterSpecByTime

	// Deprecated.
	// As of vSphere API 4.0, use eventTypeId instead.
	//
	//
	// This property, if set, limits the set of collected events to those
	// specified types.
	// If the property is not set, events are collected regardless of their
	// types.
	Type []string

	// The filter specification for retrieving events by username.
	// If the property is not set, then events belonging to any user are collected.
	UserName *EventFilterSpecByUsername
}

//
// This option specifies a managed entity used to filter event history.
//
// If the specified managed entity is a Folder or a ResourcePool, the query
// will actually be performed on the entities contained within that Folder
// or ResourcePool, so you cannot query for events on Folders and
// ResourcePools themselves this way.
//
//
type EventFilterSpecByEntity struct {
	*DynamicData

	// The managed entity to which the event pertains.
	// Required Privilege: System.View
	Entity *ManagedEntity

	// Specification of related managed entities in the inventory hierarchy.
	Recursion *enum.EventFilterSpecRecursionOption
}

//
// This option specifies a time range used to filter event history.
//
//
type EventFilterSpecByTime struct {
	*DynamicData

	// The beginning of the time range.
	// If this property is not set, then events are collected from
	// the earliest time in the database.
	BeginTime time.Time

	// The end of the time range.
	// If this property is not specified, then events are collected up to
	// the latest time in the database.
	EndTime time.Time
}

//
// This option specifies users used to filter event history.
//
//
type EventFilterSpecByUsername struct {
	*DynamicData

	// filter by system user
	// true for system user event
	SystemUser bool

	// all interested username list
	// If this property is not set, then all regular user events are
	// collected
	UserList []string
}

//
// This option specifies how to select events based on child relationships
// in the inventory hierarchy. If a managed entity has children, their events
// can be retrieved with this filter option.
//
//
type EventFilterSpecRecursionOption struct {
}

//
// EventHistoryCollector provides a mechanism for
// retrieving historical data and updates when the server appends new
// events.
//
type EventHistoryCollector struct {
	*ManagedObject
	*HistoryCollector

	latestPage []*Event
}

// The items in the 'viewable latest page'. As new events that match the
// collector's EventFilterSpec are created, they are added to this
// page, and the oldest events are removed from the collector to keep the
// size of the page to that allowed by
// HistoryCollector#setLatestPageSize.
//
// The "oldest event" is the one with the smallest key (event ID). The
// events in the returned page are unordered.
func (mo *EventHistoryCollector) LatestPage() ([]*Event, error) {
	t, err := mo.currentProperty("latestPage")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Event)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Event")
	}
	return v, nil
}

//
// Reads the 'scrollable view' from the current position. The scrollable
// position is moved to the next newer page after the read. No item is
// returned when the end of the collector is reached.
//
//
//
// Required Privileges
// None
//
func (mo *EventHistoryCollector) ReadNextEvents(
	_this *ManagedObjectReference, maxCount int32,
) ([]*Event, error) {

	return nil, nil

}

//
// Reads the 'scrollable view' from the current position. The scrollable
// position is moved to the next older page after the read. No item is
// returned when the head of the collector is reached.
//
//
//
// Required Privileges
// None
//
func (mo *EventHistoryCollector) ReadPreviousEvents(
	_this *ManagedObjectReference, maxCount int32,
) ([]*Event, error) {

	return nil, nil

}

//
// This managed object type provides properties and methods for
// event management support.
// Event objects are used to record significant state changes of
// managed entities.
//
type EventManager struct {
	*ManagedObject

	description *EventDescription

	latestEvent *Event

	maxCollector int32
}

// Static descriptive strings used in events.
// Required Privilege: System.View
func (mo *EventManager) Description() (*EventDescription, error) {
	t, err := mo.currentProperty("description")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*EventDescription)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *EventDescription")
	}
	return v, nil
}

// The latest event that happened on the VirtualCenter server.
// Required Privilege: System.View
func (mo *EventManager) LatestEvent() (*Event, error) {
	t, err := mo.currentProperty("latestEvent")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*Event)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *Event")
	}
	return v, nil
}

// For each client, the maximum number of event collectors that can exist
// simultaneously.
// Required Privilege: System.View
func (mo *EventManager) MaxCollector() (int32, error) {
	t, err := mo.currentProperty("maxCollector")
	if err != nil {
		return int32(0), err
	}

	v, ok := t.(int32)
	if !ok {
		return int32(0), errors.New("Unable to make type assertion to: int32")
	}
	return v, nil
}

//
// Creates an event history collector, which is a specialized history collector
// that provides Event objects.
//
// Event collectors do not persist beyond the current client session.
//
//
// Required Privileges
// System.View
//
func (mo *EventManager) CreateCollectorForEvents(
	_this *ManagedObjectReference, filter *EventFilterSpec,
) (*EventHistoryCollector, error) {

	return nil, nil

}

//
// Logs a user defined event against a particular managed entity.
//
// Required Privileges
// None
//
func (mo *EventManager) LogUserEvent(
	_this *ManagedObjectReference, entity *ManagedEntity, msg string,
) error {

	return nil

}

//
// Posts the specified event, optionally associating it with
// a task.
//
// The event being posted should have the following info in it:
//
//
//
// • The ManagedEntity on which the event is being posted should
// be set in the appropriate EntityEventArgument field of the base
// Event class. It is OK to not set any entity, in which case the
// event is treated as an event about the system.
//
// • Some Event fields (key, chainId,
// createdTime) are mandatory because of the nature of
// the structure, but any caller-supplied values will be overwritten by
// the system.
//
//
//
//
// If the event being posted is to be associated with an existing
// Task, the appropriate TaskInfo needs to be passed in.
// This task can either be one returned from a vSphere API operation or
// an extension task created by calling TaskManager#createTask.
//
//
// Required Privileges
// Global.LogEvent
// Since
// VI API 2.5
//
func (mo *EventManager) PostEvent(
	_this *ManagedObjectReference, eventToPost *Event, taskInfo *TaskInfo,
) error {

	return nil

}

//
// Returns the events in specified filter.
// Returns empty array when there are not any events qualified.
//
// Required Privileges
// System.View
//
func (mo *EventManager) QueryEvents(
	_this *ManagedObjectReference, filter *EventFilterSpec,
) ([]*Event, error) {

	return nil, nil

}

//
// Retrieves the argument meta-data for a given Event type
//
// Required Privileges
// System.View
// Since
// vSphere API 4.0
//
func (mo *EventManager) RetrieveArgumentDescription(
	_this *ManagedObjectReference, eventTypeId string,
) ([]*EventArgDesc, error) {

	return nil, nil

}

//
// This event records that the host is no longer in
// maintenance mode.
//
//
type ExitMaintenanceModeEvent struct {
	*HostEvent
}

//
// This event records that the host failed to exit standby mode.
//
//
type ExitStandbyModeFailedEvent struct {
	*HostEvent
}

//
// This event records that the host is no longer in
// standby mode.
//
//
type ExitedStandbyModeEvent struct {
	*HostEvent
}

//
// This event records that a host has begun the process of
// exiting standby mode.
//
//
type ExitingStandbyModeEvent struct {
	*HostEvent
}

//
// An ExpiredAddonLicense fault is thrown if an attempt to acquire an Addon license
// 'feature failed for count 'count'.
//
//
type ExpiredAddonLicense struct {
	*ExpiredFeatureLicense
}

//
// An ExpiredEditionLicense fault is thrown if an attempt to acquire an Edition license
// 'feature failed for count 'count'.
//
//
type ExpiredEditionLicense struct {
	*ExpiredFeatureLicense
}

//
// An ExpiredFeatureLicense fault is thrown if an attempt to acquire an Addon license
// 'feature failed for count 'count'.
//
//
type ExpiredFeatureLicense struct {
	*NotEnoughLicenses

	Count int32

	ExpirationDate time.Time

	Feature string
}

//
// This data object encapsulates extended product information for an extension.
//
//
type ExtExtendedProductInfo struct {
	*DynamicData

	// URL to extension vendor.
	CompanyUrl string

	// URL to management UI for this extension.
	ManagementUrl string

	// URL to vendor's description of this extension.
	ProductUrl string

	// The VirtualMachine or VirtualApp that is running this extension.
	Self *ManagedEntity
}

//
// This data object contains information about entities managed by this
// extension. The data can be used by clients to show extra information
// about managed virtual machines or vApps, such as a custom icon and a
// description of the entity.
//
//
type ExtManagedEntityInfo struct {
	*DynamicData

	// Description of this managed entity type. This is typically displayed
	// by clients, and should provide users with information about the
	// function of entities of this type.
	Description string

	// The URL to an icon in PNG format that is no larger than 256x256
	// pixels. This icon will be scaled to 16x16, 32x32, 64x64, and
	// 128x128 if needed. The icon is shown for all entities of this type
	// managed by this extension.
	//
	// Since vSphere API 5.1
	IconUrl string

	// The URL to a 16x16 pixel icon in PNG format for entities of this
	// type managed by this extension. The design of the icon should
	// allow for the possibility of it being badged with the power state
	// of the entity by the vSphere client. If you do not provide this
	// icon, the icon at
	// iconUrl, if found, is
	// scaled down to 16x16 pixels.
	SmallIconUrl string

	// Managed entity type, as defined by the extension. This matches the
	// type field in the configuration
	// about a virtual machine or vApp.
	Type string
}

//
// This data object encapsulates the Solution Manager configuration for
// this extension.
//
//
type ExtSolutionManagerInfo struct {
	*DynamicData

	// URL for an icon for this extension. The icon will be shown in the Solution
	// Manager for this extension. The icon must be 16x16, and should be in PNG
	// format.
	SmallIconUrl string

	// Deprecated.
	// As of vSphere API 5.1, see client documentation for the
	// preferred way to integrate custom user interfaces.
	//
	//
	// List of tabs that must be shown in the Solution Manager for this extension.
	// Tabs are shown ordered by their position in this array.
	Tab []*ExtSolutionManagerInfoTabInfo
}

// Deprecated.
// As of vSphere API 5.1.
//
//
// This data object contains information about a tab to show in the
// Solution Manager for this extension.
//
//
type ExtSolutionManagerInfoTabInfo struct {
	*DynamicData

	// The name of the tab.
	Label string

	// The URL for the webpage to show in the tab. Extra parameters will be added
	// to this URL when vSphere Client loads it. See the "Customizing the vSphere
	// Client" technical note for more information.
	Url string
}

type ExtendedDescription struct {
	*Description

	// Provides named arguments that can be used to localize the
	// message in the catalog.
	MessageArg []*KeyAnyValue

	// Key to the localized message string in the catalog.
	// If the localized string contains parameters, values to the
	// parameters will be provided in #messageArg.
	//
	// E.g: If the message in the catalog is
	// "IP address is {address}", value for "address"
	// will be provided by #messageArg.
	//
	// Both summary and label in Description will have a corresponding
	// entry in the message catalog with the keys
	// .summary and .label
	// respectively.
	//
	// Description.summary and Description.label will contain
	// the strings in server locale.
	MessageCatalogKeyPrefix string
}

type ExtendedElementDescription struct {
	*ElementDescription

	// Provides named arguments that can be used to localize the
	// message in the catalog.
	MessageArg []*KeyAnyValue

	// Key to the localized message string in the catalog.
	// If the localized string contains parameters, values to the
	// parameters will be provided in #messageArg.
	//
	// E.g: If the message in the catalog is
	// "IP address is {address}", value for "address"
	// will be provided by #messageArg.
	//
	// Both summary and label in ElementDescription will have a corresponding
	// entry in the message catalog with the keys
	// .summary and .label
	// respectively.
	//
	// ElementDescription.summary and ElementDescription.label will contain
	// the strings in server locale.
	MessageCatalogKeyPrefix string
}

//
// This event is the base class for extended events.
//
//
type ExtendedEvent struct {
	*GeneralEvent

	// Key/value pairs associated with event.
	Data []*ExtendedEventPair

	// The id of the type of extended event.
	EventTypeId string

	// The object on which the event was logged.
	ManagedObject *ManagedObjectReference
}

//
// key/value pair
//
//
type ExtendedEventPair struct {
	*DynamicData

	Key string

	Value string
}

//
// This fault is the container for faults logged by extensions.
//
//
type ExtendedFault struct {
	*VimFault

	// Key/value pairs associated with fault.
	Data []*KeyValue

	// The id of the type of extended fault.
	FaultTypeId string
}

//
// ExtensibleManagedObject provides methods and properties that provide
// access to custom fields that may be associated with a managed object.
// Use the CustomFieldsManager to define custom fields.
// The CustomFieldsManager handles the entire list of custom fields
// on a server. You can can specify the object type to which a particular custom
// field applies by setting its managedObjectType.
// (If you do not set a managed object type for a custom field definition,
// the field applies to all managed objects.)
//
type ExtensibleManagedObject struct {
	*ManagedObject

	availableField []*CustomFieldDef

	value []*CustomFieldValue
}

// List of custom field definitions that are valid for the object's type.
// The fields are sorted by name.
//
// Since VI API 2.5
// Required Privilege: System.View
func (mo *ExtensibleManagedObject) AvailableField() ([]*CustomFieldDef, error) {
	t, err := mo.currentProperty("availableField")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*CustomFieldDef)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*CustomFieldDef")
	}
	return v, nil
}

// List of custom field values. Each value uses a key to associate
// an instance of a CustomFieldStringValue with
// a custom field definition.
//
// Since VI API 2.5
// Required Privilege: System.View
func (mo *ExtensibleManagedObject) Value() ([]*CustomFieldValue, error) {
	t, err := mo.currentProperty("value")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*CustomFieldValue)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*CustomFieldValue")
	}
	return v, nil
}

//
// Assigns a value to a custom field. The setCustomValue method requires
// whichever updatePrivilege is defined as one of the
// fieldInstancePrivileges
// for the CustomFieldDef whose value is being changed.
//
// Required Privileges
// Dynamic - See discussion above
// Since
// VI API 2.5
//
func (mo *ExtensibleManagedObject) SetCustomValue(
	_this *ManagedObjectReference, key string, value string,
) error {

	return nil

}

//
// This data object type contains all information about an extension.
// An extension may contain zero or more server interfaces and zero
// or more clients.
//
//
type Extension struct {
	*DynamicData

	// Clients for this extension.
	Client []*ExtensionClientInfo

	// Company information.
	//
	// Since vSphere API 4.0
	Company string

	// Description of extension.
	Description *Description

	// Definitions of events defined by this extension.
	EventList []*ExtensionEventTypeInfo

	// Extended product information, such as URLs to vendor, product, etc.
	//
	// Since vSphere API 5.0
	ExtendedProductInfo *ExtExtendedProductInfo

	// Definitions of faults defined by this extension.
	FaultList []*ExtensionFaultTypeInfo

	// Health specification provided by this extension.
	//
	// Since vSphere API 4.0
	HealthInfo *ExtensionHealthInfo

	// Extension key. Should follow java package naming conventions
	// for uniqueness (e.g. "com.example.management").
	//
	// Extension names can only contain characters belonging to the
	// lower ASCII character set (UTF-7) with the exception of the
	// following characters:
	//
	// All whitespace characters ("space" - ascii character 0x20 is allowed)
	// Control characters
	// Comma (ascii 0x2c), Forward slash (ascii 0x2f), Backward slash (ascii 0x5c),
	// Hash/Pound (ascii 0x23), Plus (ascii 0x2b), Greater (ascii 0x3e), Lesser (ascii 0x3c),
	// Equals (ascii 0x3d), Semi-colon (ascii 0x3b) and Double quote (ascii 0x22).
	Key string

	// Last extension heartbeat time.
	LastHeartbeatTime time.Time

	// Information about entities managed by this extension. An extension can
	// register virtual machines as managed by itself, by setting the
	// managedBy property of the virtual
	// machine.
	//
	// Since vSphere API 5.0
	ManagedEntityInfo []*ExtManagedEntityInfo

	// OVF consumer specification provided by this extension.
	//
	// Since vSphere API 5.0
	OvfConsumerInfo *ExtensionOvfConsumerInfo

	// Definitions privileges defined by this extension.
	PrivilegeList []*ExtensionPrivilegeInfo

	// Resource data for all locales
	ResourceList []*ExtensionResourceInfo

	// Servers for this extension.
	Server []*ExtensionServerInfo

	// Opt-in to the Solution Manager. If set to true, this extension will be
	// shown in the Solution Manager. If not set, or set to false, this extension
	// is not shown in the Solution Manager.
	//
	// Since vSphere API 5.0
	ShownInSolutionManager bool

	// Solution Manager configuration for this extension.
	//
	// Since vSphere API 5.0
	SolutionManagerInfo *ExtSolutionManagerInfo

	// Subject name from client certificate.
	SubjectName string

	// Definitions of tasks defined by this extension.
	TaskList []*ExtensionTaskTypeInfo

	// Type of extension (example may include CP-DVS, NUOVA-DVS, etc.).
	//
	// Since vSphere API 4.0
	Type string

	// Extension version number as a dot-separated string. For example, "1.0.0"
	Version string
}

//
// This data object type describes a client of the extension.
//
//
type ExtensionClientInfo struct {
	*DynamicData

	// Company information.
	Company string

	// Description of client.
	Description *Description

	// Type of client (examples may include win32, .net, linux, etc.).
	Type string

	// Plugin url.
	Url string

	// Client version number as a dot-separated string. For example, "1.0.0"
	Version string
}

//
// This data object type describes event types defined by the extension.
//
//
type ExtensionEventTypeInfo struct {
	*DynamicData

	// The ID of the event type. Should follow java package
	// naming conventions for uniqueness.
	EventID string

	// Optional XML descriptor for the EventType.
	//
	// The structure of this descriptor is:
	// <EventType>
	// <eventTypeID>eventID</eventTypeID>
	// <description>Optional description for event eventID</description>
	// <!-- Optional arguments: -->
	// <arguments>
	// <!-- Zero or more of: -->
	// <argument>
	// <name>argName</name>
	// <type>argtype</name>
	// </argument>
	// </arguments>
	// </EventType>
	//
	//
	// where argtype can be one of the following:
	//
	// string
	// moid
	// long
	// int
	// bool
	//
	//
	// Note: moid is really just a string, with some additional
	// semantic meaning attached - that it is the identifier of some
	// object in the inventory, and can be looked up by a client that
	// is so inclined.
	//
	// Since vSphere API 4.0
	EventTypeSchema string
}

//
// This data object type describes fault types defined by the extension.
//
//
type ExtensionFaultTypeInfo struct {
	*DynamicData

	// The ID of the fault type. Should follow java package
	// naming conventions for uniqueness.
	FaultID string
}

//
// This data object encapsulates the health specification for the
// extension.
//
//
type ExtensionHealthInfo struct {
	*DynamicData

	Url string
}

//
// This managed object type provides directory and basic management
// services for all registered extensions.
//
// Clients use the ExtensionManager, available in
// ServiceInstance,
// to access extension objects.
//
//
// While several authentication methods are available for extension
// servers to use (see SessionManager), only one
// authentication method is valid for an extension at any given
// time.
//
//
//
type ExtensionManager struct {
	*ManagedObject

	extensionList []*Extension
}

// The list of currently registered extensions.
// Required Privilege: System.View
func (mo *ExtensionManager) ExtensionList() ([]*Extension, error) {
	t, err := mo.currentProperty("extensionList")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Extension)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Extension")
	}
	return v, nil
}

//
// Returns extension with the given key, if any.
//
// Required Privileges
// System.View
//
func (mo *ExtensionManager) FindExtension(
	_this *ManagedObjectReference, extensionKey string,
) (*Extension, error) {

	return nil, nil

}

// Deprecated.
// As of VI 4.0, use trusted certificates and
// LoginExtensionBySubjectName or
// SetExtensionCertificate and
// LoginExtensionByCertificate.
//
//
// Returns VirtualCenter Server public key.
//
// Required Privileges
// System.View
//
func (mo *ExtensionManager) GetPublicKey(
	_this *ManagedObjectReference,
) (string, error) {

	return "", nil

}

//
// Query statistics about IP allocation usage, either system wide or for
// specified extensions.
//
// Refer to IpPoolManager for details.
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.1
//
func (mo *ExtensionManager) QueryExtensionIpAllocationUsage(
	_this *ManagedObjectReference, extensionKeys []string,
) ([]*ExtensionManagerIpAllocationUsage, error) {

	return nil, nil

}

//
// Find entities managed by an extension. These can be either virtual machines
// or vApps.
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *ExtensionManager) QueryManagedBy(
	_this *ManagedObjectReference, extensionKey string,
) ([]*ManagedEntity, error) {

	return nil, nil

}

//
// Registers extension.
//
// Required Privileges
// Extension.Register
//
func (mo *ExtensionManager) RegisterExtension(
	_this *ManagedObjectReference, extension *Extension,
) error {

	return nil

}

//
// Update the stored authentication certificate for a specified extension.
//
// Updates the registration of the specified extension with the
// thumbprint of the X.509 client certificate provided over SSL handshake,
// or by the "certificatePem"argument.  The thumbprint
// will be used to authenticate the extension during invocations of
// LoginExtensionByCertificate.
//
// NOTE: No verification is performed on the received certificate, such as
// expiry or revocation.
//
//
// This method will unset any public key or subject name
// associated with the extension.
//
//
// Required Privileges
// Extension.Update
// Since
// vSphere API 4.0
//
func (mo *ExtensionManager) SetExtensionCertificate(
	_this *ManagedObjectReference, extensionKey string, certificatePem string,
) error {

	return nil

}

// Deprecated.
// As of VI 4.0, use trusted certificates and
// LoginExtensionBySubjectName or
// SetExtensionCertificate and
// LoginExtensionByCertificate.
//
//
// Sets extension's public key.
//
// This method will unset any subject name or
// certificate associated with the extension.
//
//
// Required Privileges
// Extension.Update
//
func (mo *ExtensionManager) SetPublicKey(
	_this *ManagedObjectReference, extensionKey string, publicKey string,
) error {

	return nil

}

//
// Unregisters the specified extension if it exists.
//
// Required Privileges
// Extension.Unregister
//
func (mo *ExtensionManager) UnregisterExtension(
	_this *ManagedObjectReference, extensionKey string,
) error {

	return nil

}

//
// If the key specified in the extension exists,
// the existing record is updated.
//
// If the "subjectName" property of the Extension
// object has a value, and it is different from the existing
// value, this method will unset any public key or
// certificate associated with the extension.
//
//
// Required Privileges
// Extension.Update
//
func (mo *ExtensionManager) UpdateExtension(
	_this *ManagedObjectReference, extension *Extension,
) error {

	return nil

}

//
// This data object type contains usage information about an
// extension's IP allocation usage.
//
//
type ExtensionManagerIpAllocationUsage struct {
	*DynamicData

	// Key of the extension whose usage is being
	// reported.
	ExtensionKey string

	// Number of IP addresses allocated from IP pools.
	NumAddresses int32
}

//
// This data object contains configuration for extensions that also extend the OVF
// functionality of vCenter server.
//
// Note: This feature is for internal use only.
//
//
//
type ExtensionOvfConsumerInfo struct {
	*DynamicData

	// Callback url for the OVF consumer. This URL must point to a SOAP API
	// implementing the OVF consumer interface.
	//
	// Example: https://extension-host:8081/
	//
	//
	// This callback is for internal use only.
	CallbackUrl string

	// A list of fully qualified OVF section types that this consumer handles.
	//
	// Fully qualified means that each section type must be prefixed with its namespace
	// enclosed in curly braces. See the examples below.
	//
	// An InvalidArgument error is thrown if there is overlap between OVF consumers,
	// meaning that the same section type appears in the sectionType list of more than
	// one OVF consumer.
	//
	// Example: [ "{http://www.vmware.com/schema/vServiceManager}vServiceDependency",
	// "{http://www.vmware.com/schema/vServiceManager}vServiceBinding" ]
	SectionType []string
}

//
// This data object type describes privileges defined by the extension.
//
//
type ExtensionPrivilegeInfo struct {
	*DynamicData

	// Hierarchical group name. Each level of the grouping hierarchy is
	// separated by a "." so group names may not include a ".".
	// privGroupName.
	PrivGroupName string

	// The ID of the privilege.  The format should be
	// "<group name>.<privilege name>".
	// The group name should be the same as the privGroupName
	// property.
	//
	// The privilege name should follow java package naming
	// conventions for uniqueness. The set of characters allowed
	// follow the same rules as key.
	PrivID string
}

//
// This data object encapsulates the message resources for all locales.
//
//
type ExtensionResourceInfo struct {
	*DynamicData

	Data []*KeyValue

	Locale string

	// Module for a resource type and other message or fault resources.
	// Examples: "task" for task, "event" for event and "auth" for "privilege".
	Module string
}

//
// This data object type describes a server for the extension.
//
//
type ExtensionServerInfo struct {
	*DynamicData

	// Extension administrator email addresses.
	AdminEmail []string

	// Company information.
	Company string

	// Server description.
	Description *Description

	// Thumbprint of the extension server certificate presented to clients
	//
	// Since vSphere API 4.1
	ServerThumbprint string

	// Type of server (examples may include SOAP, REST, HTTP, etc.).
	Type string

	// Server url.
	Url string
}

//
// This data object type describes task types defined by the extension.
//
//
type ExtensionTaskTypeInfo struct {
	*DynamicData

	// The ID of the task type. Should follow java package
	// naming conventions for uniqueness.
	TaskID string
}

//
// Fault type that could be thrown when enabling SPBM(Storage Policy
// Based Management) feature of a compute resource.
//
//
type FailToEnableSPBM struct {
	*NotEnoughLicenses

	// The compute resource
	Cs *ComputeResource

	// The computer resource name
	CsName string

	// Array of ComputeResourceHostSPBMLicenseInfo that
	// contains SPBM license information for all hosts in the compute resource
	HostLicenseStates []*ComputeResourceHostSPBMLicenseInfo
}

//
// Thrown when trying to state lock a Fault Tolerance VM, and the
// other VM in the same Fault Tolerance pair is already locked.
//
//
type FailToLockFaultToleranceVMs struct {
	*RuntimeFault

	// The vm that is already locked, this can be a Fault Tolerance primary or secondary VM
	AlreadyLockedVm *VirtualMachine

	// The vm to be locked, this can be a Fault Tolerance primary or secondary VM
	Vm *VirtualMachine

	// The name of the vm to be locked.
	VmName string
}

//
// This event records that the amount of cluster resources has increased
// and is now sufficient to satisfy the configured HA failover level.
//
//
type FailoverLevelRestored struct {
	*ClusterEvent
}

//
// More than one VM in the same fault tolerance group are placed on the same host
//
//
type FaultToleranceAntiAffinityViolated struct {
	*MigrationFault

	// The host.
	Host *HostSystem

	// The name of the host.
	HostName string
}

//
// The memory size, reservation, limit or shares of a virtual machine cannot
// be edited if Fault Tolerance is turned on
//
//
type FaultToleranceCannotEditMem struct {
	*VmConfigFault

	// The VM.
	Vm *VirtualMachine

	// The name of the VM.
	VmName string
}

//
// FaultToleranceConfigInfo is a data object type containing Fault Tolerance
// settings for this virtual machine.
// role, instanceUuids and configPaths contain information about the
// whole fault tolerance group.
//
//
type FaultToleranceConfigInfo struct {
	*DynamicData

	// The configuration file path for all the VMs in this fault tolerance
	// group.
	ConfigPaths []string

	// The instanceUuid of all the VMs in this fault tolerance group. The
	// first element is the instanceUuid of the primary VM.
	InstanceUuids []string

	// The index of the current VM in instanceUuids array starting from 1, so
	// 1 means that it is the primary VM.
	Role int32
}

//
// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 1 register ecx for FT vms.
//
//
type FaultToleranceCpuIncompatible struct {
	*CpuIncompatible

	// Flag to indicate CPU family is incompatible.
	Family bool

	// Flag to indicate CPU model is incompatible.
	Model bool

	// Flag to indicate CPU stepping is incompatible.
	Stepping bool
}

//
// Fault Tolerance VM requires thick disks
//
//
type FaultToleranceNeedsThickDisk struct {
	*MigrationFault

	// The name of the VM.
	VmName string
}

//
// This fault is thrown when fault tolerance has not been licensed on the
// source or destination host. It must be licensed on both hosts.
//
//
type FaultToleranceNotLicensed struct {
	*VmFaultToleranceIssue

	// The host name
	HostName string
}

//
// The destination host does not have the same build or Fault Tolerance
// feature version number as the source host.
//
//
type FaultToleranceNotSameBuild struct {
	*MigrationFault

	// The string.
	Build string
}

//
// FaultTolerancePrimaryConfigInfo is a data object type containing Fault Tolerance
// settings for a primary virtual machine in a fault tolerance group
//
//
type FaultTolerancePrimaryConfigInfo struct {
	*FaultToleranceConfigInfo

	Secondaries []*VirtualMachine
}

//
// This fault is used to report that VirtualCenter did not attempt to power on
// a Fault Tolerance secondary virtual machine because it was unable to
// power on the corresponding Fault Tolerance primary virtual machine.
//
//
type FaultTolerancePrimaryPowerOnNotAttempted struct {
	*VmFaultToleranceIssue

	// The corresponding primary virtual machine
	PrimaryVm *VirtualMachine

	// The secondary virtual machine that was not attempted
	SecondaryVm *VirtualMachine
}

//
// FaultToleranceSecondaryConfigInfo is a data object type containing Fault Tolerance
// settings for a secondary virtual machine in a fault tolerance group
//
//
type FaultToleranceSecondaryConfigInfo struct {
	*FaultToleranceConfigInfo

	PrimaryVM *VirtualMachine
}

//
// FaultToleranceSecondaryOpResult is a data object that reports on
// the outcome of the CreateSecondaryVM_Task or
// EnableSecondaryVM_Task operation.
//
//
type FaultToleranceSecondaryOpResult struct {
	*DynamicData

	// Whether an attempt was made to power on the secondary. If
	// an attempt was made, powerOnResult will report the
	// status of this attempt.
	PowerOnAttempted bool

	// The powerOnResult property reports the outcome of powering on the
	// Secondary VirtualMachine if a power on was required. A power on will
	// be attempted if the Primary Virtual Machine is powered on when the
	// operation is performed. This object is only reported if powerOnAttempted is true. If the outcome of the power-on attempt
	// is not successful, the returned ClusterPowerOnVmResult
	// object will include an instance of ClusterNotAttemptedVmInfo
	// whereas if the attempt was successful, then an instance of
	// ClusterAttemptedVmInfo is returned. When
	// ClusterAttemptedVmInfo is returned, its
	// task property is only set if the cluster
	// is a HA-only cluster.
	PowerOnResult *ClusterPowerOnVmResult

	// The Secondary VirtualMachine
	Vm *VirtualMachine
}

//
// A FaultToleranceVmNotDasProtected fault occurs when an Fault Tolerance VM
// is not protected by HA and the operation for terminating the primary VM
// or secondary VM is invoked.
//
//
type FaultToleranceVmNotDasProtected struct {
	*VimFault

	// The Fault Toelrance primary VM
	Vm *VirtualMachine

	// Name of the VM
	VmName string
}

//
// This data object type describes an FCoE configuration as it pertains
// to an underlying physical NIC.
//
// Terminology is borrowed from T11's working draft of the Fibre Channel
// Backbone 5 standard (FC-BB-5).  The draft can be found at
// http://www.t11.org.
//
//
type FcoeConfig struct {
	*DynamicData

	// Settable capabilities for this FcoeConfig.
	Capabilities *FcoeConfigFcoeCapabilities

	// Indicates whether this FcoeConfig is "active" (has been used in
	// conjunction with a parent physical network adapter for FCoE
	// discovery).
	FcoeActive bool

	// 802.1p priority class used for FCoE traffic.
	PriorityClass int32

	// Source MAC address used for FCoE traffic.
	//
	// This MAC address is associated with the logical construct that is a
	// physical NIC's associated underlying FCoE Controller, as defined in the
	// FC-BB-5 standard.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where 'x' is
	// a hexadecimal digit.  Valid MAC addresses are unicast addresses.
	SourceMac string

	// VLAN ranges associated with this FcoeConfig.
	VlanRange []*FcoeConfigVlanRange
}

//
// Flags which indicate what parameters are settable for this FcoeConfig.
//
//
type FcoeConfigFcoeCapabilities struct {
	*DynamicData

	PriorityClass bool

	SourceMacAddress bool

	VlanRange bool
}

//
// An FcoeSpecification contains values relevant to issuing FCoE discovery.
// Non-mandatory values are denoted '@optional'.
//
//
type FcoeConfigFcoeSpecification struct {
	*DynamicData

	// 802.1p priority class to use for FCoE traffic.
	PriorityClass int32

	// Source MAC address to use for FCoE traffic.
	//
	// This MAC address is associated with the logical construct that is a
	// physical NIC's associated underlying FCoE Controller, as defined in
	// the FC-BB-5 standard.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where 'x'
	// is a hexadecimal digit.  Valid MAC addresses are unicast addresses.
	SourceMac string

	// The name of this FcoeSpecification's underlying PhysicalNic
	UnderlyingPnic string

	// VLAN ranges to use for FCoE traffic.
	VlanRange []*FcoeConfigVlanRange
}

//
// Used to represent inclusive intervals of VLAN IDs.
//
// Valid VLAN IDs fall within the range [0,4094], and the low value of a
// VlanRange must be less than or equal to the high value.
//
//
type FcoeConfigVlanRange struct {
	*DynamicData

	VlanHigh int32

	VlanLow int32
}

//
// Base class for faults that can be thrown while invoking FCoE management operations.
//
//
type FcoeFault struct {
	*VimFault
}

//
// This fault indicates the given Software Fcoe NIC has no uplink ports
// that is required for initiating a discovery.
//
//
type FcoeFaultPnicHasNoPortSet struct {
	*FcoeFault

	NicDevice string
}

//
// The host does not meet feature requirements of the virtual machine.
//
//
type FeatureRequirementsNotMet struct {
	*VirtualHardwareCompatibilityIssue

	// The feature requirements that were not met.
	FeatureRequirement []*VirtualMachineFeatureRequirement

	// The host whose capabilities did not meet the virtual machine's feature requirements.
	Host *HostSystem

	// The virtual machine whose feature requirements were not met.
	Vm *VirtualMachine
}

//
// The operating mode of the adapter.
//
//
type FibreChannelPortType struct {
}

//
// This fault is thrown when an operation attempts to create a file using the name of
// an existing file.
//
//
type FileAlreadyExists struct {
	*FileFault
}

//
// The virtual machine has a port (either a SerialPort or a ParallelPort) which is
// backed by a file. This is an error when migrating a virtual machine with the device
// connected, and can be returned as a subfault of DisallowedMigrationDeviceAttached.
//
//
type FileBackedPortNotSupported struct {
	*DeviceNotSupported
}

//
// Specification used to create a file based virtual disk
//
//
type FileBackedVirtualDiskSpec struct {
	*VirtualDiskSpec

	// Specify the capacity of the virtual disk in Kb.
	CapacityKb int64

	// Virtual Disk Profile requirement.
	//
	// Profiles are solution specifics.
	//
	// Profile Based Storage Management is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with it.
	//
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	//
	// Since vSphere API 5.5
	Profile []*VirtualMachineProfileSpec
}

//
// The common base type for all file-related exceptions.
//
//
type FileFault struct {
	*VimFault

	// The file in question.
	File string
}

//
// This data object type contains rudimentary information about a file in a
// datastore. The information here is not meant to cover all information in
// traditional file systems, but rather to provide sufficient information for files
// that are associated with virtual machines. Derived types describe the known file
// types for a datastore.
//
//
type FileInfo struct {
	*DynamicData

	// The size of the file in bytes.
	FileSize int64

	// The last date and time the file was modified.
	Modification time.Time

	// The user name of the owner of the file.
	//
	// Since vSphere API 4.0
	Owner string

	// The path relative to the folder path in the search results.
	Path string
}

//
// Thrown if an attempt is made to lock a file that is already in use.
//
//
type FileLocked struct {
	*FileFault
}

//
// This managed object type provides a way to manage and manipulate files and
// folders on datastores. The source and the destination names are in the form of
// a URL or a datastore path.
//
// A URL has the form
//
// scheme://authority/folder/path?dcPath=dcPath&amp;dsName=dsName
// where
// • scheme is http or https.
//
// • authority specifies the hostname or IP address of the VirtualCenter or
// ESX server and optionally the port.
//
// • dcPath is the inventory path to the Datacenter containing the
// Datastore.
//
// • dsName is the name of the Datastore.
//
// • path is a slash-delimited path from the root of the datastore.
//
//
// A datastore path has the form
// [datastore] path
// where
// • datastore is the datastore name.
//
// • path is a slash-delimited path from the root of the datastore.
//
// An example datastore path is "[storage] path/to/file.extension".
// A listing of all the files, disks and folders on
// a datastore can be obtained from the datastore browser.See HostDatastoreBrowser
//
type FileManager struct {
	*ManagedObject
}

//
// Change the owner for a file.
//
//
// This method is currently not supported.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 4.0
//
func (mo *FileManager) ChangeOwner(
	_this *ManagedObjectReference, name string, datacenter *Datacenter, owner string,
) error {

	return nil

}

//
// Copies the source file or folder to the destination.
//
// If the destination file does not exist, it is created.
// If the destination file exists, the force parameter determines whether
// to overwrite it with the source or not.
// Folders can be copied recursively. In this case, the
// destination, if it exists, must be a folder, else one will be created. Existing
// files on the destination that conflict with source files can be overwritten using
// the force parameter. Files and disks are always copied in binary format during
// recursive copy.
//
//
// If source (or destination) name is specified as a URL, then the
// corresponding datacenter parameter may be omitted.
//
//
// If any intermediate level folder specified by the source and destination
// does not exist, a FileNotFound fault is thrown.
//
//
// If a file of a virtual machine is overwritten on the destination datastore
// as a result of the force parameter, it may corrupt that virtual machine.
//
//
// If the source is an extent of a virtual disk, this operation treats the extent
// as a file.
//
//
// If source and destination resolve to the same file system location,
// the call has no effect.
//
//
// It is important to note that this operation will provide transactional guarantees
// only for a file. No guarantees are provided when copying a folder.
// If the intent is to clone a virtual machine registered in the inventory,
// with transactional guarantees, please refer to CloneVM_Task.
//
//
// Datastore.FileManagement privilege is required on both source and
// destination datastores.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *FileManager) CopyDatastoreFile_Task(
	_this *ManagedObjectReference, sourceName string, sourceDatacenter *Datacenter, destinationName string, destinationDatacenter *Datacenter, force bool,
) (*Task, error) {

	return nil, nil

}

//
// Deletes the specified file or folder from the datastore.
// If a file of a virtual machine is deleted, it may corrupt that
// virtual machine. Folder deletes are always recursive.
// The datacenter parameter may be omitted if a URL is used to name
// the file or folder.
//
// If the source is an extent of a virtual disk, this operation treats the extent
// as a file.
//
//
// It is important to note that this operation will provide transactional guarantees
// only for a file. No guarantees are provided when deleting folders.
// If the intent is to delete a virtual machine registered in the inventory,
// please refer to Destroy_Task.
//
//
//
// Requires Datastore.FileManagement privilege on the datastore.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *FileManager) DeleteDatastoreFile_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (*Task, error) {

	return nil, nil

}

//
// Create a folder using the specified name. If the parent
// or intermediate level folders do not exist, and the parameter
// createParentDirectories is false, a FileNotFound fault
// is thrown.
// If the intermediate level folders do not exist, and the parameter
// createParentDirectories is true, all the non-existent folders
// are created.
//
//
// Requires Datastore.FileManagement privilege on the datastore.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *FileManager) MakeDirectory(
	_this *ManagedObjectReference, name string, datacenter *Datacenter, createParentDirectories bool,
) error {

	return nil

}

//
// Moves the source file or folder to the destination.
//
// If the destination file does not exist, it is created.
// If the destination file exists, the force parameter determines whether
// to overwrite it with the source or not.
// If the source path is a folder, then the destination path must not exist; the
// destination cannot be overwritten even with a force flag in that case. Folder
// moves are recursive, treating all files and disks to move as binary.
//
//
// If source (or destination) name is specified as a URL, then the
// corresponding datacenter parameter may be omitted.
//
//
// If any intermediate level folder specified by the source and destination
// does not exist, a FileNotFound fault is thrown.
//
//
// If a file of a virtual machine is moved, it may corrupt that virtual machine.
// If a file of a virtual machine is overwritten on the destination datastore
// as a result of the force parameter, it may corrupt that virtual machine.
//
//
// If the source is an extent of a virtual disk, this operation treats the extent
// as a file.
//
//
// If source and destination resolve to the same file system location,
// the call has no effect.
//
//
// It is important to note that this operation will provide transactional guarantees
// only for a file. No guarantees are provided for folder moves. If the intent is
// to move a virtual machine registered in the inventory, with transactional
// guarantees, please refer to RelocateVM_Task.
// If the intent is to rename a virtual machine registered in the inventory, please
// refer to Rename_Task.
//
//
// Datastore.FileManagement privilege is required on both source and
// destination datastores.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *FileManager) MoveDatastoreFile_Task(
	_this *ManagedObjectReference, sourceName string, sourceDatacenter *Datacenter, destinationName string, destinationDatacenter *Datacenter, force bool,
) (*Task, error) {

	return nil, nil

}

//
// This fault is thrown when an operation fails because the name of the
// specified file is too long.
//
//
type FileNameTooLong struct {
	*FileFault
}

//
// This fault is thrown when an operation fails because the specified file
// does not exist.
//
//
type FileNotFound struct {
	*FileFault
}

//
// Thrown if an attempt is made to write to a read-only file.
//
//
type FileNotWritable struct {
	*FileFault
}

//
// The data object type that describes the base query specification. Contains query
// filters and details that apply to every file. Querying only file details generally
// does not require opening files and so is an efficient query. Derived types add
// query parameters specific to the type of file.
//
//
type FileQuery struct {
	*DynamicData
}

//
// The FileInfo.Details data object type is a set of flags for a search request.
// This search request specifies which details to return for each matching file.
// This data object type is here to ensure that there is one flag corresponding to
// each FileInfo property other than the path name, which a search always returns.
//
//
type FileQueryFlags struct {
	*DynamicData

	// The flag to indicate whether or not to return the file owner.
	//
	// Since vSphere API 4.0
	FileOwner bool

	// The flag to indicate whether or not the size of the file is returned.
	FileSize bool

	// The flag to indicate whether or not the files that match this query
	// specification are returned along with file type information. This field must
	// be set to return specific details about the file type.
	FileType bool

	// The flag to indicate whether or not to return the date and time the file was
	// last modified.
	Modification bool
}

//
// Status of volume's support for vStorage hardware acceleration.
// The ESX Server determines the status based on the capabilities
// of the devices that support the file system volume.
// When a host boots, the support status is unknown.
// As the ESX host attempts hardware-accelerated operations,
// it determines whether the storage device supports hardware
// acceleration and sets the vStorageSupport
// property accordingly.
//
//
type FileSystemMountInfoVStorageSupportStatus struct {
}

//
// This fault is thrown when an operation fails because the file is larger
// than the maximum file size supported by the datastore.
//
//
type FileTooLarge struct {
	*FileFault

	// The name of the datastore that does not support the file's size.
	Datastore string

	// The size (in bytes) of the file.
	FileSize int64

	// The max file size (in bytes) supported on the datastore.
	MaxFileSize int64
}

//
// Represents the information about a
// InitiateFileTransferFromGuest operation
// of GuestFileManager object.
//
// The user can use the URL provided in url property to transfer
// the file from the guest. The user should send a HTTP GET request to the
// URL. Entire file content will be returned in the body of the response
// message.
//
//
//
type FileTransferInformation struct {
	*DynamicData

	// File attributes of the file that is being transferred from the guest.
	Attributes *GuestFileAttributes

	// Total size of the file in bytes.
	Size int64

	// Specifies the URL to which the user has to send HTTP GET request.
	// Multiple GET requests cannot be sent to the URL simulatenously. URL
	// will become invalid once a successful GET request is sent.
	//
	// The host part of the URL is returned as '*' if the hostname to be used
	// is the name of the server to which the call was made. For example, if
	// the call is made to esx-svr-1.domain1.com, and the file is available for
	// download from
	// http://esx-svr-1.domain1.com/guestFile?id=1&token=1234,
	// the URL returned may be
	// http://*/guestFile?id=1&token=1234.
	// The client replaces the asterisk with the server name on which it
	// invoked the call.
	Url string
}

//
// This fault is thrown when creating a quiesced snapshot failed
// because the create snapshot operation exceeded the time limit
// for holding off I/O in the frozen VM.
//
// This indicates that when we attempted to thaw the VM after
// creating the snapshot, we got an error back indicating that
// the VM was not frozen anymore. In this case, we roll back
// the entire snapshot create operation and throw this exception.
//
//
//
type FilesystemQuiesceFault struct {
	*SnapshotFault
}

//
// The FirewallProfile data object represents a host firewall configuration.
// If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type FirewallProfile struct {
	*ApplyProfile

	// List of Rulesets that will be configured for the firewall subprofile.
	Ruleset []*FirewallProfileRulesetProfile
}

type FirewallProfileRulesetProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string
}

//
// The FloatOption data object type defines the minimum, maximum,
// and default values for a float option.
//
//
type FloatOption struct {
	*OptionType

	// The default value.
	DefaultValue float32

	// The maximum value.
	Max float32

	// The minimum value.
	Min float32
}

//
// This data object type describes a file that is a floppy disk image.
//
//
type FloppyImageFileInfo struct {
	*FileInfo
}

//
// This data object type describes the query specification for a floppy disk image.
//
//
type FloppyImageFileQuery struct {
	*FileQuery
}

//
// The Folder managed object is a container for storing and organizing
// inventory objects. Folders can contain folders and other objects.
// The childType property identifies a folder's type
// and determines the types of folders and objects the folder can contain.
//
//
// •  A folder can contain a child folder of the same type as the parent folder.
//
// •  All Datacenter objects contain dedicated folders for:
//
// •  VirtualMachine, templates, and VirtualApp objects.
//
// •  ComputeResource hierarchies.
//
// •  Network, DistributedVirtualSwitch, and
// DistributedVirtualPortgroup objects.
//
// •  Datastore objects.
//
//
//
//
// •  A folder can contain child objects of type childType.
// Virtual machine and network entity folders can also contain additional object types.
//
// •  The root folder is a data center folder.
//
//
//
// See ServiceInstance for a representation of the organization of the inventory.
//
// The Folder managed object also acts as a factory object, meaning it
// creates new entities in a folder. The object provides methods to create
// child folders and objects, methods to add existing objects to folders, and
// methods to remove objects from folders and to delete folders.
//
//
// Folder inherits the Destroy_Task method.
// Destroy_Task is a recursive operation that removes all child objects and
// folders. When you call Destroy_Task to destroy a folder, the system uses
// the specified folder as a root and traverses its descendant hierarchy, calling
// Destroy_Task on each object.
// Destroy_Task is a single operation that treats each recursive call as a
// single transaction, committing each call to remove an object individually.
// If Destroy_Task fails on an object, the method terminates at that point
// with an exception, leaving some or all of the objects still in the inventory.
//
//
// Notes on the folder destroy method:
//
//
//
// • Calling Destroy_Task on a virtual machine folder recursively calls
// Destroy_Task on all the child virtual machines and vApps, which are then
// removed from disk.
// Use UnregisterAndDestroy_Task
// to unregister virtual machines or vApps recursively without
// removing them from the disk.
//
// • For virtual machine folders, the Destroy_Task method requires the
// VirtualMachine.Delete privilege on the folder as well as
// all virtual machines to be destroyed. It also requires the VirtualApp.Delete
// privilege on all VirtualApp objects to be destroyed.
//
// • Destroying a host folder or datacenter folder unregisters all child hosts
// and virtual machines from vCenter. The hosts are simply removed
// from the inventory, along with their virtual machines. The virtual machines
// are not removed from disk nor are their runtime states changed.
//
// •  You can remove network and datastore folders only if they are empty.
//
// •  You cannot destroy, rename, or move the virtual machine, compute resource,
// network entity, and datastore child folders of a Datacenter.
//
//
//
//
type Folder struct {
	*ManagedEntity

	childEntity []*ManagedEntity

	childType []string
}

// An array of managed object references. Each entry is a reference to a child entity.
// Required Privilege: System.View
func (mo *Folder) ChildEntity() ([]*ManagedEntity, error) {
	t, err := mo.currentProperty("childEntity")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ManagedEntity)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ManagedEntity")
	}
	return v, nil
}

// Specifies the object types a folder may contain.
// When you create a folder, it inherits its childType from the parent folder
// in which it is created. childType is an array of strings. Each array entry
// identifies a set of object types - Folder and one or more managed object
// types. The following list shows childType values for the different folders:
//
// { "vim.Folder", "vim.Datacenter" } - Identifies the root folder
// and its descendant folders. Data center folders can contain
// child data center folders and Datacenter managed objects.
// Datacenter objects contain virtual machine, compute resource,
// network entity, and datastore folders.
// { "vim.Folder", "vim.Virtualmachine", "vim.VirtualApp" } - Identifies
// a virtual machine folder. A virtual machine folder may contain child
// virtual machine folders. It also can contain VirtualMachine managed objects,
// templates, and VirtualApp managed objects.
// { "vim.Folder", "vim.ComputeResource" } - Identifies a
// compute resource folder, which contains child compute resource folders
// and ComputeResource hierarchies.
// { "vim.Folder", "vim.Network" } - Identifies a network entity folder.
// Network entity folders on a vCenter Server can contain Network,
// DistributedVirtualSwitch, and DistributedVirtualPortgroup managed
// objects. Network entity folders on an ESXi host can contain only
// Network objects.
// { "vim.Folder", "vim.Datastore" } - Identifies a datastore folder.
// Datastore folders can contain child datastore folders and Datastore
// managed objects.
// Required Privilege: System.View
func (mo *Folder) ChildType() ([]string, error) {
	t, err := mo.currentProperty("childType")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]string)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []string")
	}
	return v, nil
}

//
// Creates a new single-host compute resource. The name provided can be an
// IP address, such as 192.168.0.120, or a string, such as esx120.
// If a name is specified, a DNS lookup is used to resolve it to a fully-qualified
// name, such as esx120.vmware.com. If the DNS lookup fails, the string is
// stored as specified.
//
// Licenses for the host are allocated when making the first connection to
// the host. This is because the license needed typically depends on the type
// of host and the number of CPUs.
//
//
//
// In addition to the Host.Inventory.AddStandaloneHost privilege, it
// requires System.View privilege on the VM folder that the VMs of the
// host will be placed on.
//
//
// Required Privileges
// Host.Inventory.AddStandaloneHost
//
func (mo *Folder) AddStandaloneHost_Task(
	_this *ManagedObjectReference, spec *HostConnectSpec, compResSpec *ComputeResourceConfigSpec, addConnected bool, license string,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of VI API 2.5, use CreateClusterEx.
//
//
// Creates a new cluster compute resource in this folder.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// Required Privileges
// Host.Inventory.CreateCluster
//
func (mo *Folder) CreateCluster(
	_this *ManagedObjectReference, name string, spec *ClusterConfigSpec,
) (*ClusterComputeResource, error) {

	return nil, nil

}

//
// Creates a new cluster compute resource in this folder.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// Required Privileges
// Host.Inventory.CreateCluster
// Since
// VI API 2.5
//
func (mo *Folder) CreateClusterEx(
	_this *ManagedObjectReference, name string, spec *ClusterConfigSpecEx,
) (*ClusterComputeResource, error) {

	return nil, nil

}

//
// Creates a new datacenter with the given name.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// Required Privileges
// Datacenter.Create
//
func (mo *Folder) CreateDatacenter(
	_this *ManagedObjectReference, name string,
) (*Datacenter, error) {

	return nil, nil

}

//
// Create a DistributedVirtualSwitch in the folder according to the
// specified DVSCreateSpec. The specified Folder
// must be a Network entity folder.
//
// Required Privileges
// DVSwitch.Create
// Since
// vSphere API 4.0
//
func (mo *Folder) CreateDVS_Task(
	_this *ManagedObjectReference, spec *DVSCreateSpec,
) (*Task, error) {

	return nil, nil

}

//
// Creates a new sub-folder with the specified name. The childType property
// of the new folder is the same as the childType property of the current folder.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// Required Privileges
// Folder.Create
//
func (mo *Folder) CreateFolder(
	_this *ManagedObjectReference, name string,
) (*Folder, error) {

	return nil, nil

}

//
// Creates a new storage pod in this folder.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// Required Privileges
// Folder.Create
// Since
// vSphere API 5.0
//
func (mo *Folder) CreateStoragePod(
	_this *ManagedObjectReference, name string,
) (*StoragePod, error) {

	return nil, nil

}

//
// Creates a new virtual machine in the current folder and attaches it to the
// specified resource pool. This operation creates a virtual machine,
// instead of cloning a virtual machine from an existing one.
//
//
// The server does not support creating templates using this method.
// Instead, you should create templates by marking existing virtual
// machines as templates, or by cloning an existing virtual machine or
// template.
//
//
//
// This operation only works if the folder's childType includes VirtualMachine.
//
// In addition to the VirtualMachine.Inventory.Create privilege, may also require
// any of the following privileges depending on the properties of the virtual
// machine bring created:
//
//
//
// • VirtualMachine.Config.AddExistingDisk if including a virtual disk device
// that refers to an existing virtual disk file (not RDM)
//
// • VirtualMachine.Config.AddNewDisk if including a virtual disk device that
// creates a new virtual disk file (not RDM)
//
// • VirtualMachine.Config.RawDevice if including a raw device mapping
// (RDM) or SCSI passthrough device
//
// • VirtualMachine.Config.HostUSBDevice if including a VirtualUSB device
// backed by a host USB device
//
// • VirtualMachine.Config.AdvancedConfig if setting values in
// ConfigSpec.extraConfig
//
// • VirtualMachine.Config.SwapPlacement if setting swapPlacement
//
// • VirtualMachine.Config.ChangeTracking if setting changed
// block tracking for the virtual machine's disks.
//
// • Datastore.AllocateSpace required on all datastores where the
// virtual machine and its virtual disks will be created
//
// • Network.Assign required on the network which is assigned to the
// new virtual machine that is being created
//
//
//
//
// Required Privileges
// VirtualMachine.Inventory.Create
//
func (mo *Folder) CreateVM_Task(
	_this *ManagedObjectReference, config *VirtualMachineConfigSpec, pool *ResourcePool, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Moves a set of managed entities into this folder.
//
// This operation is typically used by clients when they implement a drag-and-drop
// interface to move a set of objects into a folder.
//
//
// This operation is transactional only with respect to each individual entity.
// The set of entities is moved sequentially as specified in the list, and
// committed one at a time. If the MoveIntoFolder_Task method fails on an object, the
// method terminates at that point with an exception, leaving the rest of the
// managed entities in their original location.
//
//
// The objects that can be moved into a folder depends on the folder's
// type (as defined by the folder's childType property).
// For a datacenter folder, only datacenters and datacenter folders can be
// moved into the folder. For a virtual machine folder, only virtual machines
// and virtual machine folders can be moved into the folder.
// For a host folder, ComputeResource objects, host folder objects, and
// HostSystem objects can be moved into the folder.
//
//
// Moving a HostSystem into a host folder creates a stand-alone host from a
// host that is currently part of a ClusterComputeResource. The host must be part
// of a ClusterComputeResource in the same datacenter and the host must be in
// maintenance mode. Otherwise, the operation fails.
//
//
// A ComputeResource with a single root resource pool is created for each
// HostSystem. The name of the ComputeResource is the DNS or IP address of the
// host. This operation moves the (physical) host resources out of a cluster.
// It does not move or change the ResourcePool configuration that is part of the
// ClusterComputeResource with which the host was associated.
//
//
// Note that all virtual machines associated with a host are moved with the host
// into the folder. If there are virtual machines that should not be moved
// with the host, then migrate them from the host before initiating this operation.
//
//
// For a HostSystem move, the privileges required are Host.Inventory.EditCluster
// on the source ClusterComputeResource, Host.Inventory.MoveHost on the HostSystem,
// and Host.Inventory.AddStandaloneHost on the target Folder.
//
//
// Otherwise, the privilege required for this operation varies depending on this
// folder's type and is checked against the source container, destination container,
// and the object:
//
//
//
// • Folder.Move if the object is a Folder
//
// • Datacenter.Move if the object is a Datacenter
//
// • Host.Inventory.MoveCluster if the object is a ComputeResource
//
// • VirtualMachine.Inventory.Move if the object is a virtual machine
// or virtual machine template
//
// • DVSwitch.Move if the object is a DistributedVirtualSwitch
//
// • Datastore.Move if the object is a datastore
//
// • Network.Move if the object is a network
//
//
//
// If the object is a HostSystem, the privileges required are
// Host.Inventory.AddStandaloneHost on the folder, Host.Inventory.MoveHost on
// the HostSystem, and Host.Inventory.EditCluster on the host's original
// ComputeResource.
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *Folder) MoveIntoFolder_Task(
	_this *ManagedObjectReference, list []*ManagedEntity,
) (*Task, error) {

	return nil, nil

}

//
// Adds an existing virtual machine to the folder.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// This operation only works if the folder's type is VirtualMachine.
//
// In addition to the VirtualMachine.Inventory.Register and
// Resource.AssignVMToPool privileges, it requires System.Read privilege
// on the datastore that the existing virtual machine resides on.
//
//
// Required Privileges
// VirtualMachine.Inventory.Register
//
func (mo *Folder) RegisterVM_Task(
	_this *ManagedObjectReference, path string, name string, asTemplate bool, pool *ResourcePool, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Recursively unregisters all virtual machines and vApps, and destroys
// all child virtual machine folders. This is similar to the Destroy_Task method,
// but this method calls UnregisterAndDestroy_Task on each virtual machine
// object instead of calling Destroy_Task.
// This operation applies only to VirtualMachine folders.
//
// UnregisterAndDestroy_Task is a recursive operation that destroys the specified
// virtual machine folder, unregisters all child virtual machine objects, and destroys
// all child virtual machine folders. When you call UnregisterAndDestroy_Task
// to destroy a virtual machine folder, the system uses the specified folder
// as a root and traverses its descendant hierarchy, calling UnregisterAndDestroy_Task
// on each virtual machine object and Destroy_Task on each virtual machine folder.
// UnregisterAndDestroy_Task is a single operation that treats each recursive call
// as a single transaction, committing each call to remove an object individually.
// If a failure occurs, the method terminates at that point with an exception, leaving
// some or all objects unaffected.
//
//
// If you are removing virtual machines, you must hold the VirtualMachine.Delete
// privilege on all of the virtual machines to be unregistered, and on their parent folders.
// If you are removing virtual applications, you must hold the VApp.Delete
// privilege on all of the virtual applications to be unregistered, and on their
// parent folders.
//
//
// Required Privileges
// Folder.Delete
//
func (mo *Folder) UnregisterAndDestroy_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// The event argument is a Folder object.
//
//
type FolderEventArgument struct {
	*EntityEventArgument

	// The Folder object.
	Folder *Folder
}

//
// This data object type describes a file that is a folder (directory).
//
//
type FolderFileInfo struct {
	*FileInfo
}

//
// This data object type describes the query specification for a folder (directory).
//
//
type FolderFileQuery struct {
	*FileQuery
}

//
// The FtIssuesOnHost fault reports issues that prevent a particular
// host from being used as the register or power on host for a Fault
// Tolerance secondary virtual machine
//
//
type FtIssuesOnHost struct {
	*VmFaultToleranceIssue

	// Information on the details of the Fault Tolerance issues
	Errors []*LocalizedMethodFault

	// The host which has Fault Tolerance issues.
	Host *HostSystem

	// Name for the host which has Fault Tolerance issues.
	HostName string
}

//
// HostSelectionType defines how the host was selected
//
//
type FtIssuesOnHostHostSelectionType struct {
}

//
// An operation on a powered-on virtual machine requests a simultaneous change
// of storage location and execution host, but the host does not have that
// capability.
//
//
type FullStorageVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// These are general events.
//
//
type GeneralEvent struct {
	*Event

	// A short form of the message string, not localized.
	Message string
}

//
// This event is the general error event for a host.
//
//
type GeneralHostErrorEvent struct {
	*GeneralEvent
}

//
// This event is the general information event for a host.
//
//
type GeneralHostInfoEvent struct {
	*GeneralEvent
}

//
// This event is the general warning event for a host.
//
//
type GeneralHostWarningEvent struct {
	*GeneralEvent
}

//
// This event is the general user event type.
//
//
type GeneralUserEvent struct {
	*GeneralEvent

	// The entity on which the event was logged.
	Entity *ManagedEntityEventArgument
}

//
// This event is the general error event for a virtual machine.
//
//
type GeneralVmErrorEvent struct {
	*GeneralEvent
}

//
// This event is the general information event for a virtual machine.
//
//
type GeneralVmInfoEvent struct {
	*GeneralEvent
}

//
// This event is the general warning event for a virtual machine.
//
//
type GeneralVmWarningEvent struct {
	*GeneralEvent
}

//
// DRS returns more than one faults for each virtual machine, or DRS returns
// VimFault because of some internal errors.
//
//
type GenericDrsFault struct {
	*VimFault

	// This is an optional field to return the detailed information back to
	// the client. This optional array may consist of the exact fault for
	// some hosts in the cluster.
	HostFaults []*LocalizedMethodFault
}

//
// Thrown when a running virtual machine reports an error.
//
//
type GenericVmConfigFault struct {
	*VmConfigFault

	// Message from the virtual machine
	Reason string
}

//
// This event records when Virtual Center server found DVS proxy switches
// on the host that don't match any DVS defined in Virtual Center.
//
//
type GhostDvsProxySwitchDetectedEvent struct {
	*HostEvent

	// The list of ghost DVS proxy switch uuids that were found.
	SwitchUuid []string
}

//
// This event records when the ghost DVS proxy switches (a.k.a host
// proxy switches that don't match any DVS defined in Virtual Center)
// were removed on the host.
//
//
type GhostDvsProxySwitchRemovedEvent struct {
	*HostEvent

	// The list of ghost DVS proxy switch uuid that were removed.
	SwitchUuid []string
}

//
// This event records a change to the global message.
//
//
type GlobalMessageChangedEvent struct {
	*SessionEvent

	// The new message that was set.
	Message string
}

//
// This data object type describes a group of
// actions that occur when the alarm is triggered. These actions are not
// necessarily executed in order.
//
//
type GroupAlarmAction struct {
	*AlarmAction

	// The list of alarm actions that occur when the alarm is triggered.
	Action []*AlarmAction
}

//
// AuthManager is the managed object that provides APIs
// to manipulate the guest operating authentication.
//
type GuestAuthManager struct {
	*ManagedObject
}

//
// Authenticates in the guest and returns a GuestAuthentication object
// with the acquired credentials for use in subsequent guest operation calls.
//
// This can be used to authenticate inside the guest and obtain a
// GuestAuthentication object for supported authentication types.
//
// This operation is not needed for Name and Password Authentication. To use
// Name and Password Authentication, see NamePasswordAuthentication.
//
// For SSPI authentication, requestAuth should be of the type SSPIAuthentication.
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestAuthManager) AcquireCredentialsInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, requestedAuth *GuestAuthentication, sessionID int64,
) (*GuestAuthentication, error) {

	return nil, nil

}

//
// Releases session data and resources associated with
// a GuestAuthentication object returned by AcquireCredentialsInGuest.
//
// This frees any resources and session data associated with a
// GuestAuthentication object returned by AcquireCredentialsInGuest.
// The GuestAuthentication object can no longer be used to
// authenticate in the guest once released. Currently this operation is only
// valid for TicketedSessionAuthentication objects.
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestAuthManager) ReleaseCredentialsInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication,
) error {

	return nil

}

//
// Validates the GuestAuthentication credentials.
//
// This can be used to check the authentication data, or
// validate any authetication that has a timeout is still valid.
// If the authentication is not valid, GuestPermissionDenied
// will be thrown.
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestAuthManager) ValidateCredentialsInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication,
) error {

	return nil

}

//
// GuestAuthentication is an abstract base class for authentication
// in the guest.
//
//
type GuestAuthentication struct {
	*DynamicData

	// This is set to true if the client wants an interactive session
	// in the guest.
	InteractiveSession bool
}

//
// Fault is thrown when a call to AcquireCredentialsInGuest requires a challenge
// response in order to authenticate in the guest. The authToken string
// in serverChallenge contains a base64 encoded challenge token.
//
//
type GuestAuthenticationChallenge struct {
	*GuestOperationsFault

	// Contains the server challenge information
	ServerChallenge *GuestAuthentication

	// Contains a session ID number that associates the server response
	// with the initial request.
	SessionID int64
}

//
// A GuestComponentsOutOfDate exception is thrown when an
// operation fails because the guest operations agent is out of date and lacks
// the functionality to execute the operation.
//
//
type GuestComponentsOutOfDate struct {
	*GuestOperationsFault
}

//
// Information about each virtual disk configured in the guest operating system.
//
//
type GuestDiskInfo struct {
	*DynamicData

	// Total capacity of the disk, in bytes.
	// This is part of the virtual machine configuration.
	Capacity int64

	// Name of the virtual disk in the guest operating system. For example: C:\
	DiskPath string

	// Free space on the disk, in bytes. This is retrieved by VMware Tools.
	FreeSpace int64
}

//
// Different attributes for a guest file.
//
//
//
//
// •  Check GuestPosixFileAttributes
// for Posix guest files.
//
// •  Check GuestWindowsFileAttributes
// for Windows guest files.
//
//
//
//
//
type GuestFileAttributes struct {
	*DynamicData

	// The date and time the file was last accessed.
	// If this property is not specified when passing a
	// GuestFileAttributes object to
	// InitiateFileTransferToGuest,
	// the default value will be the time when the file is created inside the
	// guest.
	AccessTime time.Time

	// The date and time the file was last modified.
	// If this property is not specified when passing a
	// GuestFileAttributes object to
	// InitiateFileTransferToGuest,
	// the default value will be the time when the file is created inside the
	// guest.
	ModificationTime time.Time

	// The target for the file if it's a symbolic link.
	// This is currently only set for Linux guest operating systems,
	// but may be supported in the
	// future on Windows guest operating systems that support symbolic links.
	// This property gives information about files when returned from
	// ListFilesInGuest or
	// InitiateFileTransferFromGuest
	// as part of a GuestFileAttributes object.
	// This property will be ignored when passing a
	// GuestFileAttributes object to
	// InitiateFileTransferToGuest or
	// ChangeFileAttributesInGuest.
	SymlinkTarget string
}

type GuestFileInfo struct {
	*DynamicData

	// Different attributes of a file.
	Attributes *GuestFileAttributes

	// The complete path to the file
	Path string

	// The file size in bytes
	Size int64

	// The file type, one of GuestFileType
	Type string
}

//
// FileManager is the managed object that provides APIs
// to manipulate the guest operating system files.
//
type GuestFileManager struct {
	*ManagedObject
}

//
// Changes the file attributes of a specified file inside the guest.
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) ChangeFileAttributesInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, guestFilePath string, fileAttributes *GuestFileAttributes,
) error {

	return nil

}

//
// Creates a temporary directory.
//
// Creates a new unique temporary directory for the user to use as needed.
// The user is responsible for removing it when it is no longer needed.
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) CreateTemporaryDirectoryInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, prefix string, suffix string, directoryPath string,
) (string, error) {

	return "", nil

}

//
// Creates a temporary file.
//
// Creates a new unique temporary file for the user to use as needed.
// The user is responsible for removing it when it is no longer needed.
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) CreateTemporaryFileInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, prefix string, suffix string, directoryPath string,
) (string, error) {

	return "", nil

}

//
// Deletes a directory in the guest OS.
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) DeleteDirectoryInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, directoryPath string, recursive bool,
) error {

	return nil

}

//
// Deletes a file in the guest OS
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) DeleteFileInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, filePath string,
) error {

	return nil

}

//
// Initiates an operation to transfer a file from the guest.
//
// Obtains a reference to
// FileTransferInformation object
// for the file transfer operation. The information object contains a URL
// to the file inside the guest to be transferred to the client.
//
// See FileTransferInformation for
// information on how to use the information object. If the power state
// of the Virtual Machine is changed when the file transfer is in progress,
// or the Virtual Machine is migrated,
// then the transfer operation is aborted.
//
//
// In order to ensure a secure connection to the host when transferring
// a file using HTTPS, the X.509 certificate for the host must be used
// to authenticate the remote end of the connection. The certificate of
// the host that the virtual machine is running on can be retrieved using
// the following fields:
// vm (VirtualMachine) -&gt; runtime (VirtualMachineRuntimeInfo)
// -&gt; host (HostSystem) -&gt; config (HostConfigInfo)
// -&gt; certificate.
//
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) InitiateFileTransferFromGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, guestFilePath string,
) (*FileTransferInformation, error) {

	return nil, nil

}

//
// Initiates an operation to transfer a file to the guest.
//
// Obtains a URL to the file inside the guest to be transferred from the
// client. The user should send a HTTP PUT request specifying the file
// content in the body of the request. Multiple PUT request cannot be
// sent to the URL simultaneously. URL will be invalidated after a
// successful PUT request is sent. If the power state of the Virtual
// Machine is changed when the file transfer is in progress, or
// the Virtual Machine is migrated, then the
// transfer operation is aborted.
//
//
// In order to ensure a secure connection to the host when transferring
// a file using HTTPS, the X.509 certificate for the host must be used
// to authenticate the remote end of the connection. The certificate of
// the host that the virtual machine is running on can be retrieved using
// the following fields:
// vm (VirtualMachine) -&gt; runtime (VirtualMachineRuntimeInfo)
// -&gt; host (HostSystem) -&gt; config (HostConfigInfo)
// -&gt; certificate.
//
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) InitiateFileTransferToGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, guestFilePath string, fileAttributes *GuestFileAttributes, fileSize int64, overwrite bool,
) (string, error) {

	return "", nil

}

//
// Returns information about files or directories in the guest.
//
// The results could be extermely large, so to minimize the size
// of the return value for cases where a UI only needs to show
// the first N results, the answer is batched.  Files are returned in
// OS-specific (inode) order.  If the directory is modified between
// queries, missing or duplicate results can occur.
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) ListFilesInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, filePath string, index int32, maxResults int32, matchPattern string,
) (*GuestListFileInfo, error) {

	return nil, nil

}

//
// Creates a directory in the guest OS
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) MakeDirectoryInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, directoryPath string, createParentDirectories bool,
) error {

	return nil

}

//
// Moves or renames a directory in the guest.
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) MoveDirectoryInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, srcDirectoryPath string, dstDirectoryPath string,
) error {

	return nil

}

//
// Renames a file in the guest.
//
//
//
// Required Privileges
// None
//
func (mo *GuestFileManager) MoveFileInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, srcFilePath string, dstFilePath string, overwrite bool,
) error {

	return nil

}

type GuestFileType struct {
}

//
// Information about the guest operating system.
//
// Most of this information is collected by VMware Tools.
// In general, be sure you have VMware Tools installed
// and that the virtual machine is running when you access this information.
//
//
//
type GuestInfo struct {
	*DynamicData

	// Application heartbeat status.
	// Please see VirtualMachineAppHeartbeatStatusType
	//
	// Since vSphere API 4.1
	AppHeartbeatStatus string

	// Application state.
	//
	// If vSphere HA is enabled and the vm is configured for Application Monitoring
	// and this field's value is "appStateNeedReset" then HA will attempt immediately reset
	// the vm.
	//
	// There are some system conditions which may delay the immediate reset. The immediate
	// reset will be performed as soon as allowed by vSphere HA and ESX. If during these
	// conditions the value is changed to appStateOk the reset will be cancelled.See GuestInfoAppStateType
	//
	// Since vSphere API 5.5
	AppState string

	// Guest information about disks.
	//
	// You can obtain Linux guest disk information for the following file system
	// types only: Ext2, Ext3, Ext4, ReiserFS, ZFS, NTFS, VFAT, UFS, PCFS, HFS, and MS-DOS.
	Disk []*GuestDiskInfo

	// A list of namespaces and their corresponding generation numbers.
	// Only namespaces with non-zero
	// maxSizeEventsFromGuest
	// are guaranteed to be present here.
	// Use ListNamespaces to retrieve list of
	// namespaces.
	//
	// Since vSphere API 5.1
	// Required Privilege: VirtualMachine.Namespace.EventNotify
	GenerationInfo []*GuestInfoNamespaceGenerationInfo

	// Guest operating system family, if known.
	GuestFamily string

	// Guest operating system full name, if known.
	GuestFullName string

	// Guest operating system identifier (short name), if known.
	GuestId string

	// Guest Operations availability.
	//
	// If true, the vitrual machine is ready to process guest operations.
	//
	// Since vSphere API 5.0
	GuestOperationsReady bool

	// Operation mode of guest operating system. One of:
	//
	// "running" - Guest is running normally.
	// "shuttingdown" - Guest has a pending shutdown command.
	// "resetting" - Guest has a pending reset command.
	// "standby" - Guest has a pending standby command.
	// "notrunning" - Guest is not running.
	// "unknown" - Guest information is not available.
	GuestState string

	// Hostname of the guest operating system, if known.
	HostName string

	// Interactive Guest Operations availability.
	//
	// If true, the vitrual machine is ready to process guest operations
	// as the user interacting with the guest desktop.
	//
	// Since vSphere API 5.0
	InteractiveGuestOperationsReady bool

	// Primary IP address assigned to the guest operating system, if known.
	IpAddress string

	// Guest information about IP networking stack, if known.
	//
	// Since vSphere API 4.1
	IpStack []*GuestStackInfo

	// Guest information about network adapters, if known.
	Net []*GuestNicInfo

	// Guest screen resolution info, if known.
	Screen *GuestScreenInfo

	// Current running status of VMware Tools in the guest operating system,
	// if known. The set of possible values is described in
	// VirtualMachineToolsRunningStatus
	//
	// Since vSphere API 4.0
	ToolsRunningStatus string

	// Deprecated.
	// As of vSphere API 4.0 use toolsVersionStatus and
	// toolsRunningStatus.
	//
	//
	// Current status of VMware Tools in the guest operating system, if known.
	ToolsStatus *enum.VirtualMachineToolsStatus

	// Current version of VMware Tools, if known.
	ToolsVersion string

	// Deprecated.
	// as of vSphere API 5.1 use toolsVersionStatus2.
	//
	//
	// Current version status of VMware Tools in the guest operating system,
	// if known. The set of possible values is described in
	// VirtualMachineToolsVersionStatus for vSphere API 5.0.
	//
	// Since vSphere API 4.0
	ToolsVersionStatus string

	// Current version status of VMware Tools in the guest operating system,
	// if known. The set of possible values is described in
	// VirtualMachineToolsVersionStatus
	//
	// Since vSphere API 5.0
	ToolsVersionStatus2 string
}

//
// Application state type.
//
//
type GuestInfoAppStateType struct {
}

type GuestInfoNamespaceGenerationInfo struct {
	*DynamicData

	// Namespace generation number.  Generation number is changed whenever
	// there is new unread event pending from the guest to the VMODL.
	GenerationNo int32

	// The namespace name as the unique key.
	Key string
}

type GuestListFileInfo struct {
	*DynamicData

	// A list of GuestFileInfo
	// data objects containing information for all the matching files.
	Files []*GuestFileInfo

	// The number of files left to be returned.  If non-zero,
	// then the next set of files can be returned by calling
	// ListFiles again with the index set to the number of results
	// already returned.
	Remaining int32
}

type GuestNicInfo struct {
	*DynamicData

	// Flag indicating whether or not the virtual device is connected.
	Connected bool

	// Link to the corresponding virtual device.
	DeviceConfigId int32

	// DNS configuration of the adapter.
	// This property is set only when Guest OS supports it.
	// See StackInfo dnsConfig for system wide
	// settings.
	//
	// Since vSphere API 4.1
	DnsConfig *NetDnsConfigInfo

	// Deprecated.
	// as of vSphere API 5.0, use ipConfig property.
	IpAddress []string

	// IP configuration settings of the adapter
	// See StackInfo ipStackConfig for system wide
	// settings.
	//
	// Since vSphere API 4.1
	IpConfig *NetIpConfigInfo

	// MAC address of the adapter.
	MacAddress string

	// NetBIOS configuration of the adapter
	//
	// Since vSphere API 4.1
	NetBIOSConfig *NetBIOSConfigInfo

	// Name of the virtual switch portgroup or dvPort connected to this adapter.
	Network string
}

//
// The common base type for all guest operations faults.
//
//
type GuestOperationsFault struct {
	*VimFault
}

//
// GuestOperationsManager is the managed object that provides APIs
// to manipulate the guest operating system files and process.
//
// Each class of APIs is separated into its own manager.
//
type GuestOperationsManager struct {
	*ManagedObject

	authManager *GuestAuthManager

	fileManager *GuestFileManager

	processManager *GuestProcessManager
}

// A singleton managed object that provides methods for guest authentication
// operations.
// Required Privilege: System.Anonymous
func (mo *GuestOperationsManager) AuthManager() (*GuestAuthManager, error) {
	t, err := mo.currentProperty("authManager")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*GuestAuthManager)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *GuestAuthManager")
	}
	return v, nil
}

// A singleton managed object that provides methods for guest file
// operations.
// Required Privilege: System.Anonymous
func (mo *GuestOperationsManager) FileManager() (*GuestFileManager, error) {
	t, err := mo.currentProperty("fileManager")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*GuestFileManager)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *GuestFileManager")
	}
	return v, nil
}

// A singleton managed object that provides methods for guest process
// operations.
// Required Privilege: System.Anonymous
func (mo *GuestOperationsManager) ProcessManager() (*GuestProcessManager, error) {
	t, err := mo.currentProperty("processManager")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*GuestProcessManager)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *GuestProcessManager")
	}
	return v, nil
}

//
// A GuestOperationsUnavailable exception is thrown when an
// operation fails to contact the guest operations agent
// running inside the virtual machine.
//
//
type GuestOperationsUnavailable struct {
	*GuestOperationsFault
}

//
// This data object type contains information to describe a
// particular guest operating system.
//
//
type GuestOsDescriptor struct {
	*DynamicData

	// Specifies the CPU feature compatibility masks.
	CpuFeatureMask []*HostCpuIdInfo

	// Family to which this guest operating system belongs.
	Family string

	// Full name of the guest operating system.
	// For example, if the value of "id" is "win2000Pro", then
	// the value of "fullName" is "Windows 2000 Professional".
	FullName string

	// Whether I/O Controller Hub is recommended for this guest.
	//
	// Since vSphere API 5.0
	Ich7mRecommended bool

	// Identifier (short name) for the guest operating system.
	Id string

	// Maximum number of cores per socket for this guest.
	//
	// Since vSphere API 5.0
	NumSupportedCoresPerSocket int32

	// Maximum number of sockets supported for this guest.
	//
	// Since vSphere API 5.0
	NumSupportedPhysicalSockets int32

	// Recommended 3D graphics for this guest.
	//
	// Since vSphere API 5.1
	Recommended3D bool

	// Recommended default CD-ROM type for this guest.
	//
	// Since vSphere API 5.5
	RecommendedCdromController string

	// Recommended default color depth for this guest.
	RecommendedColorDepth int32

	// Recommended default disk controller type for this guest.
	RecommendedDiskController string

	// Recommended default disk size for this guest, in MB.
	RecommendedDiskSizeMB int32

	// Recommended default ethernet controller type for this guest.
	RecommendedEthernetCard string

	// Recommended firmware type for this guest.
	//
	// Possible values are described in
	// GuestOsDescriptorFirmwareType
	//
	// Since vSphere API 5.0
	RecommendedFirmware string

	// Recommended default memory size for this guest, in MB.
	RecommendedMemMB int32

	// Recommended default SCSI controller type for this guest.
	RecommendedSCSIController string

	// Recommended default USB controller type for this guest.
	//
	// Since vSphere API 5.0
	RecommendedUSBController string

	// Whether SMC (Apple hardware) is recommended for this guest.
	//
	// Since vSphere API 5.0
	SmcRecommended bool

	// Flag that indicates wether the guest requires an SMC (Apple hardware).
	// This is logically equivalent to GuestOS = Mac OS
	//
	// Since vSphere API 5.0
	SmcRequired bool

	// List of supported disk controller types for this guest.
	SupportedDiskControllerList []string

	// List of supported ethernet cards for this guest.
	SupportedEthernetCard []string

	// Supported firmware types for this guest.
	//
	// Possible values are described in
	// GuestOsDescriptorFirmwareType
	//
	// Since vSphere API 5.0
	SupportedFirmware []string

	// Whether or not this guest should be allowed for selection
	// during virtual machine creation.
	//
	// Since vSphere API 5.0
	SupportedForCreate bool

	// Maximum number of processors supported for this guest.
	SupportedMaxCPUs int32

	// Maximum memory requirements supported for this guest, in MB.
	SupportedMaxMemMB int32

	// Minimum memory requirements supported for this guest, in MB.
	SupportedMinMemMB int32

	// Number of disks supported for this guest.
	SupportedNumDisks int32

	// List of supported USB controllers for this guest.
	//
	// Since vSphere API 5.0
	SupportedUSBControllerList []string

	// Support level of this Guest
	//
	// Possible values are described in
	// GuestOsDescriptorSupportLevel
	//
	// Since vSphere API 5.0
	SupportLevel string

	// Whether this guest supports 3D graphics.
	//
	// Since vSphere API 5.0
	Supports3D bool

	// Whether virtual CPUs can be added to this guest
	// while the virtual machine is running.
	//
	// Since vSphere API 4.0
	SupportsCpuHotAdd bool

	// Whether virtual CPUs can be removed from this guest
	// while the virtual machine is running.
	//
	// Since vSphere API 4.0
	SupportsCpuHotRemove bool

	// Whether the memory size for this guest can be changed
	// while the virtual machine is running.
	//
	// Since vSphere API 4.0
	SupportsMemoryHotAdd bool

	// Flag to indicate whether or not this guest can support
	// a disk configured as a slave.
	SupportsSlaveDisk bool

	// Flag indicating whether or not this guest supports the virtual
	// machine interface.
	//
	// Since vSphere API 4.0
	SupportsVMI bool

	// Flag to indicate whether or not this guest can support Wake-on-LAN.
	SupportsWakeOnLan bool

	// Whether USB controller is recommended for this guest.
	//
	// Since vSphere API 5.0
	UsbRecommended bool

	// Video RAM size limits supported by this guest, in KB.
	//
	// Since vSphere API 5.0
	VRAMSizeInKB *IntOption
}

//
// Firmware types
//
//
type GuestOsDescriptorFirmwareType struct {
}

//
// Guest OS support level
//
//
type GuestOsDescriptorSupportLevel struct {
}

//
// A GuestPermissionDenied exception is thrown when an
// operation fails because the authentication used
// is insufficient to perform the operation.
//
//
type GuestPermissionDenied struct {
	*GuestOperationsFault
}

//
// Different attributes for Posix guest file.
//
//
type GuestPosixFileAttributes struct {
	*GuestFileAttributes

	// The group ID.
	// If this property is not specified when passing a
	// GuestPosixFileAttributes object to
	// InitiateFileTransferToGuest,
	// the default value will be the group Id of the user who invoked
	// the file transfer operation.
	GroupId int32

	// The owner ID.
	// If this property is not specified when passing a
	// GuestPosixFileAttributes object to
	// InitiateFileTransferToGuest,
	// the default value will be the owner Id of the user who invoked
	// the file transfer operation.
	OwnerId int32

	// The file permissions in chmod(2) format.
	// If this property is not specified when passing a
	// GuestPosixFileAttributes object to
	// InitiateFileTransferToGuest,
	// the file will be created with 0644 permissions.
	Permissions int64
}

type GuestProcessInfo struct {
	*DynamicData

	// The full command line
	CmdLine string

	// If the process was started using
	// StartProgramInGuest
	// then the process completion time will be available if
	// queried within 5 minutes after it completes.
	EndTime time.Time

	// If the process was started using
	// StartProgramInGuest
	// then the process exit code will be available if
	// queried within 5 minutes after it completes.
	ExitCode int32

	// The process name
	Name string

	// The process owner
	Owner string

	// The process ID
	Pid int64

	// The start time of the process
	StartTime time.Time
}

//
// ProcessManager is the managed object that provides APIs
// to manipulate the guest operating system processes.
//
type GuestProcessManager struct {
	*ManagedObject
}

//
// List the processes running in the guest operating system,
// plus those started by StartProgramInGuest
// that have recently completed.
//
//
//
// Required Privileges
// None
//
func (mo *GuestProcessManager) ListProcessesInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, pids []int64,
) ([]*GuestProcessInfo, error) {

	return nil, nil

}

//
// Reads an environment variable from the guest OS
//
// If the authentication uses interactiveSession, then the
// environment being read will be that of the user logged into the desktop.
// Otherwise it's the environment of the system user.
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestProcessManager) ReadEnvironmentVariableInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, names []string,
) ([]string, error) {

	return nil, nil

}

//
// Starts a program in the guest operating system.
//
// A process started this way can have its status queried with
// ListProcessesInGuest.
// When the process completes, its exit code and end time will be
// available for 5 minutes after completion.
//
//
//
//
// Required Privileges
// None
//
func (mo *GuestProcessManager) StartProgramInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, spec *GuestProgramSpec,
) (int64, error) {

	return int64(0), nil

}

//
// Terminates a process in the guest OS.
//
//
//
// Required Privileges
// None
//
func (mo *GuestProcessManager) TerminateProcessInGuest(
	_this *ManagedObjectReference, vm *VirtualMachine, auth *GuestAuthentication, pid int64,
) error {

	return nil

}

//
// A GuestProcessNotFound exception is thrown when an
// operation fails because the guest process specified does not exist.
//
//
type GuestProcessNotFound struct {
	*GuestOperationsFault

	// The process ID that was not found.
	Pid int64
}

//
// This describes the arguments to StartProgramInGuest.
//
//
type GuestProgramSpec struct {
	*DynamicData

	// The arguments to the program.  In Linux and Solaris guest operating
	// systems, the program will be executed by a guest shell.
	// This allows stdio redirection, but may also
	// require that characters which must be escaped to the shell also
	// be escaped on the command line provided.
	//
	//
	//
	// For Windows guest operating systems, prefixing the command with
	// "cmd /c" can provide stdio redirection.
	Arguments string

	// An array of environment variables, specified
	// in the guest OS notation (eg PATH=c:\bin;c:\windows\system32
	// or LD_LIBRARY_PATH=/usr/lib:/lib), to be set for the program
	// being run.  Note that these are not additions to the default
	// environment variables; they define the complete set available to
	// the program. If none are specified the values are guest dependent.
	EnvVariables []string

	// The absolute path to the program to start.
	//
	// For Linux guest operating systems, /bin/bash is used to start the
	// program.
	//
	// For Solaris guest operating systems, /bin/bash is used to start
	// the program if it exists.
	// Otherwise /bin/sh is used.  If /bin/sh is used, then the process ID
	// returned by StartProgramInGuest will be that of the shell used
	// to start the program, rather than the program itself, due to the
	// differences in how /bin/sh and /bin/bash work.  This PID will
	// still be usable for watching the process with
	// ListProcessesInGuest to
	// find its exit code and elapsed time.
	ProgramPath string

	// The absolute path of the working directory for the program to be
	// run.  VMware recommends explicitly setting the working directory
	// for the program to be run.  If this value is unset or is an empty
	// string, the behavior depends on the guest operating system.
	// For Linux guest operating systems, if this value is unset or is
	// an empty string, the working directory will be the home directory
	// of the user associated with the guest authentication.
	// For other guest operating systems, if this value is unset, the
	// behavior is unspecified.
	WorkingDirectory string
}

type GuestScreenInfo struct {
	*DynamicData

	// Height of the screen in pixels.
	Height int32

	// Width of the screen in pixels.
	Width int32
}

//
// Information about the Internet Protocol stack
// as configured in the guest operating system.
//
//
type GuestStackInfo struct {
	*DynamicData

	// Client side DHCP for a given interface.
	// This reports only the system wide dhcp client settings.
	// See NicInfo.IpConfig for per interface settings.
	// For example on Linux, BSD systems:
	// Using the file dhclient.conf output would be reported as:
	// key='1', value='timeout 60;'
	// key='2', value='reboot 10;'
	DhcpConfig *NetDhcpConfigInfo

	// Client DNS configuration. How DNS queries are resolved.
	DnsConfig *NetDnsConfigInfo

	// IP route table configuration.
	IpRouteConfig *NetIpRouteConfigInfo

	// Report Kernel IP configuration settings.
	// The key part contains a unique number in the report.
	// The value part contains the 'key=value'
	// as provided by the underlying provider.
	// For example on Linux, BSD, the
	// systcl -a output would be reported as:
	// key='5', value='net.ipv4.tcp_keepalive_time = 7200'
	IpStackConfig []*KeyValue
}

//
// Different attributes for a Windows guest file.
//
//
type GuestWindowsFileAttributes struct {
	*GuestFileAttributes

	// The date and time the file was created.
	// This property gives information about files when returned from
	// ListFilesInGuest or
	// InitiateFileTransferFromGuest
	// as part of a GuestWindowsFileAttributes
	// object.  This property will be ignored when passing a
	// GuestWindowsFileAttributes object to
	// InitiateFileTransferToGuest or
	// ChangeFileAttributesInGuest.
	CreateTime time.Time

	// The file is hidden.
	// If this property is not specified when passing a
	// GuestWindowsFileAttributes object to
	// InitiateFileTransferToGuest,
	// the file will not be set as a hidden file.
	Hidden bool

	// The file is read-only.
	// If this property is not specified when passing a
	// GuestWindowsFileAttributes object to
	// InitiateFileTransferToGuest,
	// the file will not be set as a read-only file.
	ReadOnly bool
}

//
// This describes the arguments to StartProgramInGuest that apply
// only for Windows guests.
//
//
type GuestWindowsProgramSpec struct {
	*GuestProgramSpec

	// Makes any program window start minimized.
	StartMinimized bool
}

//
// The destination compute resource is HA-enabled, and HA is not running
// properly.  This will cause the following problems:
// 1) The VM will not have HA protection.
// 2) If this is an intracluster VMotion, HA will not be properly
// informed that the migration completed.  This can have serious
// consequences to the functioning of HA.
//
//
type HAErrorsAtDest struct {
	*MigrationFault
}

//
// This data object represents the essential information about the
// state of a given replicated VirtualMachine.
//
//
type HbrManagerReplicationVmInfo struct {
	*DynamicData

	// An optional imageId that identifies the instance being created,
	// this is the imagId string that is passed to
	// HbrCreateInstance_Task or
	// HbrStartOfflineInstance_Task
	ImageId string

	// A MethodFault representing the last replication specific error
	// that the VirtualMachine encountered during a create
	// instance operation. The successful creation of an instance
	// will clear any error.
	LastError *LocalizedMethodFault

	// Progress stats for the current operation. Never present if the state is
	// not "syncing" or "active". If not present while in one of these states,
	// the host is still gathering initial operation statistics (progress can
	// be assumed to be 0).
	ProgressInfo *ReplicationVmProgressInfo

	// A string representing the current State of the virtual machine.
	State string
}

//
// Event used to report change in health status of VirtualCenter components.
//
//
type HealthStatusChangedEvent struct {
	*Event

	// Unique ID of the VirtualCenter component.
	ComponentId string

	// Component name.
	ComponentName string

	// Current health status of the component.
	NewStatus string

	// Previous health status of the component.
	OldStatus string
}

//
// The system health runtime information
//
//
type HealthSystemRuntime struct {
	*DynamicData

	// Available hardware health information
	HardwareStatusInfo *HostHardwareStatusInfo

	// Available system health information
	SystemHealthInfo *HostSystemHealthInfo
}

//
// This managed object type enables clients to retrieve historical data and
// receive updates when the server appends new data to a collection.
// This is a base type for item-specific types related to event or task history.
// Historical data is inherently append-only,
// although a server administrator may periodically purge old data.
//
// Typically, a client creates a history collector by using a filter on a
// potentially large set, such as all the events in a datacenter.
// The collector provides access to the items that match the filter,
// which could also be a relatively large set.
//
//
// The items in a collector are always ordered by date and time of creation.
// Item properties normally include this time stamp.
//
//
// The client may set the "viewable latest page" for the collector,
// which is the contiguous subset of the items that are of
// immediate interest. These items are available as the "latestPage"
// property, which the client may retrieve and monitor by using the
// PropertyCollector managed object.
//
//
// Clients can change the page size of the "latestPage" by using
// setLatestPageSize().
//
//
// The client may use the following features of the history collector.
//
//
//
// • RewindCollector - Moves the "scrollable view" to
// the oldest item (the default setting).
//
// • readNext - Retrieves all the items in the collector, from the oldest
// item to the newest item. Retrieves either
// tasks or
// events depending on the operation.
//
// • readPrev - Retrieves all items (excluding the "viewable latest page") in
// the collector, from the newest item to the oldest item. Retrieves either
// tasks or
// events depending on the operation.
//
// • ResetCollector - Moves the "scrollable view" to
// the item immediately preceding the "viewable latest page".
//
//
//
//
type HistoryCollector struct {
	*ManagedObject

	filter interface{}
}

// The filter used to create this collector.
//
// The type of the returned filter is determined by the managed object
// for which the collector is created.
func (mo *HistoryCollector) Filter() (interface{}, error) {
	t, err := mo.currentProperty("filter")
	if err != nil {
		return nil, err
	}

	v, ok := t.(interface{})
	if !ok {
		return nil, errors.New("Unable to make type assertion to: interface{}")
	}
	return v, nil
}

//
// Destroys this collector.
//
// Required Privileges
// None
//
func (mo *HistoryCollector) DestroyCollector(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Moves the "scrollable view" to the item immediately preceding the
// "viewable latest page". If you use "readPrev",
// ReadPreviousTasks or
// ReadPreviousEvents,
// all items
// are retrieved from the newest item to the oldest item.
//
// Required Privileges
// None
//
func (mo *HistoryCollector) ResetCollector(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Moves the "scrollable view" to the oldest item. If you use
// ReadNextTasks or
// ReadNextEvents,
// all items are retrieved from the oldest item to the newest item. This
// is the default setting when the collector is created.
//
// Required Privileges
// None
//
func (mo *HistoryCollector) RewindCollector(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Sets the "viewable latest page" size to contain at most the
// number of items specified by the maxCount parameter).
//
//
//
// Required Privileges
// None
//
func (mo *HistoryCollector) SetCollectorPageSize(
	_this *ManagedObjectReference, maxCount int32,
) error {

	return nil

}

//
// Fault thrown when an attempt is made to adjust resource settings
// directly on a host that is being managed by VC. VC is currently the
// source of truth for all resource pools on the host.
//
// Examples of methods affected by this are:
// •  create respool
//
// •  update respool
//
// •  change VM resource settings.
//
//
type HostAccessRestrictedToManagementServer struct {
	*NotSupported
}

//
// This data object type contains common parameters
// for local account creation. The password and description properties
// are not supported for group accounts on POSIX hosts.
//
//
type HostAccountSpec struct {
	*DynamicData

	// The description of the specified account.
	Description string

	// The ID of the specified account.
	Id string

	// The password for a user or group.
	Password string
}

//
// The HostActiveDirectory data object contains
// Active Directory configuration information for an ESX host.
//
// The vSphere API supports Microsoft Active Directory management
// of authentication for ESX hosts. To integrate an ESX host
// into an Active Directory environment, you use an Active Directory
// account that has the authority to add a computer to a domain.
// The ESX Server locates the Active Directory domain controller.
// When you use the host profile to configure authentication
// for an ESX host, you specify the configuration operation (add or remove).
// To add the host to a domain, specify
// the domain, and the authorized Active Directory account user name and password.
// You do not need to specify these parameters to remove the host from a domain
// because the host has the information it needs to perform the operation.
// When you call ApplyHostConfig_Task
// to apply the configuration, the ESX Server will call the appropriate
// method (JoinDomain_Task
// or LeaveCurrentDomain_Task)
// on your behalf.
//
//
// Before you call the method to apply the host profile, check to see that the
// HostAuthenticationManager.supportedStore
// array contains a HostActiveDirectoryAuthentication object.
// The presence of the Active Directory authentication object indicates
// that a host is capable of joining a domain.
// However, if you try to add a host to a domain when the
// HostAuthenticationStoreInfo.enabled
// property is True, the join method will throw a fault.
//
//
// As an alternative to using the host profile to configure Active Directory
// authentication for an ESX host, your vSphere client application can call
// the HostActiveDirectoryAuthentication join and leave methods directly
// to add the host to or remove the host from a domain.
//
//
// To take advantage of ESX host membership in an Active Directory domain,
// grant permissions on the ESX host to users and groups in Active Directory
// who should have direct access to management of the ESX host.
// Use the UserDirectory.RetrieveUserGroups
// method to obtain information about Active Directory users and groups.
// After retrieving the Active Directory data, you can use the
// AuthorizationManager.SetEntityPermissions
// method to set the principal property
// to the appropriate user or group.
//
//
// By default, the ESX host assigns the Administrator role to the "ESX Admins" group.
// If the group does not exist when the host joins the domain, the host will
// not assign the role. In this case, you must create the "ESX Admins"
// group in the Active Directory. The host will periodically check the domain controller
// for the group and will assign the role when the group exists.
//
//
//
type HostActiveDirectory struct {
	*DynamicData

	// Configuration change operation to apply to the host. You can specify
	// the following values:
	//
	// add:
	// Add the host to the domain. The ESX Server will use the
	// HostActiveDirectorySpec information
	// (domain, account user name and password) to call
	// JoinDomain_Task.
	//
	// remove:
	// Remove the host from its current domain.
	// The ESX Server will call LeaveCurrentDomain_Task,
	// specifying True for the force parameter to
	// delete existing permissions.
	//
	// See HostConfigChangeOperation
	ChangeOperation string

	// Active Directory domain access information (domain and account
	// user name and password).
	Spec *HostActiveDirectorySpec
}

//
// The HostActiveDirectoryAuthentication managed object
// indicates domain membership status and provides methods
// for adding a host to and removing a host from a domain.
//
type HostActiveDirectoryAuthentication struct {
	*ManagedObject
	*HostDirectoryStore
}

//
// Import the CAM server's certificate to the local store of vmwauth.
//
// The certificate should have already been uploaded to ESXi file system.
//
//
// Required Privileges
// Host.Config.AuthenticationStore
// Since
// vSphere API 5.0
//
func (mo *HostActiveDirectoryAuthentication) ImportCertificateForCAM_Task(
	_this *ManagedObjectReference, certPath string, camServer string,
) (*Task, error) {

	return nil, nil

}

//
// Adds the host to an Active Directory domain.
//
// If the HostAuthenticationStoreInfo.enabled
// property is True (accessed through the info property),
// the host has joined a domain.
// The vSphere API will throw the InvalidState fault if you try
// to add a host to a domain when the host has already joined a domain.
//
//
// Required Privileges
// Host.Config.AuthenticationStore
//
func (mo *HostActiveDirectoryAuthentication) JoinDomain_Task(
	_this *ManagedObjectReference, domainName string, userName string, password string,
) (*Task, error) {

	return nil, nil

}

//
// Adds the host to an Active Directory domain through CAM service.
//
// If the HostAuthenticationStoreInfo.enabled
// property is True (accessed through the info property),
// the host has joined a domain.
// The vSphere API will throw the InvalidState fault if you try
// to add a host to a domain when the host has already joined a domain.
//
//
// Required Privileges
// Host.Config.AuthenticationStore
// Since
// vSphere API 5.0
//
func (mo *HostActiveDirectoryAuthentication) JoinDomainWithCAM_Task(
	_this *ManagedObjectReference, domainName string, camServer string,
) (*Task, error) {

	return nil, nil

}

//
// Removes the host from the Active Directory domain to which it belongs.
//
// Required Privileges
// Host.Config.AuthenticationStore
//
func (mo *HostActiveDirectoryAuthentication) LeaveCurrentDomain_Task(
	_this *ManagedObjectReference, force bool,
) (*Task, error) {

	return nil, nil

}

//
// The HostActiveDirectoryInfo data object describes ESX host
// membership in an Active Directory domain. If the
// HostAuthenticationStoreInfo.enabled
// property is True, the host is a member of a domain
// and the ESX Server will set the domain information properties.
//
//
type HostActiveDirectoryInfo struct {
	*HostDirectoryStoreInfo

	// Health information about the domain membership.
	// See HostActiveDirectoryInfoDomainMembershipStatus.
	DomainMembershipStatus string

	// The domain that this host joined.
	JoinedDomain string

	// List of domains with which the joinedDomain has a trust.
	// The joinedDomain is not included in the
	// trustedDomain list.
	TrustedDomain []string
}

type HostActiveDirectoryInfoDomainMembershipStatus struct {
}

//
// The HostActiveDirectorySpec data object defines
// properties for Active Directory domain access.
//
//
type HostActiveDirectorySpec struct {
	*DynamicData

	// If set, the CAM server will be used to join the domain
	// and the userName and password fields
	// will be ignored.
	//
	// Since vSphere API 5.0
	CamServer string

	// Domain name.
	DomainName string

	// Password for the Active Directory account.
	Password string

	// Thumbprint for the SSL certficate of CAM server
	//
	// Since vSphere API 5.0
	Thumbprint string

	// Name of an Active Directory account with the authority
	// to add a host to the domain.
	UserName string
}

//
// This event records that adding a host failed.
//
//
type HostAddFailedEvent struct {
	*HostEvent

	Hostname string
}

//
// This event records the addition of a host to VirtualCenter.
//
//
type HostAddedEvent struct {
	*HostEvent
}

//
// This event records that the permission on the host has been changed such
// that only the user account used for VirtualCenter operation will have
// Administrator permission.
//
//
type HostAdminDisableEvent struct {
	*HostEvent
}

//
// This event records that the administrator permission has been restored.
//
//
type HostAdminEnableEvent struct {
	*HostEvent
}

//
// The HostApplyProfile data object provides access to subprofiles
// that contain configuration data for different host capabilities.
// The Profile Engine will use any configuration data that you supply
// to overwrite the host configuration. See the  ExecuteHostProfile
// and ApplyHostConfig_Task methods.
//
//
type HostApplyProfile struct {
	*ApplyProfile

	// Authentication Configuration.
	//
	// Since vSphere API 4.1
	Authentication *AuthenticationProfile

	// Date and time configuration.
	Datetime *DateTimeProfile

	// Firewall configuration.
	Firewall *FirewallProfile

	// Memory configuration for the host.
	// This may not be valid for all versions of the host.
	Memory *HostMemoryProfile

	// Network configuration.
	Network *NetworkProfile

	// List of subprofiles representing advanced configuration options.
	// Use the key property to access a subprofile
	// in the list.
	Option []*OptionProfile

	// Security Configuration of the host.
	// The security subprofile can include data such as administrator passwords.
	Security *SecurityProfile

	// Host configuration for services.
	// Use the key property
	// to access a subprofile in the list.
	Service []*ServiceProfile

	// Host storage configuration.
	Storage *StorageProfile

	// List of subprofiles for user accounts to be configured on the host.
	// Use the key property to access a subprofile
	// in the list.
	UserAccount []*UserProfile

	// List of subprofiles for user groups to be configured on the host.
	// Use the key property to access a subprofile
	// in the list.
	UsergroupAccount []*UserGroupProfile
}

//
// The HostAuthenticationManager managed object provides
// access to Active Directory configuration information for an
// ESX host. It also provides access to methods for adding a host
// to or removing a host from an Active Directory domain.
//
// The vSphere API supports Microsoft Active Directory management
// of authentication for ESX hosts. To integrate an ESX host
// into an Active Directory environment, you use an Active
// Directory account that has the authority to add
// a computer to a domain. The ESX Server locates the Active
// Directory domain controller. When you add a host to a domain,
// you only need to specify the domain and the account
// user name and password.
//
//
// There are two approaches that you can use to add an ESX host
// to or remove a host from an Active Directory domain.
//
//
//
// • JoinDomain_Task and
// LeaveCurrentDomain_Task
// methods - Your vSphere client application can call
// these methods directly to add the host to or remove the host
// from a domain.
//
//
// • Host configuration - Use the HostActiveDirectory data object
// to specify Active Directory configuration, either adding the host to
// or removing the host from a domain. To apply the Active Directory
// configuration, use the HostProfileManager method
// (ApplyHostConfig_Task)
// to apply the HostConfigSpec. When the ESX Server processes
// the configuration, it will invoke the join or leave method.
//
//
//
//
//
// To take advantage of ESX host membership in an Active Directory domain,
// grant permissions on the ESX host to Active Directory users and groups
// who should have direct access to management of the ESX host.
// Use the UserDirectory.RetrieveUserGroups
// method to obtain information about Active Directory users and groups.
// After retrieving the Active Directory data, you can use the
// AuthorizationManager.SetEntityPermissions
// method to set the principal property
// to the appropriate user or group.
//
//
// By default, the ESX host assigns the Administrator role to the "ESX Admins" group.
// If the group does not exist when the host joins the domain, the host will
// not assign the role. In this case, you must create the "ESX Admins"
// group in the Active Directory. The host will periodically check the domain controller
// for the group and will assign the role when the group exists.
//
//
//
type HostAuthenticationManager struct {
	*ManagedObject

	info *HostAuthenticationManagerInfo

	supportedStore []*HostAuthenticationStore
}

// Information about Active Directory membership.
func (mo *HostAuthenticationManager) Info() (*HostAuthenticationManagerInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostAuthenticationManagerInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostAuthenticationManagerInfo")
	}
	return v, nil
}

// An array that can contain managed object references to local and
// Active Directory authentication managed objects.
//
// supportedStore data implies a connection to a system
// that stores information about accounts.
// The supportedStore array can include the following objects:
//
// HostLocalAuthentication - Local authentication refers
// to user accounts on the ESX host. Local authentication is always enabled.
//
// HostActiveDirectoryAuthentication - Active Directory authentication
// refers to computer accounts and user accounts on the domain controller.
// This object indicates the domain membership status for the host
// and defines the join and leave methods for Active Directory
// membership.
//
// If supportedStore references
// a HostActiveDirectoryAuthentication object, the host
// is capable of joining a domain.
// However, if you try to add a host to a domain when the
// HostAuthenticationStoreInfo.enabled
// property is True (accessed through the info
// property), the join method will throw a fault.
func (mo *HostAuthenticationManager) SupportedStore() ([]*HostAuthenticationStore, error) {
	t, err := mo.currentProperty("supportedStore")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*HostAuthenticationStore)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*HostAuthenticationStore")
	}
	return v, nil
}

//
// The HostAuthenticationManagerInfo data object provides
// access to authentication information for the ESX host.
//
//
type HostAuthenticationManagerInfo struct {
	*DynamicData

	// An array containing entries for local authentication and host
	// Active Directory authentication.
	//
	// HostLocalAuthenticationInfo - Local authentication is always enabled.
	// HostActiveDirectoryInfo - Host Active Directory authentication information
	// includes the name of the domain, membership status,
	// and a list of other domains trusted by the membership domain.
	AuthConfig []*HostAuthenticationStoreInfo
}

//
// The HostAuthenticationStore base class represents both local user
// and host Active Directory authentication for an ESX host.
//
//
// • Local user authentication is always enabled. The vSphere API
// does not support local user configuration for a host.
//
// • Active Directory authentication for ESX hosts relies on
// an established Active Directory account that
// has the authority to add the host to a domain.
//
//
//
//
type HostAuthenticationStore struct {
	*ManagedObject

	info *HostAuthenticationStoreInfo
}

// Information about the authentication store.
func (mo *HostAuthenticationStore) Info() (*HostAuthenticationStoreInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostAuthenticationStoreInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostAuthenticationStoreInfo")
	}
	return v, nil
}

//
// The HostAuthenticationStoreInfo base class defines status information
// for local and host Active Directory authentication.
//
//
type HostAuthenticationStoreInfo struct {
	*DynamicData

	// Indicates whether the authentication store is configured.
	//
	// Host Active Directory authentication - enabled
	// is True if the host is a member of a domain.
	//
	// Local authentication - enabled is always True.
	Enabled bool
}

//
// The AutoStartManager allows clients to invoke and set up the auto-start/auto-stop
// order of virtual machines on a single host. Virtual machines configured to use
// auto-start are automatically started or stopped when the host is started or shut
// down. The AutoStartManager is available when clients connect directly to a host,
// such as an ESX Server machine or through VirtualCenter.
//
type HostAutoStartManager struct {
	*ManagedObject

	config *HostAutoStartManagerConfig
}

func (mo *HostAutoStartManager) Config() (*HostAutoStartManagerConfig, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostAutoStartManagerConfig)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostAutoStartManagerConfig")
	}
	return v, nil
}

//
// Powers-off virtual machines according to the current AutoStart configuration.
//
// See the description of the (@link vim.host.AutoStartManager.AutoPowerInfo)
// data object type for more information on Auto power-off behavior.
//
//
// Required Privileges
// Host.Config.AutoStart
//
func (mo *HostAutoStartManager) AutoStartPowerOff(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Powers-on virtual machines according to the current AutoStart configuration.
//
// See the description of the (@link vim.host.AutoStartManager.AutoPowerInfo)
// data object type for more information on Auto power-on behavior.
//
//
// Required Privileges
// Host.Config.AutoStart
//
func (mo *HostAutoStartManager) AutoStartPowerOn(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Changes the power-on or power-off sequence and system defaults. The specification
// is an incremental change to the current configuration.
//
// If systemDefaults are included, only values that are specified in the
// specification are changed.
//
//
// For the spec.powerInfo array, each element is interpreted as an incremental
// change and the changes are processed sequentially. It is not an error to remove a
// non-existing virtual machine. If both startAction and stopAction are set to
// none, then the virtual machine is removed from the configuration.
//
//
// A virtual machine's position in the order can be changed either by assigning the
// virtual machine a different position in the order or removing the machine from
// the order. When a virtual machine's position changes, all other virtual machines'
// positions may be affected as they move to new positions relative to each other.
//
//
//
//
// Required Privileges
// Host.Config.AutoStart
//
func (mo *HostAutoStartManager) ReconfigureAutostart(
	_this *ManagedObjectReference, spec *HostAutoStartManagerConfig,
) error {

	return nil

}

//
// Contains the entire auto-start/auto-stop configuration.
//
//
type HostAutoStartManagerConfig struct {
	*DynamicData

	// System defaults for auto-start/auto-stop.
	Defaults *AutoStartDefaults

	// Lists the auto-start/auto-stop configuration. If a virtual machine is not
	// mentioned in this array, it does not participate in auto-start/auto-stop
	// operations.
	PowerInfo []*AutoStartPowerInfo
}

type HostBIOSInfo struct {
	*DynamicData

	// The current BIOS version of the physical chassis
	BiosVersion string

	// The release date for the BIOS.
	ReleaseDate time.Time
}

//
// Block adapter transport information about a SCSI target.
//
//
type HostBlockAdapterTargetTransport struct {
	*HostTargetTransport
}

//
// This data object type describes the host bus adapter that
// provides block devices.
//
//
type HostBlockHba struct {
	*HostHostBusAdapter
}

//
// The HostBootDevice data object represents a boot device on the host system.
//
//
type HostBootDevice struct {
	*DynamicData

	// The description of the boot device.
	Description string

	// The identifier for the boot device.
	Key string
}

//
// This data object represents the boot device information of the host.
//
//
type HostBootDeviceInfo struct {
	*DynamicData

	// The list of boot devices present on the host
	BootDevices []*HostBootDevice

	// The key of the current boot device that the host is configured to
	// boot. This property is unset if the current boot device is disabled.
	CurrentBootDeviceKey string
}

//
// The HostBootDeviceSystem managed object provides methods to query and update
// a host boot device configuration.
//
type HostBootDeviceSystem struct {
	*ManagedObject
}

//
// Retrieves a list of the available boot devices for the host system.
//
// Required Privileges
// System.Read
//
func (mo *HostBootDeviceSystem) QueryBootDevices(
	_this *ManagedObjectReference,
) (*HostBootDeviceInfo, error) {

	return nil, nil

}

//
// Sets the current boot device for the host system.
//
// Required Privileges
// Host.Config.Maintenance
//
func (mo *HostBootDeviceSystem) UpdateBootDevice(
	_this *ManagedObjectReference, key string,
) error {

	return nil

}

//
// Host solid state drive cache configuration information.
//
//
type HostCacheConfigurationInfo struct {
	*DynamicData

	// Datastore used for swap performance enhancements.
	Key *Datastore

	// Space allocated on this datastore to implement swap performance
	// enhancements, in MB.
	SwapSize int64
}

// Deprecated.
// As of vSphere API 5.5, use
// HostVFlashManager
//
//
// Solid state drive Cache Configuration Manager.
//
// This is a managed object which provides access to ESX performance tuning
// features using solid state drive based cache.
//
type HostCacheConfigurationManager struct {
	*ManagedObject

	cacheConfigurationInfo []*HostCacheConfigurationInfo
}

// The swap performance configuration for the ESX host.  This includes
// configuration information for each datastore enabled for this purpose.
// Required Privilege: Host.Config.AdvancedConfig
func (mo *HostCacheConfigurationManager) CacheConfigurationInfo() ([]*HostCacheConfigurationInfo, error) {
	t, err := mo.currentProperty("cacheConfigurationInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*HostCacheConfigurationInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*HostCacheConfigurationInfo")
	}
	return v, nil
}

//
// Configure host cache/swap performance enhancement.
//
// Required Privileges
// Host.Config.AdvancedConfig
//
func (mo *HostCacheConfigurationManager) ConfigureHostCache_Task(
	_this *ManagedObjectReference, spec *HostCacheConfigurationSpec,
) (*Task, error) {

	return nil, nil

}

//
// Host cache configuration specification.
//
//
type HostCacheConfigurationSpec struct {
	*DynamicData

	// Datastore used for swap performance enhancement.
	Datastore *Datastore

	// Space to allocate on this datastore to implement swap performance
	// enhancements, in MB.  This value should be less or equal to free space
	// capacity on the datastore freeSpace.
	SwapSize int64
}

//
// Specifies the capabilities of the particular host. This set of
// capabilities is referenced in other parts of the API specification
// to indicate under what circumstances an API will throw a
// NotSupported fault.
//
//
type HostCapability struct {
	*DynamicData

	// Indicates if 3D hardware acceleration for virtual machines is supported.
	//
	// Since vSphere API 5.1
	Accel3dSupported bool

	// Flag indicating whether background snapshots are supported on this host.
	//
	// Since VI API 2.5
	BackgroundSnapshotsSupported bool

	// Indicates whether or not cloning a virtual machine from a snapshot
	// point is allowed.
	//
	// This property must be true on the host where the virtual machine
	// is currently residing.  This property need not be true on the
	// destination host for the clone.See snapshot
	//
	// Since vSphere API 4.0
	CloneFromSnapshotSupported bool

	// Flag indicating whether cpu and memory resource configuration is
	// supported. If this is set to false,
	// UpdateConfig,
	// UpdateChildResourceConfiguration
	// cannot be used for changing the cpu/memory resource configurations.
	//
	// Since VI API 2.5
	CpuMemoryResourceConfigurationSupported bool

	// Flag indicating whether datastore principal user
	// is supported on the host.
	DatastorePrincipalSupported bool

	// Flag indicating whether explicitly creating arbirary configurations of
	// delta disk backings is supported.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time.  A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent).  After a delta
	// disk backing is added, all writes go to the delta disk backing.  All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// If this property is false, then delta disk backings can only be implicitly
	// created through using snapshot operations and two virtual machines cannot
	// safely share a parent disk backing.
	//
	// If this property is true, then delta disk backings can be explicitly created
	// and managed, and two virtual machines may safely share a parent disk backing.
	//
	// In the context above, "safely" means that performing operations on one of the
	// virtual machines will not affect the operation of the other virtual machine.
	// See parentSee parentSee parentSee parentSee parentSee PromoteDisks_TaskSee diskMoveTypeSee diskMoveType
	//
	// Since vSphere API 4.0
	DeltaDiskBackingsSupported bool

	// Indicates whether the host is capable of accessing a VMFS disk
	// when there are eight or more hosts accessing the disk already.
	//
	// Since vSphere API 5.1
	EightPlusHostVmfsSharedAccessSupported bool

	// Indicated whether the host supports feature capabilities
	// for EVC mode.
	//
	// Since vSphere API 5.1
	FeatureCapabilitiesSupported bool

	// Indicates whether this host supports ip address based restrictions in
	// the firewall configuration.
	//
	// Since vSphere API 5.0
	FirewallIpRulesSupported bool

	// For a host which doesn't support Fault Tolerance, indicates all the reasons
	// for the incompatibility. HostCapabilityFtUnsupportedReason
	// lists the set of possible values.
	//
	// Since vSphere API 4.1
	FtCompatibilityIssues []string

	// Indicates whether this host supports Fault Tolerance
	// There can be many reasons why a host does not support Fault
	// Tolerance, which includes CPU compatibility, product
	// compatibility as well as other host configuration settings.
	// For specific reasons, look into
	// replayCompatibilityIssues and
	// ftCompatibilityIssues
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	//
	// Since vSphere API 4.0
	FtSupported bool

	// Indicates whether a dedicated nic can be selected for vSphere Replication
	// LWD traffic, i.e., from the primary host to the VR server.
	//
	// Since vSphere API 5.1
	HbrNicSelectionSupported bool

	// Is high guest memory supported.
	HighGuestMemSupported bool

	// Indicates whether the host supports VMCI for communication
	// between virtual machines.
	//
	// Since vSphere API 5.1
	InterVMCommunicationThroughVMCISupported bool

	// Flag indicating whether the host supports
	// IPMI (Intelligent Platform Management Interface).
	// XXX - Make ipmiSupported optional until there is a compatible hostagent.
	//
	// Since vSphere API 4.0
	IpmiSupported bool

	// Is access to iSCSI devices supported.
	IscsiSupported bool

	// Indicates whether the host supports latency sensitivity for the
	// virtual machines.
	//
	// Since vSphere API 5.1
	LatencySensitivitySupported bool

	// Flag indicating whether the host supports selecting a datastore that
	// that may be used to store virtual machine swapfiles.
	//
	// Since VI API 2.5
	LocalSwapDatastoreSupported bool

	// Flag indicating whether this host supports SSL thumbprint authentication
	//
	// Since vSphere API 4.0
	LoginBySSLThumbprintSupported bool

	// Is maintenance mode supported
	MaintenanceModeSupported bool

	// The maximum number of virtual machines that can be run on the host.
	// An unset value indicates that the value could not be obtained. In contrast
	// to maxRunningVMs, this value is the minimum of (i) the maximum
	// number supported by the hardware and (ii) the maximum number permitted by
	// the host license.
	//
	// Since vSphere API 5.0
	MaxHostRunningVms int32

	// The maximum number of virtual CPUs that can be run on the host.  An unset
	// value indicates that the value could not be obtained.  In contrast to
	// maxSupportedVcpus, this value is the minimum of (i) the maximum
	// number supported by the hardware and (ii) the maximum number permitted by
	// the host license.
	//
	// Since vSphere API 5.0
	MaxHostSupportedVcpus int32

	// The maximum number of registered virtual machines supported by
	// the host. If this limit is exceeded, the management agent will be
	// at risk of running out of system resources. configIssue will be posted on
	// HostSystem in this case.
	//
	// If this capability is not set, the number is unknown.
	//
	// Since vSphere API 5.1
	MaxRegisteredVMs int32

	// The maximum number of virtual machines that can be running
	// simultaneously on this host.
	// If this capability is not set, the number of virtual machines
	// running simultaneously is unlimited.
	MaxRunningVMs int32

	// The maximum number of virtual CPUs supported per virtual machine.
	// If this capability is not set, the number is unlimited.
	MaxSupportedVcpus int32

	// The maximum number of virtual machines that can exist on this host.
	// If this capability is not set, the number of virtual machines is
	// unlimited.
	MaxSupportedVMs int32

	// Indicates whether the host supports Multiple Instance TCP/IP stack
	//
	// Since vSphere API 5.5
	MultipleNetworkStackInstanceSupported bool

	// Indicates whether the host supports nested hardware-assisted virtualization.
	//
	// Since vSphere API 5.1
	NestedHVSupported bool

	// Is access to NFS devices supported.
	NfsSupported bool

	// Is NIC teaming supported.
	NicTeamingSupported bool

	// Indicates whether network traffic shaping on a
	// per virtual machine basis is supported.
	//
	// Since vSphere API 4.0
	PerVMNetworkTrafficShapingSupported bool

	// Flag indicating whether virtual machine execution on this host involves
	// a swapfile for each virtual machine. If true, the swapfile placement
	// for a powered-on virtual machine is advertised in its FileLayout by
	// the swapFile property.
	//
	// Since VI API 2.5
	PerVmSwapFiles bool

	// Flag to indicate whether the server returns unit numbers in a
	// pre-assigned range for devices on the PCI bus.
	//
	// When the server supports this flag, the device unit number namespace is
	// partitioned by device type. Different types of devices will sit in
	// a specific range of unit numbers that may not correspond to physical
	// slots in the pci bus but present a relative ordering of the devices
	// with respect to other devices of the same type.
	//
	// Note that this does not mean that the user can set the relative ordering
	// between device types, but only allows stable orderings between devices
	// of the same type. The unit number will now clearly represent an ordering
	// between devices of the same type.
	//
	// unitNumber
	// This property is only available for devices on the pci controller.
	//
	// Since VI API 2.5
	PreAssignedPCIUnitNumbersSupported bool

	// Flag indicating whether rebooting the host is supported.
	RebootSupported bool

	// Indicates whether this host supports record and replay
	//
	// Since vSphere API 4.0
	RecordReplaySupported bool

	RecursiveResourcePoolsSupported bool

	// Indicates that this host uses a reliable memory aware allocation policy.
	//
	// Since vSphere API 5.5
	ReliableMemoryAware bool

	// For a host which doesn't support replay, indicates all the reasons
	// for the incompatibility. HostReplayUnsupportedReason
	// lists the set of possible values.
	//
	// Since vSphere API 4.1
	ReplayCompatibilityIssues []string

	// Deprecated.
	// As of vSphere API 4.1, use
	// replayCompatibilityIssues.
	//
	//
	// For a host whose CPU doesn't support replay, indicates the reason
	// for the incompatibility. HostReplayUnsupportedReason
	// represents the set of possible values.
	//
	// Since vSphere API 4.0
	ReplayUnsupportedReason string

	// Indicates whether this host supports relocation of
	// virtual machines with snapshots.  Must be true on the
	// source and destination hosts for the relocation to work.
	// Even if this is true, the following conditions must hold:
	// 1) All the the vm's files are in one directory prior
	// to the relocate.
	// 2) All of the vm's files will be in one directory
	// after the relocate.
	// 3) The source and destination hosts are the same product
	// version.
	//
	// Since VI API 2.5
	RestrictedSnapshotRelocateSupported bool

	// Flag indicating whether access to SAN devices is supported.
	SanSupported bool

	// Indicates whether scaling is supported for screenshots retrieved over https.
	// If true, screenshot retrieval supports the additional optional
	// parameters 'width' and 'height'. After cropping, the returned image will be scaled
	// to these dimensions. If only one of these parameters is specified, default behavior
	// is to return an image roughly proportional to the source image.
	//
	// Since VI API 2.5
	ScaledScreenshotSupported bool

	// Indicates whether the host supports scheduled hardware upgrades.See scheduledHardwareUpgradeInfo
	//
	// Since vSphere API 5.1
	ScheduledHardwareUpgradeSupported bool

	// Indicates whether the screenshot retrival over https is supported for this host's
	// virtual machines.
	// If true, a screenshot can be retrieved at the HTTPS relative path
	// /screen?id=<managed object ID of virtual machine or snapshot>.
	// If any of the optional parameters 'top', 'left', 'bottom', and 'right' is
	// specified, the returned image will be cropped from the rectangle with upper left
	// corner (left, top) and bottom right corner (right - 1, bottom - 1). These values
	// default to the top, left, bottom and right edges of the image.
	//
	// The client must use an authenticated session with privilege
	// VirtualMachine.Interact.ConsoleInteract on the requested virtual machine or,
	// in the case of a snapshot, the virtual machine associated with that snapshot.
	//
	// Since VI API 2.5
	ScreenshotSupported bool

	// Indicates whether this host supports package information in service
	// configuration.
	//
	// Since vSphere API 5.0
	ServicePackageInfoSupported bool

	// Flag indicating whether the host can be powered off
	ShutdownSupported bool

	// Indicates whether this host supports unrestricted relocation of virtual
	// machines with snapshots. Only needs to be true on the destination host for
	// the unrestricted relocation to work. The full snapshot relocation does not
	// restrict the layout of snapshot files or disks of the virtual machine, nor
	// its power state. If the virtual machine is powered on, a storage vmotion
	// will be performed to relocate its snapshots and disks.
	//
	// Since vSphere API 5.0
	SnapshotRelayoutSupported bool

	// Flag indicating whether you can put the host in a power down
	// state, from which it can be powered up automatically.
	//
	// Since VI API 2.5
	StandbySupported bool

	// Indicates whether the host supports storage I/O resource
	// management.
	//
	// Since vSphere API 4.1
	StorageIORMSupported bool

	// Indicates that host supports Object-based Storage System and
	// Storage-Profile based disk provisioning.
	//
	// Since vSphere API 5.5
	StoragePolicySupported bool

	// Indicates whether the storage of a powered-on virtual machine may be
	// relocated.
	//
	// Since vSphere API 4.0
	StorageVMotionSupported bool

	// CPU feature set that is supported by the virtualization platform. This
	// feature set may reflect characteristics of the product capabilities and
	// licensing. For any feature marked '-', reference the
	// cpuFeature array of the host's
	// HardwareInfo to determine the correct value.
	//
	// Since vSphere API 4.0
	SupportedCpuFeature []*HostCpuIdInfo

	// List of VMFS major versions supported by the host.
	//
	// Since vSphere API 5.0
	SupportedVmfsMajorVersion []int32

	// Indicates whether this host supports relocation of
	// suspended virtual machines.  Must be true on the source
	// and destination hosts for the relocation to work.
	SuspendedRelocateSupported bool

	// Flag indicating whether this host supports the integrity measurement using
	// a TPM device.
	//
	// Since vSphere API 4.0
	TpmSupported bool

	// Flag indicating whether the host supports participating in a VMotion
	// where the virtual machine swapfile is not visible to the destination.
	//
	// Since VI API 2.5
	UnsharedSwapVMotionSupported bool

	// Indicates whether the host supports vFlash.
	//
	// Since vSphere API 5.5
	VFlashSupported bool

	// Indicates whether the host supports configuring hardware
	// virtualization (HV) support for virtual machines.
	//
	// Since vSphere API 4.0
	VirtualExecUsageSupported bool

	// Is VLAN Tagging supported.
	VlanTaggingSupported bool

	// Indicates whether the host supports network passthrough using
	// VMDirectPath Gen 2. Note that this is a general capability for the host
	// and is independent of support by a given physical NIC. If false, the
	// reason(s) for lack of support will be provided in
	// vmDirectPathGen2UnsupportedReason and/or in
	// vmDirectPathGen2UnsupportedReasonExtended.See vmDirectPathGen2Supported
	//
	// Since vSphere API 4.1
	VmDirectPathGen2Supported bool

	// If vmDirectPathGen2Supported is false, this array will be
	// populated with reasons for the lack of support (chosen from
	// VmDirectPathGen2UnsupportedReason). If there is a reason for
	// the lack of support that cannot be described by the available constants,
	// vmDirectPathGen2UnsupportedReasonExtended will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.
	//
	// If the reason "hostNptIncompatibleProduct" is provided, then that will
	// be the only provided reason, as the host software is incapable of
	// providing additional information.
	//
	// Since vSphere API 4.1
	VmDirectPathGen2UnsupportedReason []string

	// If vmDirectPathGen2Supported is false, this property may
	// contain an explanation provided by the platform, beyond the reasons (if
	// any) enumerated in vmDirectPathGen2UnsupportedReason.
	//
	// Since vSphere API 4.1
	VmDirectPathGen2UnsupportedReasonExtended string

	// Indicates whether the host is capable of mounting/unmounting
	// VMFS datastores.
	//
	// Since vSphere API 5.0
	VmfsDatastoreMountCapable bool

	// Indicates whether the network of a powered-on virtual machine can be
	// changed while simultaneously changing the execution host of the
	// virtual machine.
	//
	// Since vSphere API 5.5
	VmotionAcrossNetworkSupported bool

	// Flag indicating whether you can perform VMotion.
	VmotionSupported bool

	// Indicates whether the storage of a powered-on virtual machine may be
	// relocated while simultaneously changing the execution host of the
	// virtual machine.
	//
	// Since vSphere API 4.0
	VmotionWithStorageVMotionSupported bool

	// Indicates whether the host supports vurtual CPU performance counters.
	//
	// Since vSphere API 5.1
	VPMCSupported bool

	// Indicates whether the host supports VSAN functionality.See HostVsanSystem
	//
	// Since vSphere API 5.5
	VsanSupported bool

	// Indicates whether the host supports vStorage Hardware
	// acceleration.
	//
	// Since vSphere API 4.1
	VStorageCapable bool
}

//
// Set of possible values for
// ftCompatibilityIssues
//
//
type HostCapabilityFtUnsupportedReason struct {
}

//
// Set of possible values for vmDirectPathGen2UnsupportedReason.
//
//
type HostCapabilityVmDirectPathGen2UnsupportedReason struct {
}

//
// This event records a failure to connect to a host
// due to a failure to set up a management account.
//
//
type HostCnxFailedAccountFailedEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to the host being managed by a different VirtualCenter server.
//
//
type HostCnxFailedAlreadyManagedEvent struct {
	*HostEvent

	// The name of the VirtualCenter server that manages the host.
	ServerName string
}

//
// This event records a failure to connect to a host
// due to no response being received from the host agent.
//
//
type HostCnxFailedBadCcagentEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to an invalid user name and password combination.
//
//
type HostCnxFailedBadUsernameEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to an incompatible client version.
//
//
type HostCnxFailedBadVersionEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to a conflict with an upgrade or installation of the host agent.
//
//
type HostCnxFailedCcagentUpgradeEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to an unspecified condition.
//
//
type HostCnxFailedEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to a network error.
//
//
type HostCnxFailedNetworkErrorEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to insufficient account privileges.
//
//
type HostCnxFailedNoAccessEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to a host not being present on the network.
//
//
type HostCnxFailedNoConnectionEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to a licensing issue.
//
//
type HostCnxFailedNoLicenseEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to a failure to resolve the host name.
//
//
type HostCnxFailedNotFoundEvent struct {
	*HostEvent
}

//
// This event records a failure to connect to a host
// due to a timeout on the connection attempt.
//
//
type HostCnxFailedTimeoutEvent struct {
	*HostEvent
}

//
// A HostCommunication fault is thrown if an error happened
// while communicating to a host. This would typically be
// due to network connections or server failures.
//
//
type HostCommunication struct {
	*RuntimeFault
}

//
// This event records that a compliance check was triggered
// on the host.
//
//
type HostComplianceCheckedEvent struct {
	*HostEvent

	Profile *ProfileEventArgument
}

//
// This event records that host is in compliance.
//
//
type HostCompliantEvent struct {
	*HostEvent
}

//
// This event records that a configuration was applied on a host
//
//
type HostConfigAppliedEvent struct {
	*HostEvent
}

//
// This data object type describes types and constants related to the
// specification of changes to a host configuration.
//
//
type HostConfigChange struct {
	*DynamicData
}

//
// This is a global mode on a configuration specification indicating
// whether the structure represents the desired state or the set of
// operations to apply on the managed object.
//
//
//
//
type HostConfigChangeMode struct {
}

//
// This list indicates the operation that should be performed for a
// network entity.
//
//
//
//
type HostConfigChangeOperation struct {
}

//
// Fault to indicate configuration of the host failed.
// Configuration could have failed because of multiple
// reasons and individual failures will be reported in
// #failure.
//
//
type HostConfigFailed struct {
	*HostConfigFault

	Failure []*LocalizedMethodFault
}

//
// Base class for all Host configuration related faults
//
//
type HostConfigFault struct {
	*VimFault
}

//
// This data object type encapsulates a typical set of host configuration
// information that is useful for displaying and configuring a host.
//
// VirtualCenter can retrieve this set of information
// very efficiently even for a large set of hosts.
//
//
//
type HostConfigInfo struct {
	*DynamicData

	// The diagnostic partition that will be set as the current
	// diagnostic partition on the host.
	ActiveDiagnosticPartition *HostDiagnosticPartition

	// If the flag is true, the permissions on the host have been modified such
	// that it is only accessible through local console or an authorized
	// centralized management application. This flag is affected by the
	// EnterLockdownMode and
	// ExitLockdownMode operations.
	//
	// This flag is supported in VirtualCenter only. The value returned from host
	// should be ignored.See EnterLockdownModeSee ExitLockdownMode
	//
	// Since VI API 2.5
	AdminDisabled bool

	// Current authentication configuration.
	//
	// Since vSphere API 4.1
	AuthenticationManagerInfo *HostAuthenticationManagerInfo

	// AutoStart configuration.
	AutoStart *HostAutoStartManagerConfig

	// Deprecated.
	// As of vSphere API 5.5, use vFlashConfigInfo instead.
	//
	//
	// Host solid stats drive cache configuration information.
	//
	// Since vSphere API 5.0
	CacheConfigurationInfo []*HostCacheConfigurationInfo

	// Capability vector indicating the available network features.
	Capabilities *HostNetCapabilities

	// Full Host Certificate in PEM format, if known
	//
	// Since vSphere API 5.0
	Certificate []int8

	// Memory configuration.
	ConsoleReservation *ServiceConsoleReservationInfo

	// Capability vector indicating available datastore features.
	//
	// Since VI API 2.5
	DatastoreCapabilities *HostDatastoreSystemCapabilities

	// Datastore principal user
	DatastorePrincipal string

	// Date/Time related configuration
	//
	// Since VI API 2.5
	DateTimeInfo *HostDateTimeInfo

	// Array of the feature capabilities that the host has. This is not
	// expected to change after the host boots. It may change between reboots
	// in the case BIOS options are changed, or hardware, or firmware is
	// changed or upgraded.
	//
	// Since vSphere API 5.1
	FeatureCapability []*HostFeatureCapability

	// List of feature-specific version information. Each element refers
	// to the version information for a specific feature.
	//
	// Since vSphere API 4.1
	FeatureVersion []*HostFeatureVersionInfo

	// Storage system file system volume information.
	FileSystemVolume *HostFileSystemVolumeInfo

	// Firewall configuration.
	Firewall *HostFirewallInfo

	// Additional flags for a host.
	//
	// Since VI API 2.5
	Flags *HostFlagInfo

	// The list of graphics devices available on this host.
	//
	// Since vSphere API 5.5
	GraphicsInfo []*HostGraphicsInfo

	// A reference to a managed object on a host.
	Host *HostSystem

	// If hyperthreading is supported, this is the CPU configuration for
	// optimizing hyperthreading.
	HyperThread *HostHyperThreadScheduleInfo

	// IPMI (Intelligent Platform Management Interface) info for the host.
	//
	// Since vSphere API 4.0
	Ipmi *HostIpmiInfo

	// Datastore visible to this host that may be used to store virtual
	// machine swapfiles, for virtual machines executing on this host. The
	// value of this property is set or unset by invoking
	// UpdateLocalSwapDatastore.
	// The policy for using this datastore is determined by the compute
	// resource configuration's
	// vmSwapPlacement
	// property in concert with each individual virtual machine configuration's
	// swapPlacement property.
	//
	// Note: Using a host-specific swap location may degrade VMotion performance.
	//
	// Since VI API 2.5
	LocalSwapDatastore *Datastore

	// Array of the feature capabilities that the host has after the
	// mask has been applied.
	//
	// Since vSphere API 5.1
	MaskedFeatureCapability []*HostFeatureCapability

	// Storage multipath state information.
	//
	// Since vSphere API 4.0
	MultipathState *HostMultipathStateInfo

	// Network system information.
	Network *HostNetworkInfo

	// Deprecated.
	// As of VI API 4.0, the system defaults will be used.
	//
	//
	// capabilities to offload operations either to the host or to physical
	// hardware when a virtual machine is transmitting on a network
	OffloadCapabilities *HostNetOffloadCapabilities

	// Host configuration options as defined by the
	// OptionValue data object type.
	Option []*OptionValue

	// A list of supported options.
	OptionDef []*OptionDef

	// PCI passthrough information.
	//
	// Since vSphere API 4.0
	PciPassthruInfo []*HostPciPassthruInfo

	// Host power management capability.
	//
	// Since vSphere API 4.1
	PowerSystemCapability *PowerSystemCapability

	// Host power management information.
	//
	// Since vSphere API 4.1
	PowerSystemInfo *PowerSystemInfo

	// Information about a product.
	Product *AboutInfo

	// Host service configuration.
	Service *HostServiceInfo

	// SSL Thumbprints registered on this host.
	//
	// Since vSphere API 5.0
	SslThumbprintData []*HostSslThumbprintInfo

	// Deprecated.
	// As of vSphere API 5.0, use sslThumbprintData instead.
	//
	//
	// SSL Thumbprint info for hosts registered on this host.
	//
	// Since vSphere API 4.0
	SslThumbprintInfo *HostSslThumbprintInfo

	// Storage system information.
	StorageDevice *HostStorageDeviceInfo

	// Datastore paths of files used by the host system on
	// mounted volumes, for instance, the COS vmdk file of the
	// host. For information on datastore paths, see Datastore.
	//
	// Since vSphere API 4.1
	SystemFile []string

	// Reference for the system resource hierarchy, used for configuring
	// the set of resources reserved to the system and unavailable to
	// virtual machines.
	SystemResources *HostSystemResourceInfo

	// The system swap configuration specifies which options are currently
	// enabled.See HostSystemSwapConfiguration
	//
	// Since vSphere API 5.1
	SystemSwapConfiguration *HostSystemSwapConfiguration

	// Host vFlash configuration information
	//
	// Since vSphere API 5.5
	VFlashConfigInfo *HostVFlashManagerVFlashConfigInfo

	// Virtual machine memory configuration.
	//
	// Since VI API 2.5
	VirtualMachineReservation *VirtualMachineMemoryReservationInfo

	// VirtualNic manager information.
	//
	// Since vSphere API 4.0
	VirtualNicManagerInfo *HostVirtualNicManagerInfo

	// Deprecated.
	// As of VI API 4.0, use virtualNicManagerInfo
	//
	//
	// VMotion system information.
	Vmotion *HostVMotionInfo

	// VSAN configuration for a host.
	//
	// Since vSphere API 5.5
	VsanHostConfig *VsanHostConfigInfo

	// Indicates if a host is wake on lan capable.
	// A host is deemed wake on lan capable if there exists at least one
	// physical network card that is both backing the vmotion interface and
	// is itself wake on lan capable.
	//
	// Since vSphere API 5.0
	WakeOnLanCapable bool
}

//
// This data object type describes the configuration of a host
// across products and versions.
//
//
type HostConfigManager struct {
	*DynamicData

	// Advanced options.
	AdvancedOption *OptionManager

	// Authentication method configuration - for example, for Active Directory membership.
	//
	// Since vSphere API 4.1
	AuthenticationManager *HostAuthenticationManager

	// Auto-start and auto-stop configuration.
	AutoStartManager *HostAutoStartManager

	// Boot device order management.
	//
	// Since VI API 2.5
	BootDeviceSystem *HostBootDeviceSystem

	// Deprecated.
	// As of vSphere API 5.5, use vFlashManager instead.
	//
	//
	// Host solid state drive cache configuration manager.
	//
	// Since vSphere API 5.0
	CacheConfigurationManager *HostCacheConfigurationManager

	// The CPU scheduler that determines which threads execute on a CPU
	// at any given time.
	CpuScheduler *HostCpuSchedulerSystem

	// The datastore manager.
	DatastoreSystem *HostDatastoreSystem

	// DateTime configuration
	//
	// Since VI API 2.5
	DateTimeSystem *HostDateTimeSystem

	// The diagnostic for the ESX Server system.
	DiagnosticSystem *HostDiagnosticSystem

	// Esx Agent resource configuration manager
	//
	// Since vSphere API 5.0
	EsxAgentHostManager *HostEsxAgentHostManager

	// The firewall configuration.
	FirewallSystem *HostFirewallSystem

	// Firmware management.
	//
	// Since VI API 2.5
	FirmwareSystem *HostFirmwareSystem

	// Host graphics manager.
	//
	// Since vSphere API 5.5
	GraphicsManager *HostGraphicsManager

	// System health status manager.
	//
	// Since VI API 2.5
	HealthStatusSystem *HostHealthStatusSystem

	// Host image configuration management.
	//
	// Since vSphere API 5.0
	ImageConfigManager *HostImageConfigManager

	// Iscsi Management Operations managed entity
	//
	// Since vSphere API 5.0
	IscsiManager *IscsiManager

	// Kernel module configuration management.
	//
	// Since vSphere API 4.0
	KernelModuleSystem *HostKernelModuleSystem

	// License manager
	//
	// Since vSphere API 4.0
	LicenseManager *LicenseManager

	// The memory manager on the host.
	MemoryManager *HostMemorySystem

	// The network system configuration.
	NetworkSystem *HostNetworkSystem

	// Host patch management.
	//
	// Since VI API 2.5
	PatchManager *HostPatchManager

	// PciDeviceSystem for passthru.
	//
	// Since vSphere API 4.0
	PciPassthruSystem *HostPciPassthruSystem

	// Power System manager.
	//
	// Since vSphere API 4.1
	PowerSystem *HostPowerSystem

	// The configuration of the host services (for example,
	// SSH, FTP, and Telnet).
	ServiceSystem *HostServiceSystem

	// Snmp configuration
	SnmpSystem *HostSnmpSystem

	// The storage configuration.
	StorageSystem *HostStorageSystem

	// vFlash Manager
	//
	// Since vSphere API 5.5
	VFlashManager *HostVFlashManager

	// The VirtualNic configuration.
	//
	// Since vSphere API 4.0
	VirtualNicManager *HostVirtualNicManager

	// Deprecated.
	// As of VI API 4.0, use virtualNicManager
	// to manage the VMotion configuration of the host.
	//
	//
	// The VMotion configuration.
	VmotionSystem *HostVMotionSystem

	// VsanInternalSystem managed entity.
	//
	// Since vSphere API 5.5
	VsanInternalSystem *HostVsanInternalSystem

	// VsanSystem managed entity.
	//
	// Since vSphere API 5.5
	VsanSystem *HostVsanSystem
}

//
// The HostConfigSpec data object provides access to data objects
// that specify configuration changes to be applied to an ESX host.
//
//
type HostConfigSpec struct {
	*DynamicData

	// Active Directory configuration change.
	//
	// Since vSphere API 4.1
	ActiveDirectory []*HostActiveDirectory

	// Datastore principal user.
	DatastorePrincipal string

	// Password for the datastore principal.
	DatastorePrincipalPasswd string

	// DateTime Configuration.
	Datetime *HostDateTimeConfig

	// Firewall configuration.
	Firewall *HostFirewallConfig

	// Advanced configuration.
	//
	// Since vSphere API 5.0
	GenericConfig []*KeyAnyValue

	// License configuration for the host.
	License *HostLicenseSpec

	// Memory configuration for the host.
	Memory *HostMemorySpec

	// Configurations to create NAS datastores.
	NasDatastore []*HostNasVolumeConfig

	// Network system information.
	Network *HostNetworkConfig

	// Type selection for different VirtualNics.
	NicTypeSelection []*HostVirtualNicManagerNicTypeSelection

	// Host configuration options as defined by the
	// OptionValue data object type.
	Option []*OptionValue

	// Security specification.
	Security *HostSecuritySpec

	// Host service configuration.
	Service []*HostServiceConfig

	// Storage system information.
	StorageDevice *HostStorageDeviceInfo

	// List of users to create/update with new password.
	UserAccount []*HostAccountSpec

	// List of users to create/update with new password.
	UsergroupAccount []*HostAccountSpec
}

//
// An overview of the key configuration parameters.
//
//
type HostConfigSummary struct {
	*DynamicData

	// Datastore used to deploy Agent VMs on for this host.
	//
	// Since vSphere API 5.0
	AgentVmDatastore *Datastore

	// Management network for Agent VMs.
	//
	// Since vSphere API 5.0
	AgentVmNetwork *Network

	// The flag to indicate whether or not Fault Tolerance logging is enabled on this host.
	//
	// Since vSphere API 4.0
	FaultToleranceEnabled bool

	// List of feature-specific version information. Each element refers
	// to the version information for a specific feature.
	//
	// Since vSphere API 4.1
	FeatureVersion []*HostFeatureVersionInfo

	// The name of the host.
	Name string

	// The port number.
	Port int32

	// Information about the software running on the host, if known.
	//
	// The current supported hosts are ESX Server 2.0.1 (and later) and VMware Server
	// 2.0.0 (and later).
	Product *AboutInfo

	// The SSL thumbprint of the host, if known.
	//
	// Since vSphere API 4.0
	SslThumbprint string

	// The flag to indicate whether or not VMotion is enabled on this host.
	VmotionEnabled bool
}

//
// A base clase for faults that are related to connecting or
// adding a host to the inventory.
//
//
type HostConnectFault struct {
	*VimFault
}

//
// This data object type contains information about a single host that can be used by
// the connection wizard. This can be returned without adding the host to VirtualCenter.
//
//
type HostConnectInfo struct {
	*DynamicData

	// Whether or not the host supports clustering capabilities such as HA or DRS and
	// therefore can be added to a cluster. If false, the host must be added as a
	// standalone host.
	ClusterSupported bool

	// The list of datastores on the host.
	Datastore []*HostDatastoreConnectInfo

	// Summary information about the host. The status fields and managed object
	// reference is not set when an object of this type is created. These fields and
	// references are typically set later when these objects are associated with a host.
	Host *HostListSummary

	// If the host is already being managed by a vCenter Server, this property
	// reports true if the host is also part of a vSphere HA enabled cluster. If
	// this is the case, remove or disconnect the host
	// from this cluster before adding it to another vCenter Server.
	//
	// Since vSphere API 5.0
	InDasCluster bool

	// License manager information on the host
	//
	// Since vSphere API 4.0
	License *HostLicenseConnectInfo

	// The list of network information for networks configured on this host.
	Network []*HostConnectInfoNetworkInfo

	// The IP address of the VirtualCenter already managing this host, if any.
	ServerIp string

	// Whether or not the host requires a vimAccountName and password to be set in the
	// ConnectSpec. This is normally only required for VMware Server hosts.
	VimAccountNameRequired bool

	// The list of virtual machines on the host.
	Vm []*VirtualMachineSummary
}

//
// The base data object type for information about networks on the host.
//
//
type HostConnectInfoNetworkInfo struct {
	*DynamicData

	// Basic network information, such as network name. The managed object reference
	// is not set.
	Summary *NetworkSummary
}

//
// Specifies the parameters needed to add a single host. This includes
// a small set of optional information about the host configuration.
// This allows the network and datastore configuration of the host to
// be synchronized with the naming conventions of the datacenter, as well
// as the configuration of a vim account (the username/password for the
// virtual machine files that is created on disk).
//
//
type HostConnectSpec struct {
	*DynamicData

	// If this flag is set to "true", then the connection succeeds even
	// if the host is already being managed by another VirtualCenter server.
	// The original VirtualCenter server loses connection to the host.
	Force bool

	// The DNS name or IP address of the host. (Required for adding
	// a host.)
	HostName string

	// The IP address of the VirtualCenter server that will manage this host.
	// This field can be used to control which IP address the VirtualCenter agent
	// will send heartbeats to. If it is not set, VirtualCenter will use the local IP
	// address used when communicating with the host. Setting this field is useful
	// when the VirtualCenter server is behind a NAT in which case the external NAT
	// address must be used.
	//
	// Since vSphere API 4.0
	ManagementIp string

	// The password for the administration account. (Required for adding
	// a host.)
	Password string

	// The port number for the connection. If this is not specified,
	// the default port number is used. For ESX 2.x hosts this is the authd
	// port (902 by default). For ESX 3.x and above and VMware Server hosts
	// this is the https port (443 by default).
	// If this is a reconnect, the port number is unchanged.
	Port int32

	// The thumbprint of the SSL certificate, which the host is
	// expected to have.  If this value is set and matches the
	// certificate thumbprint presented by the host, then the host is
	// authenticated. If this value is not set or does not match the
	// certificate thumbprint presented by the host, then the host's
	// certificate is verified by checking whether it was signed by a
	// recognized CA.
	//
	// The thumbprint is always computed using the SHA1 hash and is
	// the string representation of that hash in the format:
	// xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx
	// where, 'x' represents a hexadecimal digit
	//
	// Since VI API 2.5
	SslThumbprint string

	// The administration account on the host. (Required for adding
	// a host.)
	UserName string

	// The username to be used for accessing the virtual
	// machine files on the disk.
	VimAccountName string

	// The password to be used  with the
	// vimAccountName
	// property for accessing the virtual
	// machine files on the disk.
	VimAccountPassword string

	// The folder in which to store the existing virtual machines on the host.
	// If this folder is not specified, a default folder is chosen
	// (and possibly created) by the VirtualCenter.  This folder exists (or
	// is possibly created) on the
	// VirtualCenter server and is called "Discovered VM".
	VmFolder *Folder
}

//
// This event records a successful host connection.
//
//
type HostConnectedEvent struct {
	*HostEvent
}

//
// This event records the loss of a host connection.
//
//
type HostConnectionLostEvent struct {
	*HostEvent
}

//
// The CpuIdInfo data object type is used to represent the CPU features of
// a particular host or product, or to specify what the CPU feature
// requirements are for a particular virtual machine or guest operating
// system.
//
// For each register (eax,ebx,ecx,edx), the string is a bit mask of the form:
//
// ????:????:????:????:????:????:????:????
//
//
// When used to represent the features of a specific processor package
// (cpuPkg), the features common to all
// processors on a host (cpuFeature), or the
// features supported by a virtualization platform
// (supportedCpuFeature), each bit is either '0'
// or '1', or '-' for unknown/unspecified. In these feature vectors, the
// vendor field is never set.
//
//
// Optional values in these feature vectors default to
// '----:----:----:----:----:----:----:----'.
//
//
// When specifying the required feature set for a virtual machine or a guest
// operating system, the bits can take on the values as described below, and
// the vendor field may be set. The total feature requirements for a virtual
// machine are composed by using any requirements listed in the virtual
// machine's configuration to override the requirements listed in the
// descriptor for the virtual machine's guest OS.
//
//
// Bits used for specifying requirements:
//
//
//
// • x: Unused by guest software.
//
// • T: Feature that the guest software requires to be enabled.
//
// • F: Feature that the guest software requires to be disabled.
//
// • 1: Feature will be reported as enabled if queried by the guest
// software.
//
// • 0: Feature will be reported as disabled if queried by the guest
// software.
//
// • R: Feature will be reported as disabled if queried by the guest
// software; however, for VMotion the actual value of this
// feature is required to be the same on both hosts.
//
// • H: Used by guest software. For VMotion the value of this
// feature is required to be the same on both hosts.
//
// • -: This bit type is only used in the requirements stored in
// the virtual machine's configuration. It indicates that, for
// this bit position, the requirement from the guest OS
// descriptor should be used instead.
//
//
//
// The values 'F' and '1' are rarely used but included for completeness. The
// '0' and '1' values do not promise a faithful virtualization of these
// features; whether the features work when forced to 0 or 1 is highly
// dependent on the guest software.
//
// Optional values in the requirements from the virtual machine's
// configuration default to '----:----:----:----:----:----:----:----'.
// Optional values in the requirements from the guest OS descriptor default
// to 'xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx'.
//
//
// Once the feature requirements for a virtual machine have been composed
// from the virtual machine's configuration and guest OS descriptor, the bit
// types above are used to identify whether or not the virtual machine
// can be powered on or be migrated with VMotion to a particular host.
// The rules are as follows:
//
//
//
// • Power-on: Requirements marked as 'T' or 'F' must match bits
// '1' or '0', respectively, in the features advertised by the HardwareInfo
// of the power-on host.
//
// • VMotion: Requirements marked as 'T' or 'F' must match bits
// '1' or '0', respectively, in the features advertised by the HardwareInfo
// of the destination host. Also, at the positions where requirements are
// marked 'H' or 'R', the advertised value of that feature for the source
// host must match that of the destination host.
//
//
//
//
//
type HostCpuIdInfo struct {
	*DynamicData

	// String representing the required EAX bits.
	Eax string

	// String representing the required EBX bits.
	Ebx string

	// String representing the required ECX bits.
	Ecx string

	// String representing the required EDX bits.
	Edx string

	// Level (EAX input to CPUID).
	Level int32

	// Used if this mask is for a particular vendor.
	Vendor string
}

//
// Information about the CPUs.
//
//
type HostCpuInfo struct {
	*DynamicData

	// CPU speed per core. This might be an averaged value if the speed
	// is not uniform across all cores. The total CPU speed of the box is
	// defined as hz * numCpuCores
	Hz int64

	// Number of physical CPU cores on the host.
	NumCpuCores int16

	// Number of physical CPU packages on the host.
	NumCpuPackages int16

	// Number of physical CPU threads on the host.
	NumCpuThreads int16
}

//
// Information about a physical CPU package.
//
//
type HostCpuPackage struct {
	*DynamicData

	// Bus speed in HZ.
	BusHz int64

	// The CPU feature bit on this particular CPU. This is independent of
	// the product and licensing capabilities.
	CpuFeature []*HostCpuIdInfo

	// String summary description of CPU (for display purposes).
	Description string

	// CPU speed in HZ.
	Hz int64

	// Package index, starting from zero.
	Index int16

	// The logical CPU threads on this package.
	ThreadId []int16

	// CPU vendor name, possible names currently are "Intel", "AMD",
	// or "unknown".
	Vendor string
}

type HostCpuPackageVendor struct {
}

//
// The CpuPowerManagementInfo data object type describes supported
// power management and current policy.
//
//
type HostCpuPowerManagementInfo struct {
	*DynamicData

	// Information about current CPU power management policy.
	CurrentPolicy string

	// Information about supported CPU power management.
	HardwareSupport string
}

//
// Possible values for Current CPU power management policy
//
//
type HostCpuPowerManagementInfoPolicyType struct {
}

//
// This managed object provides an interface
// through which you can gather and configure the host CPU scheduler
// policies that affect the performance of running virtual machines.
//
// Note: This managed object is useful only on platforms where
// resource management controls are available to optimize the running
// of virtual machines.
//
//
//
type HostCpuSchedulerSystem struct {
	*ExtensibleManagedObject

	hyperthreadInfo *HostHyperThreadScheduleInfo
}

// The hyperthread configuration for the CpuSchedulerSystem.  The
// existence of this data object type indicates if the CPU scheduler
// is capable of scheduling hyperthreads as resources.
func (mo *HostCpuSchedulerSystem) HyperthreadInfo() (*HostHyperThreadScheduleInfo, error) {
	t, err := mo.currentProperty("hyperthreadInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostHyperThreadScheduleInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostHyperThreadScheduleInfo")
	}
	return v, nil
}

//
// Don't treat hyperthreads as schedulable resources the next time the CPU
// scheduler starts.  If successful, this operation will change the
// configured setting.
//
// Required Privileges
// Host.Config.HyperThreading
//
func (mo *HostCpuSchedulerSystem) DisableHyperThreading(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Treat hyperthreads as schedulable resources the next time the CPU
// scheduler starts.  If successful, this operation will set the
// config
// property to "true".
//
// Required Privileges
// Host.Config.HyperThreading
//
func (mo *HostCpuSchedulerSystem) EnableHyperThreading(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// This event records when HA has been disabled on a host.
//
//
type HostDasDisabledEvent struct {
	*HostEvent
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records when HA is being disabled on a host.
//
//
type HostDasDisablingEvent struct {
	*HostEvent
}

//
// This event records when HA has been enabled on a host.
//
//
type HostDasEnabledEvent struct {
	*HostEvent
}

//
// This event records when HA is being enabled on a host.
//
//
type HostDasEnablingEvent struct {
	*HostEvent
}

// Deprecated.
// As of vSphere API 5.0, the Server will generate the EventEx event
// with the eventTypeId property set to "com.vmware.vc.HA.HostAgentErrorEvent".
//
//
// This event records when there is a HA error on a host.
//
//
type HostDasErrorEvent struct {
	*HostEvent

	// Since VI API 2.5
	Message string

	// The reason for the failure.
	//
	// Since vSphere API 4.0
	Reason string
}

type HostDasErrorEventHostDasErrorReason struct {
}

//
// Top-level event for host DAS events to extend.
//
//
type HostDasEvent struct {
	*HostEvent
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records when HA on a host returns to normal after an error.
//
//
type HostDasOkEvent struct {
	*HostEvent
}

//
// The DatastoreBrowser managed object type provides access to the contents of one or
// more datastores. The items in a datastore are files that contain configuration,
// virtual disk, and the other data associated with a virtual machine.
//
// Although datastores may often be implemented using a traditional file system, a full
// interface to a file system is not provided here. Instead, specialized access for
// virtual machine files is provided. A datastore implementation may completely hide the
// file directory structure.
//
//
// The intent is to provide functionality analogous to a file chooser in a user
// interface.
//
//
// Files on datastores do not have independent permissions through this API. Instead,
// the permissions for all the files on a datastore derive from the datastore object
// itself. It is not possible to change individual file permissions as the user browsing
// the datastore may not necessarily be a recognized user from the point of view of the
// host changing the permission. This occurs if the user browsing the datastore is doing
// so through the VirtualCenter management server.
//
//
// The DatastoreBrowser provides many ways to customize a search for files. A search can
// be customized by specifying the types of files to be searched, search criteria
// specific to a file type, and the amount of detail about each file. The most basic
// queries only use file details and are efficient with limited side effects. For these
// queries, file metadata details can be optionally retrieved, but the files themselves
// are opened and their contents examined. As a result, these files are not necessarily
// validated.
//
//
// More complicated queries can be formed by specifying the specific types of files to
// be searched, the parameters to filter for each type, and the desired level of detail
// about each file. This method of searching for files is convenient because it allows
// additional data about the virtual machine component to be retrieved. In addition,
// certain validation checks can be performed on matched files as an inherent part of
// the details collection process. However, gathering extra details or the use of type
// specific filters can sometimes only be implemented by examining the contents of a
// file. As a result, the use of these conveniences comes with the cost of additional
// latency in the request and possible side effects on the system as a whole.
//
//
// The DatastoreBrowser is referenced from various objects, including from
// Datastore, ComputeResource, HostSystem and
// VirtualMachine.  Depending on which object is used, there are different
// requirements for the accessibility of the browsed datastore from the host (or hosts)
// associated with the object:
//
//
//
// •  When referenced from the target Datastore, it needs to be
// accessible from at least one host on which the datastore is mounted.
// See accessible.
//
// •  When referenced from a ComputeResource, the target datastore
// needs to be accessible from at least one host in the ComputeResource.
// See accessible.
//
// •  When referenced from a HostSystem, the target datastore needs
// to be accessible from that host. See accessible.
//
// •  When referenced from a VirtualMachine, the target datastore
// needs to be accessible from the host on which the virtual machine is
// registered.  See accessible.
//
//
// See FileInfo
//
type HostDatastoreBrowser struct {
	*ManagedObject

	datastore []*Datastore

	supportedType []*FileQuery
}

// Set of datastores that can be searched on this DatastoreBrowser.
//
// The list of datastores available to browse on this DatastoreBrowser is contextual
// information that depends on the object being browsed. If the host is being
// browsed, the host's datastores are used. If the Datacenter is being browsed, the
// Datacenter's list of datastores is used.
// Required Privilege: System.View
func (mo *HostDatastoreBrowser) Datastore() ([]*Datastore, error) {
	t, err := mo.currentProperty("datastore")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Datastore)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Datastore")
	}
	return v, nil
}

// The list of supported file types. The supported file types are represented as
// items in this list. For each supported file type, there is an object in the list
// whose dynamic type is one of the types derived from the
// FileQuery data object
// type. In general, the properties in this query type are not set.
//
// Use the Query of the desired file type in the SearchSpec.query to indicate the
// desired file types.
//
// This property is used by clients to determine what kinds of file types are
// supported. Clients should consult this list to avoid querying for types of virtual
// machine components that are not supported.
func (mo *HostDatastoreBrowser) SupportedType() ([]*FileQuery, error) {
	t, err := mo.currentProperty("supportedType")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*FileQuery)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*FileQuery")
	}
	return v, nil
}

// Deprecated.
// As of VI API 2.5, use DeleteDatastoreFile_Task.
//
//
// Deletes the specified files from the datastore. If a valid virtual disk file is
// specified, then all the components of the virtual disk are deleted.
//
// Required Privileges
// Datastore.DeleteFile
//
func (mo *HostDatastoreBrowser) DeleteFile(
	_this *ManagedObjectReference, datastorePath string,
) error {

	return nil

}

//
// Returns the information for the files that match the given search criteria as a
// SearchResults object. Searches only the folder specified by the datastore path.
// The Datastore.Browse privilege must be held on the datastore identified
// by the datastore path.
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *HostDatastoreBrowser) SearchDatastore_Task(
	_this *ManagedObjectReference, datastorePath string, searchSpec *HostDatastoreBrowserSearchSpec,
) (*Task, error) {

	return nil, nil

}

//
// Returns the information for the files that match the given search criteria as a
// SearchResults[] object. Searches the folder specified by the datastore path and
// all subfolders. The Datastore.Browse privilege must be held on the
// datastore identified by the datastore path.
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *HostDatastoreBrowser) SearchDatastoreSubFolders_Task(
	_this *ManagedObjectReference, datastorePath string, searchSpec *HostDatastoreBrowserSearchSpec,
) (*Task, error) {

	return nil, nil

}

//
// This data object type contains the results of a search method for one datastore. A
// search method typically returns a set of these objects as an array.
//
//
type HostDatastoreBrowserSearchResults struct {
	*DynamicData

	// Datastore contains the results.
	Datastore *Datastore

	// Set of matching files, if any.
	File []*FileInfo

	// Relative path to the top-level folder.
	FolderPath string
}

//
// The data object type describes a search for files in one or more datastores. The
// properties do not include the starting datastore path because that path is a
// separate parameter to the search method.
//
// A SearchSpec contains the query parameters and some global search modifiers.
//
//
//
type HostDatastoreBrowserSearchSpec struct {
	*DynamicData

	// This object comprises a set of booleans that describe what details to return
	// for each file. The file level details apply globally to all matched files.
	Details *FileQueryFlags

	// Specifies a list of file patterns that must match for a file to be returned.
	// This search property is a filter that applies globally so that only files
	// matching the specified patterns are returned, regardless of the other search
	// parameters.
	MatchPattern []string

	// The set of file types to match, search criteria specific to the file type, and
	// the amount of detail for a file. These search parameters are specific to a file
	// type, meaning that they can be specified only if the file type to which they
	// are associated is in the set. A file type cannot appear more than once in the
	// set.
	//
	// If this query object is not present, then all files providing only file level
	// details are matched.
	Query []*FileQuery

	// This flag indicates whether or not to search using a case insensitive match on
	// type. In general the algorithm used to match file types relies on file
	// extensions. Although the specific file extensions used are encapsulated by this
	// API, clients are still allowed to modify the filtering behavior.
	//
	// By default, the DatastoreBrowser uses a platform-consistent algorithm to
	// determine if a file is of a type. Specifically on Linux, where case is
	// important, the search is case sensitive. On Windows, case is not important, so
	// the search is case insensitive.
	//
	// In an environment with heterogenous platforms, being platform-consistent may
	// not be desirable. As a result, the default behavior can be overridden by
	// setting this optional flag.
	SearchCaseInsensitive bool

	// By default, files are sorted in alphabetical order regardless of file type. If
	// this flag is set to "true", folders are placed at the start of the list of
	// results in alphabetical order. The remaining files follow in alphabetical
	// order.
	SortFoldersFirst bool
}

//
// The base data object type for information about datastores on the host.
//
//
type HostDatastoreConnectInfo struct {
	*DynamicData

	// Basic datastore information. The managed object reference is not set.
	Summary *DatastoreSummary
}

//
// This data object type describes a datastore on the host that matches an existing
// datastore on VirtualCenter that has a different name.
//
//
type HostDatastoreExistsConnectInfo struct {
	*HostDatastoreConnectInfo

	// The name of a matching datastore on VirtualCenter. The datastore on the host
	// will be renamed to this name.
	NewDatastoreName string
}

//
// This data object type describes a datastore on the host that has the same name as
// a different datastore on VirtualCenter.
//
//
type HostDatastoreNameConflictConnectInfo struct {
	*HostDatastoreConnectInfo

	// To resolve a conflict with existing datastores, a suggested new name of the
	// datastore can be provided.
	NewDatastoreName string
}

//
// This managed object creates and removes datastores from the host.
//
// To a host, a datastore is a storage abstraction that is backed by one
// of several types of storage volumes:
//
//
// Local file system
//
// A datastore that is backed by a local file system volume uses a host native
// local file system such as NTFS or ext3.  The datastore is created by
// identifying a file path for a directory in which virtual machine data will
// be stored.  When the datastore is deleted, the mapping from the datastore to
// the file is deleted.  The contents of the directory are not deleted.
//
//
//
// NAS Volume
//
// A datastore that is backed by a network-attached storage device is created
// by specifying the required data needed to attach the volume to the host.
// Destroying the datastore detaches the volume from the host.
//
//
//
// VMFS
//
// A datastore that is backed by a VMware File System (VMFS) is created by
// specifying a disk with unpartitioned space, the desired disk partition
// format on the disk, and some VMFS attributes.
//
// An ESX Server system automatically discovers the VMFS volume on attached Logical
// Unit Numbers (LUNs) on startup and after re-scanning the host bus adapter.
// Datastores are automatically created.  The datastore label is based on the
// VMFS volume label.  If there is a conflict with an existing datastore,
// it is made unique by appending a suffix.  The VMFS volume label will
// be unchanged.
//
//
// Destroying the datastore removes the partitions that compose the VMFS volume.
//
//
//
// Datastores are never automatically removed because transient storage
// connection outages may occur.  They must be removed from the host using
// this interface.See Datastore
//
type HostDatastoreSystem struct {
	*ManagedObject

	capabilities *HostDatastoreSystemCapabilities

	datastore []*Datastore
}

// Capability vector indicating the available product features.
//
// Since VI API 2.5
func (mo *HostDatastoreSystem) Capabilities() (*HostDatastoreSystemCapabilities, error) {
	t, err := mo.currentProperty("capabilities")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostDatastoreSystemCapabilities)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostDatastoreSystemCapabilities")
	}
	return v, nil
}

// List of datastores on this host.
// Required Privilege: System.View
func (mo *HostDatastoreSystem) Datastore() ([]*Datastore, error) {
	t, err := mo.currentProperty("datastore")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Datastore)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Datastore")
	}
	return v, nil
}

//
// Configures datastore principal user for the host.
//
// All virtual machine-related file I/O is performed under
// this user. Configuring datastore principal user
// will result in all virtual machine files (configuration, disk,
// and so on) being checked for proper access. If necessary, ownership
// and permissions are modified.  Note that in some environments,
// file ownership and permissions modification may not be possible.
// For example, virtual machine files stored on NFS cannot be
// modified for ownership and permissions if root squashing is
// enabled.  Ownership and permissions for these files must be
// manually changed by a system administrator.  In general, if
// server process does not have rights to change ownership
// and file permissions of virtual machine files, they must
// be modified manually.  If a virtual machine files are not
// read/writeable by this user, virtual machine related operations such as
// power on/off, configuration, and so on will fail.  This operation
// must be performed while in maintenance mode and requires host
// reboot.
//
//
// Required Privileges
// Host.Config.Maintenance
//
func (mo *HostDatastoreSystem) ConfigureDatastorePrincipal(
	_this *ManagedObjectReference, userName string, password string,
) error {

	return nil

}

//
// Creates a new local datastore.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDatastoreSystem) CreateLocalDatastore(
	_this *ManagedObjectReference, name string, path string,
) (*Datastore, error) {

	return nil, nil

}

//
// Creates a new network-attached storage datastore.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDatastoreSystem) CreateNasDatastore(
	_this *ManagedObjectReference, spec *HostNasVolumeSpec,
) (*Datastore, error) {

	return nil, nil

}

//
// Creates a new VMFS datastore.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDatastoreSystem) CreateVmfsDatastore(
	_this *ManagedObjectReference, spec *VmfsDatastoreCreateSpec,
) (*Datastore, error) {

	return nil, nil

}

//
// Increases the capacity of an existing VMFS datastore by expanding
// (increasing the size of) an existing extent of the datastore.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostDatastoreSystem) ExpandVmfsDatastore(
	_this *ManagedObjectReference, datastore *Datastore, spec *VmfsDatastoreExpandSpec,
) (*Datastore, error) {

	return nil, nil

}

//
// Increases the capacity of an existing VMFS datastore by adding new
// extents to the datastore.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDatastoreSystem) ExtendVmfsDatastore(
	_this *ManagedObjectReference, datastore *Datastore, spec *VmfsDatastoreExtendSpec,
) (*Datastore, error) {

	return nil, nil

}

//
// Query to list disks that can be used to contain VMFS datastore extents.
// If the optional parameter name is supplied, queries for disks that can be
// used to contain extents for a VMFS datastore identified by the supplied
// name.  Otherwise, the method retrieves disks that can be used to contain
// new VMFS datastores.
//
// This operation will filter out disks that are currently in use by an
// existing VMFS unless the VMFS using the disk is one being extended.
// It will also filter out management LUNs and disks that are referenced by
// RDMs.  These disk LUNs are also unsuited for use by a VMFS.
//
//
// Disk LUNs referenced by RDMs are found by examining all virtual machines
// known to the system and visiting their virtual disk backends.  If a
// virtual disk backend uses an RDM that is referencing a disk LUN, the disk
// LUN becomes ineligible for use by a VMFS datastore.
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDatastoreSystem) QueryAvailableDisksForVmfs(
	_this *ManagedObjectReference, datastore *Datastore,
) ([]*HostScsiDisk, error) {

	return nil, nil

}

//
// Get the list of unbound VMFS volumes.
// For sharing a volume across hosts, a VMFS volume is bound to its
// underlying block device storage. When a low level block copy is
// performed to copy or move the VMFS volume, the copied volume will
// be unbound.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *HostDatastoreSystem) QueryUnresolvedVmfsVolumes(
	_this *ManagedObjectReference,
) ([]*HostUnresolvedVmfsVolume, error) {

	return nil, nil

}

//
// Queries options for creating a new VMFS datastore for a disk.See devicePath
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDatastoreSystem) QueryVmfsDatastoreCreateOptions(
	_this *ManagedObjectReference, devicePath string, vmfsMajorVersion int32,
) ([]*VmfsDatastoreOption, error) {

	return nil, nil

}

//
// Queries for options for increasing the capacity of an existing VMFS
// datastore by expanding (increasing the size of) an existing extent of
// the datastore.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostDatastoreSystem) QueryVmfsDatastoreExpandOptions(
	_this *ManagedObjectReference, datastore *Datastore,
) ([]*VmfsDatastoreOption, error) {

	return nil, nil

}

//
// Queries for options for increasing the capacity of an existing VMFS
// datastore by adding new extents using space from the specified disk.See devicePath
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDatastoreSystem) QueryVmfsDatastoreExtendOptions(
	_this *ManagedObjectReference, datastore *Datastore, devicePath string, suppressExpandCandidates bool,
) ([]*VmfsDatastoreOption, error) {

	return nil, nil

}

//
// Removes a datastore from a host.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDatastoreSystem) RemoveDatastore(
	_this *ManagedObjectReference, datastore *Datastore,
) error {

	return nil

}

//
// Resignature an unbound VMFS volume.
//
// To safely enable sharing of the volume across hosts, a VMFS volume
// is bound to its underlying block device storage.  When a low level
// block copy is performed to copy or move the VMFS volume, the copied
// volume will be unbound.  In order for the VMFS volume to be usable,
// a resolution operation is needed to determine whether the VMFS volume
// should be treated as a new volume or not and what extents compose
// that volume in the event there is more than one unbound volume.
//
// With 'Resignature' operation, a new Vmfs Uuid is assigned to the
// volume but its contents are kept intact. Resignature results in a
// new Vmfs volume on the host. Users can specify a list of hosts on which
// the volume will be auto-mounted.
//
//
//
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostDatastoreSystem) ResignatureUnresolvedVmfsVolume_Task(
	_this *ManagedObjectReference, resolutionSpec *HostUnresolvedVmfsResignatureSpec,
) (*Task, error) {

	return nil, nil

}

//
// Choose the
// localSwapDatastore
// for this host. Any change to this setting will affect virtual machines
// that subsequently power on or resume from a suspended state at this host,
// or that migrate to this host while powered on; virtual machines that are
// currently powered on at this host will not yet be affected.
//
// Required Privileges
// Host.Config.Storage
// Since
// VI API 2.5
//
func (mo *HostDatastoreSystem) UpdateLocalSwapDatastore(
	_this *ManagedObjectReference, datastore *Datastore,
) error {

	return nil

}

//
// Capability vector indicating the available product features.
//
//
type HostDatastoreSystemCapabilities struct {
	*DynamicData

	// Indicates whether local datastores are supported.
	LocalDatastoreSupported bool

	// Indicates whether mounting the NFS volume is required to be done as part
	// of NAS datastore creation. If this is set to true, then NAS datastores
	// cannot be created for currently mounted NFS volumes.
	NfsMountCreationRequired bool

	// Indicates whether mounting an NFS volume is supported
	// when a NAS datastore is created. If this option is false,
	// then NAS datastores corresponding to NFS volumes can be created
	// only for already mounted NFS volumes.
	NfsMountCreationSupported bool

	// Indicates whether vmfs extent expansion is supported.
	//
	// Since vSphere API 4.0
	VmfsExtentExpansionSupported bool
}

//
// This data object represents the dateTime configuration of the host.
//
//
type HostDateTimeConfig struct {
	*DynamicData

	// The NTP configuration on the host.
	NtpConfig *HostNtpConfig

	// The time zone of the host.
	// Must be one of the values of
	// key
	TimeZone string
}

//
// This data object represents the dateTime configuration of the host.
//
//
type HostDateTimeInfo struct {
	*DynamicData

	// The NTP configuration on the host.
	NtpConfig *HostNtpConfig

	// The time zone of the host.
	TimeZone *HostDateTimeSystemTimeZone
}

//
// This managed object provides for NTP and date/time related
// configuration on a host.
//
// Information regarding the running status of the NTP daemon and
// functionality to start and stop the daemon is provided by the
// HostServiceSystem object.
//
type HostDateTimeSystem struct {
	*ManagedObject

	dateTimeInfo *HostDateTimeInfo
}

// The DateTime configuration of the host.
// Required Privilege: System.Read
func (mo *HostDateTimeSystem) DateTimeInfo() (*HostDateTimeInfo, error) {
	t, err := mo.currentProperty("dateTimeInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostDateTimeInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostDateTimeInfo")
	}
	return v, nil
}

//
// Retrieves the list of available timezones on the host.
// The API works off the public domain 'tz' timezone database.
//
// Required Privileges
// System.Read
//
func (mo *HostDateTimeSystem) QueryAvailableTimeZones(
	_this *ManagedObjectReference,
) ([]*HostDateTimeSystemTimeZone, error) {

	return nil, nil

}

//
// Get the current DateTime on the host.
//
// Required Privileges
// System.Read
//
func (mo *HostDateTimeSystem) QueryDateTime(
	_this *ManagedObjectReference,
) (time.Time, error) {

	return time.Now(), nil

}

//
// Refresh the DateTime related settings to pick up any changes that might have
// occurred.
//
// Required Privileges
// Host.Config.DateTime
//
func (mo *HostDateTimeSystem) RefreshDateTimeSystem(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Update the date/time on the host.
// This method should be used with caution since network delays, execution
// delays can result in time skews.
//
// Required Privileges
// Host.Config.DateTime
//
func (mo *HostDateTimeSystem) UpdateDateTime(
	_this *ManagedObjectReference, dateTime time.Time,
) error {

	return nil

}

//
// Update the DateTime configuration of the host.
//
// Required Privileges
// Host.Config.DateTime
//
func (mo *HostDateTimeSystem) UpdateDateTimeConfig(
	_this *ManagedObjectReference, config *HostDateTimeConfig,
) error {

	return nil

}

type HostDateTimeSystemTimeZone struct {
	*DynamicData

	// Description of the time zone.
	Description string

	// The GMT offset in seconds that is currently applicable to the timezone
	// (with respect to the current time on the host).
	GmtOffset int32

	// The identifier for the time zone.
	Key string

	// The time zone name.
	Name string
}

//
// This data object type defines a device on the host.
//
//
type HostDevice struct {
	*DynamicData

	// The name of the device on the host. For example,
	// /dev/cdrom or \\serverX\device_name.
	DeviceName string

	// Device type when available:
	// floppy, mouse, cdrom, disk, scsi device, or adapter.
	DeviceType string
}

//
// A dynamic host control protocol (DHCP) service instance serves IP
// addresses to a single virtual network subnet.  The instances may
// be handled collectively by a single server.  This decision can
// be made during implementation.
//
//
type HostDhcpService struct {
	*DynamicData

	// The instance ID of the DHCP service.
	Key string

	// Configurable properties for the DHCP service.
	Spec *HostDhcpServiceSpec
}

//
// This data object type describes the configuration of a DHCP service
// instance representing both the configured properties
// on the instance and identification information.
//
//
type HostDhcpServiceConfig struct {
	*DynamicData

	// Indicates the change operation to apply on this configuration
	// specification.See HostConfigChangeOperation
	ChangeOperation string

	// The instance ID of the DHCP service.
	Key string

	// Specification of the DHCP service.
	Spec *HostDhcpServiceSpec
}

type HostDhcpServiceSpec struct {
	*DynamicData

	// The default DHCP lease duration (minutes).
	DefaultLeaseDuration int32

	// Subnet served by DHCP service.
	IpSubnetAddr string

	// Subnet mask of network served by DHCP service.
	IpSubnetMask string

	// The start of the IP address range served by the DHCP service.
	LeaseBeginIp string

	// The end of the IP address range served by the DHCP service.
	LeaseEndIp string

	// The maximum DHCP lease duration (minutes).
	MaxLeaseDuration int32

	// A flag to indicate whether or not unlimited DHCP lease
	// durations are allowed.
	UnlimitedLease bool

	// The name of the virtual switch to which DHCP service is connected.
	VirtualSwitch string
}

//
// This data object type contains information about an available or active
// diagnostic partition.
//
//
type HostDiagnosticPartition struct {
	*DynamicData

	// Indicates the type of the diagnostic partition.See DiagnosticPartitionType
	DiagnosticType string

	// Diagnostic partition identification information.
	Id *HostScsiDiskPartition

	// The number of slots in the diagnostic partition.
	Slots int32

	// Indicates the storage type of the diagnostic partition.See DiagnosticPartitionStorageType
	StorageType string
}

//
// The diagnostic partition create description details what will be done
// to create a new diagnostic partition on a disk.  It contains a CreateSpec
// that can be submitted to create the partition and information that can
// be shown to the user.
//
//
type HostDiagnosticPartitionCreateDescription struct {
	*DynamicData

	// The UUID of the SCSI disk on which to create the diagnostic partition.
	// This disk UUID will match that found in the identification field of the
	// creation spec.See HostScsiDiskSee uuid
	DiskUuid string

	// Layout describing the format of the disk
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	Layout *HostDiskPartitionLayout

	// Creation specification for diagnostic partition
	Spec *HostDiagnosticPartitionCreateSpec
}

//
// This data object describes a disk that can be used to create a
// diagnostic partition.
//
//
type HostDiagnosticPartitionCreateOption struct {
	*DynamicData

	// Indicates the type of the diagnostic partition to be created.See DiagnosticPartitionType
	DiagnosticType string

	// The disk which has sufficient free space to contain a diagnostic
	// partition.
	Disk *HostScsiDisk

	// Indicates the storage type of diagnostic partition to be created.See DiagnosticPartitionStorageType
	StorageType string
}

//
// The diagnostic create specification is used by the system to create a new
// diagnostic partition on a SCSI disk.
//
//
type HostDiagnosticPartitionCreateSpec struct {
	*DynamicData

	// Indicates if the created diagnostic partition should be made the
	// active diagnostic partition.  If not supplied, the system will
	// decide whether or not the created specification is active.
	Active bool

	// Indicates the type of the diagnostic partition to be created.See DiagnosticPartitionType
	DiagnosticType string

	// Diagnostic partition identification information.
	Id *HostScsiDiskPartition

	// Partitioning specification.
	Partition *HostDiskPartitionSpec

	// Indicates the storage type where the diagnostic partition
	// will be created.See DiagnosticPartitionStorageType
	StorageType string
}

//
// The DiagnosticSystem managed object is used to configure the diagnostic
// mechanisms specific to the host.  The DiagnosticSystem interface supports
// the following concepts:
//
//
// •  Notion of an active diagnostic partition that is selected from
// a set of available partitions.
//
// •  Ability to create a diagnostic partition that gets added to the
// list of available partitions and could be made active.
//
//
//
//
type HostDiagnosticSystem struct {
	*ManagedObject

	activePartition *HostDiagnosticPartition
}

// The currently active diagnostic partition.
func (mo *HostDiagnosticSystem) ActivePartition() (*HostDiagnosticPartition, error) {
	t, err := mo.currentProperty("activePartition")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostDiagnosticPartition)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostDiagnosticPartition")
	}
	return v, nil
}

//
// Creates a diagnostic partition according to the provided create
// specification.  On success, this method will create the partition
// and make the partition the active diagnostic partition if specified.
// On failure, the diagnostic partition may exist but may not be active
// if the partition was supposed to be made active.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDiagnosticSystem) CreateDiagnosticPartition(
	_this *ManagedObjectReference, spec *HostDiagnosticPartitionCreateSpec,
) error {

	return nil

}

//
// Retrieves a list of available diagnostic partitions.  The server will
// provide the list in order of preference.  In general, local diagnostic
// partitions are better than shared diagnostic partitions because of
// the impossibility of multiple servers sharing the same partition.  The
// most preferred diagnostic partition will be first in the array.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDiagnosticSystem) QueryAvailablePartition(
	_this *ManagedObjectReference,
) ([]*HostDiagnosticPartition, error) {

	return nil, nil

}

//
// For a disk, query for the diagnostic partition creation description.
// The description details how the diagnostic partition will be created
// on the disk and provides a creation specification that is needed to
// invoke the create operation.See HostScsiDiskSee uuid
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDiagnosticSystem) QueryPartitionCreateDesc(
	_this *ManagedObjectReference, diskUuid string, diagnosticType string,
) (*HostDiagnosticPartitionCreateDescription, error) {

	return nil, nil

}

//
// Retrieves a list of disks that can be used to contain a diagnostic
// partition.  This list will contain disks that have sufficient space
// to contain a diagnostic partition of the specific type.
//
// The choices will be returned in the order that is most preferable
// as determined by the system.
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDiagnosticSystem) QueryPartitionCreateOptions(
	_this *ManagedObjectReference, storageType string, diagnosticType string,
) ([]*HostDiagnosticPartitionCreateOption, error) {

	return nil, nil

}

//
// Changes the active diagnostic partition to a different partition.
// Setting a NULL partition will result in unsetting the diagnostic
// partition.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostDiagnosticSystem) SelectActivePartition(
	_this *ManagedObjectReference, partition *HostScsiDiskPartition,
) error {

	return nil

}

//
// This data object type describes the digest information
//
//
type HostDigestInfo struct {
	*DynamicData

	// Method in which the digest value is calculated. The set of possible
	// values is described in HostDigestInfoDigestMethodType.
	DigestMethod string

	// The variable length byte array containing the digest value calculated by
	// the specified digestMethod.
	DigestValue []int8

	// The name of the object from which this digest value is calcaulated.
	ObjectName string
}

//
// The set of digest methods that can be used by TPM to calculate the PCR
// values.
//
//
type HostDigestInfoDigestMethodType struct {
}

//
// HostDirectoryStore is a base class for
// directory-based authentication stores.
//
type HostDirectoryStore struct {
	*ManagedObject
	*HostAuthenticationStore
}

//
// HostDirectoryStoreInfo is a base class for objects that
// provide information about directory-based authentication stores.
//
//
type HostDirectoryStoreInfo struct {
	*HostAuthenticationStoreInfo
}

//
// This event records a disconnection from a host.
//
//
type HostDisconnectedEvent struct {
	*HostEvent

	// Reason why the host was disconnected.
	//
	// Since vSphere API 4.0
	Reason string
}

type HostDisconnectedEventReasonCode struct {
}

//
// Disk configuration result returns success or fault of the
//
// operation on the disk.
//
//
type HostDiskConfigurationResult struct {
	*DynamicData

	// The device path. See ScsiDisk
	DevicePath string

	// 'fault' would be set if the operation was not successful
	Fault *LocalizedMethodFault

	// Flag to indicate if the operation is successful
	Success bool
}

//
// This data object type describes multiple coordinate systems
// used to refer to a location or size on a disk.
//
//
type HostDiskDimensions struct {
	*DynamicData
}

//
// This data object type describes dimensions using the cylinder,
// head, sector (CHS) coordinate system.  This coordinate system
// is generally needed for partitioning for legacy reasons.  When defining
// partitions, many partitioning utilities do not function correctly when
// certain CHS constraints are not met.
//
//
type HostDiskDimensionsChs struct {
	*DynamicData

	// The number of cylinders.
	Cylinder int64

	// The number of heads per cylinders.
	Head int32

	// The number of sectors per head.
	Sector int32
}

//
// This data object type describes the logical block addressing system
// that uses block numbers and block sizes to refer to a block.  This
// scheme is employed by SCSI.  If a SCSI disk is not involved,
// then blockSize is 512 bytes.
//
//
type HostDiskDimensionsLba struct {
	*DynamicData

	// The number of blocks.
	Block int64

	// The size of the blocks.
	BlockSize int32
}

//
// The HostDiskMappingInfo data object type describes
// a virtual disk mapping to a host disk.
//
//
type HostDiskMappingInfo struct {
	*DynamicData

	// Flag to indicate whether or not the virtual machine has exclusive access
	// to the host device.
	Exclusive bool

	// Host resource name.
	Name string

	// The partition used on the host, if not mapping
	// to a full disk device.
	PhysicalPartition *HostDiskMappingPartitionInfo
}

//
// The HostDiskMappingOption data object type describes
// the options for a virtual disk mapping to a host disk.
//
//
type HostDiskMappingOption struct {
	*DynamicData

	// Host resource name.
	Name string

	// Array of valid partitions on this physical disk.
	// There is no default for this array.
	PhysicalPartition []*HostDiskMappingPartitionOption
}

//
// The PhysicalPartitionInfo data class.
//
//
type HostDiskMappingPartitionInfo struct {
	*DynamicData

	// Partition capacity, in KB.
	CapacityInKb int64

	// Filesystem, if the partition is formatted.
	FileSystem string

	// Partition name.
	Name string
}

//
// The PhysicalPartitionOption data class contains the options
// for a partition on a physical disk.
//
//
type HostDiskMappingPartitionOption struct {
	*DynamicData

	// Partition capacity, in KB.
	CapacityInKb int64

	// File system, if the partition is formatted.
	FileSystem string

	// Partition name.
	Name string
}

//
// Information about a single disk partition.  A partition is a contiguous
// set of blocks on a disk that is marked for use.  The typeId identifies
// the purpose of the data in the partition.
//
//
type HostDiskPartitionAttributes struct {
	*DynamicData

	// The attributes on the partition.
	Attributes int8

	// The end sector.
	EndSector int64

	// Globally Unique Identifier of the partition, as defined by the GUID
	// Partition Table (GPT) format. This is available only for GPT formatted
	// disks.
	//
	// Since vSphere API 5.0
	Guid string

	// The flag to indicate whether or not the partition is
	// logical.  If true, the partition
	// number should be greater than 4.
	Logical bool

	// The partition number.  Must be a positive integer.
	Partition int32

	// Partition alignment in bytes.
	// If unset, partition alignment value is unknown.
	//
	// Since vSphere API 5.0
	PartitionAlignment int64

	// The start sector.
	StartSector int64

	// Type of data in the partition.  If it is a well-known partition type,
	// it will be one of the defined types.  If it is not, then it will be
	// reported as a hexadecimal number.  For example, "none", "vmfs", "linux",
	// and "0x20" are all valid values.See HostDiskPartitionInfoType
	Type string
}

//
// A BlockRange data object type describes a contiguous set of blocks
// on a disk.  A BlockRange may describe either a partition or
// unpartitioned (primordial) blocks on the disk.
//
//
type HostDiskPartitionBlockRange struct {
	*DynamicData

	// The end block address of the disk range.  The block numbers start
	// from zero.  The range is inclusive of the end address.
	End *HostDiskDimensionsLba

	// Partition number.  This number is a hint from the server indicating
	// what the partition number for this block range is if the range
	// corresponds to a partition.  The partition number should correlate to
	// the one in the partition specification.  If sent back to the server,
	// this property is ignored.
	Partition int32

	// The starting block address of the disk range.  The block numbers start
	// from zero.  The range is inclusive of the end address.
	Start *HostDiskDimensionsLba

	// The type of data in the partition.See type
	Type string
}

//
// Information about the partitions on a disk.  A DiskPartitionInfo object
// provides two different views into the partitions on a disk:
//
//
//
//
//
// • A detailed specification that is used to create the partition
// table.
//
// • A convenient view that shows the allocations
// of blocks as a contiguous sequence of block ranges.
//
//
// See RetrieveDiskPartitionInfoSee ComputeDiskPartitionInfoSee UpdateDiskPartitions
//
//
type HostDiskPartitionInfo struct {
	*DynamicData

	// The device name of the disk to which this partition information
	// corresponds.
	DeviceName string

	// A convenient format for describing disk layout.  This layout
	// specification can be converted to a Specification object.See ComputeDiskPartitionInfo
	Layout *HostDiskPartitionLayout

	// The detailed disk partition specification.  Use this specification for
	// manipulating the file system.See RetrieveDiskPartitionInfoSee UpdateDiskPartitions
	Spec *HostDiskPartitionSpec
}

//
// List of partition format types. This denotes the partition table layout.
//
//
type HostDiskPartitionInfoPartitionFormat struct {
}

//
// List of symbol partition types
//
//
type HostDiskPartitionInfoType struct {
}

//
// This data object type describes the disk partition layout
// specified as a list of ordered BlockRanges.  This
// view of the disk partitions shows the data on the disk as a contiguous
// set of BlockRanges.
//
//
type HostDiskPartitionLayout struct {
	*DynamicData

	// List of block ranges on the disk.
	Partition []*HostDiskPartitionBlockRange

	// Total number of blocks on a disk.
	Total *HostDiskDimensionsLba
}

//
// This data object type describes the disk partition table
// specification used to configure the partitions on a
// disk.  This data object represents the fundamental data needed to specify
// a partition table.
//
//
type HostDiskPartitionSpec struct {
	*DynamicData

	// Disk dimensions expressed as cylinder, head, sector (CHS)
	// coordinates.
	Chs *HostDiskDimensionsChs

	// List of partitions on the disk.
	Partition []*HostDiskPartitionAttributes

	// Partition format type on the disk.
	//
	// Since vSphere API 5.0
	PartitionFormat string

	// Disk dimensions expressed in total number of
	// 512-byte sectors.
	TotalSectors int64
}

//
// This data object type describes the DNS configuration.
//
// All IPv4 addresses, subnet addresses, and netmasks are specified using
// dotted decimal notation.  For example, "192.0.2.1".
// IPv6 addresses are 128-bit addresses represented as
// eight fields of up to four hexadecimal digits.
// A colon separates each field (:). For example,
// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
// symbol '::' to represent multiple 16-bit groups of
// contiguous 0's only once in an address as described in RFC 2373.
//
//
//
type HostDnsConfig struct {
	*DynamicData

	// The IP addresses of the DNS servers, placed in order of preference.
	//
	// Note:  When DHCP is not enabled, the property can be set
	// explicitly.  When DHCP is enabled, the property reflects the current
	// DNS configuration, but cannot be set.
	Address []string

	// The flag to indicate whether or not DHCP (dynamic host control
	// protocol) is used to determine DNS configuration automatically.
	Dhcp bool

	// The domain name portion of the DNS name.  For example, "vmware.com".
	//
	// Note:  When DHCP is not enabled, the property can be set
	// explicitly.  When DHCP is enabled, the property reflects the current
	// DNS configuration, but cannot be set.
	DomainName string

	// The host name portion of DNS name.  For example, "esx01".
	//
	// Note:  When DHCP is not enabled, the property can be set
	// explicitly.  When DHCP is enabled, the property reflects the current
	// DNS configuration, but cannot be set.
	HostName string

	// The domain in which to search for hosts, placed in order of preference.
	//
	// Note:  When DHCP is not enabled, the property can be set
	// explicitly.  When DHCP is enabled, the property reflects the current
	// DNS configuration, but cannot be set.
	SearchDomain []string

	// If DHCP is enabled, the DHCP DNS of the service console network
	// adapter will override the system DNS. This field is ignored
	// if DHCP is disabled by the dhcp property.
	VirtualNicDevice string
}

//
// Dataobject for configuring the DNS settings on the host.
//
//
type HostDnsConfigSpec struct {
	*HostDnsConfig

	// Choose a Virtual nic based on what it is connected to.
	VirtualNicConnection *HostVirtualNicConnection
}

//
// This event records the failure to restore some of the administrator's permissions.
//
//
type HostEnableAdminFailedEvent struct {
	*HostEvent

	Permissions []*Permission
}

//
// This managed object type is used to configure agent virtual machine resource
// configuration, such as what network and datastore to use for agent virtual
// machines.
//
type HostEsxAgentHostManager struct {
	*ManagedObject

	configInfo *HostEsxAgentHostManagerConfigInfo
}

// Configuration of agent virtual machine resources
// Required Privilege: Host.Config.Settings
func (mo *HostEsxAgentHostManager) ConfigInfo() (*HostEsxAgentHostManagerConfigInfo, error) {
	t, err := mo.currentProperty("configInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostEsxAgentHostManagerConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostEsxAgentHostManagerConfigInfo")
	}
	return v, nil
}

//
// Update the host's ESX agent configuration.
//
// The entire configuration must be set each time since all values are
// overwritten. E.g. a field set to null clears the value on the host.
//
// Required Privileges
// Host.Config.Settings
//
func (mo *HostEsxAgentHostManager) EsxAgentHostManagerUpdateConfig(
	_this *ManagedObjectReference, configInfo *HostEsxAgentHostManagerConfigInfo,
) error {

	return nil

}

type HostEsxAgentHostManagerConfigInfo struct {
	*DynamicData

	// Datastore used for deploying Agent VMs on this host.
	AgentVmDatastore *Datastore

	// Management Network for Agent VMs on this host.
	AgentVmNetwork *Network
}

//
// These are host-related events.
//
//
type HostEvent struct {
	*Event
}

//
// The event argument is a Host object.
//
//
type HostEventArgument struct {
	*EntityEventArgument

	// The host object.
	Host *HostSystem
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records the fact that a host has extra networks not used by
// other hosts for HA communication
//
//
type HostExtraNetworksEvent struct {
	*HostDasEvent

	// The comma-separated list of extra networks
	Ips string
}

//
// A feature that the host is able to provide at a particular value.
//
//
type HostFeatureCapability struct {
	*DynamicData

	// Name of the feature. Identical to the key.
	FeatureName string

	// Accessor name to the feature capability.
	Key string

	// Opaque value that the feature is capable at.
	Value string
}

//
// A mask that is applied to a host feature capability.
//
//
type HostFeatureMask struct {
	*DynamicData

	// Name of the feature Identical to the key.
	FeatureName string

	// Accessor name to the feature mask.
	Key string

	// Opaque value to change the host feature capability to.
	// Masking operation is contained in the value.
	Value string
}

//
// Feature-specific version information for a host
//
//
type HostFeatureVersionInfo struct {
	*DynamicData

	// A unique key that identifies a feature, list of possible values are
	// specified in HostFeatureVersionKey
	Key string

	// The version string of this feature
	Value string
}

//
// Set of possible values for
// key, which
// is a unique key that identifies a feature.
//
//
type HostFeatureVersionKey struct {
}

//
// This data object type describes the Fibre Channel host bus adapter.
//
//
type HostFibreChannelHba struct {
	*HostHostBusAdapter

	// The world wide node name for the adapter.
	NodeWorldWideName int64

	// The type of the fiber channel port.
	PortType *enum.FibreChannelPortType

	// The world wide port name for the adapter.
	PortWorldWideName int64

	// The current operating speed of the adapter in
	// bits per second.
	Speed int64
}

//
// This data object type describes the FCoE host bus adapter
// interface.
//
// Terminology is borrowed from T11's working draft of the Fibre Channel
// Backbone 5 standard (FC-BB-5).  The draft can be found at
// http://www.t11.org.
//
//
type HostFibreChannelOverEthernetHba struct {
	*HostFibreChannelHba

	// True if this host bus adapter is a software based FCoE initiator.
	IsSoftwareFcoe bool

	// Link information that can be used to uniquely identify this FCoE HBA.
	LinkInfo *HostFibreChannelOverEthernetHbaLinkInfo

	// True if this host bus adapter has been marked for removal.
	MarkedForRemoval bool

	// The name associated with this FCoE HBA's underlying FcoeNic.
	UnderlyingNic string
}

//
// Represents FCoE link information.
//
// The link information represents a VNPort to VFPort Virtual Link, as
// described in the FC-BB-5 standard, with the addition of the VLAN ID
// over which a link exists.
//
//
type HostFibreChannelOverEthernetHbaLinkInfo struct {
	*DynamicData

	// FCF MAC address, also known as the VFPort MAC address in the FC-BB-5
	// standard.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where
	// 'x' is a hexadecimal digit.  Valid MAC addresses are unicast
	// addresses.
	FcfMac string

	// VLAN ID.
	//
	// This field represents the VLAN on which an FCoE HBA was
	// discovered.  Valid numbers fall into the range [0,4094].
	VlanId int32

	// VNPort MAC address, as defined by the FC-BB-5 standard.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where
	// 'x' is a hexadecimal digit.  Valid MAC addresses are unicast
	// addresses.
	VnportMac string
}

//
// Fibre Channel Over Ethernet transport information about a SCSI target.
//
// FCoE transport information is that of: the regular FC World Wide Node
// and Port Names; the VNPort MAC address and FCF MAC address which
// constitute a VN_Port to VF_Port Virtual Link; and the VLAN on which
// an FCoE target resides.
//
// More FCoE information can be found in the working draft of the T11's
// Fibre Channel Backbone 5 standard (FC-BB-5).  The draft can be found
// at http://www.t11.org.
//
//
type HostFibreChannelOverEthernetTargetTransport struct {
	*HostFibreChannelTargetTransport

	// FCF MAC address.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where
	// 'x' is a hexadecimal digit.  Valid MAC addresses are unicast
	// addresses.
	FcfMac string

	// VLAN ID.
	//
	// Valid VLAN IDs fall within the range [0,4094].
	VlanId int32

	// VNPort MAC address.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where
	// 'x' is a hexadecimal digit.  Valid MAC addresses are unicast
	// addresses.
	VnportMac string
}

//
// Fibre Channel transport information about a SCSI target.
//
//
type HostFibreChannelTargetTransport struct {
	*HostTargetTransport

	// The world wide node name of the target.
	NodeWorldWideName int64

	// The world wide port name of the target.
	PortWorldWideName int64
}

//
// This data object type contains a single access control
// entry for a file permissions list.
//
//
type HostFileAccess struct {
	*DynamicData

	// Rights given to the user or group.
	What string

	// User or group to which the access applies.
	Who string
}

//
// The HostFileSystemMountInfo data object describes
// a host mount point for a file system.
//
//
type HostFileSystemMountInfo struct {
	*DynamicData

	// Information about the mount point.
	MountInfo *HostMountInfo

	// Information about the mounted volume.
	Volume *HostFileSystemVolume

	// vStorage hardware acceleration support status. This property
	// represents the volume's capability for storage acceleration.
	// See FileSystemMountInfoVStorageSupportStatus for valid
	// values.
	//
	// If the ESX Server supports hardware acceleration, the Server
	// can offload specific virtual machine management operations
	// to a storage device with the hardware acceleration feature.
	// With hardware assistance, the host performs storage operations
	// faster and consumes less CPU, memory, and storage fabric bandwidth.
	//
	// For vSphere 4.0 or earlier hosts, this value will be unset.
	//
	// Since vSphere API 4.1
	VStorageSupport string
}

//
// Detailed information about a file system.  This is a base type for derived types
// that have more specific details about specific filesystem types.
//
// Typically a FileSystem is exposed as a datatoreSee DatastoreInfoSee HostVmfsVolumeSee HostNasVolumeSee HostVffsVolumeSee HostLocalFileSystemVolumeSee HostVfatVolume
//
//
//
type HostFileSystemVolume struct {
	*DynamicData

	// The capacity of the file system volume, in bytes.
	Capacity int64

	// Name of the file system volume.
	Name string

	// Type of file system volume.
	//
	// The following values are defined:
	//
	// VMFS
	//
	// VMware File System (ESX Server only).  If this is set,
	// the type of the file system volume is VMFS.
	//
	//
	// NFS
	//
	// Network file system v3 and below (Linux and ESX Server only).
	// If this is set, the type of the file system volume is NetworkFileSystem.
	//
	//
	// NFSV41
	//
	// Network file system version v4.1 or later (Linux only and ESX Server only).
	// If this is set, the type of the file system volume is NetworkFileSystem41.
	//
	//
	// CIFS
	//
	// Common Internet file system (Windows only). If this is set,
	// the type of the file system volume is CIFS.
	//
	//
	// VFAT
	//
	// Virtual FAT (ESX Server  only). If this is set,
	// the type of the file system volume is VFAT.
	//
	//
	// vsan
	//
	// VSAN (ESX Server  only). If this is set, the type of the file system
	// volume is VSAN.
	//
	//
	//
	// VFFS
	//
	// vFlash File System (ESX Server only). If this is set, the type
	// of the file system volume is VFFS.
	Type string
}

//
// The HostFileSystemVolumeInfo data object describes the file system volume
// information for the host.
//
// A file system volume refers to a storage abstraction that allows files
// to be created and organized.  A host can have multiple file system
// volumes.  File system volumes are typically mounted into a file namespace
// that allows all files in mounted file systems to be addressable from the
// host.
//
//
// A file system volume is backed by disk storage.  It could span one or more
// disks but need not use an entire disk.
//
//
// A file system volume by definition must be mounted on the file system
// in order to exist.
//
//
//
type HostFileSystemVolumeInfo struct {
	*DynamicData

	// The list of file system volumes mounted on the host.
	MountInfo []*HostFileSystemMountInfo

	// The list of supported file system volume types.
	VolumeTypeList []string
}

//
// DataObject used for firewall configuration
//
//
type HostFirewallConfig struct {
	*DynamicData

	// Default settings for the firewall,
	// used for ports that are not explicitly opened.
	DefaultBlockingPolicy *HostFirewallDefaultPolicy

	// Rules determining firewall settings.
	Rule []*HostFirewallConfigRuleSetConfig
}

type HostFirewallConfigRuleSetConfig struct {
	*DynamicData

	// The list of allowed ip addresses
	//
	// Since vSphere API 5.0
	AllowedHosts *HostFirewallRulesetIpList

	// Flag indicating if the specified ruleset should be enabled.
	Enabled bool

	// Id of the ruleset.
	RulesetId string
}

//
// Default settings for the firewall, used for ports
// that are not explicitly opened.
//
//
type HostFirewallDefaultPolicy struct {
	*DynamicData

	// Flag indicating whether incoming traffic should be blocked by default.
	IncomingBlocked bool

	// Flag indicating whether outgoing traffic should be blocked by default.
	OutgoingBlocked bool
}

//
// Data object describing the firewall configuration.
//
//
type HostFirewallInfo struct {
	*DynamicData

	// Default firewall policy.
	DefaultPolicy *HostFirewallDefaultPolicy

	// List of configured rulesets.
	Ruleset []*HostFirewallRuleset
}

//
// This data object type describes a port (or range of ports),
// identified by port number(s), direction and protocol.  It is
// used as a convenient way for users to express what ports they
// want to permit through the firewall.
//
//
type HostFirewallRule struct {
	*DynamicData

	// The port direction.
	Direction *enum.HostFirewallRuleDirection

	// For a port range, the ending port number.
	EndPort int32

	// The port number.
	Port int32

	// The port type.
	//
	// Since vSphere API 5.0
	PortType *enum.HostFirewallRulePortType

	// The port protocol.  Valid values are defined by the
	// HostFirewallRuleProtocol enumeration.
	Protocol string
}

//
// Enumeration of port directions.
//
//
type HostFirewallRuleDirection struct {
}

//
// Enumeration of port types.
//
//
type HostFirewallRulePortType struct {
}

//
// Set of valid port protocols.
//
//
type HostFirewallRuleProtocol struct {
}

//
// Data object that describes a single network ruleset that can be
// allowed or blocked by the firewall using the HostFirewallSystem object.
//
//
type HostFirewallRuleset struct {
	*DynamicData

	// List of ipaddress to allow access to the service
	//
	// Since vSphere API 5.0
	AllowedHosts *HostFirewallRulesetIpList

	// Flag indicating whether the ruleset is enabled.  If the
	// ruleset is enabled, all ports specified in the ruleset are
	// opened by the firewall.
	Enabled bool

	// Brief identifier for the ruleset.
	Key string

	// Display label for the ruleset.
	Label string

	// Flag indicating whether the ruleset is required and cannot be disabled.
	Required bool

	// List of rules within the ruleset.
	Rule []*HostFirewallRule

	// Managed service (if any) that uses this ruleset. Must be one of
	// the services listed in service.
	Service string
}

type HostFirewallRulesetIpList struct {
	*DynamicData

	// Flag indicating whether the ruleset works for all ip addresses.
	AllIp bool

	// The list of ipAddresses.
	// All IPv4 addresses are specified as strings using dotted
	// decimal format. For example, "192.0.20.10".
	// IPv6 addresses are 128-bit addresses represented
	// as eight fields of up to four hexadecimal digits. A colon separates each
	// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
	// also consist of  symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress []string

	// The list of networks
	IpNetwork []*HostFirewallRulesetIpNetwork
}

type HostFirewallRulesetIpNetwork struct {
	*DynamicData

	// The IPv4 or IPv6 network.
	// All IPv4 subnet addresses are specified as strings using dotted
	// decimal format. For example, "192.0.20.0".
	// IPv6 addresses are 128-bit addresses represented
	// as eight fields of up to four hexadecimal digits. A colon separates each
	// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
	// also consist of  symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	Network string

	// The prefix length for the network.
	// For example the prefix length for a network 10.20.120/22 is 22
	PrefixLength int32
}

//
// The ruleset update specification.
//
//
type HostFirewallRulesetRulesetSpec struct {
	*DynamicData

	// The list of allowed ip addresses
	AllowedHosts *HostFirewallRulesetIpList
}

//
// The FirewallSystem managed object describes the firewall configuration
// of the host.
//
// The firewall should be configured first by setting the default policy and
// then by making exceptions to the policy to get the desired openness.
//
//
//
type HostFirewallSystem struct {
	*ExtensibleManagedObject

	firewallInfo *HostFirewallInfo
}

// Firewall configuration.
func (mo *HostFirewallSystem) FirewallInfo() (*HostFirewallInfo, error) {
	t, err := mo.currentProperty("firewallInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostFirewallInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostFirewallInfo")
	}
	return v, nil
}

//
// Blocks the firewall ports belonging to the specified ruleset.
// If the ruleset has a managed service with a policy of 'auto'
// and all other rulesets used by the service are blocked, stops
// the service.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostFirewallSystem) DisableRuleset(
	_this *ManagedObjectReference, id string,
) error {

	return nil

}

//
// Opens the firewall ports belonging to the specified ruleset.
// If the ruleset has a managed service with a policy of 'auto'
// that is not running, starts the service.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostFirewallSystem) EnableRuleset(
	_this *ManagedObjectReference, id string,
) error {

	return nil

}

//
// Refresh the firewall information and settings to pick up any changes
// made directly on the host.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostFirewallSystem) RefreshFirewall(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Updates the default firewall policy; unset fields are left unchanged.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostFirewallSystem) UpdateDefaultPolicy(
	_this *ManagedObjectReference, defaultPolicy *HostFirewallDefaultPolicy,
) error {

	return nil

}

//
// Update the firewall ruleset specification.
//
// Required Privileges
// Host.Config.NetService
// Since
// vSphere API 5.0
//
func (mo *HostFirewallSystem) UpdateRuleset(
	_this *ManagedObjectReference, id string, spec *HostFirewallRulesetRulesetSpec,
) error {

	return nil

}

//
// The HostFirmwareSystem managed object type provides access to the firmware
// of an embedded ESX host. It provides operations to backup, restore, and reset the
// configuration of an embedded ESX host.
//
type HostFirmwareSystem struct {
	*ManagedObject
}

//
// Backup the configuration of the host.
//
// The method generates a bundle containing the host configuration.
// You can use an HTTP GET operation to download the bundle from the returned URL.
//
//
// Required Privileges
// Host.Config.Firmware
//
func (mo *HostFirmwareSystem) BackupFirmwareConfiguration(
	_this *ManagedObjectReference,
) (string, error) {

	return "", nil

}

//
// Return the URL on the host to which the configuration bundle must be
// uploaded for a restore operation.
// See RestoreFirmwareConfiguration.
//
// Required Privileges
// Host.Config.Firmware
//
func (mo *HostFirmwareSystem) QueryFirmwareConfigUploadURL(
	_this *ManagedObjectReference,
) (string, error) {

	return "", nil

}

//
// Reset the configuration to factory defaults.
//
// This method will reset all configuration options, including the "admin"
// password, to the factory defaults. The host will be rebooted immediately.
// The host needs to be in maintenance mode before this operation can be
// performed.
//
//
// Required Privileges
// Host.Config.Firmware
//
func (mo *HostFirmwareSystem) ResetFirmwareToFactoryDefaults(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Restore the configuration of the host to that specified in the bundle.
//
// Upload the bundle to the URL returned by the
// QueryFirmwareConfigUploadURL method.
// The RestoreFirmwareConfiguration method
// will restore all configuration options,
// including the "admin" password, to the values in the bundle.
// The host will be rebooted immediately.
// The host must be in maintenance mode before this operation can be
// performed.
//
//
// Required Privileges
// Host.Config.Firmware
//
func (mo *HostFirmwareSystem) RestoreFirmwareConfiguration(
	_this *ManagedObjectReference, force bool,
) error {

	return nil

}

//
// The FlagInfo data object type encapsulates the flag settings for a host.
// These properties are optional since the same structure is used to change
// the values during an edit or create operation.
//
//
type HostFlagInfo struct {
	*DynamicData

	// Flag to specify whether background snapshots are enabled.
	BackgroundSnapshotsEnabled bool
}

//
// When the system detects a copy of a VmfsVolume, it will not be
// auto-mounted on the host and it will be detected as
// 'UnresolvedVmfsVolume'.
// If user decides to keep the original Uuid and mount it on the host,
// it will have 'forceMounted' flag and 'forceMountedInfo' set.
// 'ForceMountedInfo' provides additional information specific to
// user-mounted VmfsVolume.
//
//
type HostForceMountedInfo struct {
	*DynamicData

	// Indicates if the volume is currently mounted on the host
	Mounted bool

	// Indicates if the vmfsExtent information persistent across
	// host reboots.
	Persist bool
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that hostname -s failed or returned a name containing '.'.
//
//
type HostGetShortNameFailedEvent struct {
	*HostEvent
}

//
// This data object type describes information about a single
// graphics device.
//
//
type HostGraphicsInfo struct {
	*DynamicData

	// The device name.
	DeviceName string

	// Graphics type (@see GraphicsType).
	GraphicsType string

	// Memory capacity of graphics device or zero if not available.
	MemorySizeInKB int64

	// PCI ID of this device composed of "bus:slot.function".
	PciId string

	// The vendor name.
	VendorName string

	// Virtual machines using this graphics device.
	Vm []*VirtualMachine
}

//
// Possible values for graphics type.
//
//
type HostGraphicsInfoGraphicsType struct {
}

//
// This managed object manages the graphics state of the host.
//
type HostGraphicsManager struct {
	*ExtensibleManagedObject

	graphicsInfo []*HostGraphicsInfo
}

// Array of graphics information
// Required Privilege: System.Read
func (mo *HostGraphicsManager) GraphicsInfo() ([]*HostGraphicsInfo, error) {
	t, err := mo.currentProperty("graphicsInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*HostGraphicsInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*HostGraphicsInfo")
	}
	return v, nil
}

//
// Indicate if shared graphics device is active on the host.
//
// Required Privileges
// System.Read
//
func (mo *HostGraphicsManager) IsSharedGraphicsActive(
	_this *ManagedObjectReference,
) (bool, error) {

	return false, nil

}

//
// Refresh the available graphics information.
//
// Required Privileges
// Host.Config.Settings
//
func (mo *HostGraphicsManager) RefreshGraphicsManager(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Data object describing the operational status of a physical
// element.
//
//
type HostHardwareElementInfo struct {
	*DynamicData

	// The name of the physical element
	Name string

	// The operational status of the physical element. The status is one of
	// the values specified in HostHardwareElementStatus.See HostHardwareElementStatus
	Status *ElementDescription
}

//
// The current status of the hardware
//
//
type HostHardwareElementStatus struct {
}

//
// The HardwareInfo data object type describes the hardware
// configuration of the host.
//
//
type HostHardwareInfo struct {
	*DynamicData

	// Information about the system BIOS
	//
	// Since VI API 2.5
	BiosInfo *HostBIOSInfo

	// CPU feature set that is supported by the hardware. This is the
	// intersection of the feature sets supported by the individual CPU
	// packages. This feature set is modified by the
	// supportedCpuFeature
	// array in the host capabilities to obtain the feature set supported by
	// the virtualization platform.
	CpuFeature []*HostCpuIdInfo

	// Overall CPU information.
	CpuInfo *HostCpuInfo

	// Information about each of the physical CPU packages on the host.
	CpuPkg []*HostCpuPackage

	// Since vSphere API 4.0
	CpuPowerManagementInfo *HostCpuPowerManagementInfo

	// Total amount of physical memory on the host in bytes.
	MemorySize int64

	// Information about the NUMA (non-uniform memory access).
	NumaInfo *HostNumaInfo

	// The list of Peripheral Component Interconnect (PCI) devices
	// available on this host.
	PciDevice []*HostPciDevice

	// Information about reliable memory.
	//
	// Since vSphere API 5.5
	ReliableMemoryInfo *HostReliableMemoryInfo

	// Presence of System Management Controller, indicates the host is
	// Apple hardware, and thus capable of running Mac OS guest as VM.
	//
	// Since vSphere API 5.0
	SmcPresent bool

	// Information about the system as a whole.
	SystemInfo *HostSystemInfo
}

//
// Data object representing the status of the
// hardware components of the host.
//
//
type HostHardwareStatusInfo struct {
	*DynamicData

	// Status of the CPU packages
	CpuStatusInfo []*HostHardwareElementInfo

	// Status of the physical memory
	MemoryStatusInfo []*HostHardwareElementInfo

	// Status of the physical storage system
	StorageStatusInfo []*HostStorageElementInfo
}

//
// This data object type summarizes hardware used by the host.
//
//
type HostHardwareSummary struct {
	*DynamicData

	// The speed of the CPU cores. This is an average value if there are multiple
	// speeds. The product of cpuMhz and numCpuCores is approximately equal to the
	// sum of the MHz for all the individual cores on the host.
	CpuMhz int32

	// The CPU model.
	CpuModel string

	// The physical memory size in bytes.
	MemorySize int64

	// The system model identification.
	Model string

	// Number of physical CPU cores on the host. Physical CPU cores are the
	// processors contained by a CPU package.
	NumCpuCores int16

	// Number of physical CPU packages on the host. Physical CPU packages are chips
	// that contain one or more processors. Processors contained by a package are
	// also known as CPU cores. For example, one dual-core package is comprised of
	// one chip that contains two CPU cores.
	NumCpuPkgs int16

	// Number of physical CPU threads on the host.
	NumCpuThreads int16

	// The number of host bus adapters (HBAs).
	NumHBAs int32

	// The number of network adapters.
	NumNics int32

	// Other identification information. This information may be vendor
	// specific.
	//
	// Since VI API 2.5
	OtherIdentifyingInfo []*HostSystemIdentificationInfo

	// The hardware BIOS identification.
	Uuid string

	// The hardware vendor identification.
	Vendor string
}

//
// This managed object manages the health state of the host.
//
type HostHealthStatusSystem struct {
	*ManagedObject

	runtime *HealthSystemRuntime
}

func (mo *HostHealthStatusSystem) Runtime() (*HealthSystemRuntime, error) {
	t, err := mo.currentProperty("runtime")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HealthSystemRuntime)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HealthSystemRuntime")
	}
	return v, nil
}

//
// Refresh the available runtime hardware health information.
//
// Required Privileges
// System.Read
//
func (mo *HostHealthStatusSystem) RefreshHealthStatusSystem(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Resets the state of the sensors of the IPMI subsystem. On certain types
// of hardware IPMI sensor states latch onto unhealthy states and will stay
// in an unhealth state until the sensor state is reset. This method will
// explicitly reset the sensors state.
//
// Required Privileges
// Host.Config.Settings
//
func (mo *HostHealthStatusSystem) ResetSystemHealthInfo(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// This data object type describes the bus adapter for
// the host. A host bus adapter (HBA) is a hardware
// or software adapter that connects the host to storage devices.
//
//
type HostHostBusAdapter struct {
	*DynamicData

	// The host bus number.
	Bus int32

	// The device name of host bus adapter.
	Device string

	// The name of the driver.
	Driver string

	// The linkable identifier.
	Key string

	// The model name of the host bus adapter.
	Model string

	// The Peripheral Connect Interface (PCI) ID of the device
	// representing the host bus adapter.
	Pci string

	// The operational status of the adapter.  Valid values include "online",
	// "offline", "unbound", and "unknown".
	Status string
}

//
// This data object type describes the CpuSchedulerSystem configuration
// for optimizing hyperthreading.  The primary hyperthreading
// optimization employed by the CpuSchedulerSystem is to utilize
// hyperthreads as additional schedulable resources.  Although
// hyperthreads provide limited additional concurrency,
// certain workloads (such as idling) can take advantage of
// these hyperthreads.  This is particularly useful for SMP virtual
// machines that use gang scheduling.  (Gang scheduling refers to a
// situation in which all of a parallel program's tasks are grouped
// into a "gang" and concurrently scheduled on distinct
// processors of a parallel computer system.)
//
// Changes to the hyperthreading optimization can take effect only
// after a system restart.  Therefore, while it is possible to change
// the configuration at any time, the change will take effect only
// on the next boot.
//
//
//
type HostHyperThreadScheduleInfo struct {
	*DynamicData

	// The flag to indicate whether or not the CPU scheduler is
	// currently treating
	// hyperthreads as schedulable resources.  Setting this property
	// involves a successful invocation of either the
	// enableHyperThreading() method ("true") or the
	// disableHyperthreading() method
	// ("false").  The property is set once the system is rebooted.
	Active bool

	// The flag to indicate whether or not hyperthreading
	// optimization is available on the system.  This property
	// is set by VMware prior to installation.
	Available bool

	// The flag to indicate whether or not the CPU scheduler
	// should treat hyperthreads as
	// schedulable resources the next time the CPU scheduler starts.
	//
	//
	//
	// This property is set to "true" by successfully invoking the
	// enableHyperThreading() method.
	// This property is set to "false" by successfully invoking the
	// disableHyperthreading() method.
	Config bool
}

//
// Acceptance level definitions
//
//
type HostImageAcceptanceLevel struct {
}

//
// This managed object is the interface for
// configuration of the ESX software image, including
// properties such as acceptance level.
// It is currently designed to be host agent specific.
//
type HostImageConfigManager struct {
	*ManagedObject
}

//
// Queries the current host acceptance level setting.See HostImageAcceptanceLevel
//
// Required Privileges
// System.Read
//
func (mo *HostImageConfigManager) HostImageConfigGetAcceptance(
	_this *ManagedObjectReference,
) (string, error) {

	return "", nil

}

//
// Queries the current host image profile information.See HostImageProfileSummary
//
// Required Privileges
// System.Read
//
func (mo *HostImageConfigManager) HostImageConfigGetProfile(
	_this *ManagedObjectReference,
) (*HostImageProfileSummary, error) {

	return nil, nil

}

//
// Sets the acceptance level of the host image profile.See HostImageAcceptanceLevel
//
// Required Privileges
// Host.Config.Image
//
func (mo *HostImageConfigManager) UpdateHostImageAcceptanceLevel(
	_this *ManagedObjectReference, newAcceptanceLevel string,
) error {

	return nil

}

//
// Summary of an image profile
//
//
type HostImageProfileSummary struct {
	*DynamicData

	// The name of the image profile
	Name string

	// The organization publishing the image profile.
	Vendor string
}

//
// Host is booted in audit mode.
//
//
type HostInAuditModeEvent struct {
	*HostEvent
}

//
// Fault indicating that an operation cannot be performed while
// the host is part of a Windows domain.
//
//
type HostInDomain struct {
	*HostConfigFault
}

//
// This fault is thrown when an attempt is made to configure a fault tolerant
// virtual machine on a host that is incompatible.
//
//
type HostIncompatibleForFaultTolerance struct {
	*VmFaultToleranceIssue

	HostName string

	// The specific reason why the host does not support fault tolerance.
	// Values should come from HostIncompatibleForFaultToleranceReason.
	Reason string
}

//
// Reasons why fault tolerance is not supported on the host.
//
//
type HostIncompatibleForFaultToleranceReason struct {
}

//
// This fault is thrown when an attempt is made record or replay
// a virtual machine on a host that is incompatible.
//
//
type HostIncompatibleForRecordReplay struct {
	*VimFault

	HostName string

	// The specific reason why the host does not support record/replay.
	// Values should come from HostIncompatibleForRecordReplayReason.
	Reason string
}

//
// Reasons why record/replay is not supported on a host.
//
//
type HostIncompatibleForRecordReplayReason struct {
}

//
// This data object type describes the iSCSI host bus adapter
// interface.
//
//
type HostInternetScsiHba struct {
	*HostHostBusAdapter

	// A list of the current options settings for the host bus adapter.
	//
	// Since vSphere API 4.0
	AdvancedOptions []*HostInternetScsiHbaParamValue

	// The authentication capabilities for this host bus adapter.
	AuthenticationCapabilities *HostInternetScsiHbaAuthenticationCapabilities

	// The authentication settings for this host bus adapter.
	// All static and discovery targets will inherit the use of these
	// settings unless their authentication settings are explicitly set.
	AuthenticationProperties *HostInternetScsiHbaAuthenticationProperties

	// Can this adapter be disabled
	//
	// Since vSphere API 5.0
	CanBeDisabled bool

	// The configured iSCSI send target entries.
	ConfiguredSendTarget []*HostInternetScsiHbaSendTarget

	// The configured iSCSI static target entries.
	ConfiguredStaticTarget []*HostInternetScsiHbaStaticTarget

	// The Current operating link speed of the port in megabits per second.
	CurrentSpeedMb int32

	// The authentication capabilities for this host bus adapter.
	//
	// Since vSphere API 4.0
	DigestCapabilities *HostInternetScsiHbaDigestCapabilities

	// The digest settings for this host bus adapter.
	// All static and discovery targets will inherit the use of these
	// properties unless their digest settings are explicitly set.
	//
	// Since vSphere API 4.0
	DigestProperties *HostInternetScsiHbaDigestProperties

	// The discovery capabilities for this host bus adapter.
	DiscoveryCapabilities *HostInternetScsiHbaDiscoveryCapabilities

	// The discovery settings for this host bus adapter.
	DiscoveryProperties *HostInternetScsiHbaDiscoveryProperties

	// The IP capabilities for this host bus adapter.
	IpCapabilities *HostInternetScsiHbaIPCapabilities

	// The IP settings for this host bus adapter.
	IpProperties *HostInternetScsiHbaIPProperties

	// The iSCSI alias of this host bus adapter.
	IScsiAlias string

	// The iSCSI name of this host bus adapter.
	IScsiName string

	// True if this host bus adapter is a software based initiator
	// utilizing the hosting system's existing TCP/IP network connection
	IsSoftwareBased bool

	// The maximum supported link speed of the port in megabits per second.
	MaxSpeedMb int32

	// Specifies if this iSCSI Adapter requires a bound network
	// interface to function.
	//
	// Since vSphere API 5.0
	NetworkBindingSupport *enum.HostInternetScsiHbaNetworkBindingSupportType

	// A list of supported key/value pair advanced options for the
	// host bus adapter including their type information.
	//
	// Since vSphere API 4.0
	SupportedAdvancedOptions []*OptionDef
}

//
// The authentication capabilities for this host bus adapter.
//
//
type HostInternetScsiHbaAuthenticationCapabilities struct {
	*DynamicData

	// True if this host bus adapter supports changing the configuration
	// state of CHAP authentication.  CHAP is mandatory, however some
	// adapter may not allow disabling this authentication method.
	ChapAuthSettable bool

	// Always false in this version of the API.
	Krb5AuthSettable bool

	// When chapAuthSettable is TRUE, this describes if Mutual CHAP
	// configuration is allowed as well.
	//
	// Since vSphere API 4.0
	MutualChapSettable bool

	// Always false in this version of the API.
	SpkmAuthSettable bool

	// Always false in this version of the API.
	SrpAuthSettable bool

	// When targetChapSettable is TRUE, this describes if
	// CHAP configuration is allowed on targets associated
	// with the adapter.
	//
	// Since vSphere API 4.0
	TargetChapSettable bool

	// When targetMutualChapSettable is TRUE, this describes if
	// Mutual CHAP configuration is allowed on targets associated
	// with the adapter.
	//
	// Since vSphere API 4.0
	TargetMutualChapSettable bool
}

//
// The authentication settings for this host bus adapter or target.
//
//
type HostInternetScsiHbaAuthenticationProperties struct {
	*DynamicData

	// True if CHAP is currently enabled
	ChapAuthEnabled bool

	// The preference for CHAP or non-CHAP protocol if CHAP is enabled
	//
	// Since vSphere API 4.0
	ChapAuthenticationType string

	// CHAP settings are inherited
	//
	// Since vSphere API 4.0
	ChapInherited bool

	// The CHAP user name if enabled
	ChapName string

	// The CHAP secret if enabled
	ChapSecret string

	// The preference for CHAP or non-CHAP protocol if CHAP is enabled
	//
	// Since vSphere API 4.0
	MutualChapAuthenticationType string

	// Mutual-CHAP settings are inherited
	//
	// Since vSphere API 4.0
	MutualChapInherited bool

	// When Mutual-CHAP is enabled, the user name that target needs to
	// use to authenticate with the initiator
	//
	// Since vSphere API 4.0
	MutualChapName string

	// When Mutual-CHAP is enabled, the secret that target needs to
	// use to authenticate with the initiator
	//
	// Since vSphere API 4.0
	MutualChapSecret string
}

//
// The type of CHAP authentication setting to use.
// prohibited  : do not use CHAP.
// preferred   : use CHAP if successfully negotiated,
// but allow non-CHAP connections as fallback
// discouraged : use non-CHAP, but allow CHAP connectsion as fallback
// required    : use CHAP for connection strictly, and fail if CHAP
// negotiation fails.
//
// Defaults to preferred on first configuration if unspecified.
//
//
type HostInternetScsiHbaChapAuthenticationType struct {
}

//
// The digest capabilities for this host bus adapter.
//
//
type HostInternetScsiHbaDigestCapabilities struct {
	*DynamicData

	// True if this host bus adapter supports the configuration
	// of the use of data digest. Defaults to false, in which
	// case no data digests will be used.
	DataDigestSettable bool

	// True if this host bus adapter supports the configuration
	// of the use of header digest. Defaults to false, in which
	// case no header digests will be used.
	HeaderDigestSettable bool

	// True if configuration of the use of data digest is supported
	// on the targets associated with the host bus adapter. Defaults to
	// false, in which case no data digests will be used.
	TargetDataDigestSettable bool

	// True if configuration of the use of header digest is supported
	// on the targets associated with the host bus adapter. Defaults to
	// false, in which case no header digests will be used.
	TargetHeaderDigestSettable bool
}

//
// The digest settings for this host bus adapter.
//
//
type HostInternetScsiHbaDigestProperties struct {
	*DynamicData

	// Data digest setting is inherited
	DataDigestInherited bool

	// The data digest preference if data digest is enabled
	DataDigestType string

	// Header digest setting is inherited
	HeaderDigestInherited bool

	// The header digest preference if header digest is enabled
	HeaderDigestType string
}

//
// The type of integrity checks to use. The digest setting for header
// and data traffic can be separately configured.
// prohibited  : do not use digest.
// preferred   : use digest if successfully negotiated, but skip the use
// of digest otherwise.
// discouraged : do not use digest if target allows, otherwise use digest.
// required    : use digest strictly, and fail if target does not support
// digest.
//
// Defaults to preferred on first configuration if unspecified.
//
//
type HostInternetScsiHbaDigestType struct {
}

//
// The discovery capabilities for this host bus adapter.
// At least one discovery mode must always be active.
// Multiple modes may be active at the same time.
//
//
type HostInternetScsiHbaDiscoveryCapabilities struct {
	*DynamicData

	// True if this host bus adapter supports iSNS
	ISnsDiscoverySettable bool

	// True if this host bus adapter supports changing the configuration
	// state of send targets discovery.  Send targets is mandatory, however
	// some adapters may not allow disabling this discovery method.
	SendTargetsDiscoverySettable bool

	// True if this host bus adapter supports SLP
	SlpDiscoverySettable bool

	// True if this host bus adapter supports static discovery
	StaticTargetDiscoverySettable bool
}

//
// The discovery settings for this host bus adapter.
// At least one discovery mode must always be active.
// Multiple modes may be active at the same time.
//
//
type HostInternetScsiHbaDiscoveryProperties struct {
	*DynamicData

	// True if iSNS is currently enabled
	ISnsDiscoveryEnabled bool

	// The iSNS discovery method in use when iSNS is enabled.
	// Must be one of the values of
	// InternetScsiSnsDiscoveryMethod
	ISnsDiscoveryMethod string

	// For STATIC iSNS, this is the iSNS server address
	ISnsHost string

	// True if send targets discovery is enabled
	SendTargetsDiscoveryEnabled bool

	// True if SLP is enabled
	SlpDiscoveryEnabled bool

	// The current SLP discovery method when SLP is enabled.
	// Must be one of the values of
	// SlpDiscoveryMethod
	SlpDiscoveryMethod string

	// When the SLP discovery method is set to MANUAL, this property
	// reflects the hostname, and optionally port number of the SLP DA.
	SlpHost string

	// True if static target discovery is enabled
	StaticTargetDiscoveryEnabled bool
}

//
// The IP Capabilities for the host bus adapter
//
//
type HostInternetScsiHbaIPCapabilities struct {
	*DynamicData

	// True if the host bus adapter supports setting its IP address.
	AddressSettable bool

	// True if the host bus adapter supports setting its secondary DNS.
	AlternateDnsServerAddressSettable bool

	// True if the host bus adapter supports setting its ARP Redirect value
	//
	// Since vSphere API 4.0
	ArpRedirectSettable bool

	// True if the host bus adapter supports setting its gateway.
	DefaultGatewaySettable bool

	// True if the discovery and static targets can be configured with
	// a host name as opposed to an IP address.
	//
	// Since vSphere API 4.0
	HostNameAsTargetAddress bool

	// True if the host bus adapter supports DHCP.
	IpConfigurationMethodSettable bool

	// True if the host bus adapter supports the use of IPv6 addresses
	//
	// Since vSphere API 4.0
	Ipv6Supported bool

	// True if the host bus adapter supports setting its MTU, (for Jumbo
	// Frames, etc)
	//
	// Since vSphere API 4.0
	MtuSettable bool

	// True if the host bus adapter supports setting its name and alias
	//
	// Since vSphere API 4.1
	NameAliasSettable bool

	// True if the host bus adapter supports setting its primary DNS.
	PrimaryDnsServerAddressSettable bool

	// True if the host bus adapter supports setting its subnet mask.
	SubnetMaskSettable bool
}

//
// The IP properties for the host bus adapter
//
//
type HostInternetScsiHbaIPProperties struct {
	*DynamicData

	// The current IPv4 address.
	Address string

	// The current secondary DNS address.
	AlternateDnsServerAddress string

	// True if ARP Redirect is enabled
	//
	// Since vSphere API 4.0
	ArpRedirectEnabled bool

	// The current IPv4 gateway.
	DefaultGateway string

	// True if the host bus adapter fetches its IP using DHCP.
	DhcpConfigurationEnabled bool

	// The current IPv6 address.
	//
	// Since vSphere API 4.0
	Ipv6Address string

	// The current IPv6 default gateway.
	//
	// Since vSphere API 4.0
	Ipv6DefaultGateway string

	// The current IPv6 subnet mask.
	//
	// Since vSphere API 4.0
	Ipv6SubnetMask string

	// Since vSphere API 4.0
	JumboFramesEnabled bool

	// The MAC address.
	Mac string

	// True if the host bus adapter supports setting its MTU, (for Jumbo
	// Frames, etc)
	// Setting enableJumboFrames and not a numeric mtu value implies
	// autoselection of appropriate MTU value for Jumbo Frames.
	//
	// Since vSphere API 4.0
	Mtu int32

	// The current primary DNS address.
	PrimaryDnsServerAddress string

	// The current IPv4 subnet mask.
	SubnetMask string
}

//
// The binding mode of the adapter.
//
//
type HostInternetScsiHbaNetworkBindingSupportType struct {
}

//
// Describes the the value of an iSCSI parameter, and whether
// the value is being inherited.
//
//
type HostInternetScsiHbaParamValue struct {
	*OptionValue

	// Indicates if the value is inherited from some other source.
	//
	// If unset, the value is not inheritable.
	// isInherited can be modified only if it has already been set.
	//
	// If value is to being modified, isInherited should be set to true.
	// Setting isInherited to false will result in the value being
	// once again inherited from the source.
	IsInherited bool
}

//
// The iSCSI send target.
//
//
type HostInternetScsiHbaSendTarget struct {
	*DynamicData

	// The IP address or hostname of the storage device.
	Address string

	// A list of the current options settings for the host bus adapter.
	//
	// Since vSphere API 4.0
	AdvancedOptions []*HostInternetScsiHbaParamValue

	// The authentication settings for this discovery target.
	// All static targets discovered via this target will inherit the
	// use of these settings unless the static target's authentication
	// settings are explicitly set.
	//
	// Since vSphere API 4.0
	AuthenticationProperties *HostInternetScsiHbaAuthenticationProperties

	// The digest settings for this discovery target.
	// All static targets discovered via this target will inherit the
	// use of these settings unless the static target's digest
	// settings are explicitly set.
	//
	// Since vSphere API 4.0
	DigestProperties *HostInternetScsiHbaDigestProperties

	// The device name of the host bus adapter from which settings
	// can be inherited.
	//
	// Since vSphere API 4.0
	Parent string

	// The TCP port of the storage device.
	// If not specified, the standard default of 3260 is used.
	Port int32

	// A list of supported key/value pair advanced options for the
	// host bus adapter including their type information.
	//
	// Since vSphere API 4.0
	SupportedAdvancedOptions []*OptionDef
}

//
// The iSCSI static target.
//
//
type HostInternetScsiHbaStaticTarget struct {
	*DynamicData

	// The IP address or hostname of the storage device.
	Address string

	// A list of the current options settings for the host bus adapter.
	//
	// Since vSphere API 4.0
	AdvancedOptions []*HostInternetScsiHbaParamValue

	// The authentication settings for this target.
	//
	// Since vSphere API 4.0
	AuthenticationProperties *HostInternetScsiHbaAuthenticationProperties

	// The digest settings for this target.
	//
	// Since vSphere API 4.0
	DigestProperties *HostInternetScsiHbaDigestProperties

	// Discovery method
	// each static target is discovered by some method
	// define in TargetDiscoveryMethod.
	//
	// Since vSphere API 5.1
	DiscoveryMethod string

	// The iSCSI name of the storage device.
	IScsiName string

	// The parent entity from which settings can be inherited. It can either
	// be unset, or set to the device name of the host bus adapter or the
	// name of the SendTarget.
	//
	// Since vSphere API 4.0
	Parent string

	// The TCP port of the storage device.
	// If not specified, the standard default of 3260 is used.
	Port int32

	// A list of supported key/value pair advanced options for the
	// host bus adapter including their type information.
	//
	// Since vSphere API 4.0
	SupportedAdvancedOptions []*OptionDef
}

//
// The method of discovery of an iScsi target.
// staticMethod: static discovery
// sendTargetsMethod: sendtarget discovery
// slpMethod: Service Location Protocol discovery
// isnsMethod: Internet Storage Name Service discovery
// unknownMethod: discovery method not identified by iscsi stack
//
//
type HostInternetScsiHbaStaticTargetTargetDiscoveryMethod struct {
}

//
// A collection of one or more static targets or discovery addresses.
// At least one of the arrays must be non-empty.
//
//
type HostInternetScsiHbaTargetSet struct {
	*DynamicData

	SendTargets []*HostInternetScsiHbaSendTarget

	StaticTargets []*HostInternetScsiHbaStaticTarget
}

//
// Internet SCSI transport information about a SCSI target.
//
//
type HostInternetScsiTargetTransport struct {
	*HostTargetTransport

	// The IP addresses through which the target may be reached.
	Address []string

	// The iSCSI alias of the target.
	IScsiAlias string

	// The iSCSI name of the target.
	IScsiName string
}

//
// A HostInventoryFull is thrown if the inventory has reach the max capacity of hosts.
//
//
type HostInventoryFull struct {
	*NotEnoughLicenses

	Capacity int32
}

//
// This event records if the inventory of hosts has reached capacity.
//
//
type HostInventoryFullEvent struct {
	*LicenseEvent

	Capacity int32
}

//
// Event indicating that the virtual machine inventory
// file on the host is damaged or unreadable.
//
//
type HostInventoryUnreadableEvent struct {
	*Event
}

//
// This event records a change in host IP address.
//
//
type HostIpChangedEvent struct {
	*HostEvent

	// New IP address of the host.
	NewIP string

	// Old IP address of the host.
	OldIP string
}

//
// The IP configuration.
//
//
type HostIpConfig struct {
	*DynamicData

	// The flag to indicate whether or not DHCP (dynamic host
	// control protocol) is enabled.  If this property is set to true,
	// the ipAddress and the subnetMask strings cannot be set explicitly.
	Dhcp bool

	// The IP address currently used by the network adapter.
	// All IP addresses are specified using IPv4 dot notation.
	// For example, "192.168.0.1". Subnet addresses and netmasks are
	// specified using the same notation.
	//
	// Note: When DHCP is enabled, this property reflects the
	// current IP configuration and cannot be set.  When DHCP is not
	// enabled, this property can be set explicitly.
	IpAddress string

	// The ipv6 configuration
	//
	// Since vSphere API 4.0
	IpV6Config *HostIpConfigIpV6AddressConfiguration

	// The subnet mask.
	//
	// Note: When DHCP is not enabled, this property can be
	// set explicitly.  When DHCP is enabled, this property reflects the
	// current IP configuration and cannot be set.
	SubnetMask string
}

//
// The ipv6 address specification
//
//
type HostIpConfigIpV6Address struct {
	*DynamicData

	// The state of this ipAddress. Can be one of
	// HostIpConfigIpV6AddressStatus
	DadState string

	// The ipv6 address. When DHCP is enabled, this property
	// reflects the current IP configuration and cannot be set.
	IpAddress string

	// The time when will this address expire. If not set
	// the address lifetime is unlimited.
	Lifetime time.Time

	// Valid values are "add" and "remove".
	// See HostConfigChangeOperation.
	Operation string

	// The type of the ipv6 address configuration on the interface.
	// This can be one of the types defined my the enum
	// HostIpConfigIpV6AddressConfigType.
	Origin string

	// The prefix length. An ipv6 prefixLength is a decimal value that indicates
	// the number of contiguous, higher-order bits of the address that make up the
	// network portion of the address.
	// For example, 10FA:6604:8136:6502::/64 is a possible IPv6 prefix. The prefix
	// length in this case is 64.
	PrefixLength int32
}

//
// This specifies how the ipv6 address is configured for the interface.
// We follow rfc4293 in defining the values for the configType.
//
//
type HostIpConfigIpV6AddressConfigType struct {
}

//
// The ipv6 address configuration
//
//
type HostIpConfigIpV6AddressConfiguration struct {
	*DynamicData

	// Specify if IPv6 address and routing information information
	// be enabled or not as per RFC 2462.
	AutoConfigurationEnabled bool

	// The flag to indicate whether or not DHCP (dynamic host
	// control protocol) is enabled to obtain an ipV6 address.
	// If this property is set to true, an ipV6 address is configured through dhcpV6.
	DhcpV6Enabled bool

	// Ipv6 adrresses configured on the interface. The global addresses can be configured
	// through DHCP, stateless or manual configuration. Link local addresses can be
	// only configured with the origin set to
	// other.
	IpV6Address []*HostIpConfigIpV6Address
}

type HostIpConfigIpV6AddressStatus struct {
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that the IP address resolution returned different
// addresses on the host.  Please check your host's network configuration.
//
//
type HostIpInconsistentEvent struct {
	*HostEvent

	IpAddress string

	IpAddress2 string
}

//
// IP Route Configuration.  All IPv4 addresses, subnet addresses, and
// netmasks are specified as strings using dotted decimal notation.
// For example, "192.0.2.1".
// IPv6 addresses are 128-bit addresses represented
// as eight fields of up to four hexadecimal digits. A colon separates each
// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
// also consist of  symbol '::' to represent multiple 16-bit groups of
// contiguous 0's only once in an address as described in RFC 2373.
//
//
type HostIpRouteConfig struct {
	*DynamicData

	// The default gateway address.
	DefaultGateway string

	// The gateway device. This applies to service console gateway only, it
	// is ignored otherwise.
	GatewayDevice string

	// The default ipv6 gateway address
	//
	// Since vSphere API 4.0
	IpV6DefaultGateway string

	// The ipv6 gateway device. This applies to service console gateway only, it
	//
	// Since vSphere API 4.0
	IpV6GatewayDevice string
}

//
// Dataobject specifying the configuration for IpRoute
//
//
type HostIpRouteConfigSpec struct {
	*HostIpRouteConfig

	// Choose a gateway device based on what the VirtualNic is connected to.
	// This applies to service console gateway only, it
	// is ignored otherwise.
	GatewayDeviceConnection *HostVirtualNicConnection

	// The ipv6 gateway device based on what the VirtualNic is connected to.
	// This applies to service console gateway only, it
	// is ignored otherwise.
	IpV6GatewayDeviceConnection *HostVirtualNicConnection
}

//
// IpRouteEntry.  Routing entries are individual static routes which combined
// with the default route form all of the routing rules for a host.
//
//
type HostIpRouteEntry struct {
	*DynamicData

	// If available the property indicates the device associated with the
	// routing entry. This property can only be read from the server.
	// It will be ignored if set by the client.
	//
	// Since vSphere API 4.1
	DeviceName string

	// Gateway for the routing entry
	Gateway string

	// Network of the routing entry
	// Of the format "10.20.120.0" or "2001:db8::1428:57"
	Network string

	// Prefix length of the network (this is the 22 in 10.20.120.0/22)
	PrefixLength int32
}

//
// Routing Entry Operation.  Routing entries are individual static routes
// which combined with the default route form all of the routing rules for
// a host.
//
//
type HostIpRouteOp struct {
	*DynamicData

	// This property indicates the change operation to apply on
	// this configuration specification.See HostConfigChangeOperation
	ChangeOperation string

	// The routing entry itself
	Route *HostIpRouteEntry
}

//
// IpRouteEntry.  Routing entries are individual static routes which combined
// with the default route form all of the routing rules for a host.
//
//
type HostIpRouteTableConfig struct {
	*DynamicData

	// The array of Routing ops (routes to be added/removed)
	IpRoute []*HostIpRouteOp

	Ipv6Route []*HostIpRouteOp
}

//
// IpRouteTableInfo. This is the list of all static routes on the host
//
//
type HostIpRouteTableInfo struct {
	*DynamicData

	// The array of IpRouteEntry
	IpRoute []*HostIpRouteEntry

	Ipv6Route []*HostIpRouteEntry
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that the host's IP address could not be resolved to a short name.
//
//
type HostIpToShortNameFailedEvent struct {
	*HostEvent
}

//
// The IpmiInfo data object contains IPMI (Intelligent Platform Management Interface)
// and BMC (Baseboard Management Controller) information for the host.
//
//
type HostIpmiInfo struct {
	*DynamicData

	// IP address of the BMC on the host. It should be null terminated.
	BmcIpAddress string

	// MAC address of the BMC on the host. The MAC address should be of the
	// form xx:xx:xx:xx:xx:xx where each x is a hex digit. It should be null
	// terminated.
	BmcMacAddress string

	// User ID for logging into the BMC. BMC usernames may be up to 16
	// characters and must be null terminated. Hence, a login comprises
	// 17 or fewer characters.
	Login string

	// Password for logging into the BMC. Only used for configuration, returned as unset
	// while reading. The password can be up to 16 characters and must be null
	// terminated. Hence, a password comprises 17 or fewer characters.
	Password string
}

//
// This event records that the isolation address could not be pinged.
// The default isolation address is the service console's default gateway.
//
//
type HostIsolationIpPingFailedEvent struct {
	*HostDasEvent

	IsolationIp string
}

//
// The KernelModuleSystem managed object controls the configuration
// of kernel modules on the host.
//
type HostKernelModuleSystem struct {
	*ManagedObject
}

//
// Query the options configured to be passed to the kernel module when loaded.
// Note that this is not necessarily the option string currently in use by
// the kernel module.
//
// Required Privileges
// Host.Config.Settings
//
func (mo *HostKernelModuleSystem) QueryConfiguredModuleOptionString(
	_this *ManagedObjectReference, name string,
) (string, error) {

	return "", nil

}

//
// Query the set of modules on the host.
//
// Required Privileges
// Host.Config.Settings
// Since
// vSphere API 4.0
//
func (mo *HostKernelModuleSystem) QueryModules(
	_this *ManagedObjectReference,
) ([]*KernelModuleInfo, error) {

	return nil, nil

}

//
// Specifies the options to be passed to the kernel module when loaded.
//
// Required Privileges
// Host.Config.Settings
//
func (mo *HostKernelModuleSystem) UpdateModuleOptionString(
	_this *ManagedObjectReference, name string, options string,
) error {

	return nil

}

//
// Encapsulates information about all licensable resources on the host.
//
//
type HostLicensableResourceInfo struct {
	*DynamicData

	// List of currently supported resources.
	// The type of every value is long. The key can be one of ResourceKey
	// or arbitrary string.
	// NOTE:
	// The values in this property may not be accurate for pre-5.0 hosts when returned by vCenter 5.0
	Resource []*KeyAnyValue
}

//
// Identifiers of currently supported resources.
//
//
type HostLicensableResourceKey struct {
}

//
// This data object type describes license information stored on the host.
//
//
type HostLicenseConnectInfo struct {
	*DynamicData

	// Evaluation information.
	Evaluation *LicenseManagerEvaluationInfo

	// License information.
	License *LicenseManagerLicenseInfo

	// Licensable resources information.
	// NOTE:
	// The values in this property may not be accurate for pre-5.0 hosts when returned by vCenter 5.0
	//
	// Since vSphere API 5.0
	Resource *HostLicensableResourceInfo
}

//
// This event records an expired host license.
//
//
type HostLicenseExpiredEvent struct {
	*LicenseEvent
}

type HostLicenseSpec struct {
	*DynamicData

	// Disabled features. When an edition is set, all the features in it
	// are enabled by default. The following parameter gives a finer
	// control on which features are disabled.
	DisabledFeatureKey []string

	// License edition to use
	EditionKey string

	// Enabled features
	EnabledFeatureKey []string

	// License source to be used
	Source *LicenseSource
}

//
// This data object type encapsulates a typical set of host information that is useful
// for list views and summary pages.
//
// VirtualCenter can retrieve this information very efficiently, even for a large set
// of hosts.
//
//
//
type HostListSummary struct {
	*DynamicData

	// Basic configuration information, if known.
	Config *HostConfigSummary

	// The Enhanced VMotion Compatibility mode that is currently in effect
	// for this host. If the host is in a cluster where EVC is active, this
	// will match the cluster's EVC mode; otherwise this will be unset.See supportedEVCMode
	//
	// Since vSphere API 4.0
	CurrentEVCModeKey string

	// The customized field values.
	CustomValue []*CustomFieldValue

	// Basic hardware information, if known.
	Hardware *HostHardwareSummary

	// The reference to the host-managed object.
	Host *HostSystem

	// IP address of the VirtualCenter server managing this host, if any.
	//
	// Since VI API 2.5
	ManagementServerIp string

	// The most capable Enhanced VMotion Compatibility mode supported by the
	// host hardware and software; unset if this host cannot participate in
	// any EVC mode.See supportedEVCMode
	//
	// Since vSphere API 4.0
	MaxEVCModeKey string

	// The overall alarm status of the host.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	OverallStatus *enum.ManagedEntityStatus

	// Basic host statistics.
	QuickStats *HostListSummaryQuickStats

	// Indicates whether or not the host requires a reboot due to a configuration
	// change.
	RebootRequired bool

	// Basic runtime information, if known.
	Runtime *HostRuntimeInfo
}

//
// Basic host statistics.
//
// Included in the host statistics are fairness scores. Fairness scores are
// represented in units with relative values, meaning they are evaluated relative to
// the scores of other hosts. They should not be thought of as having any particular
// absolute value. Each fairness unit represents an increment of 0.001 in a fairness
// score. The further the fairness score diverges from 1, the less fair the
// allocation. Therefore, a fairness score of 990, representing 0.990, is more fair
// than a fairness score of 1015, which represents 1.015. This is because 1.015 is
// further from 1 than 0.990.
//
//
//
type HostListSummaryQuickStats struct {
	*DynamicData

	// The fairness of distributed CPU resource allocation on the host.
	DistributedCpuFairness int32

	// The fairness of distributed memory resource allocation on the host.
	DistributedMemoryFairness int32

	// Aggregated CPU usage across all cores on the host in MHz. This is only
	// available if the host is connected.
	OverallCpuUsage int32

	// Physical memory usage on the host in MB. This is only available if the
	// host is connected.
	OverallMemoryUsage int32

	// The system uptime of the host in seconds.
	//
	// Since vSphere API 4.1
	Uptime int32
}

//
// This managed object type provides an interface
// through which local accounts on a host are managed.  Note that this
// managed object applies only to applications that use a local account
// database on the host to provide authentication (ESX Server, for example).
// POSIX and win32 hosts may impose different restrictions on the password,
// ID, and description formats. POSIX host implementation may restrict the
// user or group name to be lower case letters and less than 16 characters in
// total.  It may also disallow characters such as
// ";", "\n", and so on.  In short, all the platform dependent rules and
// restrictions regarding naming of users/groups and password apply here.
// An InvalidArgument fault is thrown if any of these rules are not obeyed.
//
type HostLocalAccountManager struct {
	*ManagedObject
}

// Deprecated.
// As of vSphere API 5.1, local user groups are not supported
// and group specific methods will throw NotSupported.
//
//
// Assigns a user to a group.
//
//
//
// Required Privileges
// Host.Local.ManageUserGroups
//
func (mo *HostLocalAccountManager) AssignUserToGroup(
	_this *ManagedObjectReference, user string, group string,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 5.1, local user groups are not supported
// and group specific methods will throw NotSupported.
//
//
// Creates a local group account using the parameters defined in the
// HostLocalAccountManagerAccountSpecification
// data object type.  For POSIX hosts, passing the
// HostLocalAccountManagerPosixAccountSpecification data object
// type allows you to control
// the group ID format of the group account being created.
//
//
//
// Required Privileges
// Host.Local.ManageUserGroups
//
func (mo *HostLocalAccountManager) CreateGroup(
	_this *ManagedObjectReference, group *HostAccountSpec,
) error {

	return nil

}

//
// Creates a local user account using the parameters defined in the
// HostLocalAccountManagerAccountSpecification
// data object type. For POSIX hosts,
// passing HostLocalAccountManagerPosixAccountSpecification data object
// type allows you to control the
// format of the user ID of the user account being created.
//
// Required Privileges
// Host.Local.ManageUserGroups
//
func (mo *HostLocalAccountManager) CreateUser(
	_this *ManagedObjectReference, user *HostAccountSpec,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 5.1, local user groups are not supported
// and group specific methods will throw NotSupported.
//
//
// Removes a local group account.
//
//
//
// Required Privileges
// Host.Local.ManageUserGroups
//
func (mo *HostLocalAccountManager) RemoveGroup(
	_this *ManagedObjectReference, groupName string,
) error {

	return nil

}

//
// Removes a local user account.
//
// As of vSphere API 5.1, this operation will first try to remove all
// permissions associated with the specifed account. The permissions of
// the user are removed one by one, not atomically, and the operation
// is not rolled back, if the removal of some permission fails.
//
//
// Required Privileges
// Host.Local.ManageUserGroups
//
func (mo *HostLocalAccountManager) RemoveUser(
	_this *ManagedObjectReference, userName string,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 5.1, local user groups are not supported
// and group specific methods will throw NotSupported.
//
//
// Unassigns a user from a group.
//
//
//
// Required Privileges
// Host.Local.ManageUserGroups
//
func (mo *HostLocalAccountManager) UnassignUserFromGroup(
	_this *ManagedObjectReference, user string, group string,
) error {

	return nil

}

//
// Updates a local user account using the parameters defined in the
// HostLocalAccountManagerAccountSpecification
// data object type.
//
// Required Privileges
// Host.Local.ManageUserGroups
//
func (mo *HostLocalAccountManager) UpdateUser(
	_this *ManagedObjectReference, user *HostAccountSpec,
) error {

	return nil

}

//
// The HostLocalAuthentication managed object represents
// local authentication for user accounts on an ESX host.
//
type HostLocalAuthentication struct {
	*ManagedObject
	*HostAuthenticationStore
}

//
// The HostLocalAuthenticationInfo data object represents
// local authentication on the ESX host. Local authentication
// is always enabled.
//
//
type HostLocalAuthenticationInfo struct {
	*HostAuthenticationStoreInfo
}

//
// Local file system volume.
//
//
type HostLocalFileSystemVolume struct {
	*HostFileSystemVolume

	// The device of the local file system.
	Device string
}

//
// The specification for creating a new local file system volume.
//
//
type HostLocalFileSystemVolumeSpec struct {
	*DynamicData

	// The device of the local file system.
	Device string

	// The file path on the host where the file system is mounted.
	LocalPath string
}

//
// This event records when host local port is created to recover from
// management network connectivity loss.
//
//
type HostLocalPortCreatedEvent struct {
	*DvsEvent

	// The configuration of the new host local port.
	HostLocalPort *DVSHostLocalPortInfo
}

//
// File layout spec of a virtual disk. The disk could be either a base-disk
// or a delta disk.
//
//
type HostLowLevelProvisioningManagerDiskLayoutSpec struct {
	*DynamicData

	// Bus number associated with the controller for this disk.
	BusNumber int32

	// Disk controller type, e.g. vim.vm.device.VirtualSCSIController or
	// vim.vm.device.VirtualIDEController.
	ControllerType string

	// Destination filename in datastore path.
	DstFilename string

	// Source disk filename in datastore path.
	SrcFilename string

	// Unit number of this disk on its controller.
	UnitNumber int32
}

//
// The target of the disk reload.
//
//
type HostLowLevelProvisioningManagerReloadTarget struct {
}

//
// File layout spec of a snapshot, including path to the vmsn file of the
// snapshot and the layout of virtual disks when the snapshot was taken.
//
//
type HostLowLevelProvisioningManagerSnapshotLayoutSpec struct {
	*DynamicData

	// Layout of each virtual disk of the virtual machine when the
	// snapshot was taken.
	Disk []*HostLowLevelProvisioningManagerDiskLayoutSpec

	// Name of the destination snapshot file in datastore path.
	DstFilename string

	// The unique identifier of the snapshot
	Id int32

	// Name of the source snapshot file in datastore path.
	SrcFilename string
}

//
// The status of a virtual machine migration operation.
//
//
type HostLowLevelProvisioningManagerVmMigrationStatus struct {
	*DynamicData

	// Whether the operation is considered successful. A migration
	// operation is considered successful if its switch over phase has
	// completed successfully.
	//
	// More specifically, for an in-progress migration, it is considered
	// successful if it has had a sucessful switch over, otherwise it is
	// considered unsuccessful. Likewise, the status of a completed
	// migration operation is also based on the switch over completion
	// status.
	//
	// The difference between a completed vs. in-progress migration with
	// the same consideredSuccessful property is that in the former case
	// the server is able to complete the clean up process thus leaves
	// nothing for the recovery process to clean up.
	ConsideredSuccessful bool

	// Unique identifier for this operation, currently it's unique
	// within one virtual center instance.
	MigrationId int64

	// Whether the virtual machine is the source of the migration.
	// For disk only migration, the value is always true.
	Source bool

	// Manner in which the migration process is performed. The set of
	// possible values is described in
	// HostVMotionManagerVMotionType.
	Type string
}

//
// Virtual machine information that can be used for recovery, for
// example, to decide whether to register a virtual machine with a
// server if the virtual machine is currently unregistered. This data
// object does not contain a complete virtual machine configuration,
// but a subset of information available from VirtualMachineConfigInfo, all of which are available via virtual machine
// configuration files.
//
// The documentation for each property in this data object describes
// the property in VirtualMachineConfigInfo that contains the same
// information if available.
//
//
//
type HostLowLevelProvisioningManagerVmRecoveryInfo struct {
	*DynamicData

	// 128-bit SMBIOS UUID of this virtual machine. Same as
	// uuid.
	BiosUUID string

	// Fault Tolerance settings for this virtual machine. Same as
	// ftInfo. Unset if non FT.
	FtInfo *FaultToleranceConfigInfo

	// VirtualCenter-specific 128-bit UUID of this virtual machine. Same
	// as instanceUuid.
	InstanceUUID string

	// The hardware version of this virtual machine. Same as
	// version.
	Version string
}

//
// The HostMaintenanceSpec data object may be used to specify
// actions to be taken by a host upon entering maintenance mode.
//
// If the HostMaintenanceSpec or any of its fields are omitted in a
// call to EnterMaintenanceMode_Task, default actions
// will be chosen as documented for each field's type.See EnterMaintenanceMode_TaskSee VsanHostDecommissionMode
//
//
type HostMaintenanceSpec struct {
	*DynamicData

	// The VsanHostDecommissionMode for this MaintenanceSpec.
	VsanMode *VsanHostDecommissionMode
}

//
// This class defines healthcheck result of the vSphere Distributed Switch.
//
//
type HostMemberHealthCheckResult struct {
	*DynamicData

	// The summary of health check result.
	Summary string
}

//
// The HostMemberRuntimeInfo data object
// contains healthcheck and status information about a host
// member of a distributed virtual switch.
//
//
type HostMemberRuntimeInfo struct {
	*DynamicData

	// Health check result for the host that joined the distributed virtual switch.
	HealthCheckResult []*HostMemberHealthCheckResult

	// The host.
	Host *HostSystem

	// Host proxy switch status. See
	// HostComponentState for valid values.
	// This property replaces the deprecated
	// DistributedVirtualSwitchHostMember.status.
	Status string

	// Additional information regarding the current membership status of the host.
	// This property replaces the deprecated
	// DistributedVirtualSwitchHostMember.statusDetail.
	StatusDetail string
}

//
// This class defines healthcheck result of a specified Uplink port
// in vSphere Distributed Switch.
//
//
type HostMemberUplinkHealthCheckResult struct {
	*HostMemberHealthCheckResult

	// The uplink port key.
	UplinkPortKey string
}

//
// The HostMemoryProfile data object represents
// memory configuration for the host.
// This may not be valid all versions of the host.
//
// Use the policy list for access to configuration data
// for the host memory profile. Use the property list
// for access to subprofile configuration data, if any.
//
//
//
type HostMemoryProfile struct {
	*ApplyProfile
}

//
// DataObject used for configuring the memory setting
//
//
type HostMemorySpec struct {
	*DynamicData

	// Service Console reservation in bytes.
	ServiceConsoleReservation int64
}

//
// The MemoryManagerSystem managed object provides an interface through which
// the host memory management policies that affect the performance of running
// virtual machines can be gathered and configured.
//
type HostMemorySystem struct {
	*ExtensibleManagedObject

	consoleReservationInfo *ServiceConsoleReservationInfo

	virtualMachineReservationInfo *VirtualMachineMemoryReservationInfo
}

// Service console reservation information for the memory manager.  The
// existence of this data object indicates if the service console memory
// reservation must be configured for this host.
func (mo *HostMemorySystem) ConsoleReservationInfo() (*ServiceConsoleReservationInfo, error) {
	t, err := mo.currentProperty("consoleReservationInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ServiceConsoleReservationInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ServiceConsoleReservationInfo")
	}
	return v, nil
}

// Virtual machine reservation information for the memory manager.  The
// existence of this data object indicates if the virtual machine memory
// reservation must be configured for this host.
//
// Since VI API 2.5
func (mo *HostMemorySystem) VirtualMachineReservationInfo() (*VirtualMachineMemoryReservationInfo, error) {
	t, err := mo.currentProperty("virtualMachineReservationInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineMemoryReservationInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineMemoryReservationInfo")
	}
	return v, nil
}

//
// Sets the configured service console memory reservation.  This change
// affects only the serviceConsoleReservedCfg property.  The
// configuration change
// propagates to the other properties after the next boot.
//
// Required Privileges
// Host.Config.Memory
//
func (mo *HostMemorySystem) ReconfigureServiceConsoleReservation(
	_this *ManagedObjectReference, cfgBytes int64,
) error {

	return nil

}

//
// Updates the virtual machine reservation information.
//
// Required Privileges
// Host.Config.Memory
// Since
// VI API 2.5
//
func (mo *HostMemorySystem) ReconfigureVirtualMachineReservation(
	_this *ManagedObjectReference, spec *VirtualMachineMemoryReservationSpec,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records the fact that a host is missing networks that
// other hosts are using for HA communication
//
//
type HostMissingNetworksEvent struct {
	*HostDasEvent

	Ips string
}

//
// This event records when host monitoring state has changed.
//
//
type HostMonitoringStateChangedEvent struct {
	*ClusterEvent

	// The service state in
	// ClusterDasConfigInfoServiceState
	State string
}

//
// The HostMountInfo data object provides information related
// to a configured mount point. This object does not include information
// about the mounted file system. (See HostFileSystemMountInfo.)
//
//
type HostMountInfo struct {
	*DynamicData

	// Flag that indicates if the datastore is currently accessible from
	// the host.
	//
	// For the case of a standalone host, this property has the same value as
	// DatastoreSummary.accessible.
	// You can use the DatastoreSummary property if the HostMountInfo
	// property is not set. The VirtualCenter Server will always make
	// sure the DatastoreSummary property is set correctly.
	//
	// Since VI API 2.5
	Accessible bool

	// Access mode to the underlying file system for this host.
	AccessMode string

	// This optional property for inaccessible reason is reported only if
	// a datastore becomes inaccessible as reported by
	// accessible and
	// DatastoreSummary.accessible.
	//
	// The values for inaccessible reason are defined in the enum
	// InaccessibleReason
	// This helps to determine host specific reason for datastore inaccessibility.
	//
	// If the datastore becomes accessible following an inaccessible condition,
	// the property inaccessibleReason will be unset.
	//
	// Since vSphere API 5.1
	InaccessibleReason string

	// The mount state of this mount point. For a discovered
	// volume, which is mounted, this is true. When this value is
	// unset, the default value is true.
	//
	// Since vSphere API 5.0
	Mounted bool

	// Local file path where file system volume is mounted, if applicable.
	// This path identifies the file system volume from the point of view
	// of the host.
	Path string
}

//
// A datastore can become inaccessible due to a number of reasons as
// defined in this enum InaccessibleReason.
// The reason for a datastore being inaccessibile is reported in
// inaccessibleReason.
//
// APD ("All Paths Down") is a condition where a SAN or NFS storage has
// become inaccessible for unknown reasons. It only indicates loss of
// connectivity and does not indicate storage device failure or
// LUN removal (Permanent Device Loss or PDL)
//
// A difference between APD and PDL is that APD may recover
// in which case all use cases will start to work as before. In case of PDL
// the failed datastore/device is unlikely to recover and hence the device
// path information and data cache will be emptied. If the PDL condition
// recovers, the failed datastores have to be added back to the host. Once
// in PDL a datastore cannot be added back until there are no longer any
// open files on the datastore.
//
// PDL is not linked to the APD and can happen at any time with or without APD
// preceding. If APD and PDL occur at the same time, APD  will be reported first.
// Once (and if) the APD condition clears, PermanentDataLoss will be reported if
// PDL condition still exists.
//
//
type HostMountInfoInaccessibleReason struct {
}

//
// Defines the access mode of the datastore.
//
//
type HostMountMode struct {
}

//
// The HostMultipathInfo data object describes the multipathing policy
// configuration to determine the storage failover policies
// for a SCSI logical unit.  The multipathing policy configuration operates on
// SCSI logical units and the paths to the logical units.
//
// Multipath policy configuration is only possible on storage devices
// provided by the native multipathing plug-store plugin.  Storage devices
// using the native multipathing storage plugin will have an entry
// in this data object.  Storage devices provided by a different
// storage plugin will not appear in the inventory represented by
// this data object.
//
//
// Legacy note: In hosts where HostMultipathStateInfo is not
// defined or does not exist on the HostStorageDeviceInfo object,
// only native multipathing exists.  That means for these hosts, the
// MultipathInfo object contains the complete set of LUNs and paths on the LUNs
// available on the host.
//
//
//
type HostMultipathInfo struct {
	*DynamicData

	// List of logical units that can be configured for multipathing.
	Lun []*HostMultipathInfoLogicalUnit
}

//
// The HostMultipathInfoFixedLogicalUnitPolicy data object
// describes a multipathing policy for a logical unit which uses
// a preferred path whenever possible.
//
//
type HostMultipathInfoFixedLogicalUnitPolicy struct {
	*HostMultipathInfoLogicalUnitPolicy

	// Preferred path used for the fixed policy.
	Prefer string
}

//
// The HostMultipathInfoLogicalUnit data object
// represents a storage entity that provides disk blocks to a host.
//
//
type HostMultipathInfoLogicalUnit struct {
	*DynamicData

	// Identifier of LogicalUnit.
	//
	// Use this id to configure LogicalUnit multipathing policy using SetMultipathLunPolicy.
	Id string

	// Linkable identifier.
	Key string

	// SCSI device corresponding to logical unit.
	Lun string

	// Array of paths available to access this LogicalUnit.
	Path []*HostMultipathInfoPath

	// Policy that the logical unit should use when selecting a path.
	Policy *HostMultipathInfoLogicalUnitPolicy

	// Policy used to determine how a storage device is accessed.  This policy
	// is currently immutable.
	//
	// Since vSphere API 4.0
	StorageArrayTypePolicy *HostMultipathInfoLogicalUnitStorageArrayTypePolicy
}

//
// The HostMultipathInfoLogicalUnitPolicy data object
// describes a path selection policy for a device. This policy determines
// how paths should be utilized when accessing a device.
//
//
type HostMultipathInfoLogicalUnitPolicy struct {
	*DynamicData

	// String representing the path selection policy for a device. Use one of the following
	// strings:
	//
	//
	// VMW_PSP_FIXED - Use a preferred path whenever possible.
	// VMW_PSP_RR -  Load balance.
	// VMW_PSP_MRU -  Use the most recently used path.
	//
	//
	// You can also use the
	// QueryPathSelectionPolicyOptions method
	// to retrieve the set of valid strings.
	// Use the key from the resulting structure
	// HostPathSelectionPolicyOption.
	Policy string
}

//
// The HostMultipathInfoLogicalUnitStorageArrayTypePolicy
// data object describes a storage array type policy for
// for a device.  This policy determines how device I/O and management
// is performed.
//
//
type HostMultipathInfoLogicalUnitStorageArrayTypePolicy struct {
	*DynamicData

	// String indicating the storage array type policy.
	Policy string
}

//
// The HostMultipathInfoPath data object
// is a storage entity that represents a topological path from a
// host bus adapter to a SCSI logical unit.  Each path is unique although each
// host bus adapter/SCSI logical unit pair can have multiple paths.
//
// Path objects are identified by a key.  The specifics of how
// the key is formatted are dependent on the implementation.  Example
// implementations include using strings like "vmhba1:0:0:0".
//
//
//
type HostMultipathInfoPath struct {
	*DynamicData

	// The host bus adapter at one endpoint of this path.
	Adapter string

	// A path, managed by a given path selection policy(psp) plugin, is
	// denoted to be a Working Path if the psp plugin is likely to select the
	// path for performing I/O in the near future.
	//
	// Since vSphere API 4.0
	IsWorkingPath bool

	// Identifier of the path.
	Key string

	// The logical unit at one endpoint of this path.
	Lun string

	// Name of path.
	//
	// Use this name to configure LogicalUnit multipathing policy using EnableMultipathPath and DisableMultipathPath.
	Name string

	// Deprecated.
	// As of VI API 4.0:
	//
	// System reported path states are available in state.
	// Paths slated for I/O can be found using isWorkingPath.
	//
	//
	//
	// State of the path.  Must be one of the values of
	// MultipathState
	//
	// active
	// Path can be used for I/O and is currently a working path.
	// standby
	// Path can be used for I/O but is not a working path or can be
	// used if active paths fail.
	// disabled
	// Path has been administratively disabled.
	// dead
	// Path cannot be used for I/O.
	// unknown
	// Path is in unknown error state.
	PathState string

	// System-reported state of the path. Must be one of the values of
	// MultipathState
	//
	// active
	// Path can be used for I/O.
	// standby
	// Path can be used for I/O if active paths fail.
	// disabled
	// Path has been administratively disabled.
	// dead
	// Path cannot be used for I/O.
	// unknown
	// Path is in unknown error state.
	//
	//
	// Since vSphere API 4.0
	State string

	// Transport information for the target end of the path.
	Transport *HostTargetTransport
}

//
// This data object type describes the state of storage paths on the host.
// All storage paths on the host are enumerated in this data object.
//
// The reason all path state information is encapsulated in this data
// object is because the path may actively change.  This data object
// ensures that a request to gather path state changes only needs to
// fetch this data object.
//
//
//
type HostMultipathStateInfo struct {
	*DynamicData

	// List of paths on the system and their path states.
	Path []*HostMultipathStateInfoPath
}

//
// Data object indicating state of storage path for a named path.
//
//
type HostMultipathStateInfoPath struct {
	*DynamicData

	// Name of path.
	//
	// Use this name to enable or disable storage paths EnableMultipathPath and DisableMultipathPath.
	//
	// In addition to being the identifier for the path state
	// operations, the name is used to correlate this object to the
	// corresponding Path object in other contexts.See name
	Name string

	// The state of the path.  Must be one of the values of
	// MultipathState.
	PathState string
}

//
// This data object type describes the NAS volume.  Applies to both
// NFS and CIFS.
//
//
type HostNasVolume struct {
	*HostFileSystemVolume

	// The host that runs the NFS/CIFS server.
	// Clients must plan to use remoteHostNames for both NFS v3
	// as well as NFS v4.1 because this field remoteHost may be
	// deprecated in future.
	RemoteHost string

	// The remote path of NFS/CIFS mount point.
	RemotePath string

	// In case of CIFS, the user name used while connecting to the server.
	//
	// Since VI API 2.5
	UserName string
}

//
// This describes the NAS Volume configuration containing
// the configurable properties on a NAS Volume
//
//
type HostNasVolumeConfig struct {
	*DynamicData

	// Indicates the change operation to apply on this configuration
	// specification.See HostConfigChangeOperation
	ChangeOperation string

	// The specification volume.
	Spec *HostNasVolumeSpec
}

//
// Specification for creating NAS volume.
//
// When mounting a NAS volume on multiple hosts, the same remoteHost and remotePath
// values should be used on every host, otherwise it will be treated as different
// datastores.  For example, if one host references the remotePath of a NAS volume
// as "/mnt/mount1" and another references it as "/mnt/mount1/", it will not be
// recognized as the same datastore.
//
//
//
type HostNasVolumeSpec struct {
	*DynamicData

	// Access mode for the mount point.
	//
	// Mounting in read-write mode would be successful irregardless on
	// how the mount point is exported or access permissions. For
	// example, mounting a volume that is exported as read-only as
	// readWrite will succeed. Hence, that a readWrite mount succeeds
	// should not be taken as an indication that all files on a mount
	// is writable.
	//
	// If a file system is mounted readOnly, the system cannot create
	// or modify any files on the file system. This is mostly useful
	// for storing ISO images and templates, since a virtual machine
	// cannot be powered on from a readOnly volume.
	//
	// The access mode of a mounted NFS volume can be obtained at
	// accessMode.
	// See HostMountMode
	AccessMode string

	// The localPath refers to the name of the NAS datastore to be created
	// using this specification.
	//
	// In the case of ESX Server, the datastore name is a component in the
	// file system path at which the NAS volume can be found. For example,
	// if localPath is set to "nas_volume" the created NAS datastore will be
	// named "nas_volume" and it can be accessed via the file system path
	// "/vmfs/volumes/nas_volume".
	//
	// In the case of VMware Server, the localPath will also be used as the
	// datastore name, but the datastore name may not necessarily be
	// reflected in the file system path where the NAS volume may be
	// accessed.
	LocalPath string

	// If type is CIFS, the password to use when connecting to the
	// CIFS server. If type is NFS, this field will be ignored.
	//
	// Since VI API 2.5
	Password string

	// The host that runs the NFS v3 or CIFS server. For NFS v4.1
	// and beyond use remoteHostNames defined later. The field remotehost
	// may be deprecated in future for NFS, so clients should plan to use the
	// property remoteHostNames to send in the host name(s) for both NFS v3
	// and v4.1
	RemoteHost string

	// The remote path of the NFS mount point.
	RemotePath string

	// The type of the the NAS volume (CIFS / NFS). If not specified,
	// defaults to nfs.
	//
	// Since VI API 2.5
	Type string

	// If type is CIFS, the user name to use when connecting to the
	// CIFS server. If type is NFS, this field will be ignored.
	//
	// Since VI API 2.5
	UserName string
}

//
// A network address translation (NAT) service instance provides
// firewall and network address translation services for a virtual
// network.
//
//
type HostNatService struct {
	*DynamicData

	// The instance ID of the NAT service.
	Key string

	// The configurable properties for the NatService object.
	Spec *HostNatServiceSpec
}

//
// This data object type describes the network address
// translation (NAT) service configuration
// representing both the configured properties
// on a NAT Service and identification information.
//
//
type HostNatServiceConfig struct {
	*DynamicData

	// Indicates the change operation to apply on this configuration
	// specification.See HostConfigChangeOperation
	ChangeOperation string

	// The instance ID of the NAT service.
	Key string

	// The specification of the NAT service.
	Spec *HostNatServiceSpec
}

//
// This data object type specifies the information for the
// name servers.
//
//
type HostNatServiceNameServiceSpec struct {
	*DynamicData

	// The flag to indicate whether or not the DNS server should
	// be automatically detected or specified explicitly.
	DnsAutoDetect bool

	// The list of DNS servers.
	DnsNameServer []string

	// The policy to use when multiple DNS addresses are available
	// on the host.
	DnsPolicy string

	// The number of retries before giving up on a DNS request
	// from a virtual network.
	DnsRetries int32

	// The time (in seconds) before retrying a DNS request to an external
	// network.
	DnsTimeout int32

	// The time (in seconds) allotted for queries to the NetBIOS
	// Datagram Server (NBDS).
	NbdsTimeout int32

	// Number of retries for each query to the NBNS.
	NbnsRetries int32

	// The time (in seconds) allotted for queries to the NBNS.
	NbnsTimeout int32
}

//
// This data object type describes the
// Network Address Translation (NAT) port forwarding specification.
//
//
type HostNatServicePortForwardSpec struct {
	*DynamicData

	// The IP address for the guest.  Network traffic from the host is
	// forwarded to this IP address.
	GuestIpAddress string

	// The port number for the guest.  Network traffic from the host is
	// forwarded to this port.
	GuestPort int32

	// The port number on the host.  Network traffic sent to the host on this
	// TCP/UDP port is forwarded to the guest at the specified IP address
	// and port.
	HostPort int32

	// The user-defined name to identify the service being forwarded.
	// No white spaces are allowed in the string.
	Name string

	// Either "tcp" or "udp".
	Type string
}

//
// This data object type provides the details about the
// Network Address Translation (NAT) service.
//
//
type HostNatServiceSpec struct {
	*DynamicData

	// The flag to indicate whether or not non-passive mode FTP
	// connections should be allowed.
	ActiveFtp bool

	// The flag to indicate whether or not the NAT
	// Service allows media access control traffic from any
	// Organizational Unique Identifier (OUI)?
	// By default, it does not allow traffic that originated
	// from the host to avoid packet loops.
	AllowAnyOui bool

	// The flag to indicate whether or not the NAT Service
	// should open a configuration port.
	ConfigPort bool

	// The IP address that the NAT Service should use on
	// the virtual network.
	IpGatewayAddress string

	// The configuration of naming services.  These parameters are
	// specific to Windows.
	NameService *HostNatServiceNameServiceSpec

	// The port forwarding specifications to allow network
	// connections to be initiated from outside the firewall.
	PortForward []*HostNatServicePortForwardSpec

	// The time allotted for UDP packets.
	UdpTimeout int32

	// The name of the virtual switch to which nat service is connected.
	VirtualSwitch string
}

//
// Capability vector indicating the available product features.
//
//
type HostNetCapabilities struct {
	*DynamicData

	// The flag to indicate whether or not a physical network
	// adapter's link speed and duplex settings can be changed through
	// this API.  For a hosted product, the host uses its physical network
	// adapters for network connectivity.  Configuration of link speed is
	// done through regular host operations.  In ESX Server, the configuration
	// can be changed through this API.
	CanSetPhysicalNicLinkSpeed bool

	// This flag indicates whether or not the host is able to support
	// dhcp configuration for vnics.
	//
	// Since VI API 2.5
	DhcpOnVnicSupported bool

	// The flag to indicate whether DNS configuration for the host is
	// supported.
	//
	// Since VI API 2.5
	DnsConfigSupported bool

	// The flag to indicate whether ip route configuration for the host
	// is supported.
	//
	// Since VI API 2.5
	IpRouteConfigSupported bool

	// The flag to indicate whether the host is capable of communicating
	// using ipv6 protocol
	//
	// Since vSphere API 4.0
	IpV6Supported bool

	// The maximum number of port groups supported per virtual switch.
	// This property will not be set if this value is unlimited.
	//
	// Since VI API 2.5
	MaxPortGroupsPerVswitch int32

	// The available teaming policies if the platform supports network
	// adapter teaming.
	NicTeamingPolicy []string

	// The flag to indicate whether or not the host is able
	// to support
	// the querying of network hints.
	SupportsNetworkHints bool

	// The flag to indicate whether or not network adapter teaming is
	// available.  Multiple network adapters can be bridged to a
	// virtual switch through a BondBridge.  Also, network adapter teaming
	// policies such as failover order and detection are enabled.
	SupportsNicTeaming bool

	// The flag to indicate whether or not VLANs can be configured on
	// PortGroups attached to VirtualSwitch objects.
	// This allows VLANs for virtual machines without requiring special VLAN
	// capable hardware switches.
	SupportsVlan bool

	// The flag to indicate whether or not a service
	// console network adapter
	// is used or required.  This means that the system
	// software has two TCP/IP stacks.  As a result, at least two types of
	// VirtualNics may be created -- the normal VirtualNic and the service
	// console VirtualNic.  If this is not set, then only the VirtualNic type is
	// supported.
	UsesServiceConsoleNic bool

	// The flag to indicate whether Virtual NIC configuration is supported.
	// This means that operations to add, remove, update virtualNic are
	// supported.
	//
	// Since VI API 2.5
	VnicConfigSupported bool

	// The flag to indicate whether virtual switch configuration is
	// supported. This means that operations to add, remove, update virtual
	// switches are supported.
	//
	// Since VI API 2.5
	VswitchConfigSupported bool
}

// Deprecated.
// As of VI API 4.0, the system defaults will be used.
//
//
// Offload capabilities are used to optimize virtual machine network
// performance.  When a virtual machine is transmitting on a network,
// some operations can be offloaded either to the host or to physical
// hardware.  This data object type defines the set of offload capabilities
// that may be available on a host.
//
// This data object type is used both to publish the list of offload capabilities
// and to contain offload capability policy settings.  The network
// policy logic is built on a two-level inheritance scheme which
// requires that all settings be optional.  As a result, all properties
// on the NetOffloadCapabilities object must be optional.See HostNetworkPolicy
//
//
//
type HostNetOffloadCapabilities struct {
	*DynamicData

	// (Optional) The flag to indicate whether or not checksum
	// offloading is supported.
	CsumOffload bool

	// (Optional) The flag to indicate whether or not TCP segmentation
	// offloading (TSO) is supported.
	TcpSegmentation bool

	// (Optional) The flag to indicate whether or not zero copy
	// transmits are supported.
	ZeroCopyXmit bool
}

//
// This class describes Network Stack Instance configuration
//
//
type HostNetStackInstance struct {
	*DynamicData

	// The TCP congest control algorithm used by this instance,
	// See CongestionControlAlgorithmType for valid values.
	CongestionControlAlgorithm string

	// DNS configuration
	DnsConfig *HostDnsConfig

	// IP Route configuration
	IpRouteConfig *HostIpRouteConfig

	// Enable or disable IPv6 protocol on this stack instance.
	// This property is not supported currently.
	IpV6Enabled bool

	// Key of instance
	// For instance which created by host, its value should be SystemStackKey.
	Key string

	// The display name
	Name string

	// The maximum number of socket connection that are requested on this instance
	RequestedMaxNumberOfConnections int32

	RouteTableConfig *HostIpRouteTableConfig
}

//
// Define TCP congestion control algorithm used by an instance
//
//
type HostNetStackInstanceCongestionControlAlgorithmType struct {
}

//
// Define the instance identifier for different traffic type
//
//
type HostNetStackInstanceSystemStackKey struct {
}

//
// This data object type describes networking host configuration data objects.
// These objects contain only the configuration information for networking.
// The runtime information is available from the
// NetworkInfo data object type.See HostNetworkInfo
//
//
type HostNetworkConfig struct {
	*DynamicData

	// IP route configuration of the service console.
	ConsoleIpRouteConfig *HostIpRouteConfig

	// Virtual network adapters configured for use by the Service
	// Console.
	ConsoleVnic []*HostVirtualNicConfig

	// Dynamic Host Control Protocol (DHCP) Service instances configured
	// on the host.
	//
	// Since VI API 2.5
	Dhcp []*HostDhcpServiceConfig

	// Deprecated.
	// As of vSphere API 5.5, which is moved to
	// the default NetStackInstance
	//
	//
	// Client-side DNS configuration for the host.  The DNS configuration is
	// global to the entire host.
	DnsConfig *HostDnsConfig

	// Deprecated.
	// As of vSphere API 5.5, which is moved to
	// the default NetStackInstance
	//
	//
	// IP route configuration of the host.
	IpRouteConfig *HostIpRouteConfig

	// Enable or disable IPv6 protocol on this system.
	// This property must be set by itself, no other property can accompany
	// this change. Following the successful change, the system should be rebooted to
	// have the change take effect.
	//
	// Since vSphere API 4.0
	IpV6Enabled bool

	// Network address translation (NAT) Service instances configured
	// on the host.
	//
	// Since VI API 2.5
	Nat []*HostNatServiceConfig

	// The list of network stack instance spec
	//
	// Since vSphere API 5.5
	NetStackSpec []*HostNetworkConfigNetStackSpec

	// Physical network adapters as seen by the primary operating system.
	Pnic []*PhysicalNicConfig

	// Port groups configured on the host.
	Portgroup []*HostPortGroupConfig

	// Host proxy switches configured on the host.
	//
	// Since vSphere API 4.0
	ProxySwitch []*HostProxySwitchConfig

	// Deprecated.
	// As of vSphere API 5.5, which is moved to
	// the default NetStackInstance
	//
	//
	// IP routing table configuration of the host.
	//
	// Since vSphere API 4.0
	RouteTableConfig *HostIpRouteTableConfig

	// Virtual network adapters configured for use by the host
	// operating system network adapter.
	Vnic []*HostVirtualNicConfig

	// Virtual switches configured on the host.
	Vswitch []*HostVirtualSwitchConfig
}

//
// This data type describes Network Stack Spec
//
//
type HostNetworkConfigNetStackSpec struct {
	*DynamicData

	// Network stack instance
	NetStackInstance *HostNetStackInstance

	// Operation type, see
	// ConfigSpecOperation for valid values.
	// Only edit operation is supported currently.
	Operation string
}

//
// The result returned by updateNetworkConfig call.See UpdateNetworkConfig
//
//
type HostNetworkConfigResult struct {
	*DynamicData

	// Service console virtual network adapter keys.
	ConsoleVnicDevice []string

	// Virtual network adapter keys.
	VnicDevice []string
}

//
// This data object type describes networking host
// configuration data objects.
//
//
type HostNetworkInfo struct {
	*DynamicData

	// If true then dual IPv4/IPv6 stack enabled else IPv4 only.
	//
	// Since vSphere API 4.1
	AtBootIpV6Enabled bool

	// IP route configuration of the service console.
	ConsoleIpRouteConfig *HostIpRouteConfig

	// Virtual network adapters configured for use by the service console.
	// The service
	// console uses this network access for system management and bootstrapping
	// services like network boot.
	//
	// The two sets of virtual network adapters are mutually exclusive.
	// A virtual network adapter
	// in this list cannot be used for things like VMotion.  Likewise, a
	// virtual network adapter in the other list cannot be used by the
	// service console.
	ConsoleVnic []*HostVirtualNic

	// DHCP Service instances configured on the host.
	//
	// Since VI API 2.5
	Dhcp []*HostDhcpService

	// Deprecated.
	// As of vSphere API 5.5, which is moved to
	// each NetStackInstance. For this property in NetworkInfo,
	// Get operation will only return its value of default NetStackInstance.
	//
	//
	// Client-side DNS configuration.
	DnsConfig *HostDnsConfig

	// Deprecated.
	// As of vSphere API 5.5, which is moved to
	// each NetStackInstance. For this property in NetworkInfo,
	// Get operation will only return its value of default NetStackInstance.
	//
	//
	// IP route configuration.
	IpRouteConfig *HostIpRouteConfig

	// Enable or disable IPv6 protocol on this system.
	//
	// Since vSphere API 4.0
	IpV6Enabled bool

	// NAT service instances configured on the host.
	//
	// Since VI API 2.5
	Nat []*HostNatService

	// List of NetStackInstances
	//
	// Since vSphere API 5.5
	NetStackInstance []*HostNetStackInstance

	// List of opaque networks
	//
	// Since vSphere API 5.5
	OpaqueNetwork []*HostOpaqueNetworkInfo

	// List of opaque switches configured on the host.
	//
	// Since vSphere API 5.5
	OpaqueSwitch []*HostOpaqueSwitch

	// Physical network adapters as seen by the primary operating system.
	Pnic []*PhysicalNic

	// Port groups configured on the host.
	Portgroup []*HostPortGroup

	// Proxy switches configured on the host.
	//
	// Since vSphere API 4.0
	ProxySwitch []*HostProxySwitch

	// Deprecated.
	// As of vSphere API 5.5, which is moved to
	// each NetStackInstance. For this property in NetworkInfo,
	// Get operation will only return its value of default NetStackInstance.
	//
	//
	// IP routing table
	//
	// Since vSphere API 4.0
	RouteTableInfo *HostIpRouteTableInfo

	// Virtual network adapters configured on the host (hosted products)
	// or the vmkernel.
	// In the hosted architecture, these network adapters are used by the
	// host to
	// communicate with the virtual machines running on that host.  In the
	// VMkernel architecture, these virtual network adapters provide the
	// ESX Server with
	// external network access through a virtual switch that is bridged to a
	// physical network adapter.  The VMkernel uses these network adapters
	// for features such as VMotion, NAS, iSCSI, and remote MKS connections.
	Vnic []*HostVirtualNic

	// Virtual switches configured on the host.
	Vswitch []*HostVirtualSwitch
}

//
// This data object type describes network policies that can be configured for
// both virtual switches and port groups.  The policy settings on the
// port group can inherit policy settings from their containing virtual
// switch.  These policy settings are inherited if
// the settings on the port group are not set.  Since every policy
// setting on a port group is optional, every individual policy setting
// can be inherited.
//
// By contrast, if a host is capable of implementing a policy setting, every
// virtual switch has some value assigned to the policy setting.  In this
// case, although all of the policy settings are optional,
// they always have some value either by inheritance or by direct
// setting.
//
//
// Policy settings are organized into policy groups such as SecurityPolicy.
// Policy groups are optional since it is possible that a host may not implement
// such policies.  If a host does not support a policy group, the policy group
// is not set on both the virtual switches and the port groups.See HostNetCapabilities
//
//
//
type HostNetworkPolicy struct {
	*DynamicData

	// The network adapter teaming policy. The bridge must be BondBridge
	// for this property to be valid.
	NicTeaming *HostNicTeamingPolicy

	// Deprecated.
	// As of VI API 4.0, the system defaults will be used.
	//
	//
	// Offload capabilities are used to optimize virtual machine network
	// performance.  When a virtual machine is transmitting on a network,
	// some operations can be offloaded to either the host or the physical
	// hardware.  This policy indicates what networking related operations
	// should be offloaded.
	//
	// All virtual machines using this PortGroup are subject to this
	// policy.  There is no setting for an individual virtual machine
	// to determine if an operation should be offloaded.
	OffloadPolicy *HostNetOffloadCapabilities

	// The security policy governing ports on this virtual switch.
	Security *HostNetworkSecurityPolicy

	// The traffic shaping policy.
	ShapingPolicy *HostNetworkTrafficShapingPolicy
}

//
// This data object type describes security policy governing ports.
//
//
type HostNetworkSecurityPolicy struct {
	*DynamicData

	// The flag to indicate whether or not all traffic is seen
	// on the port.
	AllowPromiscuous bool

	// The flag to indicate whether or not the virtual network adapter
	// should be allowed to send network traffic with a different MAC
	// address than that of the virtual network adapter.
	ForgedTransmits bool

	// The flag to indicate whether or not the Media Access
	// Control (MAC) address can be changed.
	MacChanges bool
}

//
// This managed object type describes networking host configuration and
// serves as the top level container for relevant networking
// data objects.
//
type HostNetworkSystem struct {
	*ExtensibleManagedObject

	capabilities *HostNetCapabilities

	consoleIpRouteConfig *HostIpRouteConfig

	dnsConfig *HostDnsConfig

	ipRouteConfig *HostIpRouteConfig

	networkConfig *HostNetworkConfig

	networkInfo *HostNetworkInfo

	offloadCapabilities *HostNetOffloadCapabilities
}

// Capability vector indicating the available product features.
func (mo *HostNetworkSystem) Capabilities() (*HostNetCapabilities, error) {
	t, err := mo.currentProperty("capabilities")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostNetCapabilities)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostNetCapabilities")
	}
	return v, nil
}

// IP route configuration for the service console.  The IP route
// configuration is global to the entire host.  This property is
// set only if
// IP routing can be configured for the service console.
func (mo *HostNetworkSystem) ConsoleIpRouteConfig() (*HostIpRouteConfig, error) {
	t, err := mo.currentProperty("consoleIpRouteConfig")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostIpRouteConfig)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostIpRouteConfig")
	}
	return v, nil
}

// Deprecated.
// As of vSphere API 5.5, which is moved to
// each NetStackInstance. This only works on the default NetStackInstance.
//
//
// Client-side DNS configuration.
func (mo *HostNetworkSystem) DnsConfig() (*HostDnsConfig, error) {
	t, err := mo.currentProperty("dnsConfig")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostDnsConfig)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostDnsConfig")
	}
	return v, nil
}

// Deprecated.
// As of vSphere API 5.5, which is moved to
// each NetStackInstance. This only works on the default NetStackInstance.
//
//
// The IP route configuration.
func (mo *HostNetworkSystem) IpRouteConfig() (*HostIpRouteConfig, error) {
	t, err := mo.currentProperty("ipRouteConfig")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostIpRouteConfig)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostIpRouteConfig")
	}
	return v, nil
}

// Network configuration information.  This information can be applied
// using the updateNetworkConfig() method.  The
// information is a strict subset of the information available in NetworkInfo.See HostNetworkInfo
func (mo *HostNetworkSystem) NetworkConfig() (*HostNetworkConfig, error) {
	t, err := mo.currentProperty("networkConfig")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostNetworkConfig)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostNetworkConfig")
	}
	return v, nil
}

// The network configuration and runtime information.
func (mo *HostNetworkSystem) NetworkInfo() (*HostNetworkInfo, error) {
	t, err := mo.currentProperty("networkInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostNetworkInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostNetworkInfo")
	}
	return v, nil
}

// Deprecated.
// As of VI API 4.0, the system defaults will be used.
//
//
// The offload capabilities available on this server.
func (mo *HostNetworkSystem) OffloadCapabilities() (*HostNetOffloadCapabilities, error) {
	t, err := mo.currentProperty("offloadCapabilities")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostNetOffloadCapabilities)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostNetOffloadCapabilities")
	}
	return v, nil
}

//
// Adds a port group to the virtual switch.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) AddPortGroup(
	_this *ManagedObjectReference, portgrp *HostPortGroupSpec,
) error {

	return nil

}

//
// Adds a virtual service console network adapter.  Returns the device of the
// VirtualNic.
//
// IP configuration is required although it does not have to be enabled
// if the host is an ESX Server system.
//
// The dynamic privilege check will ensure that users have Host.Config.Network
// privilege on the host, and Network.Assign privilege on the connecting
// DVPortGroup, or DVS if connecting to a standalone DVPort.
// Network.Assign privilege is not required for operations on standard network
// or for operations performed directly on the hostSee usesServiceConsoleNic
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *HostNetworkSystem) AddServiceConsoleVirtualNic(
	_this *ManagedObjectReference, portgroup string, nic *HostVirtualNicSpec,
) (string, error) {

	return "", nil

}

//
// Adds a virtual host/VMkernel network adapter.  Returns the device of the virtual
// network adapter.
//
// IP configuration is required although it does not have to be enabled
// if the host is an ESX Server system.
//
// The dynamic privilege check will ensure that users have Host.Config.Network
// privilege on the host, and Network.Assign privilege on the connecting
// DVPortGroup, or DVS if connecting to a standalone DVPort.
// Network.Assign privilege is not required for operations on standard network
// or for operations performed directly on the host.
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *HostNetworkSystem) AddVirtualNic(
	_this *ManagedObjectReference, portgroup string, nic *HostVirtualNicSpec,
) (string, error) {

	return "", nil

}

//
// Adds a new virtual switch to the system with the given name.  The
// name must be unique with respect to other virtual switches on the
// host and is limited to 32 characters.See UpdateVirtualSwitch
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) AddVirtualSwitch(
	_this *ManagedObjectReference, vswitchName string, spec *HostVirtualSwitchSpec,
) error {

	return nil

}

//
// Requests network hint information for a physical network adapter.
// A network hint is
// some information about the network to which the physical network
// adapter is attached.  The method receives in a list of physical
// network adapter devices and returns an equal number of hints
// if some devices are provided.  If the list of devices is empty,
// then the method accesses hints for all physical
// network adapters.See supportsNetworkHintsSee device
//
// Required Privileges
// System.Read
//
func (mo *HostNetworkSystem) QueryNetworkHint(
	_this *ManagedObjectReference, device []string,
) ([]*PhysicalNicHintInfo, error) {

	return nil, nil

}

//
// Refresh the network information and settings to pick up any changes
// that might have occurred.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) RefreshNetworkSystem(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Removes port group from the virtual switch.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) RemovePortGroup(
	_this *ManagedObjectReference, pgName string,
) error {

	return nil

}

//
// Removes a virtual service console network adapter.See usesServiceConsoleNic
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) RemoveServiceConsoleVirtualNic(
	_this *ManagedObjectReference, device string,
) error {

	return nil

}

//
// Removes a virtual host/VMkernel network adapter.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) RemoveVirtualNic(
	_this *ManagedObjectReference, device string,
) error {

	return nil

}

//
// Removes an existing virtual switch from the system.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) RemoveVirtualSwitch(
	_this *ManagedObjectReference, vswitchName string,
) error {

	return nil

}

//
// Restart the service console virtual network adapter interface.
// If the service console virtual network adapter uses DHCP, restarting
// the interface may result it with a different IP configuration, or
// even fail to be brought up depending on the host system network
// configuration.See usesServiceConsoleNic
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) RestartServiceConsoleVirtualNic(
	_this *ManagedObjectReference, device string,
) error {

	return nil

}

//
// Applies the IP route configuration for the service console.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) UpdateConsoleIpRouteConfig(
	_this *ManagedObjectReference, config *HostIpRouteConfig,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 5.5, which is moved to
// each NetStackInstance. This API only works on the default NetStackInstance.
//
//
// Applies the client-side DNS configuration.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) UpdateDnsConfig(
	_this *ManagedObjectReference, config *HostDnsConfig,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 5.5, which is moved to
// each NetStackInstance. This API only works on the default NetStackInstance.
//
//
// Applies the IP route configuration.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) UpdateIpRouteConfig(
	_this *ManagedObjectReference, config *HostIpRouteConfig,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 5.5, which is moved to
// each NetStackInstance. This API only works on the default NetStackInstance.
//
//
// Applies the IP route table configuration.
//
// Required Privileges
// Host.Config.Network
// Since
// vSphere API 4.0
//
func (mo *HostNetworkSystem) UpdateIpRouteTableConfig(
	_this *ManagedObjectReference, config *HostIpRouteTableConfig,
) error {

	return nil

}

//
// Applies the network configuration.  This method operates primarily
// in two modes: replace or modify mode.
//
// replace
// When called in replace mode, this method applies the fully
// specified networking configuration to the networking system.
//
//
// Upon successful completion of the call, the state of networking will
// match the configuration specified in config.  In general, objects
// are created or destroyed to match the elements in the array of
// configurations.  The identifier field in each element in an array of
// configurations is used to match an existing network entity.
// The state of existing network entities is patched to match that
// of the configuration.
//
//
// An exception to this approach applies to the array of PhysicalNic.Config
// objects.  The cardinality of physical network adapters cannot be
// changed through this
// operation.  Thus, the identifier of every element in the array must match an
// existing PhysicalNic.  If there are fewer elements in the array than
// there are existing PhysicalNics, then no change is made on the
// unreferenced PhysicalNic objects.
//
//
// If the call fails, the networking error is returned as an exception
// and the state of networking reverts to the state prior to the start
// of the call.
//
//
// modify
// When called in modify mode, only changes that are specified are
// made.  For singleton entities like DnsConfig, the state is
// changed only if the data object is set.  For array elements, there is
// an Operation field that indicates if the element should be added,
// removed, or edited.  In the case of editing or removal, the entity
// must exist or an exception is thrown.  In the case of adding, a
// specification needs to be provided.
//
//
// It returns device names of vmkernel and service console virtual network
// adapter added to the system.
//
//
// Currently, the only mode that is implemented is incremental mode.
// Only add operations are supported for instances.  Singleton
// configuration is not supported.
// The dynamic privilege check will ensure that users have Host.Config.Network
// privilege on the host, and Network.Assign privilege on the connecting
// DVPortGroup, or DVS if connecting to a standalone DVPort.
// Network.Assign privilege is not required for operations on standard network
// or for operations performed directly on the hostSee HostConfigChangeMode
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *HostNetworkSystem) UpdateNetworkConfig(
	_this *ManagedObjectReference, config *HostNetworkConfig, changeMode string,
) (*HostNetworkConfigResult, error) {

	return nil, nil

}

//
// Configures link speed and duplexity.  If linkSpeed is not specified,
// physical network adapter will be set to autonegotiate.See canSetPhysicalNicLinkSpeed
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) UpdatePhysicalNicLinkSpeed(
	_this *ManagedObjectReference, device string, linkSpeed *PhysicalNicLinkInfo,
) error {

	return nil

}

//
// Reconfigures a port group on the virtual switch.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) UpdatePortGroup(
	_this *ManagedObjectReference, pgName string, portgrp *HostPortGroupSpec,
) error {

	return nil

}

//
// Configures the IP configuration for a virtual service console network
// adapter.
//
// IP configuration is required although it does not have to be enabled
// if the host is an ESX Server system.
//
// The dynamic privilege check will check that the users
// have Network.Assign privilege on the DVPortGroup
// or the DVS if the port resides on a DVPortGroup or is a stand-alone DVS port.See usesServiceConsoleNic
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *HostNetworkSystem) UpdateServiceConsoleVirtualNic(
	_this *ManagedObjectReference, device string, nic *HostVirtualNicSpec,
) error {

	return nil

}

//
// Configures virtual host/VMkernel network adapter.
//
// IP configuration is required although it does not have to be enabled
// if the host is an ESX Server system.
//
// The dynamic privilege check will ensure that users have Host.Config.Network
// privilege on the host, and Network.Assign privilege on the connecting
// DVPortGroup, or DVS if connecting to a standalone DVPort.
// Network.Assign privilege is not required for operations on standard network
// or for operations performed directly on the host.
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *HostNetworkSystem) UpdateVirtualNic(
	_this *ManagedObjectReference, device string, nic *HostVirtualNicSpec,
) error {

	return nil

}

//
// Updates the properties of the virtual switch.
//
// If the bridge is NULL, the configuration will be unset.
//
//
// If a network adapter is listed in the active or standby list, then
// changing the set of network adapters to which the physical network
// adapter is associated may have a side effect of changing the network
// adapter order policy.  If a network adapter is removed from
// the bridge configuration, then the network adapter is removed
// from the network
// adapter teaming order.
//
//
// The BondBridge configuration is the only valid bridge configuration for
// an ESX Server system.See HostNicOrderPolicy
//
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostNetworkSystem) UpdateVirtualSwitch(
	_this *ManagedObjectReference, vswitchName string, spec *HostVirtualSwitchSpec,
) error {

	return nil

}

//
// This data object type describes traffic shaping policy.
//
//
type HostNetworkTrafficShapingPolicy struct {
	*DynamicData

	// The average bandwidth in bits per second if shaping is enabled on
	// the port.
	AverageBandwidth int64

	// The maximum burst size allowed in bytes if shaping is enabled on
	// the port.
	BurstSize int64

	// The flag to indicate whether or not traffic shaper is enabled on
	// the port.
	Enabled bool

	// The peak bandwidth during bursts in bits per second if traffic
	// shaping is enabled on the port.
	PeakBandwidth int64
}

//
// Network information for a network that will be added to VirtualCenter when the
// host is added.
//
//
type HostNewNetworkConnectInfo struct {
	*HostConnectInfoNetworkInfo
}

//
// This data object type describes the network adapter failover
// detection algorithm for a network adapter team.
//
//
type HostNicFailureCriteria struct {
	*DynamicData

	// The flag to indicate whether or not to enable this property to
	// enable beacon probing as a method to validate
	// the link status of a physical network adapter.
	//
	// checkBeacon can be enabled only if the VirtualSwitch has been
	// configured to use the beacon.  Attempting to set checkBeacon
	// on a PortGroup or VirtualSwitch that does not have beacon probing
	// configured for the applicable VirtualSwitch results in an error.See beaconSee HostVirtualSwitchBeaconConfig
	CheckBeacon bool

	// Deprecated.
	// As of VI API 5.1, this property is not supported
	//
	//
	// The flag to indicate whether or not to use the link duplex reported
	// by the driver as link selection criteria.
	//
	// If checkDuplex is true, then fullDuplex is the configured
	// duplex mode.  The link is considered bad if the link duplex reported
	// by driver is not the same as fullDuplex.
	//
	//
	// If checkDuplex is false, then fullDuplex is unused, and
	// link duplexity is not used as a detection method.
	CheckDuplex bool

	// Deprecated.
	// As of VI API 5.1, this property is not supported
	//
	//
	// The flag to indicate whether or not to use link error percentage
	// to detect failure.
	//
	// If checkErrorPercent is true, then percentage is the configured
	// error percentage that is tolerated.  The link is considered bad
	// if error rate exceeds percentage.
	//
	// If checkErrorPercent is false, percentage is unused, and
	// error percentage is not used as a detection method.
	CheckErrorPercent bool

	// Deprecated.
	// As of VI API 5.1, this property is not supported
	//
	//
	// To use link speed as the criteria, checkSpeed must be one of
	// the following values:
	//
	//
	// exact: Use exact speed to detect link failure.
	// speed is the configured exact speed in megabits per second.
	// minimum: Use minimum speed to detect failure.
	// speed is the configured minimum speed in megabits per second.
	// empty string: Do not use link speed to detect failure.
	// speed is unused in this case.
	CheckSpeed string

	// Deprecated.
	// As of VI API 5.1, this property is not supported
	//
	//
	// see vim.host.NetworkPolicy.NicFailureCriteria#checkDuplexSee checkDuplex
	FullDuplex bool

	// Deprecated.
	// As of VI API 5.1, this property is not supported
	//
	//
	// see vim.host.NetworkPolicy.NicFailureCriteria#checkErrorPercentSee checkErrorPercent
	Percentage int32

	// Deprecated.
	// As of VI API 5.1, this property is not supported
	//
	//
	// see vim.host.NetworkPolicy.NicFailureCriteria#checkSpeedSee checkSpeed
	Speed int32
}

//
// This data object type describes network adapter ordering policy for a
// network adapter team.  A physical network adapter can be in the active
// list, the standby list, or neither.  It cannot be in both lists.
//
// For a virtual switch, the NicOrderPolicy property is never null when
// retrieved from the server.  When creating a new virtual switch or
// updating an existing virtual switch, the NicOrderPolicy can be null,
// in which case the default NicOrderPolicy from the server will be
// used.
//
// For a portgroup, a null NicOrderPolicy property means the portgroup
// inherits the policy from its parent.  Otherwise, the NicOrderPolicy
// property defined in the portgroup takes precedence.
//
// In all cases where the NicOrderPolicy property is set, an empty
// activeNic array means there are no active Ethernet adapters in the team.  An
// empty standbyNic array means there are no standby Ethernet adapters.
//
//
type HostNicOrderPolicy struct {
	*DynamicData

	// List of active network adapters used for load balancing.
	ActiveNic []string

	// Standby network adapters used for failover.
	StandbyNic []string
}

//
// Policy for a network adapter team.
//
//
type HostNicTeamingPolicy struct {
	*DynamicData

	// Failover detection policy for this network adapter team.
	// The bridge must be BondBridge for this property to be valid.
	FailureCriteria *HostNicFailureCriteria

	// Failover order policy for network adapters on this switch.
	// The bridge must be BondBridge for this property to be valid.
	NicOrder *HostNicOrderPolicy

	// Flag to specify whether or not to notify the physical switch
	// if a link fails. If this property is true, ESX Server will
	// respond to the failure by sending a RARP packet from a different
	// physical adapter, causing the switch to update its cache.
	NotifySwitches bool

	// Network adapter teaming policy includes failover and load balancing,
	// It can be one of the following:
	//
	//
	// loadbalance_ip: route based on ip hash.
	// loadbalance_srcmac: route based on source MAC hash.
	// loadbalance_srcid: route based on the source of the port ID.
	// failover_explicit: use explicit failover order.
	//
	// See nicTeamingPolicy
	Policy string

	// Deprecated.
	// As of VI API 5.1, the system default (true) will be used
	//
	//
	// The flag to indicate whether or not the teaming policy is applied
	// to inbound frames as well.
	// For example, if the policy is explicit failover, a broadcast request goes
	// through uplink1 and comes back through uplink2.  Then if the
	// reverse policy is set, the frame is dropped when it is
	// received from
	// uplink2. This reverse policy is useful to prevent the virtual machine
	// from getting reflections.
	ReversePolicy bool

	// The flag to indicate whether or not to use a rolling policy when
	// restoring links. For example, assume the explicit link order is
	// (vmnic9, vmnic0), therefore vmnic9 goes down, vmnic0 comes
	// up. However, when vmnic9 comes backup, if rollingOrder is set
	// to be true, vmnic0 continues to be used, otherwise, vmnic9
	// is restored as specified in the explicitly order.
	RollingOrder bool
}

//
// This event records the fact that a host does not have any available networks
// for HA communication
//
//
type HostNoAvailableNetworksEvent struct {
	*HostDasEvent

	// The comma-separated list of used networks
	Ips string
}

//
// This event records the fact that a host does not have any HA-enabled port
// groups
//
//
type HostNoHAEnabledPortGroupsEvent struct {
	*HostDasEvent
}

//
// This event records the fact that a host does not have a redundant
// management network.  It is recommended that host management networks
// be configured with redundancy.
//
//
type HostNoRedundantManagementNetworkEvent struct {
	*HostDasEvent
}

//
// This event records that host went out of compliance.
//
//
type HostNonCompliantEvent struct {
	*HostEvent
}

//
// A HostNotConnected fault is thrown if a method needs
// to communicate with a host that has been disconnected in
// VirtualCenter.
//
//
type HostNotConnected struct {
	*HostCommunication
}

//
// This event records that the host is not a cluster member.
//
//
type HostNotInClusterEvent struct {
	*HostDasEvent
}

//
// A HostNotReachable fault is thrown if the server was unable
// to communicate with the host
//
//
type HostNotReachable struct {
	*HostCommunication
}

//
// Configuration information for the NTP (Network Time Protocol) service.
//
//
type HostNtpConfig struct {
	*DynamicData

	// List of time servers, specified as either IP addresses or
	// fully qualified domain names (FQDNs).
	Server []string
}

//
// Information about NUMA (non-uniform memory access).
//
//
type HostNumaInfo struct {
	*DynamicData

	// Information about each of the NUMA nodes on the host.
	// The array is empty if the host is not NUMA-capable.
	NumaNode []*HostNumaNode

	// The number of NUMA nodes on the host. The value is 0 if the
	// host is not NUMA-capable.
	NumNodes int32

	// Deprecated.
	// As of vSphere API 5.1, this property is always
	// set to "NUMA".
	//
	//
	// The type of NUMA technology.
	Type string
}

//
// Information about a single NUMA node.
//
// NOTE: This data object is not modeled correctly if the NUMA node
// contains multiple disjoint memory ranges. If there are multiple memory
// ranges, the client will see one memory ranges from this NumaNode
// object, and the memory range may or may not belong to this NUMA node.
//
//
//
type HostNumaNode struct {
	*DynamicData

	// Information about each of the CPUs associated with the node.
	CpuID []int16

	// Beginning memory range for this NUMA node.
	MemoryRangeBegin int64

	// Length of the memory range for this node in bytes, that is, the amount
	// of memory on the node.
	MemoryRangeLength int64

	// Zero-based NUMA ID for the node.
	TypeId int8
}

//
// Health state of the numeric sensor as reported by the sensor probes.
//
//
type HostNumericSensorHealthState struct {
}

//
// Base class for numeric sensor information.
//
//
type HostNumericSensorInfo struct {
	*DynamicData

	// The base units in which the sensor reading is specified. If rateUnits
	// is set the units of the current reading is further qualified by the
	// rateUnits.See rateUnits
	BaseUnits string

	// The current reading of the element indicated by the sensor. The actual
	// sensor reading is obtained by multiplying the current reading by the
	// scale factor.
	CurrentReading int64

	// The health state of the of the element indicated by the sensor.
	// This property is populated only for sensors that support threshold
	// settings.See HostNumericSensorHealthState
	HealthState *ElementDescription

	// The name of the physical element associated with the sensor
	Name string

	// The rate units in which the sensor reading is specified. For example if
	// the baseUnits is Volts and the rateUnits is per second the value
	// returned by the sensor are in Volts/second.
	RateUnits string

	// The type of the sensor. If the sensor type is set to Other the sensor
	// name can be used to further identify the type of sensor. The sensor
	// units can also be used to further implicitly determine the type of the
	// sensor.See HostNumericSensorType
	SensorType string

	// The unit multiplier for the values returned by the sensor. All values
	// returned by the sensor are current reading * 10 raised to the power of
	// the UnitModifier.
	UnitModifier int32
}

type HostNumericSensorType struct {
}

//
// Information on opaque networks that are available on the host.
//
//
type HostOpaqueNetworkInfo struct {
	*DynamicData

	// The ID of the opaque network.
	OpaqueNetworkId string

	// The name of the opaque network.
	OpaqueNetworkName string

	// The type of the opaque network.
	OpaqueNetworkType string
}

//
// The OpaqueSwitch contains basic information about virtual switches that are
// managed by a management plane outside of vSphere.
//
//
type HostOpaqueSwitch struct {
	*DynamicData

	// The opaque switch key.
	Key string

	// The opaque switch name.
	Name string

	// The set of physical network adapters associated with this switch.
	Pnic []string
}

//
// This event records when a host's capacity cannot satisfy resource
// configuration constraints.
//
//
type HostOvercommittedEvent struct {
	*ClusterOvercommittedEvent
}

//
// The ParallelScsiHba data object type describes a
// parallel SCSI host bus adapter.
//
//
type HostParallelScsiHba struct {
	*HostHostBusAdapter
}

//
// Parallel SCSI transport information about a SCSI target.
//
//
type HostParallelScsiTargetTransport struct {
	*HostTargetTransport
}

//
// This managed object is the interface for scanning and patching an ESX
// server.
//
// VMware publishes updates through its external website. A patch update is
// synonymous with a bulletin. An update may contain many individual patch
// binaries, but its installation and uninstallation are atomic.
//
type HostPatchManager struct {
	*ManagedObject
}

//
// Check the list of metadata and returns the dependency, obsolete and conflict information
// The operation is cancelable through the returned Task object. No integrity checks
// are performed on the metadata.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *HostPatchManager) CheckHostPatch_Task(
	_this *ManagedObjectReference, metaUrls []string, bundleUrls []string, spec *HostPatchManagerPatchManagerOperationSpec,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// Method is deprecated, use InstallHostPatchV2_Task instead.
//
//
// Patch the host. The operation is not cancelable. If the
// patch installation failed, an atomic rollback of the installation will
// be attempted. Manual rollback is required if the atomic rollback
// failed, see PatchInstallFailed for details.
//
// Required Privileges
// Host.Config.Patch
//
func (mo *HostPatchManager) InstallHostPatch_Task(
	_this *ManagedObjectReference, repository *HostPatchManagerLocator, updateID string, force bool,
) (*Task, error) {

	return nil, nil

}

//
// Patch the host. The operation is not cancelable. If the
// patch installation failed, an atomic rollback of the installation will
// be attempted. Manual rollback is required if the atomic rollback
// failed, see PatchInstallFailed for details.
//
// Required Privileges
// Host.Config.Patch
// Since
// vSphere API 4.0
//
func (mo *HostPatchManager) InstallHostPatchV2_Task(
	_this *ManagedObjectReference, metaUrls []string, bundleUrls []string, vibUrls []string, spec *HostPatchManagerPatchManagerOperationSpec,
) (*Task, error) {

	return nil, nil

}

//
// Query the host for installed bulletins.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *HostPatchManager) QueryHostPatch_Task(
	_this *ManagedObjectReference, spec *HostPatchManagerPatchManagerOperationSpec,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of VI API 4.0, use ScanHostPatchV2_Task.
//
//
// Scan the host for the patch status. The operation is cancelable
// through the returned Task object. Integrity checks are
// performed on the metadata only during the scan operation.
//
// Required Privileges
// System.Read
//
func (mo *HostPatchManager) ScanHostPatch_Task(
	_this *ManagedObjectReference, repository *HostPatchManagerLocator, updateID []string,
) (*Task, error) {

	return nil, nil

}

//
// Scan the host for the patch status. The operation is cancelable
// through the returned Task object. Integrity checks are
// performed on the metadata only during the scan operation.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *HostPatchManager) ScanHostPatchV2_Task(
	_this *ManagedObjectReference, metaUrls []string, bundleUrls []string, spec *HostPatchManagerPatchManagerOperationSpec,
) (*Task, error) {

	return nil, nil

}

//
// Stage the vib files to esx local location and possibly do some run time check.
//
// Required Privileges
// Host.Config.Patch
// Since
// vSphere API 4.0
//
func (mo *HostPatchManager) StageHostPatch_Task(
	_this *ManagedObjectReference, metaUrls []string, bundleUrls []string, vibUrls []string, spec *HostPatchManagerPatchManagerOperationSpec,
) (*Task, error) {

	return nil, nil

}

//
// Uninstall patch from the host. The operation is not cancelable.
//
// Required Privileges
// Host.Config.Patch
// Since
// vSphere API 4.0
//
func (mo *HostPatchManager) UninstallHostPatch_Task(
	_this *ManagedObjectReference, bulletinIds []string, spec *HostPatchManagerPatchManagerOperationSpec,
) (*Task, error) {

	return nil, nil

}

//
// The installation state if the update is installed on the server.
//
//
type HostPatchManagerInstallState struct {
}

//
// The integrity validation status.
//
//
type HostPatchManagerIntegrityStatus struct {
}

type HostPatchManagerLocator struct {
	*DynamicData

	// The proxy setting required to access the URL from the host.
	// If unset, a direct URL connection will be attempted.
	Proxy string

	// The URL that will be used to access the patch repository.
	Url string
}

//
// Optional parameters for hostd to pass to exupdate.
//
//
type HostPatchManagerPatchManagerOperationSpec struct {
	*DynamicData

	// Possible command line options when calling esxupdate.
	CmdOption string

	// The password used for the proxy server. This is passed with ssl through a
	// trusted channel.
	Password string

	// The port of the possible proxy for esxupdate to use to connect to a server.
	// The patch and metadata may be cached within the proxy server.
	Port int32

	// The name of the possible proxy for esxupdate to use to connect to a server.
	// The patch and metadata may be cached within the proxy server.
	Proxy string

	// The user name used for the proxy server.
	UserName string
}

//
// Reasons why an update is not applicable to the ESX host.
//
//
type HostPatchManagerReason struct {
}

//
// The result of the operation. Some of the fields are only valid for
// specific operations.
//
//
type HostPatchManagerResult struct {
	*DynamicData

	// The scan results for each patch.
	Status []*HostPatchManagerStatus

	// The version of the scan result schema.
	Version string

	// The scan results in XML format.
	XmlResult string
}

type HostPatchManagerStatus struct {
	*DynamicData

	// Whether or not this update is applicable to this host. An update
	// may not be applicable to the ESX host for many reasons--for
	// example, it is obsolete, it conflicts with other installed
	// patches or libraries, and so on. The reason shows some of the reasons
	// why the update is not applicable.
	//
	// An update could be inapplicable with no reason listed. This is
	// because the prerequisite install state is not correct. For example,
	// update A is one of the prerequisites of update B. B not only
	// requires A to be installed, but also requires the host is
	// rebooted after A is installed. When A is installed and the host
	// has not been restarted after the installation, B will not be
	// applicable. In such a case, the scan on both updates A and B
	// would yield a whole picture of the update applicable status.
	Applicable bool

	// Unique identifier for this update.
	Id string

	// Whether the update is installed on the server.
	Installed bool

	// The installation state of the update. Unset if the update is not
	// installed on the server.See HostPatchManagerInstallState
	InstallState []string

	// The integrity status of the update's metadata. The value would
	// be unset if the integrity status is unknown to the server.See HostPatchManagerIntegrityStatus
	Integrity string

	// Prerequisite update.
	PrerequisitePatch []*HostPatchManagerStatusPrerequisitePatch

	// Possible reasons why an update is not applicable to the ESX host.See HostPatchManagerReason
	Reason []string

	// Whether or not this update requires caller to reconnect to the
	// host. This is usually because the update is on the agent that
	// running on the host, the agent would thus be restarted when the
	// update is applied. Caller can reconnect (and possibly relogin) to
	// the host after the agent has been restarted.
	ReconnectRequired bool

	// Whether or not this update requires a host restart to take effect.
	RestartRequired bool

	// Patches that are superseded by this update.
	SupersededPatchIds []string

	// Whether or not this update requires the host in maintenance mode.
	VmOffRequired bool
}

//
// Updates that are required to be installed before this update can
// be installed on the server.
//
// In addition to being installed on the server, an update can have
// additional requirement on the server or services running on the
// server pertaining to the prerequisite update.
//
//
type HostPatchManagerStatusPrerequisitePatch struct {
	*DynamicData

	// Unique identifier of the prerequisite update.
	Id string

	// The requirement on the server or services running on the
	// server pertaining to the prerequisite update. For example,
	// this update could require the server to be rebooted after the
	// prerequisite update is installed. Unset if there is no
	// additional requirement on the prerequisite update.See HostPatchManagerInstallState
	InstallState []string
}

//
// Description of options associated with a native multipathing
// path selection policy plugin.
//
//
type HostPathSelectionPolicyOption struct {
	*DynamicData

	// Description of the paths selection policy.  Use the key as the
	// identifier.
	Policy *ElementDescription
}

//
// This data object type describes information about
// a single Peripheral Component Interconnect (PCI) device.
//
//
type HostPciDevice struct {
	*DynamicData

	// The bus ID of this PCI.
	Bus int8

	// The class of this PCI.
	ClassId int16

	// The device ID of this PCI.
	//
	// The device ID might be a negative value. A vSphere Server uses an unsigned
	// short integer to represent a PCI device ID. The WSDL representation of the ID
	// is a signed short integer. If the PCI ID is greater than 32767, the Server
	// will convert the ID to its two's complement for the WSDL representation.
	// When you specify a PCI device ID for a virtual machine
	// (VirtualPCIPassthroughDeviceBackingInfo.deviceId),
	// you must use the HostPciDevice.deviceId value as retrieved
	// and convert it to a string.
	DeviceId int16

	// The device name of this PCI.
	DeviceName string

	// The function ID of this PCI.
	Function int8

	// The name ID of this PCI, composed of "bus:slot.function".
	Id string

	// The parent bridge of this PCI.
	//
	// Since vSphere API 4.0
	ParentBridge string

	// The slot ID of this PCI.
	Slot int8

	// The subdevice ID of this PCI.
	//
	// The subdevice ID might be a negative value.  A vSphere Server uses an unsigned
	// short integer to represent a PCI subdevice ID. The WSDL representation of the ID
	// is a signed short integer. If the subdevice ID is greater than 32767, the Server
	// will convert the ID to its two's complement for the WSDL representation.
	SubDeviceId int16

	// The subvendor ID of this PCI.
	//
	// The subvendor ID might be a negative value.  A vSphere Server uses an unsigned
	// short integer to represent a PCI subvendor ID. The WSDL representation of the ID
	// is a signed short integer. If the subvendor ID is greater than 32767, the Server
	// will convert the ID to its two's complement for the WSDL representation.
	SubVendorId int16

	// The vendor ID of this PCI.
	//
	// The vendor ID might be a negative value. A vSphere Server uses an unsigned
	// short integer to represent a PCI vendor ID. The WSDL representation of the ID
	// is a signed short integer. If the vendor ID is greater than 32767, the Server
	// will convert the ID to its two's complement for the WSDL representation.
	// When you specify a PCI device vendor ID for a virtual machine
	// (VirtualPCIPassthroughDeviceBackingInfo.vendorId),
	// you must use the retrieved HostPciDevice.deviceId value.
	VendorId int16

	// The vendor name of this PCI.
	VendorName string
}

//
// This data object provides information about the state of PciPassthru
// for all pci devices.
//
//
type HostPciPassthruConfig struct {
	*DynamicData

	// The name ID of this PCI, composed of "bus:slot.function".
	Id string

	// Whether passThru is has been configured for this device
	PassthruEnabled bool
}

//
// This data object provides information about the state of PciPassthru
// for all pci devices.
//
//
type HostPciPassthruInfo struct {
	*DynamicData

	// Device which needs to be unclaimed by vmkernel (may be bridge)
	DependentDevice string

	// The name ID of this PCI, composed of "bus:slot.function".
	Id string

	// Whether passThru is active for this device (meaning enabled + rebooted)
	PassthruActive bool

	// Whether passThru is even possible for this device (decided by vmkctl)
	PassthruCapable bool

	// Whether passThru has been configured by the user
	PassthruEnabled bool
}

//
// This managed object manages the PciPassthru state of the host.
//
type HostPciPassthruSystem struct {
	*ExtensibleManagedObject

	pciPassthruInfo []*HostPciPassthruInfo
}

// Array of PciPassthru information
// Required Privilege: System.Read
func (mo *HostPciPassthruSystem) PciPassthruInfo() ([]*HostPciPassthruInfo, error) {
	t, err := mo.currentProperty("pciPassthruInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*HostPciPassthruInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*HostPciPassthruInfo")
	}
	return v, nil
}

//
// Refresh the available PciPassthru information.
//
// Required Privileges
// Host.Config.Settings
//
func (mo *HostPciPassthruSystem) Refresh(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Updates the PciPassthru configuration, this will
// get called for the dependent device with the enabled
// bool set
//
// Required Privileges
// Host.Config.PciPassthru
//
func (mo *HostPciPassthruSystem) UpdatePassthruConfig(
	_this *ManagedObjectReference, config []*HostPciPassthruConfig,
) error {

	return nil

}

//
// This data object represents the plug-store topology on a host
// system.  Through this data object, the storage structure of a system
// that utilizes the plug-store architecture can be presented.
//
// The object entity-relationship diagram is modeled below:
//
//
//
//
// 0..N             0..N      0..N
// Plugin -----&gt;  Device  ------&gt;  Path  &lt;------  Adapter
// &lt;------   |    ------&gt;
// 0,1       |          1
// |
// | 0,1
// \|/
// Target
//
//
//
// Description and reasoning behind the relationships:
//
// When a storage device driver is loaded, it claims a PCI device as a
// host bus adapter.  This host bus adapter is represented as an Adapter.
// The PCI device identifier is a property on the HostBusAdapter in the
// Adapter.
//
//
// Once the host bus adapter is on the system, the hardware bus is scanned.
// If a storage Device is found on the bus, the communication path to the
// Device from the the host bus adapter is represented by a Path.  A Device
// may have more than one Path.  How those Paths are composed to create a
// Device is determined by a storage Plugin.
//
//
// When a storage Plugin is loaded, it claims a set of Paths.  It groups these
// Paths into a set of Devices.  Devices are hence associated with a set of
// Paths that might be used to provide a single logical device such as in the
// case of multipathing.  Devices may be also composed of zero Paths meaning
// that they do not directly use a host bus adapter for communication with
// underlying storage.
//
//
// The purpose of this data object is to represent the topology of storage
// as seen by the base plug-store system.  There is some overlap
// with information in other objects such as ScsiTopology which is only
// applicable when a particular "native multipathing" plugin is used.  This
// data object provides the complete inventory of Devices and Paths.  Hence
// it provides a superset of Device mappings over data object such as
// ScsiTopology and Multipa
//
//
// The use cases that this data object accommodates includes the following
// non-exhaustive list:
//
//
//
//
// • Enumerate paths on a host bus adapter.
//
// • Enumerate paths on a storage device.
//
// • Conveniently access the devices a host bus adapter is
// associated with by traversing the path.
//
// • Determine which plugin a device belongs.
//
// • Determine which paths are claimed by a plugin by
// accumulating the paths of all device of the plugin.
//
// • Determine which plugin a path belongs to by accessing its
// device and finding that device in the Plugin list.
//
//
//
//
//
type HostPlugStoreTopology struct {
	*DynamicData

	// List of host bus adapters in the plug store inventory.
	Adapter []*HostPlugStoreTopologyAdapter

	// List of devices in the plug store inventory.
	Device []*HostPlugStoreTopologyDevice

	// List of paths in the plug store inventory.
	Path []*HostPlugStoreTopologyPath

	// List of plugins in the plug store inventory.
	Plugin []*HostPlugStoreTopologyPlugin

	// Partial list of targets as seen by the host.  The list of targets
	// may not be exhaustive on the host.
	Target []*HostPlugStoreTopologyTarget
}

//
// This data object type is an association class that describes a host bus
// adapter and its associated storage Paths.  The set of Paths on all the
// host bus adapters is the complete set of Paths in the system.
//
//
type HostPlugStoreTopologyAdapter struct {
	*DynamicData

	// The link to the host bus adapter for this inebtrface.
	Adapter string

	// The identifier for the host bus adapter.
	Key string

	// The list of paths to which the host bus adapter is associated.
	Path []string
}

//
// This data object type is an association class that describes a ScsiLun
// and its associated Path objects.  The ScsiLun is a Device that is formed
// from a set of Paths.
//
//
type HostPlugStoreTopologyDevice struct {
	*DynamicData

	// Linkable identifier.
	Key string

	// The SCSI device corresponding to logical unit.
	Lun string

	// The array of paths available to access this LogicalUnit.
	Path []string
}

//
// This data object type is an association class that describes a Path and
// its associated Device.  A Path may be claimed by at most one Device.
//
//
type HostPlugStoreTopologyPath struct {
	*DynamicData

	// The adapter that provided the Path.
	Adapter string

	// The channel number for a path if applicable.
	ChannelNumber int32

	// The device that claimed the Path if any.
	Device string

	// The identifier for the Path.
	Key string

	// The LUN number for a path if applicable.
	LunNumber int32

	// Name of path.  Use this property to correlate this path object to other
	// path objects.
	//
	// The state of the Path can be retrieved from the data object (@link
	// vim.host.MultipathStateInfo.Path} on the HostMultipathStateInfo data object.
	//
	// Use this name to configure LogicalUnit multipathing policy using EnableMultipathPath and DisableMultipathPath.
	Name string

	// The target of the Path if any.
	Target string

	// The target number for a path if applicable.  The target number is not
	// guaranteed to be consistent across reboots or rescans of the adapter.
	TargetNumber int32
}

//
// This data object type represents a Plugin in the plug store architecture.
// A Plugin claims a set of paths and groups them into Devices.
//
//
type HostPlugStoreTopologyPlugin struct {
	*DynamicData

	// The set of paths claimed by this plugin.  Not every claimed path
	// will necessarily appear as part of a Device.  Claimed paths will
	// only appear under Devices if the device identifier of the path
	// matches up with the device identifier exposed by the Device.
	ClaimedPath []string

	// The set of devices formed by this plugin.
	Device []string

	// The identifier of the plugin.
	Key string

	// The name of the plugin.
	Name string
}

//
// This data object represents target information.
//
//
type HostPlugStoreTopologyTarget struct {
	*DynamicData

	// The identifier of the target.  This will be a string representing the
	// transport information of the target.
	Key string

	// Detailed, transport-specific information about the target of a path.
	Transport *HostTargetTransport
}

//
// This data object type is used to describe port groups.
// Port groups are used to group virtual network adapters on a virtual switch,
// associating them with networks and network policies.
//
//
type HostPortGroup struct {
	*DynamicData

	// Computed network policies that are applicable for a port group.  The
	// inheritance scheme for PortGroup requires knowledge about the
	// NetworkPolicy for a port group and its parent virtual switch as well as
	// the logic for computing the results.  This information is provided as
	// a convenience so that callers need not duplicate the inheritance logic
	// to determine the proper values for a network policy.
	//
	// See the description of the
	// NetworkPolicy data object type
	// for more information.
	ComputedPolicy *HostNetworkPolicy

	// The linkable identifier.
	Key string

	// The ports that currently exist and are used on this port group.
	Port []*HostPortGroupPort

	// The specification of a port group.
	Spec *HostPortGroupSpec

	// The virtual switch that contains this port group.
	Vswitch string
}

//
// This describes the port group configuration containing both
// the configurable properties on a port group and the associated
// virtual switch.
//
//
type HostPortGroupConfig struct {
	*DynamicData

	// Indicates the change operation to apply on this configuration
	// specification.See HostConfigChangeOperation
	ChangeOperation string

	// The specification of the port group.
	Spec *HostPortGroupSpec
}

//
// A Port data object type is a runtime representation of network
// connectivity between a network service or virtual machine and a
// virtual switch.  This is different from a port group in that
// the port group represents the configuration aspects of the
// network connection.  The Port object provides runtime statistics.
//
//
type HostPortGroupPort struct {
	*DynamicData

	// The linkable identifier.
	Key string

	// The Media Access Control (MAC) address of network service of
	// the virtual machine connected on this port.
	Mac []string

	// The type of component connected on this port.  Must be one of the
	// values of PortGroupConnecteeType.
	Type string
}

//
// The HostPortGroupProfile data object represents the subprofile
// for a port group that will be used by the ESX host.
// If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type HostPortGroupProfile struct {
	*PortGroupProfile

	// IP address configuration for the Host network.
	IpConfig *IpAddressProfile
}

//
// This data object type describes the PortGroup specification
// representing the properties on a PortGroup that
// can be configured.
//
//
type HostPortGroupSpec struct {
	*DynamicData

	// The name of the port group.
	Name string

	// Policies on the port group take precedence over the ones specified
	// on the virtual switch.
	Policy *HostNetworkPolicy

	// The VLAN ID for ports using this port group. Possible values:
	//
	// A value of 0 specifies that you do not want the port group associated
	// with a VLAN.
	// A value from 1 to 4094 specifies a VLAN ID for the port group.
	// A value of 4095 specifies that the port group should use trunk mode,
	// which allows the guest operating system to manage its own VLAN tags.
	VlanId int32

	// The identifier of the virtual switch on which
	// this port group is located.
	VswitchName string
}

//
// This data object type contains a POSIX-specific parameter
// for local account creation.
//
//
type HostPosixAccountSpec struct {
	*HostAccountSpec

	// Deprecated.
	// As of vSphere API 5.1, this property is deprecated and
	// is ignored.
	//
	//
	// The user ID or group ID of a specified account.
	PosixId int32

	// Deprecated.
	// As of vSphere API 5.1, this property is deprecated and
	// is ignored. CreateUser will always set this to true, and
	// UpdateUser will set it to true if it is already false.
	//
	// As of vSphere API 5.1, shell access is granted only to users with
	// Administrator role on the root folder and no other non-Admin role on
	// any other inventory objects (and this property should not be false).
	//
	//
	// Grants shell access if true. By default, shell access is disallowed.
	//
	// As of vSphere API 4.1, this property has effect only on users with Administrator
	// role on one or more VIM objects. For all others the default is applied.
	ShellAccess bool
}

//
// This fault is thrown when a host power operation fails.
//
//
type HostPowerOpFailed struct {
	*VimFault
}

type HostPowerOperationType struct {
}

//
// Power Management Policy data object.
//
//
//
// Used to retrieve and specify current host power management policy.
//
//
type HostPowerPolicy struct {
	*DynamicData

	// Power Policy Description.
	Description string

	// Power Policy Key.
	//
	//
	//
	// Internally generated key which uniquely identifies power management
	//
	// policy on a host.
	Key int32

	// Power Policy Name.
	Name string

	// Power Policy Short Name.
	//
	//
	//
	// This is not localizable property which can be used to identify specific
	//
	// power managing policies like "custom" power policy.  Custom power policy
	//
	// has short name set to "custom".
	ShortName string
}

//
// Managed object responsible for getting and setting host
//
// power management policies.
//
type HostPowerSystem struct {
	*ManagedObject

	capability *PowerSystemCapability

	info *PowerSystemInfo
}

// Power system capabilities object.
// Required Privilege: Host.Config.Power
func (mo *HostPowerSystem) Capability() (*PowerSystemCapability, error) {
	t, err := mo.currentProperty("capability")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*PowerSystemCapability)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *PowerSystemCapability")
	}
	return v, nil
}

// Power system state info object.
// Required Privilege: Host.Config.Power
func (mo *HostPowerSystem) Info() (*PowerSystemInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*PowerSystemInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *PowerSystemInfo")
	}
	return v, nil
}

//
// Configure host power policy.
//
// Required Privileges
// Host.Config.Power
//
func (mo *HostPowerSystem) ConfigurePowerPolicy(
	_this *ManagedObjectReference, key int32,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that the primary agent specified is not a short name.
// The name of the primary agent is usually stored as a short name. You should
// not normally see this error. Please check the network configurations of your
// hosts.
//
//
type HostPrimaryAgentNotShortNameEvent struct {
	*HostDasEvent

	PrimaryAgent string
}

//
// A host profile describes ESX Server configuration.
// The HostProfile managed object provides access to profile data and
// it defines methods to manipulate the profile.
// A host profile is a combination of subprofiles, each of which contains
// configuration data for a specific capability. Some examples of host capabilities are
// authentication, memory, networking, and security. For access to individual subprofiles,
// see the HostApplyProfile data object
// (HostProfile.config.applyProfile).
//
// Host profiles are part of the stateless configuration architecture.
// In the stateless environment, a Profile Engine runs on each ESX host,
// but an ESX host does not store its own configuration state. Instead,
// host configuration data is stored on vCenter Servers. Every time a host
// boots or reboots, it obtains its profile from the vCenter Server.
//
//
//
// • To create a base host profile use the
// HostProfileManager.CreateProfile
// method. To create a profile from an ESX host, specify a
// HostProfileHostBasedConfigSpec. To create a profile from a file,
// specify a HostProfileSerializedHostProfileSpec.
//
//
// • To create a subprofile for a particular host capability, use the
// HostProfileManager.CreateDefaultProfile
// method. After you create the default profile you can modify it and save it in the base profile.
//
//
//
// • To update an existing profile, use the
// HostProfile.UpdateHostProfile method.
//
//
// •
// To apply a host profile to an ESX host, use the ExecuteHostProfile method
// to generate configuration changes, then call the
// HostProfileManager.ApplyHostConfig_Task
// method to apply them.
//
//
//
//
//
// Host-Specific Configuration
//
//
// An individual host or a set of hosts may have some configuration settings
// that are different from the settings specified in the host profile.
// For example, the IP configuration for the host's virtual network adapters
// must be unique.
//
//
//
// • To verify host-specific data, use the deferredParam parameter
// to the ExecuteHostProfile method.
// The Profile Engine will determine if you have specified all of the required
// parameters for the host configuration. If additional data is required,
// call the ExecuteHostProfile method again as many times as necessary
// to verify a complete set of parameters.
//
//
//
// • To apply host-specific data, use the userInput parameter to the
// HostProfileManager.ApplyHostConfig_Task
// method.
//
//
//
//
//
// The Profile Engine saves host-specific data in an AnswerFile
// that is stored on the vCenter Server.
// The HostProfileManager provides several methods to manipulate
// answer files.
//
// Profile Compliance
//
//
// You can create associations between hosts and profiles to support compliance checking.
// When you perform compliance checking, you can determine if a host configuration
// conforms to a host profile.
//
//
//
// • To create an association between a host and a profile, use the
// AssociateProfile method.
// The method adds the host to the
// HostProfile.entity[] list.
//
//
// • To retrieve the list of profiles associated with a host, use the
// HostProfileManager.FindAssociatedProfile
// method.
//
//
// • To check host compliance, use the
// CheckProfileCompliance_Task method.
// If you do not specify any hosts, the method will check the compliance of all hosts
// that are associated with the profile.
//
//
//
//
// You can also use the Profile Compliance Manager to check compliance by specifying
// profiles, entities (hosts), or both. See
// ProfileComplianceManager.CheckCompliance_Task.
//
// Profile Plug-Ins
//
//
// The vSphere architecture uses VMware profile plug-ins to define profile extensions.
// For information about using a plug-in to extend a host profile, see the VMware Technical Note
// Developing a Host Profile Extension Plug-in.
//
//
// For access to host configuration data that is defined by plug-ins, use the
// ApplyProfile.policy[] and
// ApplyProfile.property[] lists.
// The HostApplyProfile and its subprofiles, which collectively
// define host configuration data, are derived from the ApplyProfile.
//
//
//
// • Policies store ESX configuration data in PolicyOption objects.
//
// • Profile property lists contain subprofiles defined by plug-ins. Subprofiles can be nested.
//
//
// • Subprofile lists are available as an extension to the base host profile
// (HostProfile.config.applyProfile.property[]).
//
//
// • Subprofile lists are available as extensions to the host subprofiles - for example,
// the network subprofile
// (HostApplyProfile.network.property[]).
//
//
//
//
//
//
//
//
//
// If you make changes to host profile data, later versions of profile plug-ins may not support
// the host configuration implied by the changes that you make. When a subsequent vSphere
// version becomes available, you must verify that the new version supports any previous
// configuration changes that you have made.
//
type HostProfile struct {
	*ManagedObject
	*Profile

	referenceHost *HostSystem
}

// Reference host in use for this host profile. To set this property,
// use the UpdateReferenceHost
// method. If you do not specify a host for validation
// (HostProfileCompleteConfigSpec.validatorHost),
// the Profile Engine uses the reference host to validate the profile.
func (mo *HostProfile) ReferenceHost() (*HostSystem, error) {
	t, err := mo.currentProperty("referenceHost")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostSystem)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostSystem")
	}
	return v, nil
}

//
// Run the Profile Engine to determine the list of configuration changes
// needed for the specified host. The method generates configuration changes
// based on the host profile.
//
// You can also specify deferred parameters to verify additional host-specific data.
// The Profile Engine uses the policy options
// (HostProfile.config.applyProfile.policy[])
// to determine the required parameters
// (PolicyOption.parameter[])
// for host configuration. If you do not provide all of the required parameters,
// you must call the method again to provide the complete list to the Profile Engine.
// After successful profile execution, when you apply the profile,
// the Profile Engine will save the host-specific data in an AnswerFile.
//
//
// Required Privileges
// System.View
//
func (mo *HostProfile) ExecuteHostProfile(
	_this *ManagedObjectReference, host *HostSystem, deferredParam []*ProfileDeferredPolicyOptionParameter,
) (*ProfileExecuteResult, error) {

	return nil, nil

}

//
// Update the HostProfile with the specified configuration data.
//
// Required Privileges
// Profile.Edit
//
func (mo *HostProfile) UpdateHostProfile(
	_this *ManagedObjectReference, config *HostProfileConfigSpec,
) error {

	return nil

}

//
// Sets the HostProfile.referenceHost property.
//
// Required Privileges
// Profile.Edit
//
func (mo *HostProfile) UpdateReferenceHost(
	_this *ManagedObjectReference, host *HostSystem,
) error {

	return nil

}

//
// This event records that a Profile application was done
// on the host
//
//
type HostProfileAppliedEvent struct {
	*HostEvent

	// Link to the profile which was applied
	Profile *ProfileEventArgument
}

//
// The HostProfileCompleteConfigSpec data object
// specifies the complete configuration for a host profile.
//
//
type HostProfileCompleteConfigSpec struct {
	*HostProfileConfigSpec

	// Profile that contains configuration data for the host.
	ApplyProfile *HostApplyProfile

	// User defined compliance profile.
	// Reserved for future use.
	CustomComplyProfile *ComplianceProfile

	// List of expressions to be disabled. Each entry in the list specifies
	// a ProfileExpression.id.
	// All expressions are enabled by default.
	//
	// If you set disabledExpressionListChanged
	// to True, the Profile Engine uses the contents of this list to replace the contents
	// of the HostProfile.config.disabledExpressionList.
	//
	// The expression list is contained in the
	// defaultComplyProfile.
	// The Profile Engine automatically generates the default compliance profile
	// when you create a host profile.
	DisabledExpressionList []string

	// Flag indicating if this configuration specification contains changes
	// in the disabledExpressionList.
	// If False, the Profile Engine ignores the contents of the disabled expression list.
	DisabledExpressionListChanged bool

	// Host for profile validation. This can be a host on which the profile
	// is intended to be used. If you do not specify a validator host,
	// the Profile Engine uses the HostProfile.referenceHost
	// to validate the profile.
	//
	// Since vSphere API 5.0
	ValidatorHost *HostSystem
}

//
// The HostProfileConfigInfo data object
// contains host profile data and information about profile compliance.
//
//
type HostProfileConfigInfo struct {
	*ProfileConfigInfo

	// Profile data for host configuration.
	ApplyProfile *HostApplyProfile

	// User defined compliance profile.
	// Reserved for future use.
	CustomComplyProfile *ComplianceProfile

	// List of compliance locators. Each locator specifies an association between
	// the applyProfile and the defaultComplyProfile.
	// The association identifies a component profile and the expression generated
	// by the profile. vSphere clients can use this data to provide contextual
	// information to the user.
	DefaultComplyLocator []*ComplianceLocator

	// Default compliance profile. The ESX Server uses the applyProfile
	// (HostProfile.config.applyProfile)
	// to generate the default compliance profile when you create a host profile.
	// When the applyProfile is modified, the Server automatically
	// updates the compliance profile to match it.
	DefaultComplyProfile *ComplianceProfile

	// Disabled expressions in the default compliance profile
	// (DefaultComplyProfile).
	// Use this property to specify which expressions are disabled.
	// All expressions are enabled by default.
	DisabledExpressionList []string
}

//
// HostProfileConfigSpec is the base data object
// for all HostProfile configuration specifications.
//
//
type HostProfileConfigSpec struct {
	*ProfileCreateSpec
}

//
// The HostProfileHostBasedConfigSpec data object
// specifies the host from which configuration data is to be extracted
// and the profile(s) to be created or updated.
//
//
type HostProfileHostBasedConfigSpec struct {
	*HostProfileConfigSpec

	// ESX host.
	Host *HostSystem

	// Flag indicating if the Profile Engine should use the profile
	// plug-ins present on the host to create the profile.
	// If true, the host Profile Engine uses the vSphere 5.0
	// (or later) profile plug-ins. The resulting profile is not compatible
	// with legacy hosts (pre 5.0). If false or not specified,
	// the Profile Engine creates a legacy host profile.
	//
	// Since vSphere API 5.0
	UseHostProfileEngine bool
}

//
// The HostProfileManager provides access to a list of
// HostProfiles and it defines methods to manipulate
// profiles and AnswerFiles.
//
type HostProfileManager struct {
	*ManagedObject
	*ProfileManager
}

//
// Apply the configuration to the host. If you specify any user input,
// the configuration will be saved in the AnswerFile
// associated with the host. If there is no answer file, the Profile Engine
// will create one.
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *HostProfileManager) ApplyHostConfig_Task(
	_this *ManagedObjectReference, host *HostSystem, configSpec *HostConfigSpec, userInput []*ProfileDeferredPolicyOptionParameter,
) (*Task, error) {

	return nil, nil

}

//
// Check the validity of the answer files for the specified hosts.
// The Profile Engine uses the profile associated with a host to check
// the answer file.
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *HostProfileManager) CheckAnswerFileStatus_Task(
	_this *ManagedObjectReference, host []*HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Create a default subprofile of a given type (for example, a
// VirtualSwitchProfile). After you create
// the subprofile, you can add it to a configuration specification
// and update the host profile:
//
//
// • Call the CreateDefaultProfile method.
//
// • Create a HostProfileCompleteConfigSpec object.
//
// • Copy the existing profile from the host configuration information
// (HostProfile.config.applyProfile) to the configuration specification.
//
// • Add the new subprofile to the configuration specification. For example,
// if you create a VirtualSwitchProfile, you would add it to the list
// of virtual switches in the network profile for the configuration specification
// (NetworkProfile.vswitch[]).
//
//
// • Call HostProfile.UpdateHostProfile
// to save the new subprofile.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *HostProfileManager) CreateDefaultProfile(
	_this *ManagedObjectReference, profileType string, profileTypeName string, profile *Profile,
) (*ApplyProfile, error) {

	return nil, nil

}

//
// Export a host's answer file into a serialized form. The method returns a string
// that contains only the list of user input options.
// See AnswerFile.userInput.
//
// Required Privileges
// Profile.Export
// Since
// vSphere API 5.0
//
func (mo *HostProfileManager) ExportAnswerFile_Task(
	_this *ManagedObjectReference, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of vSphere API 5.5 use
// GenerateHostProfileTaskList_Task
//
//
// Generate a list of configuration tasks that will be performed on the
// host during HostProfile application.
//
// Required Privileges
// System.View
//
func (mo *HostProfileManager) GenerateConfigTaskList(
	_this *ManagedObjectReference, configSpec *HostConfigSpec, host *HostSystem,
) (*HostProfileManagerConfigTaskList, error) {

	return nil, nil

}

//
// Generate a list of configuration tasks that will be performed on the
// host during HostProfile application. This differs from the
// GenerateConfigTaskList method in
// that it returns a task to monitor the progress of the operation.
//
// Required Privileges
// System.View
// Since
// vSphere API 5.5
//
func (mo *HostProfileManager) GenerateHostProfileTaskList_Task(
	_this *ManagedObjectReference, configSpec *HostConfigSpec, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Returns the status of the answer files associated with specified hosts.
// This method returns the most recent status determined by
// CheckAnswerFileStatus_Task.
// See HostProfileManagerAnswerFileStatus for valid values.
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *HostProfileManager) QueryAnswerFileStatus(
	_this *ManagedObjectReference, host []*HostSystem,
) ([]*AnswerFileStatusResult, error) {

	return nil, nil

}

//
// Retrieve the metadata for a set of profiles.
//
// Required Privileges
// System.View
//
func (mo *HostProfileManager) QueryHostProfileMetadata(
	_this *ManagedObjectReference, profileName []string, profile *Profile,
) ([]*ProfileMetadata, error) {

	return nil, nil

}

//
// Get information about the structure of the profile.
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *HostProfileManager) QueryProfileStructure(
	_this *ManagedObjectReference, profile *Profile,
) (*ProfileProfileStructure, error) {

	return nil, nil

}

//
// Returns the answer file associated with a particular host.
//
// Required Privileges
// None
// Since
// vSphere API 5.0
//
func (mo *HostProfileManager) RetrieveAnswerFile(
	_this *ManagedObjectReference, host *HostSystem,
) (*AnswerFile, error) {

	return nil, nil

}

//
// Returns the answer file associated with a particular host, augmented
// with whatever answer file values are required for the supplied host
// profile.
//
// Required Privileges
// None
// Since
// vSphere API 5.1
//
func (mo *HostProfileManager) RetrieveAnswerFileForProfile(
	_this *ManagedObjectReference, host *HostSystem, applyProfile *HostApplyProfile,
) (*AnswerFile, error) {

	return nil, nil

}

//
// Update the AnswerFile for the specified host.
// If there is no answer file associated with the host, the Profile Engine
// uses the answer file configuration specification to create a new one.
//
// Required Privileges
// Profile.Edit
// Since
// vSphere API 5.0
//
func (mo *HostProfileManager) UpdateAnswerFile_Task(
	_this *ManagedObjectReference, host *HostSystem, configSpec *AnswerFileCreateSpec,
) (*Task, error) {

	return nil, nil

}

//
// The HostProfileManagerAnswerFileStatus enum
// defines possible values for answer file status.
//
//
type HostProfileManagerAnswerFileStatus struct {
}

//
// The HostProfileManagerConfigTaskList data object
// represents a set of tasks to be performed on a host during host profile application.
//
//
type HostProfileManagerConfigTaskList struct {
	*DynamicData

	// Set of configuration changes to be applied to the host.
	ConfigSpec *HostConfigSpec

	// Description of tasks that will be performed on the host
	// to carry out HostProfile application.
	TaskDescription []*LocalizableMessage
}

//
// The HostProfileSerializedHostProfileSpec data object
// contains a string representation of a host profile. Use this object when you
// create a host profile from a file.
//
//
type HostProfileSerializedHostProfileSpec struct {
	*ProfileSerializedCreateSpec

	// Host for profile validation. This can be a host on which
	// the profile is intended to be used.
	ValidatorHost *HostSystem
}

//
// The HostProxySwitch is a software entity which represents the component
// of a DistributedVirtualSwitch on a particular host.
//
//
type HostProxySwitch struct {
	*DynamicData

	// The configured number of ports that this switch has.
	// If configured number of ports is changed,
	// a host reboot is required for the new value to take effect.
	//
	// Since vSphere API 5.0
	ConfigNumPorts int32

	// The name of the DistributedVirtualSwitch that the HostProxySwitch
	// is part of.
	DvsName string

	// The uuid of the DistributedVirtualSwitch that the HostProxySwitch
	// is a part of.
	DvsUuid string

	// The Link Aggregation Control Protocol group and
	// Uplink ports in the group.
	//
	// Since vSphere API 5.5
	HostLag []*HostProxySwitchHostLagConfig

	// The proxy switch key.
	Key string

	// The maximum transmission unit (MTU) associated with this switch
	// in bytes.
	Mtu int32

	// Indicates whether network reservation is supported on this switch
	//
	// Since vSphere API 5.5
	NetworkReservationSupported bool

	// The number of ports that this switch currently has.
	NumPorts int32

	// The number of ports that are available on this virtual switch.
	NumPortsAvailable int32

	// The set of physical network adapters associated with this switch.
	Pnic []string

	// The specification of the switch.
	Spec *HostProxySwitchSpec

	// The list of ports that can be potentially used by physical nics.
	// This property contains the keys and names of such ports.
	UplinkPort []*KeyValue
}

//
// This data object type describes the HostProxySwitch configuration
// containing both the configurable
// properties on a HostProxySwitch and identification information.
//
//
type HostProxySwitchConfig struct {
	*DynamicData

	// This property indicates the change operation to apply on
	// this configuration specification. Valid values are:
	//
	// edit
	// remove
	// See HostConfigChangeOperation
	ChangeOperation string

	// The specification of the HostProxySwitch.
	Spec *HostProxySwitchSpec

	// The uuid of the DistributedVirtualSwitch that the HostProxySwitch
	// is a part of.
	Uuid string
}

//
// This data object type describes the set of Uplink Ports in
// Link Aggregation Control Protocol group.
//
//
type HostProxySwitchHostLagConfig struct {
	*DynamicData

	LagKey string

	LagName string

	// The list of Uplink Ports in the Link Aggregation Control Protocol group.
	// This property contains the keys and names of such ports.
	UplinkPort []*KeyValue
}

//
// This data object type describes the HostProxySwitch specification
// representing the properties on a HostProxySwitch that can be
// configured once the object exists.
//
//
type HostProxySwitchSpec struct {
	*DynamicData

	// The specification describes how physical network adapters
	// are bridged to the switch.
	Backing *DistributedVirtualSwitchHostMemberBacking
}

//
// This event records a failed attempt to re-establish a host connection.
//
//
type HostReconnectionFailedEvent struct {
	*HostEvent
}

//
// Information about reliable memory installed on this host.
//
//
type HostReliableMemoryInfo struct {
	*DynamicData

	MemorySize int64
}

//
// This event records the removal of a host from VirtualCenter.
//
//
type HostRemovedEvent struct {
	*HostEvent
}

//
// Set of possible values for
// replayUnsupportedReason and
// replayCompatibilityIssues.
//
//
type HostReplayUnsupportedReason struct {
}

//
// The HostResignatureRescanResult data object
// identifies the newly created volume that is the result of a
// resignature operation. This data object is contained in the
// task object returned by the
// ResignatureUnresolvedVmfsVolume_Task
// method.
//
// When a client calls the resignature method, the Server
// resignatures the volume, rescans the specified list of hosts,
// and auto-mounts the volume on the other hosts that share the same
// underlying storage LUNs.
//
//
//
type HostResignatureRescanResult struct {
	*DynamicData

	// Deprecated.
	// As of vSphere API 5.1, the results of the operation
	// are available when the task completes. That is, for shared volumes,
	// the new volume is mounted on all of the connected hosts.
	//
	//
	// List of VMFS Rescan operation results.
	Rescan []*HostVmfsRescanResult

	// When an UnresolvedVmfsVolume has been resignatured, we want to return the
	// newly created VMFS Datastore.
	Result *Datastore
}

//
// This data object type describes the runtime state of a host.
//
//
type HostRuntimeInfo struct {
	*DynamicData

	// The time when the host was booted.
	BootTime time.Time

	// The host connection state. See the description in the enums for the
	// ConnectionState data object type.
	ConnectionState *enum.HostSystemConnectionState

	// The availability state of an active host in a vSphere HA enabled
	// cluster. A host is inactive if it is in maintenance or standby mode, or
	// it has been disconnected from vCenter Server. The active hosts in a cluster
	// form a vSphere HA fault domain.
	//
	// The property is unset if vSphere HA is disabled, the host is
	// in maintenance or standby mode, or the host is disconnected from
	// vCenter Server.
	//
	// Since vSphere API 5.0
	DasHostState *ClusterDasFdmHostState

	// Available system  health status
	//
	// Since VI API 2.5
	HealthSystemRuntime *HealthSystemRuntime

	// The maximum theoretical virtual disk capacity supported by this host
	//
	// Since vSphere API 5.5
	HostMaxVirtualDiskCapacity int64

	// The flag to indicate whether or not the host is in maintenance mode. This
	// flag is set when the host has entered the maintenance mode. It is not set
	// during the entering phase of maintenance mode.See EnterMaintenanceMode_TaskSee ExitMaintenanceMode_Task
	InMaintenanceMode bool

	// This property is for getting network related runtime info
	//
	// Since vSphere API 5.5
	NetworkRuntimeInfo *HostRuntimeInfoNetworkRuntimeInfo

	// The host power state. See the description in the enums for the
	// PowerState data object type.
	//
	// Since VI API 2.5
	PowerState *enum.HostSystemPowerState

	// The host's standby mode. For valid values see
	// HostStandbyMode. The property is only populated by
	// vCenter server. If queried directly from a ESX host, the property is
	// is unset.
	//
	// Since vSphere API 4.1
	StandbyMode string

	// Deprecated.
	// As of
	//
	//
	// The array of PCR digest values stored in the TPM device since the last
	// host boot time.
	//
	//
	// Since vSphere API 4.0
	TpmPcrValues []*HostTpmDigestInfo

	// Runtime information of vFlash resource of the host.
	//
	// Since vSphere API 5.5
	VFlashResourceRuntimeInfo *HostVFlashManagerVFlashResourceRunTimeInfo

	// Host Runtime information related to the VSAN service.
	// See VsanHostRuntimeInfo
	//
	// Since vSphere API 5.5
	VsanRuntimeInfo *VsanHostRuntimeInfo
}

//
// This data type describes network stack instance runtime info
//
//
type HostRuntimeInfoNetStackInstanceRuntimeInfo struct {
	*DynamicData

	// If true then dual IPv4/IPv6 stack enabled else IPv4 only.
	CurrentIpV6Enabled bool

	// The maximum number of socket connections can be worked on this
	// instance currently after booting up.
	MaxNumberOfConnections int32

	// Key of the instance
	NetStackInstanceKey string

	// State of the instance
	// See State for valid values.
	State string

	// The keys of vmknics that are using this stack
	VmknicKeys []string
}

//
// Define the instance state type
//
//
type HostRuntimeInfoNetStackInstanceRuntimeInfoState struct {
}

//
// This data type describes network related runtime info
//
//
type HostRuntimeInfoNetworkRuntimeInfo struct {
	*DynamicData

	// The list of network stack runtime info
	NetStackInstanceRuntimeInfo []*HostRuntimeInfoNetStackInstanceRuntimeInfo
}

//
// This data object type describes a SCSI disk.  A SCSI disk contains a
// partition table which can be changed.
// To change a SCSI disk, use the device name and the partition specification.See RetrieveDiskPartitionInfoSee UpdateDiskPartitions
//
//
type HostScsiDisk struct {
	*ScsiLun

	// The size of SCSI disk using the Logical Block Addressing scheme.
	Capacity *HostDiskDimensionsLba

	// The device path of the ScsiDisk.  This device path is a file path
	// that can be opened to create partitions on the disk.See RetrieveDiskPartitionInfoSee UpdateDiskPartitions
	DevicePath string

	// Indicates whether the ScsiDisk is SSD backed.
	// If unset, the information whether the ScsiDisk is SSD backed
	// is unknown.
	//
	// Since vSphere API 5.0
	Ssd bool
}

//
// This data object type describes the specification of a Disk partition.
//
//
type HostScsiDiskPartition struct {
	*DynamicData

	// The SCSI disk device on which a VMware File System (VMFS)
	// extent resides.See HostScsiDiskSee canonicalName
	DiskName string

	// The partition number of the partition on the ScsiDisk.
	Partition int32
}

//
// This data object type describes the SCSI topology information.  The
// data objects in this data object type model the
// SCSI storage objects from a topological point of view.  The SCSI topological
// view organizes objects by SCSI interface, which contain targets, which in
// turn contain logical units.
//
// SCSI Topology information is not guaranteed to exhaustively enumerate all
// storage devices on the system.  It only shows storage devices that are
// actually enumerable form a host bus adapter.  This means that only storage
// devices that are composed from one or more paths, which are in turn provided
// by a host bus adapter, will appear in this inventory.
//
//
// Storage devices provided by the native multipathing plugin (NMP) will always
// be represented in this inventory since NMP uses a simple policy to create
// devices out of the paths it claims.
//
//
// Examples of storage devices that will not appear in this inventory are
// logical devices that are not formed from directly claiming paths.  Specific
// examples of devices that will not appear in this inventory include a device
// backed by a ramdisk or formed from a software RAID plugin.
//
//
// Legacy note: In hosts where HostPlugStoreTopology is not
// defined or does not exist on the HostStorageDeviceInfo object,
// only native multipathing exists.  That means for these hosts, the
// ScsiTopology object contains the complete set of LUNs and targets
// available on the host.
//
//
//
type HostScsiTopology struct {
	*DynamicData

	// The list of SCSI interfaces.
	Adapter []*HostScsiTopologyInterface
}

//
// This data object type describes the SCSI interface that is associated
// with a list of targets.
//
//
type HostScsiTopologyInterface struct {
	*DynamicData

	// The link to data for this SCSI interface.
	Adapter string

	// The identifier for the SCSI interface
	Key string

	// The list of targets to which the SCSI interface is associated.
	Target []*HostScsiTopologyTarget
}

//
// This data object type describes the SCSI logical unit.
//
//
type HostScsiTopologyLun struct {
	*DynamicData

	// The identifier for the SCSI Lun
	Key string

	// The logical unit number of the SCSI logical unit.
	Lun int32

	// The link to data for this SCSI logical unit.
	ScsiLun string
}

//
// This data object type describes the SCSI target that is associated
// with a list of logical units.
//
//
type HostScsiTopologyTarget struct {
	*DynamicData

	// The identifier for the SCSI target
	Key string

	// The list of SCSI logical units with which a target is associated.
	Lun []*HostScsiTopologyLun

	// The target identifier.
	Target int32

	// SCSI Transport information about the target.
	Transport *HostTargetTransport
}

//
// DataObject used for configuring the Security settings
//
//
type HostSecuritySpec struct {
	*DynamicData

	// Permissions to add
	//
	// Since vSphere API 4.1
	AddPermission []*Permission

	// Administrator password to configure
	AdminPassword string

	// Permissions to remove
	//
	// Since vSphere API 4.1
	RemovePermission []*Permission
}

//
// Data object that describes a single service that runs on the host.
//
//
type HostService struct {
	*DynamicData

	// Brief identifier for the service.
	Key string

	// Display label for the service.
	Label string

	// Service activation policy.See Policy
	Policy string

	// Flag indicating whether the service is required and cannot be disabled.
	Required bool

	// List of firewall rulesets used by this service.  Must come from the
	// list of rulesets in ruleset.
	Ruleset []string

	// Flag indicating whether the service is currently running.
	Running bool

	// The source package associated with the service
	//
	// Since vSphere API 5.0
	SourcePackage *HostServiceSourcePackage

	// Deprecated.
	// This flag is unimplemented and will always be set to false.
	//
	//
	// Flag indicating whether the service can be uninstalled.
	Uninstallable bool
}

//
// DataObject representing configuration for a particular
// service.
//
//
type HostServiceConfig struct {
	*DynamicData

	// Key of the service to configure.
	ServiceId string

	// Startup policy which defines how the service be configured.
	// See
	StartupPolicy string
}

//
// Data object describing the host service configuration.
//
//
type HostServiceInfo struct {
	*DynamicData

	// List of configured services.
	Service []*HostService
}

//
// Set of valid service policy strings.
//
//
type HostServicePolicy struct {
}

type HostServiceSourcePackage struct {
	*DynamicData

	// The description of the source package
	Description string

	// The name of the source package
	SourcePackageName string
}

//
// The HostServiceSystem managed object describes the configuration
// of host services.  This managed object operates in conjunction
// with the HostFirewallSystem
// managed object.
//
type HostServiceSystem struct {
	*ExtensibleManagedObject

	serviceInfo *HostServiceInfo
}

// Service configuration.
func (mo *HostServiceSystem) ServiceInfo() (*HostServiceInfo, error) {
	t, err := mo.currentProperty("serviceInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostServiceInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostServiceInfo")
	}
	return v, nil
}

//
// Refresh the service information and settings to pick up any changes
// made directly on the host.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostServiceSystem) RefreshServices(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Restarts the service.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostServiceSystem) RestartService(
	_this *ManagedObjectReference, id string,
) error {

	return nil

}

//
// Starts the service.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostServiceSystem) StartService(
	_this *ManagedObjectReference, id string,
) error {

	return nil

}

//
// Stops the service.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostServiceSystem) StopService(
	_this *ManagedObjectReference, id string,
) error {

	return nil

}

//
// Uninstalls the service.  If the service is running, it is
// stopped before being uninstalled.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostServiceSystem) UninstallService(
	_this *ManagedObjectReference, id string,
) error {

	return nil

}

//
// Updates the activation policy of the service.
//
// Required Privileges
// Host.Config.NetService
//
func (mo *HostServiceSystem) UpdateServicePolicy(
	_this *ManagedObjectReference, id string, policy string,
) error {

	return nil

}

//
// Return value for ticketable host services. The server has the option to
// provide a hostname and port for a future ticket-authenticated connection to
// a service on a host. If the service provider does not return a host the
// client must connect to the same host it used to request the ticket. In case
// the service provider does not return a port, except in the case of connecting
// to CIM interfaces, the client must connect using the same port it used to
// request the ticket. In the case of connecting to a CIM interface the
// standard well known port number for the particular service will be used for
// the connection.
//
// For example, when a client requests a ticket from an ESX Server, the returned ticket
// may omit the optional host and port. In such a case, the client establishes an
// out-of-band ticketed connection to the same server host and on the same port on
// which it made the connection to request the ticket. If this request is
// made to the VirtualCenter server, but the server does not provide the required
// service directly, then the server provides a hostname and port for a server that
// accepts the ticketed connection and provides the service.
//
//
//
type HostServiceTicket struct {
	*DynamicData

	// The name of the host providing the service for which the ticket applies. If
	// omitted, then the client uses the host name for the server that issued the ticket.
	Host string

	// Access to some services is made possible by connecting to a port on a
	// server. If the service for which a ticket is issued is available on a
	// particular port, that port number is specified with this property. If
	// omitted, except in the case of connecting to CIM interfaces, the port
	// number for the service that issued the ticket is used. In the case of
	// connecting to a CIM interface the standard well known port for the
	// particular service will be used for the connection.
	Port int32

	// The name of the service to which to connect.
	Service string

	// A dot-separated string identifying the service protocol version. For example, 1.0
	// is used for NFC hosted by vpxa on ESX 2.5, and 1.1 is used for
	// NFC hosted by hostd on ESX 3.0.
	ServiceVersion string

	// An identifying string for the session created for the ticketed connection. This
	// is used by the host service to identify the operations permitted within the
	// session.
	SessionId string

	// The expected thumbprint of the SSL cert of the host to which
	// we are connecting.
	//
	// Since VI API 2.5
	SslThumbprint string
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that host name resolution returned different names on
// the host. Please check your host's network configuration and your DNS
// configuration. There may be duplicate entries.
//
//
type HostShortNameInconsistentEvent struct {
	*HostDasEvent

	ShortName string

	ShortName2 string
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that the host's short name could not be resolved to an IP address.
//
//
type HostShortNameToIpFailedEvent struct {
	*HostEvent

	ShortName string
}

//
// This event records the shutdown of a host.
//
//
type HostShutdownEvent struct {
	*HostEvent

	// The reason for the host shutdown.
	Reason string
}

//
// SNMP Agent supported capabilities enum
//
//
type HostSnmpAgentCapability struct {
}

type HostSnmpConfigSpec struct {
	*DynamicData

	Enabled bool

	// Since vSphere API 5.0
	Option []*KeyValue

	Port int32

	ReadOnlyCommunities []string

	TrapTargets []*HostSnmpDestination
}

//
// Defines a receiver for SNMP Notifications
//
//
type HostSnmpDestination struct {
	*DynamicData

	Community string

	// A system listening for SNMP notifications.
	// These must be a IPv4 unicast address or resolvable dns name.
	HostName string

	// UDP port to Notification receiver is listening on. udp/162 is
	// the reserved port
	Port int32
}

//
// Provision the SNMP Version 1,2c agent.
// This object is accessed through the
// HostConfigManager object.
//
type HostSnmpSystem struct {
	*ManagedObject

	configuration *HostSnmpConfigSpec

	limits *HostSnmpSystemAgentLimits
}

// Since VI API 2.5
// Required Privilege: Global.Settings
func (mo *HostSnmpSystem) Configuration() (*HostSnmpConfigSpec, error) {
	t, err := mo.currentProperty("configuration")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostSnmpConfigSpec)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostSnmpConfigSpec")
	}
	return v, nil
}

// Since VI API 2.5
// Required Privilege: Global.Settings
func (mo *HostSnmpSystem) Limits() (*HostSnmpSystemAgentLimits, error) {
	t, err := mo.currentProperty("limits")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostSnmpSystemAgentLimits)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostSnmpSystemAgentLimits")
	}
	return v, nil
}

//
//
// Required Privileges
// Global.Settings
// Since
// VI API 2.5
//
func (mo *HostSnmpSystem) ReconfigureSnmpAgent(
	_this *ManagedObjectReference, spec *HostSnmpConfigSpec,
) error {

	return nil

}

//
//
// Required Privileges
// Global.Settings
// Since
// VI API 2.5
//
func (mo *HostSnmpSystem) SendTestNotification(
	_this *ManagedObjectReference,
) error {

	return nil

}

type HostSnmpSystemAgentLimits struct {
	*DynamicData

	// Supported Capability for this agent
	//
	// Since vSphere API 4.0
	Capability *enum.HostSnmpAgentCapability

	// SNMP input buffer size
	MaxBufferSize int32

	// Max length of community
	MaxCommunityLength int32

	// number of allowed communities
	MaxReadOnlyCommunities int32

	// number of allowed destinations for notifications
	MaxTrapDestinations int32
}

//
// This data object allows configuration of SR-IOV device.
//
//
type HostSriovConfig struct {
	*HostPciPassthruConfig

	// Number of SR-IOV virtual functions to enable on this device
	NumVirtualFunction int32

	// enable SR-IOV for this device
	SriovEnabled bool
}

//
// This data object provides information about the state of SR-IOV device.
//
//
type HostSriovInfo struct {
	*HostPciPassthruInfo

	// Maximum number of SRIOV virtual functions supported on this device
	MaxVirtualFunctionSupported int32

	// Number of SRIOV virtual functions present on this device
	NumVirtualFunction int32

	// Number of SRIOV virtual functions requested for this device
	NumVirtualFunctionRequested int32

	// Whether SRIOV is active for this device (meaning enabled + rebooted)
	SriovActive bool

	// Whether SRIOV is possible for this device
	SriovCapable bool

	// Whether SRIOV has been enabled by the user
	SriovEnabled bool
}

//
// The SSL thumbprint information for a host managed by a vCenter Server
// or a vCenter extension to login into other hosts without
// username/password authentication.
//
//
type HostSslThumbprintInfo struct {
	*DynamicData

	// The tag associated with this registration.  Owner tags allow
	// multiple entities to register the same thumbprint without
	// interfering with each other on the life cycle of the thumbprint with
	// their unique tags.
	//
	// Each solution should use a unique tag to identify itself.
	//
	// Since vSphere API 5.0
	OwnerTag string

	// The principal used for the login session
	Principal string

	// Specify the SSL thumbprints to register on the host.
	SslThumbprints []string
}

//
// Defines a host's standby mode.
//
//
type HostStandbyMode struct {
}

//
// This event records when a host's overall status changed.
//
//
type HostStatusChangedEvent struct {
	*ClusterStatusChangedEvent
}

//
// Description of options associated with a native multipathing
// storage array type plugin.
//
//
type HostStorageArrayTypePolicyOption struct {
	*DynamicData

	// Description of the paths selection policy.  Use the key as the
	// identifier.
	Policy *ElementDescription
}

//
// This data object type describes the storage subsystem configuration.
//
//
type HostStorageDeviceInfo struct {
	*DynamicData

	// The list of host bus adapters available on the host.
	HostBusAdapter []*HostHostBusAdapter

	// The multipath configuration that controls multipath policy for ScsiLuns.
	// This data object exists only if path information is available and is
	// configurable.
	MultipathInfo *HostMultipathInfo

	// The plug-store topology on the host system.  This data object exists only if
	// the plug-store system is available and configurable.
	//
	// Since vSphere API 4.0
	PlugStoreTopology *HostPlugStoreTopology

	// The list of SCSI logical units available on the host.
	ScsiLun []*ScsiLun

	// Storage topology view of SCSI storage devices.  This data object
	// exists only if storage topology information is available.  See the
	// ScsiTopology data object type for
	// more information.
	ScsiTopology *HostScsiTopology

	// Indicates if the software iSCSI initiator is enabled on this system
	SoftwareInternetScsiEnabled bool
}

//
// Data object describing the operational status of various storage
// elements.
//
//
type HostStorageElementInfo struct {
	*HostHardwareElementInfo

	// Other information regarding the operational state of the
	// storage element.
	OperationalInfo []*HostStorageOperationalInfo
}

//
// Data class describing operational information of a storage element
//
//
type HostStorageOperationalInfo struct {
	*DynamicData

	// The property of interest for the storage element
	Property string

	// The property value for the storage element
	Value string
}

//
// This managed object gets and sets configuration information
// about the host's storage subsystem.  The properties and operations are
// used to configure the host to make storage available for virtual machines.
//
// This object contains properties that are specific to ESX Server and
// general to both the ESX Server system and the hosted architecture.
//
type HostStorageSystem struct {
	*ExtensibleManagedObject

	fileSystemVolumeInfo *HostFileSystemVolumeInfo

	multipathStateInfo *HostMultipathStateInfo

	storageDeviceInfo *HostStorageDeviceInfo

	systemFile []string
}

// File system volume information for the host.  See the
// FileSystemVolumeInfo data
// object type for more information.
func (mo *HostStorageSystem) FileSystemVolumeInfo() (*HostFileSystemVolumeInfo, error) {
	t, err := mo.currentProperty("fileSystemVolumeInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostFileSystemVolumeInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostFileSystemVolumeInfo")
	}
	return v, nil
}

// Runtime information about the state of a multipath path.
// A null value will be returned if path state information is not available
// for this system.
//
// In systems prior to the plug-store architecture, the state of a path
// may be accessible on the HostMultipathInfo data object
// of the storageDeviceInfo property.
//
// Since vSphere API 4.0
func (mo *HostStorageSystem) MultipathStateInfo() (*HostMultipathStateInfo, error) {
	t, err := mo.currentProperty("multipathStateInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostMultipathStateInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostMultipathStateInfo")
	}
	return v, nil
}

// Host storage information up to the device level.
func (mo *HostStorageSystem) StorageDeviceInfo() (*HostStorageDeviceInfo, error) {
	t, err := mo.currentProperty("storageDeviceInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostStorageDeviceInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostStorageDeviceInfo")
	}
	return v, nil
}

// Datastore paths of files used by the host system on
// mounted volumes, for instance, the COS vmdk file of the
// host. For information on datastore paths, see Datastore.
//
// Since vSphere API 4.1
func (mo *HostStorageSystem) SystemFile() ([]string, error) {
	t, err := mo.currentProperty("systemFile")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]string)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []string")
	}
	return v, nil
}

//
// Adds Send Target entries to the host bus adapter discovery list.
// The DiscoveryProperties.sendTargetsDiscoveryEnabled flag
// must be set to true.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) AddInternetScsiSendTargets(
	_this *ManagedObjectReference, iScsiHbaDevice string, targets []*HostInternetScsiHbaSendTarget,
) error {

	return nil

}

//
// Adds Static Target entries to the host bus adapter discovery list.
// The DiscoveryProperty.staticTargetDiscoveryEnabled must be set to true.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) AddInternetScsiStaticTargets(
	_this *ManagedObjectReference, iScsiHbaDevice string, targets []*HostInternetScsiHbaStaticTarget,
) error {

	return nil

}

//
// Allow I/O issue to the specified detached ScsiLun. The ScsiLun is
// administratively configured on, if the attach operation is successful.
// See DetachScsiLun.
//
// attachScsiLun is part of the Unmount, Detach workflow used
// when a device will be permanently removed.
// See also UnmountVmfsVolume.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.0
//
func (mo *HostStorageSystem) AttachScsiLun(
	_this *ManagedObjectReference, lunUuid string,
) error {

	return nil

}

//
// Extends a VMFS by attaching a disk partition as an extent.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) AttachVmfsExtent(
	_this *ManagedObjectReference, vmfsPath string, extent *HostScsiDiskPartition,
) error {

	return nil

}

//
// Computes the disk partition information given the desired disk layout.
// The server computes a new partition information object for a specific
// disk representing the desired layout.See HostDiskPartitionInfoPartitionFormat
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) ComputeDiskPartitionInfo(
	_this *ManagedObjectReference, devicePath string, layout *HostDiskPartitionLayout, partitionFormat string,
) (*HostDiskPartitionInfo, error) {

	return nil, nil

}

//
// Computes the disk partition information for the purpose of resizing
// a given partition.See HostDiskPartitionInfoPartitionFormat
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) ComputeDiskPartitionInfoForResize(
	_this *ManagedObjectReference, partition *HostScsiDiskPartition, blockRange *HostDiskPartitionBlockRange, partitionFormat string,
) (*HostDiskPartitionInfo, error) {

	return nil, nil

}

//
// For previously detached SCSI Lun, remove the state information from
// host.
//
// Detach SCSI Lun marks the device where I/Os are not allowed.
// Host still maintains the entry of this device and its state.
// If a LUN is detached using detachScsiLun, ESX will not automatically
// attach this LUN durng a rescan or after a reboot.
// See DetachScsiLun.
//
// Please note: The API takes 'canonicalName' of the ScsiLun object
// instead of the ScsiLun.uuid.See canonicalName
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.1
//
func (mo *HostStorageSystem) DeleteScsiLunState(
	_this *ManagedObjectReference, lunCanonicalName string,
) error {

	return nil

}

//
// For previously unmounted VFFS volume, remove the state information from
// host.
//
// VFFS volumes mount state is maintained by host.
//
// deleteVffsVolumeState is part of the Unmount/Detach workflow used
// when the device will be permanently removed.
// See also UnmountVffsVolume.
//
// If the VFFS volume is unmounted using unmountVffsVolume, ESX maintains
// the state of VFFS volume. This API will remove the state from the host.
//
// If the underlying storage device is going to be un-provisioned on the
// array side, please detach the storage device.
// See also DetachScsiLun.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) DeleteVffsVolumeState(
	_this *ManagedObjectReference, vffsUuid string,
) error {

	return nil

}

//
// For previously unmounted VMFS volume, remove the state information from
// host.
//
// VMFS volumes mount state is maintained by host.
//
//
// deleteVmfsVolumeState is part of the Unmount/Detach workflow used
// when the device will be permanently removed.
// See also UnmountVmfsVolume.
//
// If the VMFS volume is unmounted using unmountVmfsVolume, ESX maintains
// the state of VMFS volume. This API will remove the state from the host.
//
// If the underlying storage device is going to be un-provisioned on the
// array side, please detach the storage device.
// See also DetachScsiLun.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.1
//
func (mo *HostStorageSystem) DeleteVmfsVolumeState(
	_this *ManagedObjectReference, vmfsUuid string,
) error {

	return nil

}

//
// Destroy a VFFS volume.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) DestroyVffs(
	_this *ManagedObjectReference, vffsPath string,
) error {

	return nil

}

//
// Disallow I/O issue to the specified ScsiLun. The ScsiLun is
// detached, i.e. administratively configured off until a subsequent
// attachScsiLun is performed, if the operation is successful.
// See AttachScsiLun.
//
// detachScsiLun is part of the Unmount / Detach workflow used
// when a device will be permanently removed.
// See also UnmountVmfsVolume.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.0
//
func (mo *HostStorageSystem) DetachScsiLun(
	_this *ManagedObjectReference, lunUuid string,
) error {

	return nil

}

//
// Disables an enabled path for a Logical Unit.
// Use the path name from HostMultipathStateInfoPath
// or HostMultipathInfoPath.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) DisableMultipathPath(
	_this *ManagedObjectReference, pathName string,
) error {

	return nil

}

//
// Initiates FCoE discovery using the given FcoeSpecification.
//
// Upon success, discovered VNPorts will have registered with the
// system as FCoE HBAs.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.0
//
func (mo *HostStorageSystem) DiscoverFcoeHbas(
	_this *ManagedObjectReference, fcoeSpec *FcoeConfigFcoeSpecification,
) error {

	return nil

}

//
// Enables a disabled path for a Logical Unit.
// Use the path name from HostMultipathStateInfoPath
// or HostMultipathInfoPath.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) EnableMultipathPath(
	_this *ManagedObjectReference, pathName string,
) error {

	return nil

}

//
// Expands a VMFS extent as specified by the Disk partition specification.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) ExpandVmfsExtent(
	_this *ManagedObjectReference, vmfsPath string, extent *HostScsiDiskPartition,
) error {

	return nil

}

//
// Extends a VFFS by attaching a SSD.See devicePath
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) ExtendVffs(
	_this *ManagedObjectReference, vffsPath string, devicePath string, spec *HostDiskPartitionSpec,
) error {

	return nil

}

//
// Format a new VFFS on a SSD disk
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) FormatVffs(
	_this *ManagedObjectReference, createSpec *HostVffsSpec,
) (*HostVffsVolume, error) {

	return nil, nil

}

//
// Formats a new VMFS on a disk partition.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) FormatVmfs(
	_this *ManagedObjectReference, createSpec *HostVmfsSpec,
) (*HostVmfsVolume, error) {

	return nil, nil

}

//
// Mark or unmark the given FCoE HBA for removal from the host system.
//
// Marking an FCoE HBA for removal will result in the HBA
// not being discovered upon host reboot.  Until reboot,
// the HBA remains visible in the storage topology.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.0
//
func (mo *HostStorageSystem) MarkForRemoval(
	_this *ManagedObjectReference, hbaName string, remove bool,
) error {

	return nil

}

//
// Mount the unmounted VFFS volume.  See UnmountVffsVolume.
//
// mountVffsVolume is part of the Unmount / Detach workflow used
// when a device will be permanently removed.
// See also DetachScsiLun.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) MountVffsVolume(
	_this *ManagedObjectReference, vffsUuid string,
) error {

	return nil

}

//
// Mount the unmounted Vmfs volume. A newly discovered vmfs volume will be
// mounted unless, it has been explicitly unmounted. The default mount
// behavior of Vmfs volumes is auto-mount. See UnmountVmfsVolume.
//
// mountVmfsVolume is part of the Unmount / Detach workflow used
// when a device will be permanently removed.
// See also DetachScsiLun.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.0
//
func (mo *HostStorageSystem) MountVmfsVolume(
	_this *ManagedObjectReference, vmfsUuid string,
) error {

	return nil

}

//
// Query the list SSD disks that can be used to contain a VFFS volume.
// If the optional parameter name is supplied, queries for the SSD
// disks that can be used to contain extents of the specified VFFS volume. Otherwise,
// the method retrieves the SSD disks that can be used to contain the new VFFS volume.
//
// This operation will filter out SSD disks that are currently in use by an existing VFFS volume.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) QueryAvailableSsds(
	_this *ManagedObjectReference, vffsPath string,
) ([]*HostScsiDisk, error) {

	return nil, nil

}

//
// Queries the set of path selection policy options.  The set of policy
// options indicates what path selection policies can be used by a
// device managed by native multipathing.  Devices managed through native
// multipathing are described in the HostMultipathInfo data
// object.
//
// Filtering capabilities are not currently present but may be added in
// the future.
//
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) QueryPathSelectionPolicyOptions(
	_this *ManagedObjectReference,
) ([]*HostPathSelectionPolicyOption, error) {

	return nil, nil

}

//
// Queries the set of storage array type policy options.  The set of policy
// options indicates what storage array type policies can be used by a
// device managed by native multipathing.  Devices managed through native
// multipathing are described in the HostMultipathInfo data
// object.
//
// Filtering capabilities are not currently present but may be added in
// the future.
//
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) QueryStorageArrayTypePolicyOptions(
	_this *ManagedObjectReference,
) ([]*HostStorageArrayTypePolicyOption, error) {

	return nil, nil

}

//
// Get the list of unbound VMFS volumes.
// For sharing a volume across hosts, a VMFS volume is bound to its
// underlying block device storage. When a low level block copy is
// performed to copy or move the VMFS volume, the copied volume will
// be unbound.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) QueryUnresolvedVmfsVolume(
	_this *ManagedObjectReference,
) ([]*HostUnresolvedVmfsVolume, error) {

	return nil, nil

}

//
// Obtains the latest host storage information related to storage devices, topology,
// and file systems. The ESX host updates its storage information asynchronously.
// The RefreshStorageSystem method obtains information from
// the host platform and it performs a rescan of VMFS volumes. It does not look for new devices.
//
// This method may update the following inventory elements:
//
//
//
// • Devices and storage topology
// (HostSystem.config.storageDevice).
//
// • VMFS and NFS datastores (HostSystem.datastore).
//
// • File system volumes
// (HostSystem.config.fileSystemVolume).
//
//
//
//
// The Server performs asynchronous updates to the inventory. Use the
// PropertyCollector.WaitForUpdatesEx
// method to obtain the property changes.
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) RefreshStorageSystem(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Removes Send Target entries from the host bus adapter discovery list.
// The DiscoveryProperty.sendTargetsDiscoveryEnabled must be set to true.
// If any of the targets provided as parameters are not found in
// the existing list, the other targets are removed and an exception
// is thrown.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) RemoveInternetScsiSendTargets(
	_this *ManagedObjectReference, iScsiHbaDevice string, targets []*HostInternetScsiHbaSendTarget,
) error {

	return nil

}

//
// Removes static target entries from the host bus adapter discovery list.
// The DiscoveryProperty.staticTargetDiscoveryEnabled must be set to true.
// If any of the targets provided as parameters are not found in
// the existing list, the other targets are removed and an exception
// is thrown.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) RemoveInternetScsiStaticTargets(
	_this *ManagedObjectReference, iScsiHbaDevice string, targets []*HostInternetScsiHbaStaticTarget,
) error {

	return nil

}

//
// Scans all host bus adapters to obtain the current list of devices and device topology.
// The RescanAllHba method looks for new devices,
// removed devices, and path changes.
//
// This method may update the following inventory elements:
//
//
//
// • Devices and storage topology
// (HostSystem.config.storageDevice).
//
// • VMFS and NFS datastores (HostSystem.datastore).
//
// • File system volumes (HostSystem.config.fileSystemVolume).
//
//
//
//
// The Server performs asynchronous updates to the inventory. Use the
// PropertyCollector.WaitForUpdatesEx
// method to obtain the property changes.
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) RescanAllHba(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Issues a request to rescan a specific host bus adapter
// for new storage devices.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) RescanHba(
	_this *ManagedObjectReference, hbaDevice string,
) error {

	return nil

}

//
// Rescans for new VFFS.
// The RefreshStorageSystem method also performs a VFFS rescan.
//
// RescanVffs may update the
// HostSystem.config.fileSystemVolume property.
// The Server performs asynchronous updates to the inventory. Use the
// PropertyCollector.WaitForUpdatesEx
// method to obtain the property changes.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) RescanVffs(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Rescans for new Virtual Machine File Systems (VMFS).
// The RefreshStorageSystem method also performs a VMFS rescan.
//
// RescanVmfs may update the
// HostSystem.config.fileSystemVolume property.
// The Server performs asynchronous updates to the inventory. Use the
// PropertyCollector.WaitForUpdatesEx
// method to obtain the property changes.
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) RescanVmfs(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Resignature or 'Force Mount' list of unbound VMFS volumes.
//
// To safely enable sharing of the volume across hosts, a VMFS volume
// is bound to its underlying block device storage.  When a low level
// block copy is performed to copy or move the VMFS volume, the copied
// volume will be unbound.  In order for the VMFS volume to be usable,
// a resolution operation is needed to determine whether the VMFS volume
// should be treated as a new volume or not and what extents compose
// that volume in the event there is more than one unbound volume.
//
// Resignature results in a new VMFS volume on the host.
// Operations performed at the StorageSystem interface apply only to a
// specific host.  Hence, callers of this method are responsible for
// issuing rescan operations to detect the new VMFS volume on other hosts.
// Alternatively, callers that want VirtualCenter to handle rescanning
// the necessary hosts should use the DatastoreSystem interface.
//
//
// When user wants to keep the original Vmfs Uuid and  mount it
// on the host, set the 'resolutionSpec.uuidResolution' to 'forceMounted'
// This is per-host operation.
//
// It will return an array of ResolutionResult describing success or failure
// associated with each specification.
//
//
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) ResolveMultipleUnresolvedVmfsVolumes(
	_this *ManagedObjectReference, resolutionSpec []*HostUnresolvedVmfsResolutionSpec,
) ([]*HostUnresolvedVmfsResolutionResult, error) {

	return nil, nil

}

//
// Resignature or 'Force Mount' list of unbound VMFS volumes.
//
// To safely enable sharing of the volume across hosts, a VMFS volume
// is bound to its underlying block device storage.  When a low level
// block copy is performed to copy or move the VMFS volume, the copied
// volume will be unbound.  In order for the VMFS volume to be usable,
// a resolution operation is needed to determine whether the VMFS volume
// should be treated as a new volume or not and what extents compose
// that volume in the event there is more than one unbound volume.
//
//
// Resignature results in a new VMFS volume on the host.
// Operations performed at the HostStorageSystem interface apply only to a
// specific host.  Hence, callers of this method are responsible for
// issuing rescan operations to detect the new VMFS volume on other hosts.
// Alternatively, callers that want VirtualCenter to handle rescanning
// the necessary hosts should use the HostDatastoreSystem interface.
//
//
// When user wants to keep the original VMFS UUID and mount it
// on the host, set the resolutionSpec.uuidResolution
// (uuidResolution)
// to forceMount.
// This is per-host operation.
//
//
// It will return an array of HostUnresolvedVmfsResolutionResult
// describing success or failure associated with each specification.
//
//
// This method behaves the same as ResolveMultipleUnresolvedVmfsVolumes
// except that it returns a task to support monitoring the operation.
// This is important for operations with large number of
// unresolved volumes which may take potentially dozens of minutes to complete.
//
//
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) ResolveMultipleUnresolvedVmfsVolumesEx_Task(
	_this *ManagedObjectReference, resolutionSpec []*HostUnresolvedVmfsResolutionSpec,
) (*Task, error) {

	return nil, nil

}

//
// Gets the partition information for the disks named by the device names.
//
// Required Privileges
// System.Read
//
func (mo *HostStorageSystem) RetrieveDiskPartitionInfo(
	_this *ManagedObjectReference, devicePath []string,
) ([]*HostDiskPartitionInfo, error) {

	return nil, nil

}

//
// Updates the path selection policy for a Logical Unit.
// Use the LUN uuid from HostMultipathInfoLogicalUnit.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) SetMultipathLunPolicy(
	_this *ManagedObjectReference, lunId string, policy *HostMultipathInfoLogicalUnitPolicy,
) error {

	return nil

}

//
// Unmount the 'forceMounted' Vmfs volume.
//
// When a low level block copy is performed to copy or move the
// VMFS volume, the copied volume is unresolved. For the VMFS
// volume to be usable, a resolution operation is applied. As
// part of resolution operation, user may decide to keep the
// original VMFS Uuid. Once the resolution is applied, the VMFS
// volume is mounted on the host for its use. User can unmount
// the VMFS volume if it is not being used by any registered
// VMs.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) UnmountForceMountedVmfsVolume(
	_this *ManagedObjectReference, vmfsUuid string,
) error {

	return nil

}

//
// Unmount the VFFS volume. An unmounted volume cannot be used for any
// filesystem operation requiring I/O. In contrast to removal, this
// operation does not destroy or alter partitions on which VFFS volumes
// reside. The mountState will be persisted across filesystem rescans and
// host reboots. See MountVffsVolume.
//
// unmountVffsVolume is part of the Unmount / Detach workflow used
// when a device will be permanently removed.
// See also DetachScsiLun.
//
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.5
//
func (mo *HostStorageSystem) UnmountVffsVolume(
	_this *ManagedObjectReference, vffsUuid string,
) error {

	return nil

}

//
// Unmount the Vmfs volume. An unmounted volume cannot be used for any
// filesystem operation requiring I/O. In contrast to removal, this
// operation does not destroy or alter partitions on which vmfs volumes
// reside. The mountState will be persisted across filesystem rescans and
// host reboots. See MountVmfsVolume.
//
// unmountVmfsVolume is part of the Unmount / Detach workflow used
// when a device will be permanently removed.
//
//
// Mounted Vmfs Volume
// unmountVmfsVolume  |  ^ mountVmfsVolume
// V  |
// Unmounted Vmfs Volume
//
// Attached Scsi Device (honors I/O)
// detachScsiLun      |  ^ attachScsiLun
// V  |
// Detached Scsi Device (does not honor I/O)
//
//
// It is safe to unprovision a Lun from the Storage array *only*
// after a Scsi device is detached.
//
//
// The best practice for decommisioning a Lun would be to find
// out the set of subsystems that a Lun is being used for.
// Many of the systems are listed as exceptions in the
// function documentation.
//
//
// One typical workflow could be:
//
//
//
//
//
// • Find out if the device is used as a Vmfs Extent. (See VmfsVolume.Extent API)
//
// • Unmount the Vmfs Volume.
//
// • Find out if device is used by the Diagnostic system (See Diagnostic System API).
//
// • Deactivate the diagnostic system, if it is being used.
//
// • Find out if this device is used to back a VM's RDM (See VirtualMachine API).
//
// • Remove this device from the VM.
//
// • Detach the Scsi device.
//
// • On success, it is safe to decommision the Lun at this point.
//
//
//
// See also DetachScsiLun.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 5.0
//
func (mo *HostStorageSystem) UnmountVmfsVolume(
	_this *ManagedObjectReference, vmfsUuid string,
) error {

	return nil

}

//
// Changes the partitions on the disk by supplying a partition specification
// and the device name.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpdateDiskPartitions(
	_this *ManagedObjectReference, devicePath string, spec *HostDiskPartitionSpec,
) error {

	return nil

}

//
// Updates the advanced options the iSCSI host bus adapter or the
// discovery addresses and targets associated with it.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) UpdateInternetScsiAdvancedOptions(
	_this *ManagedObjectReference, iScsiHbaDevice string, targetSet *HostInternetScsiHbaTargetSet, options []*HostInternetScsiHbaParamValue,
) error {

	return nil

}

//
// Updates the alias of an iSCSI host bus adapter.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpdateInternetScsiAlias(
	_this *ManagedObjectReference, iScsiHbaDevice string, iScsiAlias string,
) error {

	return nil

}

//
// Updates the authentication properties for one or more targets or
// discovery addresses associated with an iSCSI host bus adapter.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpdateInternetScsiAuthenticationProperties(
	_this *ManagedObjectReference, iScsiHbaDevice string, authenticationProperties *HostInternetScsiHbaAuthenticationProperties, targetSet *HostInternetScsiHbaTargetSet,
) error {

	return nil

}

//
// Updates the digest properties for the iSCSI host bus adapter or the
// discovery addresses and targets associated with it.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) UpdateInternetScsiDigestProperties(
	_this *ManagedObjectReference, iScsiHbaDevice string, targetSet *HostInternetScsiHbaTargetSet, digestProperties *HostInternetScsiHbaDigestProperties,
) error {

	return nil

}

//
// Updates the Discovery properties for an iSCSI host bus adapter.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpdateInternetScsiDiscoveryProperties(
	_this *ManagedObjectReference, iScsiHbaDevice string, discoveryProperties *HostInternetScsiHbaDiscoveryProperties,
) error {

	return nil

}

//
// Updates the IP properties for an iSCSI host bus adapter.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpdateInternetScsiIPProperties(
	_this *ManagedObjectReference, iScsiHbaDevice string, ipProperties *HostInternetScsiHbaIPProperties,
) error {

	return nil

}

//
// Updates the name of an iSCSI host bus adapter.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpdateInternetScsiName(
	_this *ManagedObjectReference, iScsiHbaDevice string, iScsiName string,
) error {

	return nil

}

//
// Update the mutable display name associated with a ScsiLun.  The ScsiLun
// to be updated is identified using the specified uuid.
//
// Required Privileges
// Host.Config.Storage
// Since
// vSphere API 4.0
//
func (mo *HostStorageSystem) UpdateScsiLunDisplayName(
	_this *ManagedObjectReference, lunUuid string, displayName string,
) error {

	return nil

}

//
// Enables or disables Software iSCSI.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpdateSoftwareInternetScsiEnabled(
	_this *ManagedObjectReference, enabled bool,
) error {

	return nil

}

//
// Upgrades the VMFS to the latest
// supported VMFS version.
// Prerequisite:
// All hosts that have mounted the volume must support the VMFS
// version to which the volume will be upgraded.
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpgradeVmfs(
	_this *ManagedObjectReference, vmfsPath string,
) error {

	return nil

}

//
// Iterates over all registered virtual machines. For each VM which .vmx file
// is located on the service console and all disks are available on VMFS3 or NAS,
// it will relocate the disks into directories if stored in the ROOT, and
// relocate the VMX file into the directory too. Events are logged for each
// virtual machine that is relocated.
//
// On ESXi systems, this operation has no effect.
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostStorageSystem) UpgradeVmLayout(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// This event records a failure to sync up with the VirtualCenter agent on the host
//
//
type HostSyncFailedEvent struct {
	*HostEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// The HostSystem managed object type provides access to a virtualization
// host platform.
//
// Invoking destroy on a HostSystem of standalone type throws a NotSupported fault.
// A standalone HostSystem can be destroyed only by invoking destroy on its parent
// ComputeResource.
// Invoking destroy on a failover host throws a
// DisallowedOperationOnFailoverHost fault. See
// ClusterFailoverHostAdmissionControlPolicy.
//
//
//
type HostSystem struct {
	*ManagedEntity

	capability *HostCapability

	config *HostConfigInfo

	configManager *HostConfigManager

	datastore []*Datastore

	datastoreBrowser *HostDatastoreBrowser

	hardware *HostHardwareInfo

	licensableResource *HostLicensableResourceInfo

	network []*Network

	runtime *HostRuntimeInfo

	summary *HostListSummary

	systemResources *HostSystemResourceInfo

	vm []*VirtualMachine
}

// Host capabilities. This might not be available for a
// disconnected host.
func (mo *HostSystem) Capability() (*HostCapability, error) {
	t, err := mo.currentProperty("capability")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostCapability)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostCapability")
	}
	return v, nil
}

// Host configuration information.  This might not be available for a disconnected
// host.
func (mo *HostSystem) Config() (*HostConfigInfo, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostConfigInfo")
	}
	return v, nil
}

// Host configuration systems.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
func (mo *HostSystem) ConfigManager() (*HostConfigManager, error) {
	t, err := mo.currentProperty("configManager")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostConfigManager)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostConfigManager")
	}
	return v, nil
}

// A collection of references to the subset of datastore objects in the datacenter
// that are available in this HostSystem.
// Required Privilege: System.View
func (mo *HostSystem) Datastore() ([]*Datastore, error) {
	t, err := mo.currentProperty("datastore")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Datastore)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Datastore")
	}
	return v, nil
}

// DatastoreBrowser to browse datastores for this host.
// Required Privilege: System.View
func (mo *HostSystem) DatastoreBrowser() (*HostDatastoreBrowser, error) {
	t, err := mo.currentProperty("datastoreBrowser")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostDatastoreBrowser)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostDatastoreBrowser")
	}
	return v, nil
}

// Hardware configuration of the host. This might not be available for a
// disconnected host.
func (mo *HostSystem) Hardware() (*HostHardwareInfo, error) {
	t, err := mo.currentProperty("hardware")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostHardwareInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostHardwareInfo")
	}
	return v, nil
}

// Information about all licensable resources, currently present on this host.
// This information is used mostly by the modules, manipulating information
// in the LicenseManager. Developers of such modules
// should use this property instead of hardware.
// NOTE:
// The values in this property may not be accurate for pre-5.0 hosts when returned by vCenter 5.0
//
// Since vSphere API 5.0
func (mo *HostSystem) LicensableResource() (*HostLicensableResourceInfo, error) {
	t, err := mo.currentProperty("licensableResource")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostLicensableResourceInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostLicensableResourceInfo")
	}
	return v, nil
}

// A collection of references to the subset of network objects in the datacenter that
// are available in this HostSystem.
// Required Privilege: System.View
func (mo *HostSystem) Network() ([]*Network, error) {
	t, err := mo.currentProperty("network")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Network)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Network")
	}
	return v, nil
}

// Runtime state information about the host such as connection state.
func (mo *HostSystem) Runtime() (*HostRuntimeInfo, error) {
	t, err := mo.currentProperty("runtime")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostRuntimeInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostRuntimeInfo")
	}
	return v, nil
}

// Basic information about the host, including connection state.
func (mo *HostSystem) Summary() (*HostListSummary, error) {
	t, err := mo.currentProperty("summary")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostListSummary)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostListSummary")
	}
	return v, nil
}

// Reference for the system resource hierarchy, used for configuring the set of
// resources reserved to the system and unavailable to virtual machines.
func (mo *HostSystem) SystemResources() (*HostSystemResourceInfo, error) {
	t, err := mo.currentProperty("systemResources")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostSystemResourceInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostSystemResourceInfo")
	}
	return v, nil
}

// List of virtual machines associated with this host.
func (mo *HostSystem) Vm() ([]*VirtualMachine, error) {
	t, err := mo.currentProperty("vm")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*VirtualMachine)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*VirtualMachine")
	}
	return v, nil
}

//
// Creates and returns a one-time credential used to establish a remote
// connection to a CIM interface. The port to connect to is the standard
// well known port for the service.
//
// Required Privileges
// Host.Cim.CimInteraction
// Since
// VI API 2.5
//
func (mo *HostSystem) AcquireCimServicesTicket(
	_this *ManagedObjectReference,
) (*HostServiceTicket, error) {

	return nil, nil

}

//
// Disconnects from a host and instructs the server to stop sending heartbeats.
//
// Required Privileges
// Host.Config.Connection
//
func (mo *HostSystem) DisconnectHost_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Modifies the permissions on the host, so that it will only be accessible
// through local console or an authorized centralized management application.
// Any user defined permissions found on the host are lost.
//
// Access via a VI client connected to the host is blocked.
// Access though other services running on the host is also blocked.
//
//
// If the operation is successful, adminDisabled
// will be set to true. This API is not supported on the host, If invoked
// directly on a host, a NotSupported fault will be thrown.See AuthorizationManager
//
//
// Required Privileges
// Host.Config.Settings
// Since
// vSphere API 4.1
//
func (mo *HostSystem) EnterLockdownMode(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Puts the host in maintenance mode. While this task is running and when the host is
// in maintenance mode, no virtual machines can be powered on and no provisioning
// operations can be performed on the host. Once the call completes, it is safe to
// turn off a host without disrupting any virtual machines.
//
// The task completes once there are no powered-on virtual machines on the host and
// no provisioning operations in progress on the host. The operation does not
// directly initiate any operations to evacuate or power-down powered-on virtual machines.
// However, if the host is part of a cluster with VMware DRS enabled, DRS provides
// migration recommendations to evacuate the powered-on virtual machines. If DRS is in
// fully-automatic mode, these are automatically scheduled.
//
//
// If the host is part of a cluster and the task is issued through VirtualCenter with
// evacuatePoweredOffVms set to true, the task will not succeed unless all the
// powered-off virtual machines are reregistered to other hosts. If VMware DRS is
// enabled, vCenter Server will automatically evacuate powered-off virtual machines.
//
// The task is cancellable.
//
//
// Required Privileges
// Host.Config.Maintenance
//
func (mo *HostSystem) EnterMaintenanceMode_Task(
	_this *ManagedObjectReference, timeout int32, evacuatePoweredOffVms bool, maintenanceSpec *HostMaintenanceSpec,
) (*Task, error) {

	return nil, nil

}

//
// Restores Administrator permission for the local administrative account
// for the host that was removed by prior call to EnterLockdownMode.
// If the operation is successful,
// adminDisabled will be set to false. This API
// is not supported on the host. If invoked directly on a host, a
// NotSupported fault will be thrown.See AuthorizationManager
//
// Required Privileges
// Host.Config.Settings
// Since
// vSphere API 4.1
//
func (mo *HostSystem) ExitLockdownMode(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Takes the host out of maintenance mode. This blocks if any concurrent
// running maintenance-only host configurations operations are being performed.
// For example, if VMFS volumes are being upgraded.
//
// The task is cancellable.
//
//
// Required Privileges
// Host.Config.Maintenance
//
func (mo *HostSystem) ExitMaintenanceMode_Task(
	_this *ManagedObjectReference, timeout int32,
) (*Task, error) {

	return nil, nil

}

//
// Puts the host in standby mode, a mode in which the host is in a
// standby state from which it can be powered up remotely. While
// this task is running, no virtual machines can be powered on and
// no provisioning operations can be performed on the host.
//
// The task completes only if there are no powered-on virtual
// machines on the host, no provisioning operations in progress on
// the host, and the host stopped responding. The operation does
// not directly initiate any operations to evacuate or power-down
// powered-on virtual machines. However, if a dynamic recommendation
// generation module is running, if possible, it will provide, and
// depending on the automation level, it will execute migrations
// of powered-on virtual machine. Furthermore, VMware power
// management module may evacute and put a host in standby mode to
// save power.
//
// If the host is part of a cluster and the task is issued through VirtualCenter with
// evacuatePoweredOffVms set to true, the task will not succeed unless all the
// powered-off virtual machines are reregistered to other hosts. If VMware DRS is
// enabled, vCenter Server will automatically evacuate powered-off virtual machines.
//
//
// The task is cancellable.
//
//
// This command is not supported on all hosts. Check the host capability
// standbySupported.
//
//
// Required Privileges
// Host.Config.Maintenance
// Since
// VI API 2.5
//
func (mo *HostSystem) PowerDownHostToStandBy_Task(
	_this *ManagedObjectReference, timeoutSec int32, evacuatePoweredOffVms bool,
) (*Task, error) {

	return nil, nil

}

//
// Takes the host out of standby mode. If the command is
// successful, the host wakes up and starts sending
// heartbeats. This method may be called automatically by a
// dynamic recommendation generation module to add capacity to a
// cluster, if the host is not in maintenance mode.
//
// Note that, depending on the implementation of the wakeup
// method, the client may never receive an indicator of success in
// the returned task. In some cases, it is not even possible to
// ensure that the wakeup request has made it to the host.
//
//
// The task is cancellable.
//
//
//
//
// Required Privileges
// Host.Config.Maintenance
// Since
// VI API 2.5
//
func (mo *HostSystem) PowerUpHostFromStandBy_Task(
	_this *ManagedObjectReference, timeoutSec int32,
) (*Task, error) {

	return nil, nil

}

//
// Connection-oriented information about a host.
//
// Required Privileges
// System.Read
//
func (mo *HostSystem) QueryHostConnectionInfo(
	_this *ManagedObjectReference,
) (*HostConnectInfo, error) {

	return nil, nil

}

// Deprecated.
// As of VI API 2.5, use QueryMemoryOverheadEx.
//
//
// Determines the amount of memory overhead necessary to power on a virtual
// machine with the specified characteristics.
//
// Required Privileges
// System.Read
//
func (mo *HostSystem) QueryMemoryOverhead(
	_this *ManagedObjectReference, memorySize int64, videoRamSize int32, numVcpus int32,
) (int64, error) {

	return int64(0), nil

}

// Deprecated.
// As of VI API 5.5, use
// initialOverhead.
//
//
// Determines the amount of memory overhead necessary to power on a virtual
// machine with the specified characteristics.
//
// Required Privileges
// System.Read
// Since
// VI API 2.5
//
func (mo *HostSystem) QueryMemoryOverheadEx(
	_this *ManagedObjectReference, vmConfigInfo *VirtualMachineConfigInfo,
) (int64, error) {

	return int64(0), nil

}

//
// Basic information about TPM attestation state of the host.
//
// Required Privileges
// System.Read
// Since
// vSphere API 5.1
//
func (mo *HostSystem) QueryTpmAttestationReport(
	_this *ManagedObjectReference,
) (*HostTpmAttestationReport, error) {

	return nil, nil

}

//
// Reboots a host. If the command is successful, then the host has been rebooted. If
// connected directly to the host, the client never receives an indicator of success
// in the returned task but simply loses connection to the host, upon success.
//
// This command is not supported on all hosts. Check the host capability
// vim.host.Capability.rebootSupported.
//
//
// Required Privileges
// Host.Config.Maintenance
//
func (mo *HostSystem) RebootHost_Task(
	_this *ManagedObjectReference, force bool,
) (*Task, error) {

	return nil, nil

}

//
// Reconfigures the host for vSphere HA.
//
// If the host is part of a HA cluster, this operation reconfigures the host for HA.
// For example, this operation may be used if a host is added to a HA enabled cluster
// and the automatic HA configuration system task fails. Automatic HA configuration
// may fail for a variety of reasons. For example, the host is configured
// incorrectly.
//
//
// Required Privileges
// Host.Config.Connection
//
func (mo *HostSystem) ReconfigureHostForDAS_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Reconnects to a host. This process reinstalls agents and reconfigures the host, if
// it has gotten out of date with VirtualCenter. The reconnection process goes
// through many of the same steps as addHost: ensuring the correct set of licenses
// for the number of CPUs on the host, ensuring the correct set of agents is
// installed, and ensuring that networks and datastores are discovered and registered
// with VirtualCenter.
//
// The client can change the IP address and port of the host when doing a reconnect
// operation. This can be useful if the client wants to preserve existing metadata,
// even though the host is changing its IP address. For example, clients could
// preserve existing statistics, alarms, and privileges.
//
//
// This method can also be used to change the SSL thumbprint of a connected host
// without disconnecting it.
//
//
// Any changes made to the resource hierarchy on the host when the host
// was disconnected are overriden by VirtualCenter settings on
// reconnect.
//
//
// This method is only supported through VirtualCenter.
//
//
// Required Privileges
// Host.Config.Connection
//
func (mo *HostSystem) ReconnectHost_Task(
	_this *ManagedObjectReference, cnxSpec *HostConnectSpec, reconnectSpec *HostSystemReconnectSpec,
) (*Task, error) {

	return nil, nil

}

//
// Return the hardware uptime of the host in seconds.
// The harware uptime of a host is not affected by NTP and changes to its
// wall clock time and can be used by clients to provide a common time
// reference for all hosts.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.1
//
func (mo *HostSystem) RetrieveHardwareUptime(
	_this *ManagedObjectReference,
) (int64, error) {

	return int64(0), nil

}

//
// Shuts down a host. If the command is successful, then the host has been shut down.
// Thus, the client never receives an indicator of success in the returned task if
// connected directly to the host.
//
// This command is not supported on all hosts. Check the host capability
// shutdownSupported.
//
//
// Required Privileges
// Host.Config.Maintenance
//
func (mo *HostSystem) ShutdownHost_Task(
	_this *ManagedObjectReference, force bool,
) (*Task, error) {

	return nil, nil

}

//
// Update flags that are part of the HostFlagInfo object.
//
// Required Privileges
// Host.Config.Settings
// Since
// VI API 2.5
//
func (mo *HostSystem) UpdateFlags(
	_this *ManagedObjectReference, flagInfo *HostFlagInfo,
) error {

	return nil

}

//
// Update fields that are part of the HostIpmiInfo object.
//
// Required Privileges
// Host.Config.Settings
// Since
// vSphere API 4.0
//
func (mo *HostSystem) UpdateIpmi(
	_this *ManagedObjectReference, ipmiInfo *HostIpmiInfo,
) error {

	return nil

}

//
// Update the configuration of the system resource hierarchy.
//
// Required Privileges
// Host.Config.Resources
//
func (mo *HostSystem) UpdateSystemResources(
	_this *ManagedObjectReference, resourceInfo *HostSystemResourceInfo,
) error {

	return nil

}

//
// Update the System Swap Configuration.See HostSystemSwapConfiguration
//
// Required Privileges
// Host.Config.Settings
// Since
// vSphere API 5.1
//
func (mo *HostSystem) UpdateSystemSwapConfiguration(
	_this *ManagedObjectReference, sysSwapConfig *HostSystemSwapConfiguration,
) error {

	return nil

}

//
// Defines a host's connection state.
//
//
type HostSystemConnectionState struct {
}

//
// This data object provides information about the health of the phyical
// system. The data is retrieved from numeric sensor probes.
//
//
type HostSystemHealthInfo struct {
	*DynamicData

	// Health information provided by the power probes.
	NumericSensorInfo []*HostNumericSensorInfo
}

//
// This data object describes system identifying information of the host. This
// information may be vendor specific.
//
//
type HostSystemIdentificationInfo struct {
	*DynamicData

	// The description of the identifying information.See HostSystemIdentificationInfoIdentifier
	IdentifierType *ElementDescription

	// The system identification information
	IdentifierValue string
}

type HostSystemIdentificationInfoIdentifier struct {
}

//
// Information about the system as a whole.
//
//
type HostSystemInfo struct {
	*DynamicData

	// System model identification.
	Model string

	// Other System identification information. This information may be vendor
	// specific
	//
	// Since VI API 2.5
	OtherIdentifyingInfo []*HostSystemIdentificationInfo

	// Hardware BIOS identification.
	Uuid string

	// Hardware vendor identification.
	Vendor string
}

//
// Defines a host's power state.
//
//
type HostSystemPowerState struct {
}

//
// Specifies the parameters needed to merge vCenter Server settings
// and host settings on reconnect.
//
//
type HostSystemReconnectSpec struct {
	*DynamicData

	// This flag should be set if on a host reconnect, state such as virtual
	// machine state in vCenter Server e.g. the virtual machine inventory
	// and autostart rules, has to be propogated to the host. Any virtual
	// machines that may have been unregistered or orphaned will be
	// reregistered according to the vCenter Server inventory. Any autostart
	// rules that may have changed on the host will be similarly restored.
	// This flag is primarily intended for stateless hosts to enable vCenter
	// Server to resync these hosts after a reboot.
	SyncState bool
}

//
// The SystemResourceInfo data object describes the configuration of
// a single system resource group.  System resource groups are analogous
// to ResourcePool objects for virtual machines; however,
// their structure is fixed and groups may not be created nor destroyed,
// only configured.
//
//
type HostSystemResourceInfo struct {
	*DynamicData

	// List of child resource groups.
	Child []*HostSystemResourceInfo

	// Configuration of this system resource group.
	Config *ResourceConfigSpec

	// ID of the system resource group.
	Key string
}

//
// Information and specification for control of the system swap configuration
// on the current host.
//
//
type HostSystemSwapConfiguration struct {
	*DynamicData

	// The currently enabled options.
	//
	// When this property contains only one value and this value is HostSystemSwapConfigurationDisabledOption,
	// this indicates that the system swap is disabled.
	// If the HostSystemSwapConfigurationDisabledOption option is
	// used toghether with some other option in call to UpdateSystemSwapConfiguration, a
	// InvalidArgument is thrown.
	// It is not allowed to have duplicate values in this array. If so a
	// InvalidArgument is thrown.
	Option []*HostSystemSwapConfigurationSystemSwapOption
}

//
// Use option to indicate that a user specified datastore may be used for
// system swap.
//
//
type HostSystemSwapConfigurationDatastoreOption struct {
	*HostSystemSwapConfigurationSystemSwapOption

	// The datastore to be used with this swap option.
	//
	// This value should be always set when the encapsulating option is used,
	// otherwise a call to UpdateSystemSwapConfiguration will
	// result in a InvalidArgument fault.
	Datastore string
}

//
// Indicates that the system swap on the host is currently disabled.
//
// This value is used with the
// UpdateSystemSwapConfiguration managed method to
// disable system swap. Presence of this value in option excludes appearance of any other
// options. Specifying additional options will result in a InvalidArgument fault being thrown from the UpdateSystemSwapConfiguration method.
//
//
type HostSystemSwapConfigurationDisabledOption struct {
	*HostSystemSwapConfigurationSystemSwapOption
}

//
// Use option to indicate that the host cache may be used for system
// swap.See HostCacheConfigurationManager
//
//
type HostSystemSwapConfigurationHostCacheOption struct {
	*HostSystemSwapConfigurationSystemSwapOption
}

//
// Use option to indicate that the datastore configured for host local swap
// may be used for system swap.
//
//
type HostSystemSwapConfigurationHostLocalSwapOption struct {
	*HostSystemSwapConfigurationSystemSwapOption
}

//
// Base class for all system swap options.
//
// This class is not supposed to be used directly.
// These values are to be used in a SystemSwapConfiguration.option
// array.
//
//
type HostSystemSwapConfigurationSystemSwapOption struct {
	*DynamicData

	// Specifies the order the options are prefered among each other.
	//
	// The lower the value the more important.
	Key int32
}

//
// Transport information about a SCSI target.
//
//
type HostTargetTransport struct {
	*DynamicData
}

//
// This class is used to report Trusted Platform Module (TPM) attestation
// information - values of the Platform Configuration Registers (PCRs) and
// the TPM event log to the external clients.
//
// This information can be used to determine the integrity of the software
// stack running as reported by the platform.
//
//
// The TPM stores digests (hashes) of the software stack components running on
// the host. Both binary modules and configuration information can be hashed.
// The calculated hash values are stored in special-purpose hardware registers
// called PCRs. Each PCR is defined to hold cumulative digest(s) of specific
// part(s) of the software stack.
//
//
// Due to the limited amount of PCRs available a hash-chaining scheme is implemented.
// When adding new information to a PCR the new value of hash is computed according
// to the following formula:
// NewHash = hash_function(OldHash + hash_function(NewData))
// This scheme allows storing measurements of an unlimited amount of components.
//
//
// The TPM event log provides an exact sequence of the events that contributed
// to the value of a PCR. It contains information about the type of the event
// and event-specific information. The presence of the log allows verification of
// both the final PCR state and the entire attestation path that formed it.
//
//
// It is possible for this report to be unreliable. This could be due to missing package
// information in the host database, errors in creation of the events. Only first 1000
// events are recorded by the kernel. Further events will not be recorded in the log and
// will cause the log to be marked as incomplete.
//
//
//
type HostTpmAttestationReport struct {
	*DynamicData

	// Log of TPM software stack attestation events.
	TpmEvents []*HostTpmEventLogEntry

	// This flag indicates whether the provided TPM events are a complete and reliable
	// information about host boot status.
	//
	// TPM event log may be incomplete (and therfore unreliable) if certain modules have
	// inappropriate origin or if the package information is incomplete. Only first 1000
	// events are recorded by the kernel. Further events will not be recorded in the log
	// and will cause the log to be marked as unreliable.
	TpmLogReliable bool

	// The array of PCR digest values stored in the TPM device since the last
	// host boot time.
	TpmPcrValues []*HostTpmDigestInfo
}

//
// Details of a Trusted Platform Module (TPM) event recording kernel security
// option passed at boot time and currently in effect.
//
// This event type exists to simplify parsing of the security-related information
// by internal and third-party solutions. Each boot option may be passed to kernel
// multiple times and/or in different forms. Replicating the parsing logic of the
// kernel would be neither convinient, nor secure for the client applications.
//
//
// Each instance of this event reports details of a single security-related
// boot option, as set in the kernel.
//
//
//
type HostTpmBootSecurityOptionEventDetails struct {
	*HostTpmEventDetails

	// Security-related options string, reflecting the state of an option set
	// in the kernel.
	//
	// This string is in the form of a KEY=VALUE pair.
	BootSecurityOption string
}

//
// Details of an Trusted Platform Module (TPM) event recording options entered
// manually on the command line prompt at boot time.
//
//
type HostTpmCommandEventDetails struct {
	*HostTpmEventDetails

	// Boot options as entered on the command line prompt at boot time.
	CommandLine string
}

//
// This data object type describes the digest values in the Platform
// Configuration Register (PCR) of a Trusted Platform Module (TPM) device.
//
//
type HostTpmDigestInfo struct {
	*HostDigestInfo

	// Index of the PCR that stores the TPM digest value.
	PcrNumber int32
}

//
// This is a base data object for describing an event generated by
// Trusted Platform Module (TPM). It contains parameters common to
// all TPM event types.
//
//
type HostTpmEventDetails struct {
	*DynamicData

	// Value of the Platform Configuration Register (PCR) for this event.
	DataHash []int8
}

//
// This data object represents a single entry of an event log created by
// Trusted Platform Module (TPM).
//
// An TPM event log entry represents a single change to the value of
// a Platform Configuration Register (PCR). It contains detailed information
// about the reason of PCR value change, and the specifics of the event.
//
//
// Multiple objects of this type form an TPM event log. This log allows for
// verification of the both the software stack running on a host and the attestation
// process itself.
//
//
//
type HostTpmEventLogEntry struct {
	*DynamicData

	// The details of the event.
	EventDetails *HostTpmEventDetails

	// Index of the PCR that was affected by the event.
	PcrIndex int32
}

//
// Details of a Trusted Platform Module (TPM) event recording boot-time options.
//
// The boot-time options set on the system are packaged into a file that is supplied
// to the kernel at boot time. The boot options may be a string of key=value pairs
// (possibly separated by a new line) or a blob of arbitrary data.
//
//
//
type HostTpmOptionEventDetails struct {
	*HostTpmEventDetails

	// Options set by the boot option package.
	//
	// This array exposes the raw contents of the settings file (or files) that were
	// passed to kernel during the boot up process, and, therefore, should be treated
	// accordingly.
	BootOptions []int8

	// Name of the file containing the boot options.
	OptionsFileName string
}

//
// Details of a Trusted Platform Module (TPM) event recording a software component
// related event.
//
// This event is created when measuring a software component installed on the system.
// A software component may be a tardisk, a kernel module or any other type supported
// by the package system.
//
//
// Some software components are not packaged as VIBs (currently the package database
// and persistent state information of ESXi). For these components the VIB fields
// will contain empty strings.
//
//
//
type HostTpmSoftwareComponentEventDetails struct {
	*HostTpmEventDetails

	// Name of the software component that caused this TPM event.
	ComponentName string

	// Name of the VIB containing the software component.
	VibName string

	// Vendor of the VIB containing the software component.
	VibVendor string

	// Version of the VIB containing the software component.
	VibVersion string
}

//
// Information about an unresolved VMFS volume extent
// An unresolved VMFS volume extent is a device partition which is
// detected to have copy of an extent of a VMFS volume.
// Such a copy can be created via replication or snapshots, for example.See HostUnresolvedVmfsVolume
//
//
type HostUnresolvedVmfsExtent struct {
	*DynamicData

	// The device information
	Device *HostScsiDiskPartition

	// The device path of an VMFS extent
	DevicePath string

	// Index of the last block that this extent provides.
	EndBlock int32

	// Is this a copy of the head extent of the VMFS volume?
	IsHeadExtent bool

	// A number indicating the order of an extent in a volume.  An extent with
	// a lower ordinal value than another extent provides a range of blocks to
	// a volume at an earlier block address range.  Extents with the same
	// ordinal provide the same range of blocks to a volume.  A zero ordinal
	// indicates that the extent is a head extent.
	//
	// In the case each extent in the HostUnresolvedVmfsVolume is
	// represented in the list of HostUnresolvedVmfsExtent data objects,
	// the ordinal will refer to the absolute index of the extent in the
	// volume.  For example, ordinal "1" refers to the second extent;
	// ordinal "2" refers to the third extent.
	//
	// In the case that some extents of the volume are not represented in
	// the HostUnresolvedVmfsExtent list, the ordinal will not precisely
	// describe the position in the list of extents.  A number will be skipped
	// to indicate holes in the extent order.  For example, given a volume with
	// five extents with the second and third extents missing, the ordinal
	// values in use will be {0, 2, 3}.  The missing second and third extent
	// are represented by the missing ordinal value "1" while the fourth and
	// fifth extents will be assigned an ordinal of "2" and "3" respectively.
	//
	// The reason the ordinals are not reliable in the case of missing extents
	// is because the extents are identified by their start and end blocks.
	// The ordinals are just a hint used to help indicate extents that
	// correspond to the same start and end blocks.
	Ordinal int32

	// Reason as to why the partition is marked as copy
	// of a VMFS volume's extent.
	// Possible reasons are the disk id is not matching with what
	// the scsi inq is saying or disk uuid is not matchingSee HostUnresolvedVmfsExtentUnresolvedReason
	Reason string

	// Index of the first block that this extent provides.
	StartBlock int32

	// The UUID of the VMFS volume read from to the partition.
	VmfsUuid string
}

//
// Reasons for identifying the disk extent
// as copy of VMFS volume extent.
//
//
type HostUnresolvedVmfsExtentUnresolvedReason struct {
}

//
// Specification to resignature an Unresolved VMFS volume.
//
//
type HostUnresolvedVmfsResignatureSpec struct {
	*DynamicData

	// List of device path each specifying VMFS extents.
	ExtentDevicePath []string
}

//
// When an UnresolvedVmfsVolume has been resignatured or forceMounted, we want to
// return the original spec information along with newly created VMFS volume.
//
//
type HostUnresolvedVmfsResolutionResult struct {
	*DynamicData

	// 'fault' would be set if the operation was not successful
	Fault *LocalizedMethodFault

	// The original UnresolvedVmfsResolutionSpec which user had specified
	Spec *HostUnresolvedVmfsResolutionSpec

	// Newly created VmfsVolume
	Vmfs *HostVmfsVolume
}

//
// An unresolved VMFS volume is reported when one or more device partitions
// of volume are detected to have copies of extents of the volume.
// Such copies can be created via replication or snapshots, for example.
// This data object type describes how to resolve an unbound VMFS volume.
// The SCSI device path for each of the VMFS volume extent should be
// specified.
// For the current release, only head-extent needs to be specified.
// In future releases, we will allow user to specify explicitly all the
// extents which makes up a new Vmfs Volume.
//
//
type HostUnresolvedVmfsResolutionSpec struct {
	*DynamicData

	// List of device paths each specifying a VMFS extent.
	//
	// One extent must be specified.  This property is represented as a
	// list to enable future enhancements to the interface.
	ExtentDevicePath []string

	// When set to Resignature, new Uuid is assigned to the VMFS
	// volume. When set to 'forceMount', existing uuid is assigned
	// to the Vmfs volume and Vmfs volumes metadata doesn't change.See VmfsUuidResolution
	UuidResolution string
}

type HostUnresolvedVmfsResolutionSpecVmfsUuidResolution struct {
}

//
// Information about detected unbound, unresolved VMFS volume.
// An unresolved VMFS volume is reported when one or more device
// partitions of volume are detected to have copies of extents
// of the volume. Such copies can be created via replication or
// snapshots.
//
//
// UnresolvedVmfsVolume are not mounted on the host where they
// are detected. User may choose to resignature the volume in
// which case a new Uuid is assigned to the volume and contents
// of the VMFS volume is kept intact.
//
//
//
// User may choose to keep the original Uuid and mount the VMFS
// volume as it is on the given host. In this case, user has
// choosen to mount the copy of the VMFS volume on that host with
// no change to the original Uuid. This may fail with
// VmfsVolumeAlreadyMounted exception if there is an existing
// VMFS volume with the same Uuid mounted somewhere in the same
// datacenter.
//
//
//
// Simple diagram representing the possible operations on UnresolvedVmfsVolume
//
//
// resignature                 forceMount
// VmfsVolume &lt;---------------  Unresolved ------------&gt;  VmfsVolume with
// forceMountedInfo              Vmfs Volume              forceMountedInfo
// not set                                                  will be set
//
// See HostStorageSystem
//
//
type HostUnresolvedVmfsVolume struct {
	*DynamicData

	// List of detected copies of VMFS extents.
	Extent []*HostUnresolvedVmfsExtent

	// Information related to how the volume might be resolved.
	ResolveStatus *HostUnresolvedVmfsVolumeResolveStatus

	// Total number of blocks in this volume.
	TotalBlocks int32

	// The detected VMFS label name
	VmfsLabel string

	// The detected VMFS UUID
	VmfsUuid string
}

//
// Data object that describes the resolvability of a volume.
//
//
type HostUnresolvedVmfsVolumeResolveStatus struct {
	*DynamicData

	// Is the list of extents for the volume a partial list?  A volume can only
	// be resignatured if all extents composing that volume are available.
	// Hence, a volume with a partial extent list cannot be resignatured.
	//
	// In cases where this information is not known for a volume, this
	// property will be unset.
	IncompleteExtents bool

	// Are there multiple copies of extents for this volume?  If any extent of
	// the volume has multiple copies then the extents to be resolved must be
	// explicitly specified when resolving this volume.
	//
	// In cases where this information is not known for a volume, this
	// property will be unset.
	MultipleCopies bool

	// Can this volume be resolved?  There may be other reasons a volume cannot
	// be resolved other than the fact that it is incomplete.  This boolean will
	// authoritatively indicate if the server can resolve this volume.
	Resolvable bool
}

//
// This event records a failure to connect to a host
// due to an installation or upgrade issue.
//
//
type HostUpgradeFailedEvent struct {
	*HostEvent
}

// Deprecated.
// As of vSphere API 5.0, the event is no longer relevant.
//
//
// This event records that the userworld swap is not enabled on the host. HA
// needs userworld swap to be configured on embedded ESX hosts to function.
//
//
type HostUserWorldSwapNotEnabledEvent struct {
	*HostEvent
}

//
// The VFlash Manager object is used to configure vFlash resource
//
// and vFlash cache on the ESX host.
//
type HostVFlashManager struct {
	*ManagedObject

	vFlashConfigInfo *HostVFlashManagerVFlashConfigInfo
}

// Host vFlash configuration information.
func (mo *HostVFlashManager) VFlashConfigInfo() (*HostVFlashManagerVFlashConfigInfo, error) {
	t, err := mo.currentProperty("vFlashConfigInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostVFlashManagerVFlashConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostVFlashManagerVFlashConfigInfo")
	}
	return v, nil
}

//
// Configure vFlash resource on a list of SSD disks. If the host does not have
//
// a VFFS volume, host will format the volume first and then extend the volume
//
// on the rest of the SSDs; otherwise host will extend the existing VFFS volume
//
// on the passed SSDs. Finally host will configure the vFlash resource on the
//
// VFFS volume.
//
//
// It will return HostVFlashResourceConfigurationResult
// describing success or failure associated with each device.
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostVFlashManager) ConfigureVFlashResourceEx_Task(
	_this *ManagedObjectReference, devicePath []string,
) (*Task, error) {

	return nil, nil

}

//
// Configure vFlash resource on the host by attaching to a backend VFFS volume.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostVFlashManager) HostConfigureVFlashResource(
	_this *ManagedObjectReference, spec *HostVFlashManagerVFlashResourceConfigSpec,
) error {

	return nil

}

//
// Configurate vFlash cache on the host.
//
// Required Privileges
// Host.Config.AdvancedConfig
//
func (mo *HostVFlashManager) HostConfigVFlashCache(
	_this *ManagedObjectReference, spec *HostVFlashManagerVFlashCacheConfigSpec,
) error {

	return nil

}

//
// Retrieve the default supported configuration
//
// for a given vFlash module
//
// Required Privileges
// Host.Config.AdvancedConfig
//
func (mo *HostVFlashManager) HostGetVFlashModuleDefaultConfig(
	_this *ManagedObjectReference, vFlashModule string,
) (*VirtualDiskVFlashCacheConfigInfo, error) {

	return nil, nil

}

//
// Remove vFlash resource on the host by destroying the contained VFFS volume.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostVFlashManager) HostRemoveVFlashResource(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Data object describes host vFlash cache configuration information.
//
//
type HostVFlashManagerVFlashCacheConfigInfo struct {
	*DynamicData

	// Name of the default vFlash module for the read-write cache associated
	//
	// with the VMs of this host. This setting can be overridden by
	//
	// vFlashModule
	//
	// per VMDK.
	DefaultVFlashModule string

	// Amount of vFlash resource is allocated to the host swap cache. As long as set,
	//
	// reservation will be permanent and retain regardless of host power state. The host
	//
	// swap cache will be disabled if reservation is set to zero.
	SwapCacheReservationInGB int64

	// Cache configuration options for the supported vFlash modules.
	VFlashModuleConfigOption []*HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption
}

type HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption struct {
	*DynamicData

	// blockSizeInKBOption defines a range of virtual disk cache block size.
	BlockSizeInKBOption *LongOption

	// Cache data consistency types.
	//
	// See VirtualDiskVFlashCacheConfigInfoCacheConsistencyType
	CacheConsistencyType *ChoiceOption

	// Cache modes.
	//
	// See VirtualDiskVFlashCacheConfigInfoCacheMode
	CacheMode *ChoiceOption

	// Maximal size of virtual disk supported in kilobytes.
	MaxDiskSizeInKB int64

	// Minimum supported version
	MinSupportedModuleVersion string

	// reservationInMBOption defines a range of virtual disk cache size.
	ReservationInMBOption *LongOption

	// Name of the vFlash module
	VFlashModule string

	// Version of the vFlash module
	VFlashModuleVersion string
}

//
// Specification to configure vFlash cache on the host.
//
//
type HostVFlashManagerVFlashCacheConfigSpec struct {
	*DynamicData

	// Name of the default vFlash module for the read-write caches associated
	//
	// with the VMs of this host. This setting can be overridden by
	//
	// vFlashModule
	//
	// per VMDK.
	DefaultVFlashModule string

	// Amount of vFlash resource is allocated to the host swap cache. As long as set,
	//
	// reservation will be permanent and retain regardless of host power state. The host
	//
	// swap cache will be disabled if the reservation is set to zero.
	SwapCacheReservationInGB int64
}

//
// vFlash configuraiton Information.
//
//
type HostVFlashManagerVFlashConfigInfo struct {
	*DynamicData

	// vFlash cache configuration information
	VFlashCacheConfigInfo *HostVFlashManagerVFlashCacheConfigInfo

	// vFlash resource configuration information
	VFlashResourceConfigInfo *HostVFlashManagerVFlashResourceConfigInfo
}

//
// vFlash resource configuraiton Information.
//
//
type HostVFlashManagerVFlashResourceConfigInfo struct {
	*DynamicData

	// Capacity of the vFlash resource. It is the capacity
	//
	// of the contained VFFS volume.
	Capacity int64

	// The contained VFFS volume
	Vffs *HostVffsVolume
}

//
// vFlash resource configuration specification.
//
//
type HostVFlashManagerVFlashResourceConfigSpec struct {
	*DynamicData

	// The contained VFFS volume uuid.
	VffsUuid string
}

//
// Data object provides vFlash resource runtime usage.
//
//
type HostVFlashManagerVFlashResourceRunTimeInfo struct {
	*DynamicData

	// True if all the included the VFFS volumes are accessible. False if one or
	//
	// multiple included VFFS volumes are inaccessible.
	Accessible bool

	// Overall capacity of vFlash resource, in bytes.
	Capacity int64

	// vFlash resource capacity can be allocated for VM caches
	CapacityForVmCache int64

	// Free vFlash resource can be allocated for VM caches
	FreeForVmCache int64

	// Overall usage of vFlash resource, in bytes.
	Usage int64
}

//
// vFlash resource configuration result returns the newly-configured backend
//
// VFFS volume and operation result for each passed-in SSD device.
//
//
type HostVFlashResourceConfigurationResult struct {
	*DynamicData

	// The original array of device path which user had specified
	DevicePath []string

	// Array of device operation results.
	DiskConfigurationResult []*HostDiskConfigurationResult

	// Newly configured VffsVolume
	Vffs *HostVffsVolume
}

//
// The object type for the array returned by queryVMotionCompatibility;
// specifies the VMotion compatibility types for a host.
//
//
type HostVMotionCompatibility struct {
	*DynamicData

	// Ways in which the host is compatible with the designated virtual
	// machine that is a candidate for VMotion. This array will be
	// a subset of the set of VMotionCompatibilityType strings that
	// were input to queryVMotionCompatibility.
	Compatibility []string

	// The prospective host for the virtual machine.
	Host *HostSystem
}

//
// This data object configuring VMotion on the host.
// The runtime information is available from the
// VMotionInfo data object type.
//
//
type HostVMotionConfig struct {
	*DynamicData

	// Flag to indicate whether or not VMotion is enabled.
	Enabled bool

	// Key of the VirtualNic used for VMotion.
	VmotionNicKey string
}

// Deprecated.
// As of VI API 4.0, use HostVirtualNicManagerInfo
//
//
// This data object type describes VMotion host
// configuration data objects.
//
//
type HostVMotionInfo struct {
	*DynamicData

	// IP configuration of the VMotion VirtualNic.
	IpConfig *HostIpConfig

	// VMotion network configuration.
	NetConfig *HostVMotionNetConfig
}

//
// The NetConfig data object type contains the networking
// configuration for VMotion operations.
//
//
type HostVMotionNetConfig struct {
	*DynamicData

	// List of VirtualNic objects that may be used for VMotion.
	// This will be a subset of the list of VirtualNics in
	// vnic.
	CandidateVnic []*HostVirtualNic

	// VirtualNic that is selected for use in VMotion operations.
	SelectedVnic string
}

// Deprecated.
// As of VI API 4.0, use virtualNicManager
//
//
// The VMotionSystem managed object describes the VMotion configuration
// of the host.
//
type HostVMotionSystem struct {
	*ExtensibleManagedObject

	ipConfig *HostIpConfig

	netConfig *HostVMotionNetConfig
}

// IP configuration of the VMotion VirtualNic.
func (mo *HostVMotionSystem) IpConfig() (*HostIpConfig, error) {
	t, err := mo.currentProperty("ipConfig")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostIpConfig)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostIpConfig")
	}
	return v, nil
}

// VMotion network configuration.
func (mo *HostVMotionSystem) NetConfig() (*HostVMotionNetConfig, error) {
	t, err := mo.currentProperty("netConfig")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostVMotionNetConfig)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostVMotionNetConfig")
	}
	return v, nil
}

//
// Indicate that no VirtualNic should be used for VMotion.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostVMotionSystem) DeselectVnic(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Select the VirtualNic to be used for VMotion.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostVMotionSystem) SelectVnic(
	_this *ManagedObjectReference, device string,
) error {

	return nil

}

//
// Update the IP configuration of VMotion VirtualNic.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostVMotionSystem) UpdateIpConfig(
	_this *ManagedObjectReference, ipConfig *HostIpConfig,
) error {

	return nil

}

//
// VFAT file system volume.
//
//
type HostVfatVolume struct {
	*HostFileSystemVolume
}

//
// This data object type describes the VFFS
// creation specification.
//
//
type HostVffsSpec struct {
	*DynamicData

	// The device path of the SSD disk.See devicePath
	DevicePath string

	// Major version number of VFFS.  This can be changed if the VFFS is
	// upgraded, but this is an irreversible change.
	MajorVersion int32

	// Partition specification of the SSD disk. If this property
	// is not provided, partition information will be computed
	// and generated.
	Partition *HostDiskPartitionSpec

	// Volume name of VFFS.
	VolumeName string
}

//
// vFlash File System Volume.
//
//
type HostVffsVolume struct {
	*HostFileSystemVolume

	// The list of partition names that comprise this disk's
	// VFFS extents.
	Extent []*HostScsiDiskPartition

	// Major version number of VFFS.
	MajorVersion int32

	// The universally unique identifier assigned to VFFS.
	Uuid string

	// Version string. Contains major and minor version numbers.
	Version string
}

//
// The HostVirtualNic data object describes a virtual network adapter representing
// an adapter that connects to a virtual switch. A host virtual NIC differs from a
// physical NIC:
//
//
// • A host virtual NIC is a virtual device that is connected to a virtual switch.
//
// • A physical NIC (HostNetworkInfo.pnic)
// corresponds to a physical device that is connected to the physical network.
//
//
//
//
// A host virtual NIC provides access to the external network through a virtual switch that is
// bridged through a Physical NIC to a physical network
// (HostNetworkConfig.vswitch[].spec.bridge)
//
//
//
type HostVirtualNic struct {
	*DynamicData

	// Device name.
	Device string

	// Linkable identifier.
	Key string

	// Port on the port group that the virtual network adapter is using
	// when it is enabled
	// (DistributedVirtualPort.key).
	Port string

	// If the Virtual NIC is connecting to a vSwitch, this property is the name of
	// portgroup connected. If the Virtual NIC is connecting to a
	// DistributedVirtualSwitch, this property is an empty string.
	Portgroup string

	// Configurable properties for the virtual network adapter object.
	Spec *HostVirtualNicSpec
}

//
// The HostVirtualNicConfig data object describes the Virtual NIC configuration.
// It represents both the configured properties on a HostVirtualNic and identification information.
//
//
type HostVirtualNicConfig struct {
	*DynamicData

	// Change operation to apply on this configuration
	// specification.See HostConfigChangeOperation
	ChangeOperation string

	// Virtual NIC device to which configuration applies
	// (HostVirtualNic.device).
	Device string

	// If the Virtual NIC is connecting to a vSwitch, this property is the name of
	// portgroup connected. If the Virtual NIC is connecting to a
	// DistributedVirtualSwitch, this property is ignored.
	Portgroup string

	// Specification of the virtual network adapter.
	Spec *HostVirtualNicSpec
}

//
// DataObject which provides a level of indirection when
// identifying VirtualNics during configuration.
// This dataObject lets users specify a VirtualNic in terms of
// the portgroup/Dv Port the Virtual NIC is connected to.
//
// This is useful in cases where VirtualNic will be created as part of
// a configuration operation and the created VirtualNic is referred to
// in some other part of configuration. e.g: for configuring VMotion
//
//
type HostVirtualNicConnection struct {
	*DynamicData

	// Identifier for the DistributedVirtualPort.
	// If the virtual nic is to be connected to a DVS,
	// #dvPort will be set instead of #portgroup
	DvPort *DistributedVirtualSwitchPortConnection

	// Name of the portgroup to which the virtual nic is connected to.
	// If this parameter is set, use a virtual nic connected to
	// a legacy portgroup.
	Portgroup string
}

//
// The VirtualNicManager managed object describes the special Virtual NIC
// configuration of the host.
//
type HostVirtualNicManager struct {
	*ExtensibleManagedObject

	info *HostVirtualNicManagerInfo
}

// Network configuration.
func (mo *HostVirtualNicManager) Info() (*HostVirtualNicManagerInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HostVirtualNicManagerInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HostVirtualNicManagerInfo")
	}
	return v, nil
}

//
// Deselect the VirtualNic to be a special type.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostVirtualNicManager) DeselectVnicForNicType(
	_this *ManagedObjectReference, nicType string, device string,
) error {

	return nil

}

//
// Get the NetConfig for the specified nicType
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostVirtualNicManager) QueryNetConfig(
	_this *ManagedObjectReference, nicType string,
) (*VirtualNicManagerNetConfig, error) {

	return nil, nil

}

//
// Select the NicType of the VirtualNic. Selecting a device automatically
// deselects the previous selection if NetConfig#multiSelectAllowed
// is false for the specified nicType.
// Else, the device is added to the list of selected nics.
//
// Required Privileges
// Host.Config.Network
//
func (mo *HostVirtualNicManager) SelectVnicForNicType(
	_this *ManagedObjectReference, nicType string, device string,
) error {

	return nil

}

//
// This data object type describes VirtualNic host
// configuration data objects.
//
//
type HostVirtualNicManagerInfo struct {
	*DynamicData

	// List of VirtualNicManager network configuration.See VirtualNicManagerNetConfig
	NetConfig []*VirtualNicManagerNetConfig
}

type HostVirtualNicManagerNicType struct {
}

//
// DataObject which lets a VirtualNic be marked for
// use as a HostVirtualNicManagerNicType.
//
//
type HostVirtualNicManagerNicTypeSelection struct {
	*DynamicData

	NicType []string

	// VirtualNic for the selection is being made
	Vnic *HostVirtualNicConnection
}

//
// The HostVirtualNicSpec data object
// describes the HostVirtualNic configuration
// containing both the configured properties on a
// virtual NIC and identification information.
//
//
type HostVirtualNicSpec struct {
	*DynamicData

	// DistributedVirtualPort or DistributedVirtualPortgroup
	// connection. To specify a port connection, set the
	// portKey property.
	// To specify a portgroup connection, set the
	// portgroupKey property.
	//
	// Since vSphere API 4.0
	DistributedVirtualPort *DistributedVirtualSwitchPortConnection

	// IP configuration on the virtual network adapter.
	Ip *HostIpConfig

	// Media access control (MAC) address of the virtual
	// network adapter.
	Mac string

	// Maximum transmission unit for packets size in bytes for the
	// virtual NIC. This property is applicable to VMkernel virtual
	// NICs and will be ignored if specified for service console virtual
	// NICs. If not specified, the Server will use the system default value.
	//
	// Since vSphere API 4.0
	Mtu int32

	// The NetStackInstance that the vNic uses, the value of this property
	// is default to be defaultTcpipStack
	//
	// Since vSphere API 5.5
	NetStackInstanceKey string

	// Portgroup (key)
	// to which the virtual NIC is connected.
	//
	// When reconfiguring a virtual NIC, this property indicates the new portgroup
	// to which the virtual NIC should connect. You can specify this property
	// only if you do not specify distributedVirtualPort.
	//
	// Since vSphere API 4.0
	Portgroup string

	// Flag enabling or disabling TCP segmentation offset for a virtual NIC.
	// This property is applicable to VMkernel virtual NICs and will be
	// ignored if specified for service console vitual nics. If not specified,
	// a default value of true shall be used.
	//
	// Since vSphere API 4.0
	TsoEnabled bool
}

//
// The virtual switch is a software entity to which multiple virtual network
// adapters can connect to create a virtual network.  It can also be
// bridged to a physical network.
//
//
type HostVirtualSwitch struct {
	*DynamicData

	// The virtual switch key.
	Key string

	// The maximum transmission unit (MTU) associated with this virtual switch
	// in bytes.
	//
	// Since VI API 2.5
	Mtu int32

	// The name of the virtual switch.
	// Maximum length is 32 characters.
	Name string

	// The number of ports that this virtual switch currently has.
	NumPorts int32

	// The number of ports that are available on this virtual switch.  There
	// are a number of networking services that utilize a port on the virtual
	// switch and are not accounted for in the Port array of a PortGroup.  For
	// example, each physical NIC attached to a virtual switch consumes one
	// port.  This property should be used when attempting to implement
	// admission control for new services attaching to virtual switches.
	NumPortsAvailable int32

	// The set of physical network adapters associated with this bridge.
	Pnic []string

	// The list of port groups configured for this virtual switch.
	Portgroup []string

	// The specification of a PortGroup.
	Spec *HostVirtualSwitchSpec
}

//
// This data type describes a bridge that automatically selects
// a particular physical network adapter on the host
// according to some predetermined policy.  Used primarily to support mobility
// scenarios.
//
//
type HostVirtualSwitchAutoBridge struct {
	*HostVirtualSwitchBridge

	// List of physical network adapters that have been excluded from
	// participating in the AutoBridge
	//
	// Since VI API 2.5
	ExcludedNicDevice []string
}

//
// This data object type describes the configuration of the beacon
// to probe connectivity of physical network adapters.  A
// beacon is sent out of one network adapter and should arrive on another
// network adapter in the team.  The successful roundtrip indicates
// that the network adapters are working.
//
// Define this data object to enable beacon probing as a method to validate
// the link status of a physical network adapter.  Beacon probing must
// be configured in order to use the beacon status as a criteria to
// determine if a physical network adapter failed.See checkBeacon
//
//
//
type HostVirtualSwitchBeaconConfig struct {
	*DynamicData

	// Determines how often, in seconds, a beacon should be sent.
	Interval int32
}

//
// This data object type describes a bridge that provides
// network adapter teaming capabilities.
//
//
type HostVirtualSwitchBondBridge struct {
	*HostVirtualSwitchBridge

	// The beacon configuration to probe for the validity of a link.
	// If this is set, beacon probing is configured and will be used.
	// If this is not set, beacon probing is disabled.
	Beacon *HostVirtualSwitchBeaconConfig

	// The link discovery protocol configuration for the virtual switch.See LinkDiscoveryProtocolConfig
	//
	// Since vSphere API 4.0
	LinkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig

	// The list of keys of the physical network adapters to be bridged.
	NicDevice []string
}

//
// A bridge connects a virtual switch to a physical network adapter.
// There are multiple types of bridges.
//
//
type HostVirtualSwitchBridge struct {
	*DynamicData
}

//
// This data object type describes the VirtualSwitch configuration
// containing both the configurable
// properties on a VirtualSwitch and identification information.
//
//
type HostVirtualSwitchConfig struct {
	*DynamicData

	// This property indicates the change operation to apply on
	// this configuration specification.See HostConfigChangeOperation
	ChangeOperation string

	// The name of the virtual switch.
	// Maximum length is 32 characters.
	Name string

	// The specification of the VirtualSwitch.
	Spec *HostVirtualSwitchSpec
}

//
// A bridge that is statically bound to a single physical network adapter.
//
//
type HostVirtualSwitchSimpleBridge struct {
	*HostVirtualSwitchBridge

	// The key of the physical network adapter to be bridged.
	NicDevice string
}

//
// This data object type describes the VirtualSwitch specification
// representing the properties on a VirtualSwitch that can be
// configured once the object exists.
//
//
type HostVirtualSwitchSpec struct {
	*DynamicData

	// The bridge specification describes how physical network adapters
	// can be bridged to a virtual switch.
	Bridge *HostVirtualSwitchBridge

	// The maximum transmission unit (MTU) of the virtual switch in bytes.
	//
	// Since VI API 2.5
	Mtu int32

	// The number of ports that this virtual switch is configured to use.
	// Changing this setting does not take effect until the next reboot. The maximum
	// value is 1024, although other constraints, such as memory limits, may establish
	// a lower effective limit.
	NumPorts int32

	// The virtual switch policy specification.  This has a lower
	// precedence than PortGroup. If the policy property is not set
	// and you are creating a virtual switch, then a default
	// policy property setting is used.  If the policy property is not
	// set and you are updating a virtual switch, then the policy will
	// be unchanged.
	Policy *HostNetworkPolicy
}

//
// The AccessSpec data object declares an update to the service
// access granted to a VM. The given list of services will either
// be granted in addition to existing services, replace the
// existing service or be revoked depending on the mode
// specified. In case of a revoke, an empty or non-existing service
// list indicates that all granted services should be revoked.
//
//
type HostVmciAccessManagerAccessSpec struct {
	*DynamicData

	Mode string

	Services []string

	Vm *VirtualMachine
}

//
// Set of possible values for mode field in AccessSpec.
//
//
type HostVmciAccessManagerMode struct {
}

//
// When a user resignatures an UnresolvedVmfsVolume through DatastoreSystem API,
// we resignature and auto-mount on the other hosts which share the
// same underlying storage luns. As part of the operation, we rescan host.
// This data object describes the outcome of rescan operation on a host
//
//
type HostVmfsRescanResult struct {
	*DynamicData

	// 'fault' would be set if the operation was not successful
	Fault *LocalizedMethodFault

	// Host name on which rescan was performed
	Host *HostSystem
}

//
// This data object type describes the VMware File System (VMFS)
// creation specification. Once created, these properties for the most
// part cannot be changed.  There are a few exceptions.
//
//
type HostVmfsSpec struct {
	*DynamicData

	// The block size of VMFS in megabytes (MB).  Determines the maximum file
	// size.  If this optional property is not set, the maximum
	// file size defaults to the maximum file size for the platform.
	//
	//
	// In VMFS2, the valid block sizes 1MB, 2MB, 4MB, 8MB, 16MB, 32MB, 64MB,
	// 128MB, and 256MB.
	// In VMFS3, the valid block sizes are 1MB, 2MB, 4MB, and 8MB.
	// In VMFS5, the only valid block size is 1MB.
	BlockSizeMb int32

	// Head extent of VMFS.  The head extent identifies the VMFS.  However,
	// the head extent should not be used to identify the VMFS across host
	// reboots.  The actual identifier is specified in "vmhbaI:T:L" format
	// which is not guaranteed to be stable across reboots.  Define a volume
	// name that is unique to the host and use it to refer to the VMFS.
	// Alternatively, the immutable UUID of the VMFS can be used after it
	// is created.
	Extent *HostScsiDiskPartition

	// Major version number of VMFS.  This can be changed if the VMFS is
	// upgraded, but this is an irreversible change.
	MajorVersion int32

	// Volume name of VMFS.
	VolumeName string
}

//
// The VMFS file system.
//
//
type HostVmfsVolume struct {
	*HostFileSystemVolume

	// Block size of VMFS.  Determines maximum file size.  The maximum number
	// of blocks is typically fixed with each specific version of VMFS.  To
	// increase the maximum size of a VMFS file, increase the block size.
	//
	// The minimum block size is 1MB.
	BlockSizeMb int32

	// The list of partition names that comprise this disk's
	// VMFS extents.
	//
	// This property can be accessed via various enclosing objects.
	// In VirtualCenter, where it can be accessed from multiple
	// hosts, the value of this property may differ according to the context
	// in which it is accessed. When accessed from the
	// VmfsDatastoreInfo object, in VirtualCenter, this
	// property reflects the extent information of any one of the hosts visible
	// to the datastore.
	//
	// For a VirtualCenter system which manages ESX Server 2.x and
	// ESX Server 3.x hosts, this extent information is only correlatable
	// across hosts if the extents are exposed on the same adapter on all hosts
	// which can access them. To find the extent names for a specific host,
	// this same property should be accessed via the host's
	// HostFileSystemVolume object, by correlating the uuid of
	// the VMFS datastore in the VmfsDatastoreInfo object to the uuid in the
	// FileSystemVolume object.
	//
	// For a Virtual Center system which manages only ESX Server hosts with
	// versions 4.0 onwards , this extent information is correlatable across
	// hosts, irrespective of the adapters the extents are exposed on.
	Extent []*HostScsiDiskPartition

	// Information about 'forceMounted' VmfsVolume.
	// When the system detects a copy of a VmfsVolume, it will not be
	// auto-mounted on the host and it will be detected as
	// 'UnresolvedVmfsVolume'. If user decides to 'forceMount' the
	// VmfsVolume on the host, forceMountedInfo will be populated.
	// It will not be set for automounted VMFS volumes.
	//
	// Since vSphere API 4.0
	ForceMountedInfo *HostForceMountedInfo

	// Indicates whether the volume is backed by local disk.
	// If unset, the information of the volume is local-disk backed is unknown.
	//
	// Since vSphere API 5.5
	Local bool

	// Major version number of VMFS.
	MajorVersion int32

	// Maximum number of blocks.  Determines maximum file size along
	// with blockSize. See information about the blockSize.
	MaxBlocks int32

	// Indicates whether the volume is SSD backed.
	// If unset, the information whether the volume is SSD backed is unknown.
	//
	// Since vSphere API 5.0
	Ssd bool

	// The universally unique identifier assigned to VMFS.
	Uuid string

	// Version string.  Contains major and minor version numbers.
	Version string

	// Can the filesystem be upgraded to a newer version.See UpgradeVmfs
	VmfsUpgradable bool
}

//
// This event records when some host Virtual NICs were reconfigured to use
// DVPorts with port level configuration, which might be different
// from the DVportgroup.
//
//
type HostVnicConnectedToCustomizedDVPortEvent struct {
	*HostEvent

	// Information about the Virtual NIC that is using the DVport.
	Vnic *VnicPortArgument
}

//
// The VsanInternalSystem exposes low level access to CMMDS, as well as draft
// versions of VSAN object and disk management APIs that are subject to change
// in future releases. No compatibility is guaranteed on any of the APIs,
// including their prototype, behavior or result encoding.
//
type HostVsanInternalSystem struct {
	*ManagedObject
}

//
// Query CMMDS directly. The list of given queries is executed and all
// results are returned in a flat list. No attempt is made to de-dupe
// results in the case of overlapping query results.
//
// Required Privileges
// System.Read
//
func (mo *HostVsanInternalSystem) QueryCmmds(
	_this *ManagedObjectReference, queries []*HostVsanInternalSystemCmmdsQuery,
) (string, error) {

	return "", nil

}

//
// Query DOM objects on a given set of physical disks. Finds all DOM objects
// that have at least one component on the given physical disks. In order to
// make this API efficient, the output of this API contains the found
// DOM_OBJECT, and referenced LSOM_OBJECT and DISK entries.
//
// Required Privileges
// System.Read
//
func (mo *HostVsanInternalSystem) QueryObjectsOnPhysicalVsanDisk(
	_this *ManagedObjectReference, disks []string,
) (string, error) {

	return "", nil

}

//
// Query statistics about physical VSAN disks. Using the props parameter the
// caller can control which properties are returned. Requesting only the
// required properties is encouraged to reduce server load, response time
// and client load.
//
// Required Privileges
// System.Read
//
func (mo *HostVsanInternalSystem) QueryPhysicalVsanDisks(
	_this *ManagedObjectReference, props []string,
) (string, error) {

	return "", nil

}

//
// Query information about VSAN DOM objects. Retrieves information about the
// given set of DOM object UUIDs. In order to make this API efficient, the
// output of this API contains the found DOM_OBJECT, and referenced
// LSOM_OBJECT and DISK entries.
//
// Required Privileges
// System.Read
//
func (mo *HostVsanInternalSystem) QueryVsanObjects(
	_this *ManagedObjectReference, uuids []string,
) (string, error) {

	return "", nil

}

//
// All fields in the CMMDS Query spec are optional, but at least one needs
// specified to make a valid query.
//
//
type HostVsanInternalSystemCmmdsQuery struct {
	*DynamicData

	// UUID of the owning node.
	Owner string

	// CMMDS type, e.g. DOM_OBJECT, LSOM_OBJECT, POLICY, DISK etc.
	Type string

	// UUID of the entry.
	Uuid string
}

//
// The VsanSystem managed object type exposes VSAN configuration
// primitives and serves as a host-level access point for relevant
// VSAN data objects.
//
type HostVsanSystem struct {
	*ManagedObject

	config *VsanHostConfigInfo
}

// The current VSAN service configuration information for this host.
// Required Privilege: System.Read
func (mo *HostVsanSystem) Config() (*VsanHostConfigInfo, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VsanHostConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VsanHostConfigInfo")
	}
	return v, nil
}

//
// Add the set of given disks for use by the VSAN service on this host.
// Users may use this API to manually add disks for use by VSAN, without
// specifying an explicit DiskMapping, when the VSAN service not
// configured to automatically claim storage. Any ineligible disk in
// the set of given disks and disks which would have exceeded
// the capacity will be ignored and will not be published in
// returned result.
//
// Upon successful completion of the returned Task, its
// result field will be populated with a
// VsanHostDiskMapResult[] and caller must inspect
// VsanHostDiskMapResult[] to check result for individual
// DiskMapping.See QueryDisksForVsanSee autoClaimStorage
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostVsanSystem) AddDisks_Task(
	_this *ManagedObjectReference, disk []*HostScsiDisk,
) (*Task, error) {

	return nil, nil

}

//
// Initialize and use the sets of disks in the given DiskMapping list
// for the VSAN service on this host.  Users may use this API to specify or
// change disk mappings when the VSAN service is not configured to
// automatically claim storage. For appending new non-SSDs to an existing
// DiskMapping, users need to specify only the new non-SSDs with its
// DiskMapping#ssd.
//
// Upon successful completion of the returned Task, its
// result field will be populated with a
// VsanHostDiskMapResult[] and caller must inspect
// VsanHostDiskMapResult[] to check result for individual
// DiskMapping.See QueryDisksForVsanSee autoClaimStorage
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostVsanSystem) InitializeDisks_Task(
	_this *ManagedObjectReference, mapping []*VsanHostDiskMapping,
) (*Task, error) {

	return nil, nil

}

//
// Queries disks on this host for suitability to use with the VSAN service,
// and returns the result.See vim.host.ScsiDisk#canonicalName
//
// Required Privileges
// System.Read
//
func (mo *HostVsanSystem) QueryDisksForVsan(
	_this *ManagedObjectReference, canonicalName []string,
) ([]*VsanHostDiskResult, error) {

	return nil, nil

}

//
// Queries this host's current runtime status for the VSAN service.
//
// Required Privileges
// System.Read
//
func (mo *HostVsanSystem) QueryHostStatus(
	_this *ManagedObjectReference,
) (*VsanHostClusterStatus, error) {

	return nil, nil

}

//
// Remove the set of given disks from use by the VSAN service on this host.
// Users may use this API to manually remove a DiskMapping#nonSsd
// from a DiskMapping. This operation is only permitted if the VSAN
// service on this host is not configured to automatically claim storage.
//
// This method may not be used to remove the last DiskMapping#nonSsd
// from any given DiskMapping. Removal of the last
// DiskMapping#nonSsd can be accomplished by using
// RemoveDiskMapping_Task.
//
//
// Upon successful completion of the returned Task, its
// result field will be populated with a
// VsanHostDiskResult[]. Sets DiskIsLastRemainingNonSSD fault
// in returned task if specified disk is the last DiskMapping#nonSsd
// member of DiskMapping.See RemoveDiskMapping_TaskSee UpdateVsan_TaskSee autoClaimStorage
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostVsanSystem) RemoveDisk_Task(
	_this *ManagedObjectReference, disk []*HostScsiDisk,
) (*Task, error) {

	return nil, nil

}

//
// Delete given set of disk mappings from use by the VSAN service on this host.
// This API may be used to remove all disks in a given mapping,
// including its DiskMapping#ssd. This operation is only permitted
// if the VSAN service on this host is not configured to automatically
// claim storage.
//
// Upon successful completion of the returned Task, its
// result field will be populated with an empty
// VsanHostDiskMapResult[]. If any errors are encountered,
// the returned field will instead contain populated error information.See RemoveDisk_TaskSee UpdateVsan_TaskSee autoClaimStorage
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostVsanSystem) RemoveDiskMapping_Task(
	_this *ManagedObjectReference, mapping []*VsanHostDiskMapping,
) (*Task, error) {

	return nil, nil

}

//
// Update the VSAN service on this host according to the given host
// configuration specification.
//
// Enabling and disabling the VSAN service can be achieved by using
// the enabled flag.
//
// Host storage settings can be specified through use of
// storageInfo.  If this value is omitted,
// changes will not be made to the existing storage configuration.
//
// Host cluster settings can be specified through use of
// clusterInfo.  If this value is omitted,
// changes will not be made to the existing cluster configuration.
//
// Host network settings can be specified through use of
// networkInfo.  If this value is omitted,
// changes will not be made to the existing network configuration.See VsanHostConfigInfoSee storageInfoSee clusterInfoSee networkInfoSee QueryDisksForVsan
//
//
// Required Privileges
// Host.Config.Storage
//
func (mo *HostVsanSystem) UpdateVsan_Task(
	_this *ManagedObjectReference, config *VsanHostConfigInfo,
) (*Task, error) {

	return nil, nil

}

//
// This event records a change in a host's WWN (World Wide Name).
//
//
type HostWwnChangedEvent struct {
	*HostEvent

	// The new node WWN.
	NewNodeWwns []int64

	// The new port WWN.
	NewPortWwns []int64

	// The old node WWN.
	OldNodeWwns []int64

	// The old port WWN.
	OldPortWwns []int64
}

//
// This event records a conflict of host WWNs (World Wide Name).
//
//
type HostWwnConflictEvent struct {
	*HostEvent

	// The host whose physical WWN conflicts with the
	// current host's WWN.
	ConflictedHosts []*HostEventArgument

	// The virtual machine whose WWN conflicts with the
	// current host's WWN.
	ConflictedVms []*VmEventArgument

	// The WWN in conflict.
	Wwn int64
}

//
// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the virtual machine is currently powered on.
//
//
type HotSnapshotMoveNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// The HourlyTaskScheduler data object sets the time for hourly
// task execution. By default, the scheduled task will run once every hour,
// at the specified minute.
//
// If you set the interval to a value greater than 1, the task will
// execute at the specified hourly interval. (For example, an interval
// of 2 will cause the task to execute at the specified minute every 2 hours.)
//
//
//
type HourlyTaskScheduler struct {
	*RecurrentTaskScheduler

	// The minute at which the RecurrentTaskScheduler runs
	// the task. Specify the minute value as a UTC (Coordinated Univeral Time)
	// value in the range 0 to 59.
	//
	// For vCenter 2.x and prior releases, use the server's local time.
	// For example, use Australia Northern Territory (UTC +9:30) or Indian (UTC +5:30)
	// time values, rather than a UTC value.
	Minute int32
}

//
// Represents a lease on a VirtualMachine or
// a VirtualApp, which can be used to import or export
// disks for the entity. While the lease is held, operations
// that alter the state of the virtual machines covered by the lease
// are blocked. Examples of blocked operations are PowerOn, Destroy,
// Migrate, etc.
//
// A lease is in one of four states:
//
//
//
// Initializing
// This is the initial state. The lease remains in this state
// while the corresponding import/export task is preparing the
// objects. In an import session, this involves creating
// inventory objects.
// Ready
// The lease changes to this state once the corresponding
// import/export task is done preparing the lease. The leased
// objects are now ready, and the client can use the information
// provided in the info property to determine where to
// up/download disks. The client must call HttpNfcLeaseProgress
// periodically to keep the lease alive and report progress to
// the corresponding import/export task. Failure to do so causes
// the lease to time out and enter the error state.
// Done
// When the client is done transferring disks, it calls
// HttpNfcLeaseComplete to signal the end of the import/export session.
// This causes the corresponding import/export task to complete
// successfully.
// Error
// If an error occurs during initialization or the lease times out,
// it will change to this state. The client can also abort the lease
// manually by calling HttpNfcLeaseAbort. In this state, the error
// property can be read to determine the cause.
// If the lease belongs to an import session, all objects created
// during the import are removed when the lease enters this state.
//
//
// The import/export task corresponding to the lease continues running while
// the lease is held.
//
type HttpNfcLease struct {
	*ManagedObject

	error *LocalizedMethodFault

	info *HttpNfcLeaseInfo

	initializeProgress int32

	state *enum.HttpNfcLeaseState
}

// If the lease is in the error state, this property contains the
// error that caused the lease to be aborted.
func (mo *HttpNfcLease) Error() (*LocalizedMethodFault, error) {
	t, err := mo.currentProperty("error")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*LocalizedMethodFault)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *LocalizedMethodFault")
	}
	return v, nil
}

// Provides information on the objects contained in this lease. The
// info property is only valid when the lease is in the ready state.
func (mo *HttpNfcLease) Info() (*HttpNfcLeaseInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HttpNfcLeaseInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HttpNfcLeaseInfo")
	}
	return v, nil
}

// Provides progress information (0-100 percent) for the initializing state
// of the lease. Clients can use this to track overall progress.
func (mo *HttpNfcLease) InitializeProgress() (int32, error) {
	t, err := mo.currentProperty("initializeProgress")
	if err != nil {
		return int32(0), err
	}

	v, ok := t.(int32)
	if !ok {
		return int32(0), errors.New("Unable to make type assertion to: int32")
	}
	return v, nil
}

// The current state of the lease.
func (mo *HttpNfcLease) State() (*HttpNfcLeaseState, error) {
	t, err := mo.currentProperty("state")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*HttpNfcLeaseState)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *HttpNfcLeaseState")
	}
	return v, nil
}

//
// Aborts the import/export and releases this lease. Operations on the
// objects contained in this lease will no longer be blocked. After
// calling this method, this lease will no longer be valid.
//
// Clients should call this method if an error occurs while accessing
// the disks, or if the operation is cancelled. The client can report
// the cause of the abort to other clients listening on the task with
// the fault parameter.
//
//
// Required Privileges
// None
//
func (mo *HttpNfcLease) HttpNfcLeaseAbort(
	_this *ManagedObjectReference, fault *MethodFault,
) error {

	return nil

}

//
// Completes the import/export and releases this lease. Operations on
// the objects contained in this lease will no longer be blocked. After
// calling this method, this lease will no longer be valid.
//
// Clients should call this method when they are done accessing the
// disks for the VirtualMachines in this lease. The status
// of the corresponding task will be set to success.
//
//
// Required Privileges
// None
//
func (mo *HttpNfcLease) HttpNfcLeaseComplete(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Gets the download manifest for this lease.
//
// Required Privileges
// None
// Since
// vSphere API 4.1
//
func (mo *HttpNfcLease) HttpNfcLeaseGetManifest(
	_this *ManagedObjectReference,
) ([]*HttpNfcLeaseManifestEntry, error) {

	return nil, nil

}

//
// Sets the disk up/download progress, and renews this lease. A lease
// will time out automatically after a while. If the client wishes to
// continue using it, for example if it is not done accessing the
// disks, this method must be called periodically.
//
// Required Privileges
// None
//
func (mo *HttpNfcLease) HttpNfcLeaseProgress(
	_this *ManagedObjectReference, percent int32,
) error {

	return nil

}

//
// For a given datastore, represented by datastoreKey, contains a list of leased
// multi-POST-capable hosts connected to it.
//
//
type HttpNfcLeaseDatastoreLeaseInfo struct {
	*DynamicData

	// Datastore key.
	DatastoreKey string

	// List of hosts connected to this datastore and covered by this lease. The
	// hosts in this list are multi-POST-capable, and any one of them can be used
	// to transfer disks on this datastore.
	Hosts []*HttpNfcLeaseHostInfo
}

//
// Provides a mapping from logical device IDs to upload/download
// URLs.
//
// For export, a single device id is returned based on the object
// identifiers for the objects.
//
//
// For import, two device ids are returned. One based on the object
// names used in the ImportSpec, and one based on the object
// identifiers for the created objects. This is immutable and would
// match the id if an ExportLease is latter created.
//
//
//
type HttpNfcLeaseDeviceUrl struct {
	*DynamicData

	// Key for the datastore this disk is on. This is used to look up hosts
	// which can be used to multi-POST disk contents, in the host map of the
	// lease.
	//
	// Since vSphere API 4.1
	DatastoreKey string

	// Optional value to specify if the attached file is a disk in
	// vmdk format.
	//
	// Since vSphere API 4.1
	Disk bool

	// Specifies the size of the file backing for this device. This property
	// is only set for non-disk file backings.
	//
	// Since vSphere API 4.1
	FileSize int64

	// Identifies the device based on the names in an ImportSpec. This is only
	// set for import leases.
	ImportKey string

	// The immutable identifier for the device. This is set for both import/export
	// leases.
	Key string

	// SSL thumbprint for the host the URL refers to. Empty if no SSL thumbprint
	// is available or needed.
	SslThumbprint string

	// Id for this target. This only used for multi-POSTing, where a single HTTP
	// POST is applied to multiple targets.
	//
	// Since vSphere API 4.1
	TargetId string

	Url string
}

//
// Contains information about how to connect to a given host.
//
//
type HttpNfcLeaseHostInfo struct {
	*DynamicData

	// SSL thumbprint for the host the URL refers to. Empty if no SSL thumbprint
	// is available or needed.
	SslThumbprint string

	// The host url will be of the form
	// https://hostname/nfc/ticket id/
	// The url can be used for both POST requests to a single device and for
	// multi-POST requests to multiple devices. A single-POST URL is formed
	// by adding the target id to the hostUrl:
	// https://hostname/nfc/ticket id/target id
	// a multi-POST URL looks like
	// https://hostname/nfc/ticket id/multi?targets=id1,id2,id3,...
	Url string
}

//
// This class holds information about the lease, such as the entity covered by the
// lease, and HTTP URLs for up/downloading file backings.
//
//
type HttpNfcLeaseInfo struct {
	*DynamicData

	// The deviceUrl property contains a mapping from logical device keys
	// to URLs.
	DeviceUrl []*HttpNfcLeaseDeviceUrl

	// The VirtualMachine or VirtualApp this
	// lease covers.
	Entity *ManagedEntity

	// Map of URLs for leased hosts for a given datastore. This is used to
	// look up multi-POST-capable hosts for a datastore.
	//
	// Since vSphere API 4.1
	HostMap []*HttpNfcLeaseDatastoreLeaseInfo

	// The HttpNfcLease object this information belongs to.
	Lease *HttpNfcLease

	// Number of seconds before the lease times out. The client extends
	// the lease by calling HttpNfcLeaseProgress before
	// the timeout has expired.
	LeaseTimeout int32

	// Total capacity in kilobytes of all disks in all Virtual Machines
	// covered by this lease. This can be used to track progress when
	// transferring disks.
	TotalDiskCapacityInKB int64
}

//
// Provides a manifest for downloaded (exported) files and disks.
//
//
type HttpNfcLeaseManifestEntry struct {
	*DynamicData

	// The capacity of the disk, if the file is a virtual disk backing.
	Capacity int64

	// True if the downloaded file is a virtual disk backing.
	Disk bool

	// Key used to match this entry with the corresponding DeviceUrl
	// entry in info.
	Key string

	// The populated size of the disk, if the file is a virtual disk backing.
	PopulatedSize int64

	// SHA-1 checksum of the data stream sent from the server. This can be used
	// to verify that the bytes received by the client match those sent by the
	// HttpNfc server.
	Sha1 string

	// Size of the downloaded file.
	Size int64
}

//
// List of possible states of a lease.
//
//
type HttpNfcLeaseState struct {
}

// Deprecated.
// As of VI API 2.5, use DeviceControllerNotSupported.
//
//
// The virtual machine uses a virtual disk with an IDE controller, but this
// is not supported on the host.
//
//
type IDEDiskNotSupported struct {
	*DiskNotSupported
}

//
// A IORMNotSupportedHostOnDatastore fault occurs when the datastore is connected
// to one or more hosts that do not support storage I/O resource management.
//
//
type IORMNotSupportedHostOnDatastore struct {
	*VimFault

	// The datastore.
	Datastore *Datastore

	// The name of the datastore.
	DatastoreName string

	// The list of hosts that do not support storage I/O
	// resource management.
	Host []*HostSystem
}

//
// Could not boot from iScsi.
//
//
type IScsiBootFailureEvent struct {
	*HostEvent
}

//
// Thrown if failure occurs while adding host to DVS during import operation
//
//
type ImportHostAddFailure struct {
	*DvsFault

	// Hosts on which import operation failed
	HostIp []string
}

//
// Thrown if a Import operation fails
//
//
type ImportOperationBulkFault struct {
	*DvsFault

	// Faults occurred during the import operation
	ImportFaults []*ImportOperationBulkFaultFaultOnImport
}

//
// The fault occurred on the entity during an import operation.
//
//
type ImportOperationBulkFaultFaultOnImport struct {
	*DynamicData

	// The entity type on which import failed. See EntityType
	// for valid values
	EntityType string

	// The fault that occurred.
	Fault *LocalizedMethodFault

	// The key on which import failed
	Key string
}

//
// An ImportSpec is used when importing VMs or vApps.
//
// It can be built from scratch, or it can be generated from an OVF descriptor using the
// service interface OvfManager.
//
//
// This class is the abstract base for VirtualMachineImportSpec and
// VirtualAppImportSpec.  These three classes form a composite structure
// that allows us to contain arbitrarily complex entitites in a single ImportSpec.
//
//
//
type ImportSpec struct {
	*DynamicData

	// Configuration of sub-entities (virtual machine or vApp). This is used for
	// sub-entities of a vApp that could be a virtual machine or a vApp.
	EntityConfig *VAppEntityConfigInfo

	// The instantiation OST (see OvfConsumer ) to be consumed by OVF
	// consumers.
	//
	// Since vSphere API 5.0
	InstantiationOst *OvfConsumerOstNode
}

//
// A InUseFeatureManipulationDisallowed fault is thrown if an Vim.LicenseAssignmentManager.SetFeatureInUse or Vim.LicenseAssignmentManager.ResetFeatureInUse call can not complete because a feature is not available or the manipulation is not allowed.
//
//
type InUseFeatureManipulationDisallowed struct {
	*NotEnoughLicenses
}

//
// An InaccessibleDatastore exception is thrown if the datastore corresponding to the
// given datastore path isn't currently accessible.
//
//
type InaccessibleDatastore struct {
	*InvalidDatastore

	// Since vSphere API 5.0
	Detail string
}

//
// An InaccessibleVFlashSource exception is thrown when
// an attempt is made to access the vFlash resource on
// the host, such as creating vFlash cache file for the
// virtual disk.
//
//
type InaccessibleVFlashSource struct {
	*VimFault

	// Name of the host which has the vFlash resource
	HostName string
}

//
// A default device (see defaultDevice for a
// definition) which the virtual machine is using is incompatible with
// the corresponding default device which will be created on the target host.
//
// This is an issue with powered-on or suspended migration under some
// circumstances.  The problem is that in cases where the virtual machine
// must be recreated, it will have the default device created with default
// settings that are appropriate for the target host.  If those are not
// compatible with the settings for that device that the virtual machine is currently
// using, then resuming the virtual machine on the target host might fail.
//
//
// This might happen if the device in question were reconfigured or the default
// is different between the source and the destination host.  An example of
// a default device and associated setting which might cause this is
// videoRamSizeInKB.
// This is an error.
//
//
//
type IncompatibleDefaultDevice struct {
	*MigrationFault

	// The label of the device.
	Device string
}

//
// The IncompatibleHostForFtSecondary fault is thrown when an invalid
// host has been specified when calling CreateSecondaryVM_Task
// or EnableSecondaryVM_Task.
//
//
type IncompatibleHostForFtSecondary struct {
	*VmFaultToleranceIssue

	// Information on why the host that was specified could not be used for
	// the FaultTolerance Secondary VirtualMachine.
	Error []*LocalizedMethodFault

	// The host that is not compatible with the secondary virtual machine.
	Host *HostSystem
}

//
// Thrown when two parameters in the customization settings conflict with each other.
// For example, a client may not specify both a Workgroup and a DomainName.
//
//
type IncompatibleSetting struct {
	*InvalidArgument

	// The name of the setting that is conflicting.
	ConflictingProperty string
}

//
// Thrown when an operation fails because the files do not match a
// specified file type.
//
//
type IncorrectFileType struct {
	*FileFault
}

//
// A IncorrectHostInformation is thrown if the host does not provide the information
// needed to acquire the correct set of licenses.
//
//
type IncorrectHostInformation struct {
	*NotEnoughLicenses
}

//
// This event records if the host did not provide the information needed
// to acquire the correct set of licenses.
//
//
type IncorrectHostInformationEvent struct {
	*LicenseEvent
}

//
// An operation on a powered-on virtual machine requests that the virtual
// machine's disks be moved without choosing a new home datastore for the
// virtual machine, but the host does not have that capability.
//
//
type IndependentDiskVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// This event is a general information event from upgrade.
//
//
type InfoUpgradeEvent struct {
	*UpgradeEvent
}

//
// The base class for any type of setting or configuration that may get a
// inherited value.
//
// When used in a reconfgure operation specification, if inherited is true,
// it specifies the intention to change the values of subclass's properties to the
// inhertied values from the level above. In this case, users don't need to specify
// the values and any set property in the subclass will be ignored.
// if inherited is false, it specifies the intension to explicitly set
// subclass's properties to user specified values. Users should set the properties in
// the subclass with the desired values.
//
//
// When used in a configuration information object, The values of the properties in
// the subclass are the effective values. if inherited is true, the object
// is getting the effective values from upper level. If false, the values are
// explicitly set by a user.
//
//
//
type InheritablePolicy struct {
	*DynamicData

	// Whether the configuration is set to inherited value.
	Inherited bool
}

//
// This fault is returned when the required number of deployed agent virtual
// machines is not currently deployed on a host and hence the host cannot be
// used to run client virtual machines.
//
//
type InsufficientAgentVmsDeployed struct {
	*InsufficientResourcesFault

	// The number of agent virtual machines currently deployed on the host.
	CurrentNumAgentVms int32

	HostName string

	// The number of agent virtual machines required to be deployed on the host.
	RequiredNumAgentVms int32
}

//
// CPU resources admission control failed
//
//
type InsufficientCpuResourcesFault struct {
	*InsufficientResourcesFault

	// The CPU resource amount requested in the failed operation in MHz.
	Requested int64

	// The CPU available in the resource pool requested in MHz.
	Unreserved int64
}

//
// Fault used to denote an insufficient group of disks for a given operation.See AddDisks_TaskSee InitializeDisks_Task
//
//
type InsufficientDisks struct {
	*VsanDiskFault
}

//
// This event records that the cluster resources are insufficient
// to satisfy the configured HA failover level.
//
//
type InsufficientFailoverResourcesEvent struct {
	*ClusterEvent
}

//
// This is thrown if an operation would violate the configured failover level of a HA
// cluster.
//
// In a HA cluster, virtual machines provide high availability by moving among physical
// machines in the event of a failure. HA Admission Control ensures that the total
// resource requirements for the set of virtual machines in a HA cluster does not exceed
// the resources that would be available in the worst-case scenario failure. If HA
// Admission Control is not used, physical machines may have insufficient resources to
// provide the expected level of service.
//
//
// This fault indicates that the virtual machine operation you attempted would have
// created a situation where the remaining physical machines would not meet the needs of
// the virtual machines in the event of a failure.
//
//
//
type InsufficientFailoverResourcesFault struct {
	*InsufficientResourcesFault
}

//
// The host does not have enough capacity for running the virtual machine.
//
//
type InsufficientHostCapacityFault struct {
	*InsufficientResourcesFault

	// The host which does not have the enough capacity.
	//
	// Since VI API 2.5
	Host *HostSystem
}

//
// The host does not have enough CPU capacity for running the virtual machine.
//
//
type InsufficientHostCpuCapacityFault struct {
	*InsufficientHostCapacityFault

	// The CPU resource amount requested in the failed operation in MHz.
	Requested int64

	// The CPU available on the host in MHz.
	Unreserved int64
}

//
// The host does not have enough memory capacity for running the virtual machine.
//
//
type InsufficientHostMemoryCapacityFault struct {
	*InsufficientHostCapacityFault

	// The memory resource amount requested in the failed operation in bytes.
	Requested int64

	// The memory available on the host in bytes.
	Unreserved int64
}

//
// Memory resource admission control failed
//
//
type InsufficientMemoryResourcesFault struct {
	*InsufficientResourcesFault

	// The memory resource amount requested in the failed operation in bytes.
	Requested int64

	// The memory available in the resource pool requested in bytes.
	Unreserved int64
}

//
// The host does not have enough per CPU capacity.
//
//
type InsufficientPerCpuCapacity struct {
	*InsufficientHostCapacityFault
}

//
// Base fault that occurs when an operation conflicts with a resource configuration
// policy. For example, this fault occurs if a power-on operation reserves more memory
// than is allocated to a resource pool.
//
//
type InsufficientResourcesFault struct {
	*VimFault
}

//
// This fault is thrown when Distributed Power Management cannot perform
// a given opeartion because there is insufficient CPU resource
// on standby hosts (if any) to meet the requirements of the operation.
//
//
type InsufficientStandbyCpuResource struct {
	*InsufficientStandbyResource

	// The total amount of CPU resource available (in MHz) on all the usable hosts
	// in the cluster (including powered on and standby hosts).
	Available int64

	// The additional amount of CPU resource (other than that on the hosts included
	// in "available") needed (in MHz).
	Requested int64
}

//
// This fault is thrown by Distributed Power Management algorithm. It indicates
// that there are insufficient memory resources on standby hosts (if any)
// to meet the requirements of a given operation.
//
//
type InsufficientStandbyMemoryResource struct {
	*InsufficientStandbyResource

	// The total amount of memory resource available (in bytes) on all the usable hosts
	// in the cluster (including powered on and standby hosts).
	Available int64

	// The additional amount of memory resource (other than that on the hosts included
	// in "available") needed (in bytes).
	Requested int64
}

//
// This fault is thrown when Distributed Power Management cannot perform
// a given opeartion because there are insufficient CPU/memory resources
// on standby hosts (if any) to meet the requirements of the operation.
//
//
type InsufficientStandbyResource struct {
	*InsufficientResourcesFault
}

//
// The fault occurs when Storage DRS cannot perform a given operation (e.g., fix the
// out of space condition, or place a virtual disk) because there is insufficient
// storage space in the given storage pod to meet the requirements of the operation.
//
//
type InsufficientStorageSpace struct {
	*InsufficientResourcesFault
}

//
// Insufficient vFlash resource to consume
//
//
type InsufficientVFlashResourcesFault struct {
	*InsufficientResourcesFault

	// The vFlash resource available capacity in bytes.
	FreeSpace int64

	// The vFlash resource amount requested in bytes.
	RequestedSpace int64
}

//
// The integer type of setting or configuration that may get a
// negated value.
//
//
type IntExpression struct {
	*NegatableExpression

	// The integer value that is either negated or used as it is
	Value int32
}

//
// The IntOption data object type is used to define the minimum, maximum,
// and default values for an integer option.
//
//
type IntOption struct {
	*OptionType

	// The default value.
	DefaultValue int32

	// The maximum value.
	Max int32

	// The minimum value.
	Min int32
}

//
// The integer type of setting or configuration that may get an
// inherited value.
//
//
type IntPolicy struct {
	*InheritablePolicy

	// The integer value that is either set or inherited.
	Value int32
}

//
// The available iSNS discovery methods.
//
//
type InternetScsiSnsDiscoveryMethod struct {
}

//
// An InvalidAffinitySettingsFault is thrown if an invalid affinity setting is
// specified for a virtual machine.
//
//
type InvalidAffinitySettingFault struct {
	*VimFault
}

//
// An InvalidArgument exception is thrown if the
// set of arguments passed to the function is not
// specified correctly.
//
//
type InvalidArgument struct {
	*RuntimeFault

	// Optional name of the invalid property.
	InvalidProperty string
}

//
// An InvalidBmcRole fault is thrown when a BMC user doesn't have the necessary
// privileges. BMC (Board Management Controller) is a piece of hardware required for
// IPMI.
//
//
type InvalidBmcRole struct {
	*VimFault
}

//
// An Invalid Bundle fault is thrown if an operation fails because of a
// problem with the supplied bundle.
//
//
type InvalidBundle struct {
	*PlatformConfigFault
}

//
// Fault indicating that the CAM server's certificate
// cannot be verified.
//
//
type InvalidCAMCertificate struct {
	*InvalidCAMServer
}

//
// Fault indicating that the CAM server
// for camServer cannot be reached,
// or is not a valid IP address.
//
//
type InvalidCAMServer struct {
	*ActiveDirectoryFault

	// The address of the CAM server.
	CamServer string
}

//
// This exception is thrown when a client has provided a
// certificate that fails certificate validation at the server.
//
//
type InvalidClientCertificate struct {
	*InvalidLogin
}

//
// InvalidCollectorVersion is thrown when a collector version is out
// of date or invalid.
//
//
type InvalidCollectorVersion struct {
	*MethodFault
}

//
// An InvalidController exception is thrown if
// a device refers to a controller that cannot be found.
// For example, an exception might be thrown if the client
// incorrectly passes a controller key,
// or if the client did not specify a controller where one is
// required (such as for disks or CD-ROMs).
//
//
type InvalidController struct {
	*InvalidDeviceSpec

	ControllerKey int32
}

//
// This fault is thrown when an attempt is made to configure an HA cluster with
// invalid argument.
//
//
type InvalidDasConfigArgument struct {
	*InvalidArgument

	// Name of the cluster to be configured
	ClusterName string

	// The entry for the invalid argument
	Entry string
}

type InvalidDasConfigArgumentEntryForInvalidArgument struct {
}

//
// This fault is thrown when an attempt is made to set the DAS restart
// priority of a FT VM to disabled.
//
//
type InvalidDasRestartPriorityForFtVm struct {
	*InvalidArgument

	// The virtual machine
	Vm *VirtualMachine

	// The name of the virtual machine
	VmName string
}

//
// An InvalidDatastore exception is thrown if an operation fails because of a
// problem with the specified datastore. Typically, a subclass of this
// exception is thrown, indicating a problem such as an inaccessible datastore
// or an invalid datastore path.
//
//
type InvalidDatastore struct {
	*VimFault

	// The datastore that is invalid.
	Datastore *Datastore

	// The name of the datastore that is invalid.
	Name string
}

//
// An InvalidDatastorePath exception is thrown if a datastore path violates
// the expected format. The expected format is "[dsName] path", e.g.
// "[storage1] folder/Vm1.vmdk".  This exception is also thrown if a datastore
// corresponding to the given datastore path is not found.
//
//
type InvalidDatastorePath struct {
	*InvalidDatastore

	// The invalid datastore path name, if one was provided.
	DatastorePath string
}

//
// The datastore is in an invalid state (e.g., maintenance mode)
// for a given operation.
//
//
type InvalidDatastoreState struct {
	*InvalidState

	// The name of the datastore.
	DatastoreName string
}

//
// An InvalidDeviceBacking exception is thrown if
// a device with an incompatible
// device backing is added or edited.
//
//
type InvalidDeviceBacking struct {
	*InvalidDeviceSpec
}

//
// An InvalidDeviceOperation exception is thrown if
// virtual machine creation or configuration fails because an invalid
// operation is attempted on the given device.
//
//
type InvalidDeviceOperation struct {
	*InvalidDeviceSpec

	// The invalid file operation attempted.
	BadFileOp *enum.VirtualDeviceConfigSpecFileOperation

	// The invalid operation attempted.
	BadOp *enum.VirtualDeviceConfigSpecOperation
}

//
// An InvalidDeviceSpec exception is thrown if
// a virtual machine creation or configuration fails because a device
// specification contains an invalid value.
//
//
type InvalidDeviceSpec struct {
	*InvalidVmConfig

	// Index of the device in the configuration specification that has the invalid value.
	DeviceIndex int32
}

//
// The disk format is either corrupted or not supported.
//
//
type InvalidDiskFormat struct {
	*InvalidFormat
}

//
// This fault is thrown when an attempt is made to set the DRS behavior
// of an FT VM to an unsupported value. Currently, the only supported
// behavior is DRS Disabled.
//
//
type InvalidDrsBehaviorForFtVm struct {
	*InvalidArgument

	// The virtual machine
	Vm *VirtualMachine

	// The name of the virtual machine
	VmName string
}

//
// This event records if the edition is set to an invalid value.
//
//
type InvalidEditionEvent struct {
	*LicenseEvent

	Feature string
}

//
// An ExpiredEditionLicense fault is thrown if an attempt to acquire an Edition license
// 'feature failed for count 'count'.
//
//
type InvalidEditionLicense struct {
	*NotEnoughLicenses

	Feature string
}

//
// A InvalidEvent fault is thrown when the event
// is malformed.
//
//
type InvalidEvent struct {
	*VimFault
}

//
// An InvalidFolderFault exception is thrown when a
// node is moved to an invalid place in the hierarchy.
//
// This can be because it is a child of the current node,
// or a wrong kind of container.
//
//
//
type InvalidFolder struct {
	*VimFault

	// Reference to invalid target.
	Target *ManagedEntity
}

//
// Throws when an invalid format is detected. For example, when
// a virtual machine is registered and the system is unable to parse
// the files as a virtual machine.
//
//
type InvalidFormat struct {
	*VmConfigFault
}

//
// An InvalidGuestLogin exception is thrown when an operation fails because
// authentication information used to authenticate with the guest was not
// accepted.
//
//
type InvalidGuestLogin struct {
	*GuestOperationsFault
}

//
// The host has an invalid connection state.
//
//
type InvalidHostConnectionState struct {
	*InvalidHostState
}

//
// The attempted operation requires that the host has a suitable FQDN.
//
//
type InvalidHostName struct {
	*HostConfigFault
}

//
// The host has an invalid state.
//
//
type InvalidHostState struct {
	*InvalidState

	// The host that has an invalid state.
	Host *HostSystem
}

//
// An InvalidIndexArgument exception is thrown if the
// index was not found
//
//
type InvalidIndexArgument struct {
	*InvalidArgument

	// Value of index that was not found
	Key string
}

//
// Illegal value specified for a property of the switch's IpfixConfig.
//
//
type InvalidIpfixConfig struct {
	*DvsFault

	// Path of the property in IpfixConfig that has an invalid value.
	Property string
}

//
// A InvalidIpmiLoginInfo fault is thrown when the IPMI user name and/or password is
// invalid.
//
//
type InvalidIpmiLoginInfo struct {
	*VimFault
}

//
// A InvalidIpmiMacAddress fault is thrown when the IPMI mac address provided by the
// user doesn't match with the observed mac address on the host.
//
//
type InvalidIpmiMacAddress struct {
	*VimFault

	ObservedMacAddress string

	UserProvidedMacAddress string
}

//
// Thrown when
// an attempt is made to upload license content
// that is invalid.
//
//
type InvalidLicense struct {
	*VimFault

	// The content of the license being reported as invalid.
	LicenseContent string
}

//
// Thrown when a locale name is unknown or invalid.
//
//
type InvalidLocale struct {
	*VimFault
}

//
// Thrown when a server logon fails due to a bad user name or
// password.
//
//
type InvalidLogin struct {
	*VimFault
}

//
// A InvalidName fault is thrown when the name
// contains an invalid character or format.
//
//
type InvalidName struct {
	*VimFault

	// Entity, if any, that has an invalid name.
	Entity *ManagedEntity

	// The invalid name.
	Name string
}

//
// This fault is thrown when an operation to configure a CIFS volume
// fails because the credentials specified in the
// spec are incorrect.
//
//
type InvalidNasCredentials struct {
	*NasConfigFault

	// The username associated with the CIFS connection.
	UserName string
}

//
// The network specified in the property does not exists.
//
//
type InvalidNetworkInType struct {
	*VAppPropertyFault
}

//
// This fault is thrown when an operation to configure a NAS volume fails
// because the network resource specified is invalid.
//
//
type InvalidNetworkResource struct {
	*NasConfigFault

	// The host that runs the CIFS or NFS server.
	RemoteHost string

	// The remote share.
	RemotePath string
}

//
// This fault is thrown when an attempt is made to invoke an operation on
// a secondary virtual machine that is only supported on the primary virtual
// machine of the fault tolerant group.
//
//
type InvalidOperationOnSecondaryVm struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// This exception is thrown if the
// power operation attempted could not be performed given
// the current power state of the virtual machine.
//
//
type InvalidPowerState struct {
	*InvalidState

	// Power state of the virtual machine that
	// prevented the operation from succeeding.
	ExistingState *enum.VirtualMachinePowerState

	// Power state of the virtual machine required to
	// allow the operation to succeed.
	RequestedState *enum.VirtualMachinePowerState
}

//
// A InvalidPrivilege fault is thrown when the privilege
// does not exist.
//
//
type InvalidPrivilege struct {
	*VimFault

	// The invalid privilege.
	Privilege string
}

//
// A InvalidProfileReferenceHost fault is thrown when a valid host is not
// associated with a profile in the Virtual Center inventory. This could
// be because there is no host assciated with the profile or because the
// associated host is incompatible with the profile.
//
//
type InvalidProfileReferenceHost struct {
	*RuntimeFault

	// The incompatible host if associated with the profile.
	Host *HostSystem

	Profile *Profile

	// The reason for the invalid reference host if known.
	Reason string
}

type InvalidProfileReferenceHostReason struct {
}

//
// Thrown when an invalid property path has been referenced.
//
//
type InvalidProperty struct {
	*MethodFault

	// The property name that generated the error.
	Name string
}

//
// The type specification in the property in invalid.
//
//
type InvalidPropertyType struct {
	*VAppPropertyFault
}

//
// The value of the property is not valid given the type of the property.
//
//
type InvalidPropertyValue struct {
	*VAppPropertyFault
}

//
// An InvalidRequest fault is thrown in response to a malformed
// request to the server that fails in the transport layer, e.g.,
// the SOAP XML request was invalid. Subtypes of this fault,
// provides more specific transport errors, such as a using a
// reference to an unknown managed object type or method.
//
//
type InvalidRequest struct {
	*RuntimeFault
}

//
// This fault is thrown when an operation will cause the structure of a resource
// pool hiearchy to exceed its limit. The limits are typically imposed by the total
// number of nodes, maximum fan-out, and total depth of the hierarchy.
//
//
type InvalidResourcePoolStructureFault struct {
	*InsufficientResourcesFault
}

//
// Thrown when an invalid snapshot configuration is detected. For
// example, when a virtual machine's snapshot tree includes
// snapshots that are no longer present.
//
//
type InvalidSnapshotFormat struct {
	*InvalidFormat
}

//
// An InvalidState fault is thrown if the
// operation failed due to the current state of the system.
//
//
type InvalidState struct {
	*VimFault
}

//
// InvalidType is thrown when a managed object request refers to
// an unexpected or unknown type.
//
//
type InvalidType struct {
	*InvalidRequest

	// Name of the argument that was malformed.
	Argument string
}

//
// Thrown when virtual machine creation or configuration fails. This is
// a base type for all virtual machine configuration errors.
//
//
type InvalidVmConfig struct {
	*VmConfigFault

	// Path of the property in configSpec that has an invalid value.
	Property string
}

//
// Data object to capture all information needed to
// describe a sample inventory.
//
//
type InventoryDescription struct {
	*DynamicData

	// The number of clusters.
	// Default value is equal to numHosts/5.
	NumClusters int32

	// The number cpu devices per host.
	// Default value is 4.
	NumCpuDev int32

	// The number disk devices per host.
	// Default value is 10.
	NumDiskDev int32

	// The number of hosts.
	NumHosts int32

	// The number network devices per host.
	// Default value is 2.
	NumNetDev int32

	// The number of resource pools.
	// Default value is equal to numHosts
	NumResourcePools int32

	// The number cpu devices per vm.
	// Default value is 2.
	NumvCpuDev int32

	// The number disk devices per vm.
	// Default value is 4.
	NumvDiskDev int32

	// The number of virtual machines.
	NumVirtualMachines int32

	// The number network devices per vm.
	// Default value is 1.
	NumvNetDev int32
}

//
// A InventoryHasStandardAloneHosts fault is thrown if an assignment operation tries to downgrade a license that does have allow hosts licensed with StandardAlone license in the inventory.
//
//
type InventoryHasStandardAloneHosts struct {
	*NotEnoughLicenses

	Hosts []string
}

//
// The InventoryView managed object provides a means of browsing the inventory and tracking
// changes to open folders. This managed object is particularly useful for UI clients that
// display a tree-based navigation panel of the inventory.
//
// InventoryView maintains the view list
// of managed object references to inventory objects. When you create an inventory view
// (CreateInventoryView), the server initializes the view's object
// list with a single folder - the root folder.
//
//
// InventoryView provides methods to open and close folders in the inventory. Use these
// methods to add and subtract objects from the view list.
// Use the InventoryView together with the PropertyCollector
// to manage the data resulting from OpenInventoryViewFolder
// and CloseInventoryViewFolder methods. By using the PropertyCollector,
// you have access to the modifications to the view, rather than processing the entire view list.
//
//
// For example, you might use the following sequence of operations with
// an InventoryView and the PropertyCollector:
//
//
// • Create an InventoryView.
//
// • Create a filter specification for the PropertyCollector.
//
//
// • Use the InventoryView as the starting object in the
// ObjectSpec for the filter.
//
// • Use a set of TraversalSpec
// data objects to identify paths in possible inventory configurations.
//
// • Use the PropertySpec
// to identify object properties for retrieval.
//
//
//
//
// • Use either the CheckForUpdates or
// WaitForUpdates method to obtain
// InventoryView modifications. Both methods return
// an UpdateSet object that describes
// the changes returned by the PropertyCollector.
//
// • Call the OpenInventoryViewFolder or method.
//
//
//
type InventoryView struct {
	*ManagedObject
	*ManagedObjectView
}

//
// Notify the server that folder(s) have been closed, and changes for all
// its contained objects should no longer be sent.  The associated child
// objects are removed from the view. The containers themselves
// will still be retained as open objects until their parent is closed.
//
// May partially succeed if some entities could not be resolved.  The operation
// will still succeed for all entities that could be resolved, and the
// list of those that failed is returned as the result.
//
//
// Required Privileges
// None
//
func (mo *InventoryView) CloseInventoryViewFolder(
	_this *ManagedObjectReference, entity []*ManagedEntity,
) ([]*ManagedEntity, error) {

	return nil, nil

}

//
// Adds the child objects of a given managed entity to the view.
//
// If a Datacenter is returned as a child, the implicit virtual machine folder and
// host folder objects are also returned. If a ComputeResource is returned,
// the implicit root ResourcePool and HostSystem objects are also returned.
//
//
// May partially succeed if some entities could not be resolved.  The operation
// will still succeed for all entities which could be resolved, and the
// list of those which failed is returned as the result.
//
//
// Required Privileges
// None
//
func (mo *InventoryView) OpenInventoryViewFolder(
	_this *ManagedObjectReference, entity []*ManagedEntity,
) ([]*ManagedEntity, error) {

	return nil, nil

}

//
// This is the abstract base class for IP address.
//
//
type IpAddress struct {
	*NegatableExpression
}

//
// The IpAddressProfile represents the Virtual NIC IP address.
// The policy property contains
// the configuration data values for the IP address.
//
//
type IpAddressProfile struct {
	*ApplyProfile
}

//
// An error occurred while running the IP/hostname generator application
//
//
type IpHostnameGeneratorError struct {
	*CustomizationFault
}

//
// Specifications of the network configuration to be used on a
// network. This is used to generate IP addresses and for self-customization
// of vApps.
//
//
type IpPool struct {
	*DynamicData

	// The number of allocated IPv4 addresses.
	//
	// Since vSphere API 5.1
	AllocatedIpv4Addresses int32

	// The number of allocated IPv6 addresses.
	//
	// Since vSphere API 5.1
	AllocatedIpv6Addresses int32

	// The number of IPv4 addresses available for allocation.
	//
	// Since vSphere API 5.1
	AvailableIpv4Addresses int32

	// The number of IPv6 addresses available for allocation.
	//
	// Since vSphere API 5.1
	AvailableIpv6Addresses int32

	// DNS Domain. For example, vmware.com. This can be an empty string if no
	// domain is configured.
	DnsDomain string

	// DNS Search Path. For example, eng.vmware.com;vmware.com
	DnsSearchPath string

	// Prefix for hostnames.
	HostPrefix string

	// The HTTP proxy to use on this network, e.g., :
	HttpProxy string

	// Unique ID, generated by the server. This is used to identify the pool in
	// subsequent lookups or updates. The generated value is also returned by the CreateIpPool method.
	Id int32

	// IPv4 configuration.
	//
	// This configuration is always present on the pool. To disable allocation, set the
	// ipPoolEnabled flag of the config to false.
	Ipv4Config *IpPoolIpPoolConfigInfo

	// IPv6 configuration.
	//
	// This configuration is always present on the pool. To disable allocation, set the
	// ipPoolEnabled flag of the config to false.
	Ipv6Config *IpPoolIpPoolConfigInfo

	// Pool name.
	//
	// The pool name must be unique within the datacenter.
	//
	// Any / (slash), \ (backslash), character used in this
	// name element is escaped. Similarly, any % (percent) character used in
	// this name element is escaped, unless it is used to start an escape
	// sequence. A slash is escaped as %2F or %2f. A backslash is escaped as %5C or
	// %5c, and a percent is escaped as %25.
	Name string

	// The networks that are associated with this IP pool
	NetworkAssociation []*IpPoolAssociation
}

//
// Information about a network or portgroup that is associated to an IP pool.
//
//
type IpPoolAssociation struct {
	*DynamicData

	// The network object
	// Required Privilege: System.Read
	Network *Network

	// The name of the network or portgroup
	//
	// This field is only used when querying existing IP pools. It is ignored when
	// creating or updating pools.
	NetworkName string
}

//
// Specifications of either IPv4 or IPv6 configuration to be used
// on this network. This is a part of network configuration.
//
// IPv4 addresses are in dot-decimal notation, e.g.: 192.0.2.235
//
//
// IPv6 addresses are in colon-hexadecimal notation,
// e.g.: 2001:0db8:85a3::0370:7334
//
//
//
type IpPoolIpPoolConfigInfo struct {
	*DynamicData

	// Whether a DHCP server is available on this network.
	DhcpServerAvailable bool

	// DNS servers
	//
	// For example:
	//
	// IPv4: ["10.20.0.1", "10.20.0.2"]
	// IPv6: ["2001:0db8:85a3::0370:7334", "2001:0db8:85a3::0370:7335"]
	//
	//
	// If an empty list is passed, the existing value remains unchanged. To clear this
	// list, pass an array containing the empty string as it's only element.
	Dns []string

	// Gateway. This can be an empty string - if no gateway is configured.
	//
	// Examples:
	//
	// IPv4: 192.168.5.1
	// IPv6: 2001:0db8:85a3::1
	Gateway string

	// IP addresses can only be allocated from the range if the IP pool is
	// enabled.
	IpPoolEnabled bool

	// Netmask
	//
	// For example:
	//
	// IPv4: 255.255.255.0
	// IPv6: ffff:ffff:ffff::
	Netmask string

	// IP range. This is specified as a set of ranges separated with commas.
	// One range is given by a start address, a hash (#), and the length
	// of the range.
	//
	// For example:
	//
	// 192.0.2.235 # 20 is the IPv4 range from 192.0.2.235 to 192.0.2.254
	// 2001::7334 # 20 is the IPv6 range from 2001::7334 to 2001::7347
	Range string

	// Address of the subnet.
	//
	// For example:
	//
	// IPv4: 192.168.5.0
	// IPv6: 2001:0db8:85a3::
	SubnetAddress string
}

//
// Singleton Managed Object used to manage IP Pools.
//
// IP Pools are used to allocate IPv4 and IPv6 addresses to vApps.
//
//
//
type IpPoolManager struct {
	*ManagedObject
}

//
// Allocates an IPv4 address from an IP pool.
//
// Allocated IP addresses are reserved in the IP pool until released by
// calling ReleaseIpAllocation, or until the IP pool is configured to
// have an IP range that does not contain the IP address, or until the IP
// pool is destroyed.
//
//
// The caller must be a vCenter extension. Refer to ExtensionManager
// for details on vCenter extensions.
//
//
// The caller specifies a per extension unique allocation ID. Calling this
// function twice with the same allocation ID for the same pool yields the
// same IP address. This makes it possible to do idempotent allocations.
//
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 5.1
//
func (mo *IpPoolManager) AllocateIpv4Address(
	_this *ManagedObjectReference, dc *Datacenter, poolId int32, allocationId string,
) (string, error) {

	return "", nil

}

//
// Allocates an IPv6 address from an IP pool.
//
// Allocated IP addresses are reserved in the IP pool until released by
// calling ReleaseIpAllocation, or until the IP pool is configured to
// have an IP range that does not contain the IP address, or until the IP
// pool is destroyed.
//
//
// The caller must be a vCenter extension. Refer to ExtensionManager
// for details on vCenter extensions.
//
//
// The caller specifies a per extension unique allocation ID. Calling this
// function twice with the same allocation ID for the same pool yields the
// same IP address. This makes it possible to do idempotent allocations.
//
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 5.1
//
func (mo *IpPoolManager) AllocateIpv6Address(
	_this *ManagedObjectReference, dc *Datacenter, poolId int32, allocationId string,
) (string, error) {

	return "", nil

}

//
// Create a new IP pool.
//
// The name field must be defined, all other fields are optional. If unset,
// they will be given default values.
//
//
// The ID for the pool is generated by the server and should not be defined on the
// pool object passed to this method.
//
//
// Required Privileges
// None
//
func (mo *IpPoolManager) CreateIpPool(
	_this *ManagedObjectReference, dc *Datacenter, pool *IpPool,
) (int32, error) {

	return int32(0), nil

}

//
// Destroys an IP pool on the given datacenter.
//
// Looks up the pool on the datacenter by ID and deletes it. If the pool is in use,
// the method throws InvalidState unless the force flag is true.
//
//
// Required Privileges
// None
//
func (mo *IpPoolManager) DestroyIpPool(
	_this *ManagedObjectReference, dc *Datacenter, id int32, force bool,
) error {

	return nil

}

//
// Query IP allocations by IP pool and extension key.
//
// Required Privileges
// None
// Since
// vSphere API 5.1
//
func (mo *IpPoolManager) QueryIPAllocations(
	_this *ManagedObjectReference, dc *Datacenter, poolId int32, extensionKey string,
) ([]*IpPoolManagerIpAllocation, error) {

	return nil, nil

}

//
// Return the list of IP pools for a datacenter.
//
// Required Privileges
// None
//
func (mo *IpPoolManager) QueryIpPools(
	_this *ManagedObjectReference, dc *Datacenter,
) ([]*IpPool, error) {

	return nil, nil

}

//
// Releases an IP allocation back to it's IP pool.
//
// Attempting to release an IP allocation that is not allocated from the
// specified IP pool with the specified allocation ID silently fails. This
// makes it possible to release IP allocations idempotently.
//
//
// All IP addresses allocated by an extension are automatically released
// if the extension is unregistered from vCenter.
//
//
// Required Privileges
// None
// Since
// vSphere API 5.1
//
func (mo *IpPoolManager) ReleaseIpAllocation(
	_this *ManagedObjectReference, dc *Datacenter, poolId int32, allocationId string,
) error {

	return nil

}

//
// Update an IP pool on a datacenter.
//
// The pool to update is looked up from the value of the id field.
//
//
// All fields in the pool except the id are optional. Only defined values are stored
// on the server.
//
//
// Required Privileges
// None
//
func (mo *IpPoolManager) UpdateIpPool(
	_this *ManagedObjectReference, dc *Datacenter, pool *IpPool,
) error {

	return nil

}

//
// Describes an IP allocation.
//
//
type IpPoolManagerIpAllocation struct {
	*DynamicData

	// The allocation ID
	AllocationId string

	// IP address
	IpAddress string
}

//
// This class specifies a range of IP addresses by using prefix.
// Usage: 128.20.20.10/24. Here 128.20.20.10 is IP address
// and 24 is prefix length.
//
//
type IpRange struct {
	*IpAddress

	// IP address prefix.
	AddressPrefix string

	// Prefix length with max value of 32 for IPv4 and 128 for IPv6.
	PrefixLength int32
}

//
// The IpRouteProfile data object represents the host IP route configuration.
// If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type IpRouteProfile struct {
	*ApplyProfile

	// List of static routes to be configured.
	StaticRoute []*StaticRouteProfile
}

//
// Defines a dependency entity.
//
// Contains the affected Virtual NIC device name and iSCSI HBA name
// (if Virtual NIC is associated with the HBA).
//
// See IscsiMigrationDependency
//
//
type IscsiDependencyEntity struct {
	*DynamicData

	// The affected Physical NIC device
	PnicDevice string

	// The iSCSI HBA that the Virtual NIC is associated with, if any.
	VmhbaName string

	// The affected Virtual NIC device
	VnicDevice string
}

//
// Base class for faults that can be thrown while invoking iSCSI management operations.
//
//
type IscsiFault struct {
	*VimFault
}

//
// This fault indicates an attempt is made to bind a Virtual NIC to an iSCSI adapter
// where the Virtual NIC has no association with the adapter. For ex: The uplink for
// the given Virtual NIC is not valid for the iSCSI HBA.
//
//
type IscsiFaultInvalidVnic struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates the given Physical NIC is being used by iSCSI HBA.
//
//
type IscsiFaultPnicInUse struct {
	*IscsiFault

	PnicDevice string
}

//
// This fault indicates that the given Virtual NIC is already bound to the iSCSI HBA.
//
//
type IscsiFaultVnicAlreadyBound struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates the given Virtual NIC has active storage paths associated with it.
//
//
type IscsiFaultVnicHasActivePaths struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates that the Virtual NIC has multiple uplinks and not suitable for iSCSI
// multi-pathing and can not be bound to iSCSI HBA.
//
//
type IscsiFaultVnicHasMultipleUplinks struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates the given Virtual NIC has no uplinks and not suitable for iSCSI
// multi-pathing configuration.
//
//
type IscsiFaultVnicHasNoUplinks struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates the given Virtual NIC has the wrong Physical uplink
// for iSCSI multi-pathing configuration. The Physical uplink is not associated
// with the iSCSI Host Bus Adapter.
//
//
type IscsiFaultVnicHasWrongUplink struct {
	*IscsiFault

	// Contains the VMkernel virtual NIC device name.
	VnicDevice string
}

//
// This fault indicates the given Virtual NIC is being used by iSCSI and the requested operation can't be completed.
//
//
type IscsiFaultVnicInUse struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates that the given Virtual NIC is associated with the only path to the storage. Any attempt to unbind this
// from iSCSI HBA would result in storage being inaccessible.
//
//
type IscsiFaultVnicIsLastPath struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates an attempt was made to remove a Virtual NIC from an iSCSI HBA while
// Virtual NIC is not associated with the adapter.
//
//
type IscsiFaultVnicNotBound struct {
	*IscsiFault

	VnicDevice string
}

//
// This fault indicates an attempt was made to add a non-existent Virtual NIC adapter.
//
//
type IscsiFaultVnicNotFound struct {
	*IscsiFault

	VnicDevice string
}

//
// This managed object provides interfaces for mapping VMkernel NIC to
// iSCSI Host Bus Adapter.
//
type IscsiManager struct {
	*ManagedObject
}

//
// Bind a Virtual NIC to be used for an iSCSI adapter
//
// Required Privileges
// Host.Config.Storage
//
func (mo *IscsiManager) BindVnic(
	_this *ManagedObjectReference, iScsiHbaName string, vnicDevice string,
) error {

	return nil

}

//
// Query the list of Virtual NICs that are bound to a given iSCSI HBA.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *IscsiManager) QueryBoundVnics(
	_this *ManagedObjectReference, iScsiHbaName string,
) ([]*IscsiPortInfo, error) {

	return nil, nil

}

//
// Query the candidate Virtual NICs and Physical NICs that can be used
// for Port-Binding.
//
// For dependent offload adapters, the Virtual NIC should be attached
// to the physical NIC associated with the hardware function.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *IscsiManager) QueryCandidateNics(
	_this *ManagedObjectReference, iScsiHbaName string,
) ([]*IscsiPortInfo, error) {

	return nil, nil

}

//
// Query the dependency table for a migration operation of a given Physical
// NIC.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *IscsiManager) QueryMigrationDependencies(
	_this *ManagedObjectReference, pnicDevice []string,
) (*IscsiMigrationDependency, error) {

	return nil, nil

}

//
// Query if Physical NIC device is used for iSCSI.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *IscsiManager) QueryPnicStatus(
	_this *ManagedObjectReference, pnicDevice string,
) (*IscsiStatus, error) {

	return nil, nil

}

//
// Query the status of Virtual NIC association with the iSCSI.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *IscsiManager) QueryVnicStatus(
	_this *ManagedObjectReference, vnicDevice string,
) (*IscsiStatus, error) {

	return nil, nil

}

//
// Unbind Virtual NIC binding from an iSCSI adapter.
//
// Required Privileges
// Host.Config.Storage
//
func (mo *IscsiManager) UnbindVnic(
	_this *ManagedObjectReference, iScsiHbaName string, vnicDevice string, force bool,
) error {

	return nil

}

//
// Provides migration dependency information for a given Physical NIC.
//
// Lists all the iSCSI and networking resources impacted if
// migration of a given Physical NIC is to take place.
//
//
type IscsiMigrationDependency struct {
	*DynamicData

	// Details of all the resources affected by migration.
	Dependency []*IscsiDependencyEntity

	// Reasons for not allowing migration.
	//
	// Unset if migrationAllowed is true.
	DisallowReason *IscsiStatus

	// Indicates whether migration can be safely performed
	//
	// If migrationAllowed is False, the disallowReason will
	// contain the specific condition that makes the migration
	// attempt unsafe.
	MigrationAllowed bool
}

//
// The IscsiPortInfo data object describes the
// Virtual NIC that are bound to an iSCSI adapter and
// also it describes the candidate Virtual NICs that
// can be bound to a given iSCSI adapter.
//
//
type IscsiPortInfo struct {
	*DynamicData

	// Status indicating whether the Virtual NIC is compliant with the
	// network policy that is required by iSCSI port binding.
	//
	// May be unset in the candidate NIC list.
	ComplianceStatus *IscsiStatus

	// A status, as defined in PathStatus, indicating the
	// existing storage paths dependency level on a given Virtual NIC.
	//
	// May be unset in the candidate NIC list.
	PathStatus string

	// Physical NIC Object corresponding to the pnicDevice.
	//
	// May be unset if Physical NIC object corresponding to pnicDevice doesn't
	// exist in the system or the vnicDevice doesn't have any Physical NIC
	// associated with it.
	Pnic *PhysicalNic

	// Physical NIC Name.
	PnicDevice string

	// Portgroup key to which this Virtual NIC belongs.
	//
	// May be unset if the vnicDevice and/or pnicDevice do not have a
	// Portgroup associated with them or the associated portgroup does
	// is not of VDS type.
	PortgroupKey string

	// Name of the portgroup to which this Virtual NIC belongs.
	//
	// May be unset if the vnicDevice and/or pnicDevice do not have a
	// Portgroup associated with them.
	PortgroupName string

	// portkey to which this Virtual NIC belongs.
	//
	// May be unset if the vnicDevice is not assigned to a specific port or
	// the switch is not VDS.
	PortKey string

	// Name of the virtual switch this Physical/Virtual NIC belongs.
	//
	// May be unset if the vnicDevice and/or pnicDevice do not have a
	// virtual switch associated with them.
	SwitchName string

	// UUID of the virtual switch this Physical/Virtual NIC belongs.
	//
	// May be unset if the vnicDevice and/or pnicDevice do not have a
	// virtual switch associated with them or the associated switch is not VDS.
	SwitchUuid string

	// Virtual NIC Object corresponding to the vnicDevice.
	//
	// May be unset if Virtual NIC object corresponding to vnicDevice doesn't
	// exist in the system.
	Vnic *HostVirtualNic

	// Virtual NIC Name.
	//
	// Contains the name of the Virtual NIC device. This may be
	// unset in case where the bound Virtual NIC doesn't have the system object or
	// where a candidate Physical NIC isn't associated with any Virtual NIC.
	VnicDevice string
}

type IscsiPortInfoPathStatus struct {
}

//
// The IscsiStatus data object describes the
// status of an operation.
//
//
type IscsiStatus struct {
	*DynamicData

	// List of failure reason and associated remedy.
	//
	// An array of fault codes associated with the failure. The fault itself
	// will provide an indication of the actual failure code and
	// faultMessage will indicate the remedy that
	// needs to be taken to correct the failure.
	Reason []*LocalizedMethodFault
}

//
// This data object type describes a file that is an ISO CD-ROM image.
//
//
type IsoImageFileInfo struct {
	*FileInfo
}

//
// This data object type describes the query specification for an ISO CD-ROM image.
//
//
type IsoImageFileQuery struct {
	*FileQuery
}

//
// Information about a kernel module.
//
//
type KernelModuleInfo struct {
	*DynamicData

	// BSS section information.
	BssSection *KernelModuleSectionInfo

	// Data section information.
	DataSection *KernelModuleSectionInfo

	// Is the module enabled?
	Enabled bool

	// Module filename, without the path.
	Filename string

	// Module ID.
	Id int32

	// Is the module loaded?
	Loaded bool

	// Module name.
	Name string

	// Option string configured to be passed to the kernel module when loaded.
	// Note that this is not necessarily the option string currently in use by
	// the kernel module.
	OptionString string

	// Read-only section information.
	ReadOnlySection *KernelModuleSectionInfo

	// Text section information.
	TextSection *KernelModuleSectionInfo

	// Number of references to this module.
	UseCount int32

	// Version string.
	Version string

	// Writable section information.
	WritableSection *KernelModuleSectionInfo
}

//
// Information about a module section.
//
//
type KernelModuleSectionInfo struct {
	*DynamicData

	// Base address of section.
	Address int64

	// Section length.
	Length int32
}

//
// Non-localized key/value pair in which the
// the value can be of any type.
//
//
type KeyAnyValue struct {
	*DynamicData

	// the key
	Key string

	// the value
	Value interface{}
}

//
// Non-localized key/value pair
//
//
type KeyValue struct {
	*DynamicData

	// Key.
	Key string

	// Value.
	Value string
}

//
// The virtual machine is using a 2TB+ RDM device and operation is
// unable to convert the disk to a different type.
//
//
type LargeRDMConversionNotSupported struct {
	*MigrationFault

	// The name of the disk device using the RDM.
	Device string
}

//
// The virtual machine is configured with a 2TB+ Raw Disk Mapping. This is not
// supported on the datastore.
//
//
type LargeRDMNotSupportedOnDatastore struct {
	*VmConfigFault

	// The datastore.
	Datastore *Datastore

	// The name of the datastore.
	DatastoreName string

	// The label of the 2TB+ RDM device that would have its backing placed on
	// the datastore.
	// This is not guaranteed to be the only such device.
	Device string
}

//
// Specification of the latency-sensitivity information.
//
// The latency-sensitivity is used to request from the kernel a constraint
// on the scheduling delay of the virtual CPUs or other resources. This allows
// latency-sensitive applications(e.g. VOIP, audio/video streaming, etc.) to run
// in a virtual machine which is configured to use specific scheduling
// latencies and to be scheduled with low latency.
//
//
// The kernel does not provide any guarantee that it will meet the
// latency-sensitivity requirement of a virtual machine CPU or other resources
// but it will always accept the latency-sensitivity value provided.
//
//
//
type LatencySensitivity struct {
	*DynamicData

	// The nominal latency-sensitive level of the application.
	Level *enum.LatencySensitivitySensitivityLevel

	// Deprecated.
	// As of vSphere version 5.5, this field is deprecated.
	//
	//
	// The custom absolute latency-sensitivity value of the application.
	// This value will be used only when the latency-sensitivity
	// level property is is set to
	// custom. It is ignored in all other cases.
	//
	// The unit of this value is micro-seconds and the application is more
	// latency sensitive when this value is smaller. For example, if the
	// absolute latency-sensitivity is 2000us, the kernel will
	// try to schedule the virtual machine in a way so that its scheduling
	// latency is not more than 2ms.
	Sensitivity int32
}

//
// Enumeration of the nominal latency-sensitive values which can be
// used to specify the latency-sensitivity level of the application.
//
// In terms of latency-sensitivity the values relate:
// high&gt;medium&gt;normal&gt;low.
//
//
//
type LatencySensitivitySensitivityLevel struct {
}

//
// A virtual machine's network connectivity cannot be determined
// because it uses a legacy network interface. If returned as part of migration checks,
// this is an error if the virtual  machine is currently connected to the legacy
// interface, and a warning otherwise.
//
//
type LegacyNetworkInterfaceInUse struct {
	*CannotAccessNetwork
}

//
// A  LicenseAssignmentFailed fault is thrown when VirtualCenter
// fails to assign a license to an entity.
//
//
type LicenseAssignmentFailed struct {
	*RuntimeFault

	// The reason why the assignment failed, if known.
	Reason string
}

type LicenseAssignmentFailedReason struct {
}

type LicenseAssignmentManager struct {
	*ManagedObject
}

//
// Get information about all the licenses associated with an entity
//
// Required Privileges
// System.View
//
func (mo *LicenseAssignmentManager) QueryAssignedLicenses(
	_this *ManagedObjectReference, entityId string,
) ([]*LicenseAssignmentManagerLicenseAssignment, error) {

	return nil, nil

}

//
// Remove licenses associated with an entity
//
// Required Privileges
// Global.Licenses
//
func (mo *LicenseAssignmentManager) RemoveAssignedLicense(
	_this *ManagedObjectReference, entityId string,
) error {

	return nil

}

//
// Update the license associated with an entity
//
// Required Privileges
// Global.Licenses
//
func (mo *LicenseAssignmentManager) UpdateAssignedLicense(
	_this *ManagedObjectReference, entity string, licenseKey string, entityDisplayName string,
) (*LicenseManagerLicenseInfo, error) {

	return nil, nil

}

type LicenseAssignmentManagerLicenseAssignment struct {
	*DynamicData

	// License assigned to the entity
	AssignedLicense *LicenseManagerLicenseInfo

	// Display name of the entity
	EntityDisplayName string

	// Id for the entity
	EntityId string

	// Additional properties associated with this assignment
	// Some of the properties are:
	// "inUseFeatures"  -- Features in the license key that are being used by the entity
	// "ProductName"    -- Name of the entity. Should match the product name of the assigned license.
	// "ProductVersion" -- Version of the entity. Should match the product version of the assigned license.
	// "Evaluation" -- EvaluationInfo object representing the evaluation left for the entity.
	Properties []*KeyAnyValue

	// Scope of the entityId
	Scope string
}

//
// Describes how many licenses of a particular feature is provided by the licensing
// source.
//
//
type LicenseAvailabilityInfo struct {
	*DynamicData

	// The number of licenses that have not yet been reserved on the source.
	Available int32

	// Describes the feature.
	Feature *LicenseFeatureInfo

	// Total number of licenses for this given type that are installed on the source.
	Total int32
}

//
// This data object type provides summary status and diagnostic information for
// LicenseManager. Counters in this property can be reset to zero. The
// property specified as a discontinuity is used to determine when this last
// occurred.
//
//
type LicenseDiagnostics struct {
	*DynamicData

	// A timestamp of when opState was last updated.
	LastStatusUpdate time.Time

	// Counter to track Total number of license features parsed from
	// License source that are not recognized.
	// This value starts at zero and wraps at 2^32-1 to zero.
	// Discontinuity: sourceLastChanged.
	LicenseFeatureUnknowns string

	// Counter to track Total number of licenses requests that were
	// not fulfilled (denied, timeout, or other).
	// This value starts at zero and wraps at 2^32-1 to zero.
	// Discontinuity: sourceLastChanged.
	LicenseRequestFailures string

	// Counter to track total number of licenses requested.
	// This value starts at zero and wraps at 2^32-1 to zero.
	// Discontinuity: sourceLastChanged.
	LicenseRequests string

	// A human readable reason when optState reports Fault condition.
	OpFailureMessage string

	// The general state of the license subsystem.
	OpState *enum.LicenseManagerState

	// A timestamp of when sourceAvailable last changed state, expressed in UTC.
	SourceLastChanged time.Time

	// Exponentially decaying average of the transaction time for license
	// acquisition and routine communications with LicenseSource.
	// Units: milliseconds.
	SourceLatency float32

	// Counter to track number of times connection to source was lost.
	// This value starts at zero and wraps at 2^32-1 to zero.
	// Discontinuity: sourceLastChanged.
	SourceLost string
}

//
// A LicenseDowngradeDisallowed fault is thrown if an assignment operation tries to downgrade a license that does have certain licensed features which are in use.
//
//
type LicenseDowngradeDisallowed struct {
	*NotEnoughLicenses

	Edition string

	EntityId string

	// List of conflicting features that prevent
	// downgrade
	Features []*KeyAnyValue
}

//
// An LicenseEntityNotFound fault is thrown when an attempt is
// do any operation on an entity/licensed asset that does not exist.
// Example, remove an entity that does not exist.
//
//
type LicenseEntityNotFound struct {
	*VimFault

	EntityId string
}

//
// This is a base licensing event to group all license events.
//
//
type LicenseEvent struct {
	*Event
}

//
// A LicenseExpired fault is thrown if it an operation is unsuccessful because the license used for the operation has expired.
//
//
type LicenseExpired struct {
	*NotEnoughLicenses

	// License key that has expired
	LicenseKey string
}

//
// This event records the expiration of a license.
//
//
type LicenseExpiredEvent struct {
	*Event

	Feature *LicenseFeatureInfo
}

//
// A single feature that can be licensed. This information is immutable.
//
//
type LicenseFeatureInfo struct {
	*DynamicData

	// Each license has a cost associated with it and the value of costUnit
	// specifies the applicable unit.
	// See LicenseFeatureInfoUnit
	CostUnit string

	// Report List of feature keys used by this edition.
	//
	// Since VI API 2.5
	DependentKey []string

	// Flag to indicate whether the feature is an edition.
	//
	// Since VI API 2.5
	Edition bool

	// Date representing the expiration date
	//
	// Since VI API 2.5
	ExpiresOn time.Time

	// A human readable description of what function this feature enables.
	//
	// Since VI API 2.5
	FeatureDescription string

	// The display string for the feature name.
	FeatureName string

	// Unique identifier for license as defined in License source data.
	// Max length of this string is 64 characters of ASCII/ISO Latin-1
	// character set.
	Key string

	// Describe any restriction on the source of a license for this feature.
	// See LicenseFeatureInfoSourceRestriction
	//
	// Since VI API 2.5
	SourceRestriction string

	// Describes the state of the feature based on the current edition license. This
	// property is unset for an edition license.
	State *enum.LicenseFeatureInfoState
}

//
// Some licenses may only be allowed to load from a specified source.
// This enum indicates what restrictions exist for this license if any.
//
//
type LicenseFeatureInfoSourceRestriction struct {
}

//
// Describes the state of the feature.
//
//
type LicenseFeatureInfoState struct {
}

//
// Cost units apply to licenses for the purpose of determining
// how many licenses are needed.
//
//
type LicenseFeatureInfoUnit struct {
}

//
// A LicenseKeyEntityMismatch fault is thrown if an assignment operation tries to assign a license that does not apply to an entity. For example assigning a host license to VirtualCenter.
//
//
type LicenseKeyEntityMismatch struct {
	*NotEnoughLicenses
}

//
// This managed object type controls entitlements for a given VMware
// platform. VMware platforms include VirtualCenter, ESX Server, VMware Server,
// Workstation and Player. Entitlements define what software capabilities
// this host may use.
//
// Entitlements are identified by a short string 'key'. Keys can represent either
// a particular edition (Full, Starter) or a particular feature/function (featureKey)
// (backup, nas). An edition implies zero one or more functions which are express,
// denied or optional. For example a 'Full' edition includes 'iscsi' function but a
// Starter edition might disallow it.
//
//
// Which edition a given VMware platform uses can be defined at any time. Generally this
// is done right after first install and boot as installation software may not set it.
// For editions that are similar in nature, any future changes to edition
// type will only impact future requests for functionality.
// Current functionality is left unaffected. The same is true for optional
// functions enabled/disabled after some period of time. For dissimilar editions,
// such transitions may require entering maintenance mode first else an exception of
// InvalidState will be thrown.
//
//
// To specify the edition type and any optional functions, use updateLicense for
// ESX Server and addLicense follow by LicenseAssingmentManager.updateAssignedLicense
// for VirtualCenter.
//
//
// When an edition is specified for a given host, the cost of that edition
// (how many licenses are needed) is determined. The cost is computed
// using the license's CostUnit value multiplied by the number of units activated.
// For example, when a VMware platform is set to an edition which uses a 'cpuPackage'
// on a two socket server, two licenses would be needed to successfully
// install that edition.
//
//
// Here is a diagram of the unit costs supported by this API and their relationships.
//
//
// +------------------------------+   +--------+      +-------+
// | +-----------+ +-----------+  |   | Server |      |  Host |
// | |           | |           |  |   +--------+      +-------+
// | |  cpuCore  | |   cpuCore |  |                   +-------+
// | +-----------+ +-----------+  |   +--------+      |  Host |
// |                  cpuPackage  |   |  VM    |      +-------+
// +------------------------------+   +--------+
//
//
type LicenseManager struct {
	*ManagedObject

	diagnostics *LicenseDiagnostics

	evaluation *LicenseManagerEvaluationInfo

	featureInfo []*LicenseFeatureInfo

	licenseAssignmentManager *LicenseAssignmentManager

	licensedEdition string

	licenses []*LicenseManagerLicenseInfo

	source *LicenseSource

	sourceAvailable bool
}

// Deprecated.
// As of vSphere API 4.0, this property is not used by the system.
//
//
// Return current diagnostic information.
//
// Since VI API 2.5
func (mo *LicenseManager) Diagnostics() (*LicenseDiagnostics, error) {
	t, err := mo.currentProperty("diagnostics")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*LicenseDiagnostics)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *LicenseDiagnostics")
	}
	return v, nil
}

// Since vSphere API 4.0
// Required Privilege: System.Read
func (mo *LicenseManager) Evaluation() (*LicenseManagerEvaluationInfo, error) {
	t, err := mo.currentProperty("evaluation")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*LicenseManagerEvaluationInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *LicenseManagerEvaluationInfo")
	}
	return v, nil
}

// Deprecated.
// As of VI API 2.5, use QuerySupportedFeatures
// instead.
//
//
// The list of features that can be licensed.
func (mo *LicenseManager) FeatureInfo() ([]*LicenseFeatureInfo, error) {
	t, err := mo.currentProperty("featureInfo")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*LicenseFeatureInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*LicenseFeatureInfo")
	}
	return v, nil
}

// License Assignment Manager
//
// Since vSphere API 4.0
// Required Privilege: System.View
func (mo *LicenseManager) LicenseAssignmentManager() (*LicenseAssignmentManager, error) {
	t, err := mo.currentProperty("licenseAssignmentManager")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*LicenseAssignmentManager)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *LicenseAssignmentManager")
	}
	return v, nil
}

// Deprecated.
// As of vSphere API 4.0, use
// QueryAssignedLicenses instead.
//
//
// The product's license edition. The edition defines which product license
// the server requires. This, in turn, determines the core set of functionalities
// provided by the product and the additional features that can be licensed. If
// no edition is set the property is set to the empty string ("").
//
// To set the edition use SetLicenseEdition.
//
// Since VI API 2.5
func (mo *LicenseManager) LicensedEdition() (string, error) {
	t, err := mo.currentProperty("licensedEdition")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

// Get information about all the licenses avaiable.
//
// Since vSphere API 4.0
// Required Privilege: dynamic
func (mo *LicenseManager) Licenses() ([]*LicenseManagerLicenseInfo, error) {
	t, err := mo.currentProperty("licenses")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*LicenseManagerLicenseInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*LicenseManagerLicenseInfo")
	}
	return v, nil
}

// Deprecated.
// As of vSphere API 4.0, use
// QueryAssignedLicenses to get evaluation information.
//
//
// Set or return a data object type of LocalLicense or LicenseServer.
func (mo *LicenseManager) Source() (*LicenseSource, error) {
	t, err := mo.currentProperty("source")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*LicenseSource)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *LicenseSource")
	}
	return v, nil
}

// Deprecated.
// As of vSphere API 4.0, this property is not used.
//
//
// Current state of the license source. License sources that are LocalSource
// are always available.
func (mo *LicenseManager) SourceAvailable() (bool, error) {
	t, err := mo.currentProperty("sourceAvailable")
	if err != nil {
		return false, err
	}

	v, ok := t.(bool)
	if !ok {
		return false, errors.New("Unable to make type assertion to: bool")
	}
	return v, nil
}

//
// Adds a license to the inventory of available licenses.
//
// Required Privileges
// Global.Licenses
// Since
// vSphere API 4.0
//
func (mo *LicenseManager) AddLicense(
	_this *ManagedObjectReference, licenseKey string, labels []*KeyValue,
) (*LicenseManagerLicenseInfo, error) {

	return nil, nil

}

// Deprecated.
// As of vSphere API 4.0, use
// QueryAssignedLicenses instead.
//
//
// Returns whether or not a given feature is enabled.
//
//
//
// Required Privileges
// System.Read
//
func (mo *LicenseManager) CheckLicenseFeature(
	_this *ManagedObjectReference, host *HostSystem, featureKey string,
) (bool, error) {

	return false, nil

}

// Deprecated.
// As of vSphere API 4.0, use UpdateLicense
// instead.
//
//
// Allows for reconfiguration of the License Manager license source.
//
// This changes the licensing source to be either served or local. Before changing
// the license source location, the API checks the number of licenses available at
// the new potential source to ensure there are at least as many licenses there as
// have been issued by the current source. If there are an equal or greater number of
// licenses at the new source, all licenses on the current source are released and
// then reacquired from the new source. If there are not enough licenses available on
// the new source to reissue all licenses, the operation fails.
//
//
// This is used to configure the license source on an individual host.
//
//
// PLATFORM Specific Notes:
// VirtualCenter - only supports a served source.
// the host parameter is mandatory.
// ESX Server  -  the host parameter is optional.
//
//
//
//
// Required Privileges
// Global.Licenses
//
func (mo *LicenseManager) ConfigureLicenseSource(
	_this *ManagedObjectReference, host *HostSystem, licenseSource *LicenseSource,
) error {

	return nil

}

//
// Decodes licensing information on the license specified.
//
// Required Privileges
// Global.Licenses
// Since
// vSphere API 4.0
//
func (mo *LicenseManager) DecodeLicense(
	_this *ManagedObjectReference, licenseKey string,
) (*LicenseManagerLicenseInfo, error) {

	return nil, nil

}

// Deprecated.
// As of vSphere API 4.0, use
// RemoveAssignedLicense instead.
//
//
// Release licenses for an optional feature.
//
//
//
// Required Privileges
// Global.Licenses
//
func (mo *LicenseManager) DisableFeature(
	_this *ManagedObjectReference, host *HostSystem, featureKey string,
) (bool, error) {

	return false, nil

}

// Deprecated.
// As of vSphere API 4.0, use
// UpdateAssignedLicense instead.
//
//
// Enable a feature that has an optional state.
//
//
//
// Required Privileges
// Global.Licenses
//
func (mo *LicenseManager) EnableFeature(
	_this *ManagedObjectReference, host *HostSystem, featureKey string,
) (bool, error) {

	return false, nil

}

// Deprecated.
// As of vSphere API 4.0, use
// QueryAssignedLicenses instead.
//
//
// Queries the current license source for total and available licenses available for
// each feature known to this system.
//
// Required Privileges
// Global.Licenses
//
func (mo *LicenseManager) QueryLicenseSourceAvailability(
	_this *ManagedObjectReference, host *HostSystem,
) ([]*LicenseAvailabilityInfo, error) {

	return nil, nil

}

// Deprecated.
// As of vSphere API 4.0, use
// QueryAssignedLicenses instead.
//
//
// Returns the license usage. The license usage is a list of supported features and
// the number of licenses that have been reserved.
//
// PLATFORM Specific Notes:
// VirtualCenter - Empty string returns the usage of non-host specific features.
// Must specify managed host to query.
// ESX Server - Host argument ignored.
//
//
// Required Privileges
// System.Read
//
func (mo *LicenseManager) QueryLicenseUsage(
	_this *ManagedObjectReference, host *HostSystem,
) (*LicenseUsageInfo, error) {

	return nil, nil

}

// Deprecated.
// As of vSphere API 4.0, use
// QueryAssignedLicenses instead.
//
//
// Queries the current license source for a list of available licenses that can be
// licensed from this system.
//
// Required Privileges
// Global.Licenses
// Since
// VI API 2.5
//
func (mo *LicenseManager) QuerySupportedFeatures(
	_this *ManagedObjectReference, host *HostSystem,
) ([]*LicenseFeatureInfo, error) {

	return nil, nil

}

//
// Remove license from the available set.
//
// Required Privileges
// Global.Licenses
// Since
// vSphere API 4.0
//
func (mo *LicenseManager) RemoveLicense(
	_this *ManagedObjectReference, licenseKey string,
) error {

	return nil

}

//
// Removed a license's label.
//
// Required Privileges
// Global.Licenses
// Since
// vSphere API 4.0
//
func (mo *LicenseManager) RemoveLicenseLabel(
	_this *ManagedObjectReference, licenseKey string, labelKey string,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 4.0, use
// QueryAssignedLicenses instead.
//
//
// Defines the product's license edition. The edition defines which product license
// the server requires. This, in turn, determines the core set of functionality
// provided by the product and the additional features that can be licensed.
//
// To determine what featureKey the current platform will accept, use
// querySourceAvailablity() at runtime, or consult the documentation for the
// current platform.
//
//
//
//
// Required Privileges
// Global.Licenses
//
func (mo *LicenseManager) SetLicenseEdition(
	_this *ManagedObjectReference, host *HostSystem, featureKey string,
) error {

	return nil

}

//
// Updates the available licenses to the one provided in licenseKey.
//
// This is the same as removing all the licenses using
// RemoveLicense and adding licenseKey using
// AddLicense
//
// If the optional parameter labels is specify this is the same as calling
// updateLicense without the optioal parameter and calling updateLabel for each pair
// in the labels array.
//
// Required Privileges
// Global.Licenses
// Since
// vSphere API 4.0
//
func (mo *LicenseManager) UpdateLicense(
	_this *ManagedObjectReference, licenseKey string, labels []*KeyValue,
) (*LicenseManagerLicenseInfo, error) {

	return nil, nil

}

//
// Update a license's label.
// It creates a label entry if the labelKey doesn't already exist
//
// Required Privileges
// Global.Licenses
// Since
// vSphere API 4.0
//
func (mo *LicenseManager) UpdateLicenseLabel(
	_this *ManagedObjectReference, licenseKey string, labelKey string, labelValue string,
) error {

	return nil

}

//
// Encapsulates product evaluation information
//
//
type LicenseManagerEvaluationInfo struct {
	*DynamicData

	// Evaluation properties
	Properties []*KeyAnyValue
}

//
// Encapsulates information about a license
//
//
type LicenseManagerLicenseInfo struct {
	*DynamicData

	// The cost unit for this license
	CostUnit string

	// Edition key.
	EditionKey string

	// Key-value lables for this license
	Labels []*KeyValue

	// Key for the license. E.g. serial number.
	LicenseKey string

	// Display name for the license
	Name string

	// Additional properties associated with this license
	Properties []*KeyAnyValue

	// Total number of units contain in the license
	Total int32

	// Number of units used from this license
	Used int32
}

// Deprecated.
// As of VI API 2.5, use QueryLicenseSourceAvailability
// to obtain an array of LicenseAvailabilityInfo data
// objects.
//
//
// Licensed features have unique keys to identify them.
//
//
type LicenseManagerLicenseKey struct {
}

//
// State of licensing subsystem.
//
//
type LicenseManagerState struct {
}

//
// This event records that the inventory is not license compliant.
//
//
type LicenseNonComplianceEvent struct {
	*LicenseEvent

	// Gives the url at which more details about non-compliance
	// can be found.
	Url string
}

//
// A reservation describes how many licenses of a particular feature are being used
// by a particular feature.
//
//
type LicenseReservationInfo struct {
	*DynamicData

	// Key of the License Feature.
	// See key
	Key string

	// Contains the required number of licenses of the particular type that the
	// product needs in its current configuration.
	//
	// Licenses are normally allocated at the same time as they are needed, so the
	// value of required is set at the time the license is needed. For example,
	// in the case of the number of licenses based on virtual machines, the required
	// count is set at the time a virtual machine is powered on, just before the
	// license is checked out.
	Required int32

	// Describes the reservation state of a license.
	State *enum.LicenseReservationInfoState
}

//
// Describes the reservation state of a license.
//
//
type LicenseReservationInfoState struct {
}

//
// This fault is thrown if the required licenses were unable to be checked
// out due to a restriction in the option file of the license server.
//
//
type LicenseRestricted struct {
	*NotEnoughLicenses
}

//
// This event records if the required licenses could not be reserved because
// of a restriction in the option file.
//
//
type LicenseRestrictedEvent struct {
	*LicenseEvent
}

//
// This event is reported if the LicenseServer was previously unreachable
// and is now reachable.
//
//
type LicenseServerAvailableEvent struct {
	*LicenseEvent

	LicenseServer string
}

//
// Specify a license server reachable via IPv4 network.
//
//
type LicenseServerSource struct {
	*LicenseSource

	// This property defines the server to establish a TCP session to
	// obtain license data. Format of string is host:port
	// Port is optional unsigned 16 bit integer license
	// server is listening on. A trailing colon ':' without a port number
	// is a valid expression.
	// Host can either be an IPv4 address in dotted quad
	// format or a resolvable DNS name <=254 characters. See RFC 3696.
	LicenseServer string
}

//
// This fault is thrown when the License Server
// is unavailable during an attempt to change license state.
//
//
type LicenseServerUnavailable struct {
	*VimFault

	// The name of the unavailable license server.
	LicenseServer string
}

//
// This event is reported if the LicenseServer becomes unreachable.
//
//
type LicenseServerUnavailableEvent struct {
	*LicenseEvent

	LicenseServer string
}

//
// This data object type is used to communicate configuration about
// where to find licenses to use for this system.
//
//
type LicenseSource struct {
	*DynamicData
}

//
// A LicenseSourceUnavailable is thrown if it is unable to check out a license because
// the license source is unavailable.
//
//
type LicenseSourceUnavailable struct {
	*NotEnoughLicenses

	// License source
	LicenseSource *LicenseSource
}

//
// Contains source information, licensed features, and usage.
//
//
type LicenseUsageInfo struct {
	*DynamicData

	// Includes all the features that are referenced in the reservation array.
	FeatureInfo []*LicenseFeatureInfo

	// A list of feature reservations.
	ReservationInfo []*LicenseReservationInfo

	// The source from which licensing data is acquired.See LicenseSource
	Source *LicenseSource

	// Returns whether or not the source is currently available.See sourceAvailable
	SourceAvailable bool
}

//
// This exception is thrown if one of the arguments passed to the function exceeds
// a limit.
//
//
type LimitExceeded struct {
	*VimFault

	// The limit value.
	Limit int32

	// The name of the property that exceeds the limit.
	Property string
}

//
// Dataobject representing the link discovery protocol configuration for a
// virtual or distributed virtual switch.
//
//
type LinkDiscoveryProtocolConfig struct {
	*DynamicData

	// Whether to advertise or listen. For valid values see
	// LinkDiscoveryProtocolConfigOperationType.
	Operation string

	// The discovery protocol type. For valid values
	// see LinkDiscoveryProtocolConfigProtocolType.
	Protocol string
}

//
// The Discovery Protocol operation.
//
//
type LinkDiscoveryProtocolConfigOperationType struct {
}

//
// The Discovery Protocol types.
//
//
type LinkDiscoveryProtocolConfigProtocolType struct {
}

//
// The Link Layer Discovery Protocol information.
//
//
type LinkLayerDiscoveryProtocolInfo struct {
	*DynamicData

	// ChassisId represents the chassis identification for the device that
	// transmitted the LLDP frame. The receiving LLDP agent combines the
	// Chassis ID and portId to represent the entity connected to the port
	// where the frame was received.
	ChassisId string

	// LLDP parameters
	Parameter []*KeyAnyValue

	// This property identifies the specific port that transmitted the LLDP
	// frame. The receiving LLDP agent combines the Chassis ID and Port to
	// represent the entity connected to the port where the frame was received.
	PortId string

	// It is the duration of time in seconds for which information contained
	// in the received LLDP frame shall be valid. If a value of zero is sent
	// it can also identify a device that has shut down or is no longer
	// transmitting, prompting deletion of the record from the local database.
	TimeToLive int32
}

type LinkProfile struct {
	*ApplyProfile
}

//
// Customization operation is performed on a linux source vm that
// was not shut down properly. If the filesystem has significant
// fsck errors on it, customization process cannot make changes
// to it.
//
//
type LinuxVolumeNotClean struct {
	*CustomizationFault
}

//
// The ListView managed object provides access to updates on a specific set of objects.
// You can use a ListView with a PropertyCollector method
// to retrieve data or receive notification of changes. For information about using views
// with the PropertyCollector, see the description of ViewManager.
//
// When you invoke the CreateListView method, you specify
// a list of objects. The view list
// always represents the current configuration of the virtual environment
// and reflects any subsequent changes that occur.
//
//
//
type ListView struct {
	*ManagedObject
	*ManagedObjectView
}

//
// Modify the list by giving a delta of entities to add and
// entities to remove.
//
// May partially succeed if some objects could not be resolved.  The operation
// will still succeed for all objects which could be resolved, and the
// list of those which failed is returned as the result.
//
//
// Required Privileges
// None
//
func (mo *ListView) ModifyListView(
	_this *ManagedObjectReference, add []*ManagedObjectReference, remove []*ManagedObjectReference,
) ([]*ManagedObjectReference, error) {

	return nil, nil

}

//
// Replaces the list with an entirely new set of objects.  If
// the entire set is changing, this is less data to send than a delta.
//
// May partially succeed if some objects could not be resolved.  The operation
// will still succeed for all objects which could be resolved, and the
// list of those which failed is as the result.
//
//
// Required Privileges
// None
//
func (mo *ListView) ResetListView(
	_this *ManagedObjectReference, obj []*ManagedObjectReference,
) ([]*ManagedObjectReference, error) {

	return nil, nil

}

//
// Replaces the list with the set of objects in a given view.
//
// Required Privileges
// None
//
func (mo *ListView) ResetListViewFromView(
	_this *ManagedObjectReference, view *View,
) error {

	return nil

}

//
// This event records when a local datastore is created.
//
//
type LocalDatastoreCreatedEvent struct {
	*HostEvent

	// The associated datastore.
	Datastore *DatastoreEventArgument
}

//
// The information details about a datastore that is local to a host.
//
//
type LocalDatastoreInfo struct {
	*DatastoreInfo

	// The local path on a host.  May not
	// be available when the datastore is not accessible.
	Path string
}

//
// Specify license key data to store locally.
//
//
type LocalLicenseSource struct {
	*LicenseSource

	// The size of this string is implementation dependent.
	// It must contain ASCII or ISO Latin-1 characters only.
	LicenseKeys string
}

//
// Local Tech Support Mode for the host has been enabled.
//
//
type LocalTSMEnabledEvent struct {
	*HostEvent
}

//
// Message data which is intended to be displayed according
// to the locale of a client.
//
// A LocalizableMessage contains both a formatted, localized
// version of the text and the data needed to perform localization in
// conjunction with localization catalogs.
//
//
// Clients of the VIM API may use vim.SessionManager.setLocale()
// to cause the server to emit a localized message, or may perform
// client-side localization based on message catalogs provided by the
// server.
//
//
//
//
// • If the substition variable is a string, no further lookup is required.
//
//
// • arg = [("address" = "127.0.0.1")]
//
// • CATALOG(locmsg, key) = "IP address is {address}"
//
// • ==&gt; message = "IP address is 127.0.0.1"
//
//
//
//
//
// • If the substitution variable is an integer, value is a lookup key.
//
//
// • arg = [("1" = "button.cancel"), ("2" = "msg.revert")]
//
// • CATALOG(locmsg, key) = "Select '{1}' to {2}"
//
// • CATALOG(locmsg, button.cancel) = "Cancel"
//
// • CATALOG(locmsg, msg.revert) = "revert"
//
// • ==&gt; message = "Select 'Cancel' to revert"
//
//
//
//
//
// • If the variable contains '@', value is a label lookup in another
// catalog, where {name.@CATALOG.prefix} looks up prefix.arg[name].label
// in CATALOG.
//
//
// • arg = [("field" = "queued")]
//
// • CATALOG(locmsg, key) = "State is {field.@enum.TaskInfo.State}"
//
// • CATALOG(enum, TaskInfo.State.queued.label) is "Queued"
//
// • ==&gt; message = "State is Queued"
//
//
//
//
//
//
//
//
//
type LocalizableMessage struct {
	*DynamicData

	// Substitution arguments for variables in the localized message.
	Arg []*KeyAnyValue

	// Unique key identifying the message in the localized message catalog.
	Key string

	// Message in session locale.
	// Use vim.SessionManager.setLocale() to change the session locale.
	Message string
}

//
// LocalizationManager provides access to descriptions of
// the message catalogs that are available for client-side message
// localization.
//
// Clients of the VIM API may use
// SessionManager.SetLocale
// to cause the server to emit localized messages, or may perform
// client-side localization based on message catalogs provided by the
// LocalizationManager.
//
//
// A message catalog is a file that contains a set of key-value pairs.
//
//
//
// • The key is an ASCII string that identifies the message.
//
// • The value is a UTF-8 string that contains the text of the message, sometimes
// containing substitution variables.
//
//
//
// The server will localize fields tagged with 'localizable' based on the
// value of the UserSession.locale
// and messageLocale properties which are set via
// SessionManager.SetLocale.
//
//
// The following list shows some of the ways that vSphere uses localized
// messages.
//
//
//
// • Current task status (TaskInfo.description)
//
// • Events (VirtualMachineMessage.text and
// Questions (VirtualMachineQuestionInfo.text)
//
// • Faults (MethodFault.faultMessage)
//
// • HostProfile and
// ClusterProfile descriptions
// (Profile.ProfileDescription.
// description returned by the
// Profile.RetrieveDescription method)
//
//
//
//
type LocalizationManager struct {
	*ManagedObject

	catalog []*LocalizationManagerMessageCatalog
}

// Fetches the descriptions of all the client-side localization message
// catalogs available for the current session locale.
// Required Privilege: System.View
func (mo *LocalizationManager) Catalog() ([]*LocalizationManagerMessageCatalog, error) {
	t, err := mo.currentProperty("catalog")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*LocalizationManagerMessageCatalog)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*LocalizationManagerMessageCatalog")
	}
	return v, nil
}

//
// Description of an available message catalog
//
//
type LocalizationManagerMessageCatalog struct {
	*DynamicData

	// The name of the catalog.
	CatalogName string

	// The URI (relative to the connection URL for the VirtualCenter server
	// itself) from which the catalog can be downloaded.
	//
	// The caller will need to augment this with a scheme and authority (host
	// and port) to make a complete URL.
	CatalogUri string

	// The last-modified time of the catalog file, if available
	LastModified time.Time

	// The locale for the catalog.
	Locale string

	// The checksum of the catalog file, if available
	Md5sum string

	// The module or extension that publishes this catalog.
	//
	// The moduleName will be empty for the core catalogs for the
	// VirtualCenter server itself.
	ModuleName string

	// The version of the catalog file, if available
	//
	// The format is dot-separated version string, e.g. "1.2.3".
	//
	// Since vSphere API 5.0
	Version string
}

//
// A wrapper class used to pass MethodFault data objects over the wire
// along with a localized display message for the fault.
//
//
type LocalizedMethodFault struct {
	*DynamicData

	Fault *MethodFault

	// The localized message that would be sent in the faultstring element
	// of the SOAP Fault.  It is optional so that clients are not required
	// to send a localized message to the server, but servers are required
	// to send the localized message to clients.
	LocalizedMessage string
}

//
// Locker has not been configured properly.
// This event is fired when the datastore configured to back the locker
// does not exist or when connectivity to the datastore is lost.
//
//
type LockerMisconfiguredEvent struct {
	*Event

	// The datastore that has been configured to back the locker
	Datastore *DatastoreEventArgument
}

//
// Locker was reconfigured to a new location.
//
//
type LockerReconfiguredEvent struct {
	*Event

	// The datastore that is now used to back the locker.
	// This field is not set if no datastore is currently backing the locker.
	NewDatastore *DatastoreEventArgument

	// The datastore that was previously backing the locker. This field is not
	// set if a datastore was not backing the locker previously.
	OldDatastore *DatastoreEventArgument
}

//
// A LogBundlingFailed exception is thrown when generation of a diagnostic
// data bundle fails.
//
//
type LogBundlingFailed struct {
	*VimFault
}

//
// The LongOption data object type is used to define the minimum, maximum,
// and default values for a 64-bit long option.
//
//
type LongOption struct {
	*OptionType

	// The default value.
	DefaultValue int64

	// The maximum value.
	Max int64

	// The minimum value.
	Min int64
}

//
// The long integer type of setting or configuration that may get an
// inherited value.
//
//
type LongPolicy struct {
	*InheritablePolicy

	// The boolean value that is either set or inherited.
	Value int64
}

//
// Base class for specifying MAC addresses.
//
//
type MacAddress struct {
	*NegatableExpression
}

//
// This class defines a range of MAC address.
//
//
type MacRange struct {
	*MacAddress

	// MAC address.
	Address string

	// Mask that is used in matching the MAC address. A MAC address is
	// considered matched if the "and" operation of the mask on the
	// MAC address and address yields the same result.
	// For example, a MAC of "00:A0:FF:14:FF:29" is considered matched
	// for a address of "00:A0:C9:14:C8:29" and a
	// mask of "FF:FF:00:FF:00:FF".
	Mask string
}

//
// Migration of the virtual machine to the target host will need a move of
// virtual machine files, like configuration file or virtual disks, which is
// not permitted if the source host is in maintenance mode.
//
//
type MaintenanceModeFileMove struct {
	*MigrationFault
}

//
// The ManagedByInfo data object contains information about the extension
// responsible for the life-cycle of the entity.
//
//
type ManagedByInfo struct {
	*DynamicData

	// Key of the extension managing the entity.
	ExtensionKey string

	// Managed entity type, as defined by the extension managing the entity.
	// An extension can manage different types of entities - different kinds
	// of virtual machines, vApps, etc. - and this property is used to find
	// the corresponding managedEntityInfo
	// entry from the extension.
	Type string
}

//
// ManagedEntity is an abstract base type for all managed objects present in
// the inventory tree. The base type provides common functionality for traversing the
// tree structure, as well as health monitoring and other basic functions.
//
// Most Virtual Infrastructure managed object types extend this type.
//
//
//
type ManagedEntity struct {
	*ExtensibleManagedObject

	alarmActionsEnabled bool

	configIssue []*Event

	configStatus *enum.ManagedEntityStatus

	customValue []*CustomFieldValue

	declaredAlarmState []*AlarmState

	disabledMethod []string

	effectiveRole []int32

	name string

	overallStatus *enum.ManagedEntityStatus

	parent *ManagedEntity

	permission []*Permission

	recentTask []*Task

	tag []*Tag

	triggeredAlarmState []*AlarmState
}

// Whether alarm actions are enabled for this entity.
// True if enabled; false otherwise.
//
// Since vSphere API 4.0
// Required Privilege: System.Read
func (mo *ManagedEntity) AlarmActionsEnabled() (bool, error) {
	t, err := mo.currentProperty("alarmActionsEnabled")
	if err != nil {
		return false, err
	}

	v, ok := t.(bool)
	if !ok {
		return false, errors.New("Unable to make type assertion to: bool")
	}
	return v, nil
}

// Current configuration issues that have been detected for this entity. Typically,
// these issues have already been logged as events. The entity stores these
// events as long as they are still current. The
// configStatus property provides an overall status
// based on these events.
func (mo *ManagedEntity) ConfigIssue() ([]*Event, error) {
	t, err := mo.currentProperty("configIssue")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Event)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Event")
	}
	return v, nil
}

// The configStatus indicates whether or not the system has detected a configuration
// issue involving this entity. For example, it might have detected a
// duplicate IP address or MAC address, or a host in a cluster
// might be out of compliance. The meanings of the configStatus values are:
//
// red:    A problem has been detected involving the entity.
// yellow: A problem is about to occur or a transient condition
// has occurred (For example, reconfigure fail-over policy).
// green:  No configuration issues have been detected.
// gray:   The configuration status of the entity is not being monitored.
//
// A green status indicates only that a problem has not been detected;
// it is not a guarantee that the entity is problem-free.
//
// The configIssue property contains a list of the
// problems that have been detected.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
func (mo *ManagedEntity) ConfigStatus() (*ManagedEntityStatus, error) {
	t, err := mo.currentProperty("configStatus")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ManagedEntityStatus)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ManagedEntityStatus")
	}
	return v, nil
}

// Custom field values.
// Required Privilege: System.View
func (mo *ManagedEntity) CustomValue() ([]*CustomFieldValue, error) {
	t, err := mo.currentProperty("customValue")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*CustomFieldValue)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*CustomFieldValue")
	}
	return v, nil
}

// A set of alarm states for alarms that apply to this managed entity.
// The set includes alarms defined on this entity
// and alarms inherited from the parent entity,
// or from any ancestors in the inventory hierarchy.
//
// Alarms are inherited if they can be triggered by this entity or its descendants.
// This set does not include alarms that are defined on descendants of this entity.
// Required Privilege: System.View
func (mo *ManagedEntity) DeclaredAlarmState() ([]*AlarmState, error) {
	t, err := mo.currentProperty("declaredAlarmState")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*AlarmState)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*AlarmState")
	}
	return v, nil
}

// List of operations that are disabled, given the current runtime
// state of the entity. For example, a power-on operation always fails if a
// virtual machine is already powered on. This list can be used by clients to
// enable or disable operations in a graphical user interface.
//
// Note: This list is determined by the current runtime state of an entity,
// not by its permissions.
//
// This list may include the following operations for a HostSystem:
//
// EnterMaintenanceMode_Task
// ExitMaintenanceMode_Task
// RebootHost_Task
// ShutdownHost_Task
// ReconnectHost_Task
// DisconnectHost_Task
//
//
// This list may include the following operations for a VirtualMachine:
//
// AnswerVM
// Rename_Task
// CloneVM_Task
// PowerOffVM_Task
// PowerOnVM_Task
// SuspendVM_Task
// ResetVM_Task
// ReconfigVM_Task
// RelocateVM_Task
// MigrateVM_Task
// CustomizeVM_Task
// ShutdownGuest
// StandbyGuest
// RebootGuest
// CreateSnapshot_Task
// RemoveAllSnapshots_Task
// RevertToCurrentSnapshot_Task
// MarkAsTemplate
// MarkAsVirtualMachine
// ResetGuestInformation
// MountToolsInstaller
// UnmountToolsInstaller
// Destroy_Task
// UpgradeVM_Task
// ExportVm
//
//
// This list may include the following operations for a ResourcePool:
//
// ImportVApp
// CreateChildVM_Task
// UpdateConfig
// CreateVM_Task
// Destroy_Task
// Rename_Task
//
// This list may include the following operations for a VirtualApp:
//
// Destroy_Task
// CloneVApp_Task
// unregisterVApp_Task
// ExportVApp
// PowerOnVApp_Task
// PowerOffVApp_Task
// UpdateVAppConfig
//
//
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
func (mo *ManagedEntity) DisabledMethod() ([]string, error) {
	t, err := mo.currentProperty("disabledMethod")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]string)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []string")
	}
	return v, nil
}

// Access rights the current session has to this entity.
// Required Privilege: System.View
func (mo *ManagedEntity) EffectiveRole() ([]int32, error) {
	t, err := mo.currentProperty("effectiveRole")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]int32)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []int32")
	}
	return v, nil
}

// Name of this entity, unique relative to its parent.
//
// Any / (slash), \ (backslash), character used in this
// name element will be escaped. Similarly, any % (percent) character used in
// this name element will be escaped, unless it is used to start an escape
// sequence. A slash is escaped as %2F or %2f. A backslash is escaped as %5C or
// %5c, and a percent is escaped as %25.
// Required Privilege: System.View
func (mo *ManagedEntity) Name() (string, error) {
	t, err := mo.currentProperty("name")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

// General health of this managed entity.
// The overall status of the managed entity is computed as the worst status
// among its alarms and the configuration issues detected on the entity.
// The status is reported as one of the following values:
//
// red:    The entity has alarms or configuration issues with a red status.
// yellow: The entity does not have alarms or configuration issues with a
// red status, and has at least one with a yellow status.
// green:  The entity does not have alarms or configuration issues with a
// red or yellow status, and has at least one with a green status.
// gray:   All of the entity's alarms have a gray status and the
// configuration status of the entity is not being monitored.
//
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
func (mo *ManagedEntity) OverallStatus() (*ManagedEntityStatus, error) {
	t, err := mo.currentProperty("overallStatus")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ManagedEntityStatus)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ManagedEntityStatus")
	}
	return v, nil
}

// Parent of this entity.
//
// This value is null for the root object and for
// VirtualMachine objects that are part of
// a VirtualApp.
// Required Privilege: System.View
func (mo *ManagedEntity) Parent() (*ManagedEntity, error) {
	t, err := mo.currentProperty("parent")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ManagedEntity)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ManagedEntity")
	}
	return v, nil
}

// List of permissions defined for this entity.
func (mo *ManagedEntity) Permission() ([]*Permission, error) {
	t, err := mo.currentProperty("permission")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Permission)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Permission")
	}
	return v, nil
}

// The set of recent tasks operating on this managed entity. This is a subset
// of recentTask belong to this entity. A task in this
// list could be in one of the four states: pending, running, success or error.
//
// This property can be used to deduce intermediate power states for
// a virtual machine entity. For example, if the current powerState is "poweredOn"
// and there is a running task performing the "suspend" operation, then the virtual
// machine's intermediate state might be described as "suspending."
//
// Most tasks (such as power operations) obtain exclusive access to the virtual
// machine, so it is unusual for this list to contain more than one running task.
// One exception, however, is the task of cloning a virtual machine.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
func (mo *ManagedEntity) RecentTask() ([]*Task, error) {
	t, err := mo.currentProperty("recentTask")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Task)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Task")
	}
	return v, nil
}

// The set of tags associated with this managed entity.
// Experimental. Subject to change.
//
// Since vSphere API 4.0
// Required Privilege: System.View
func (mo *ManagedEntity) Tag() ([]*Tag, error) {
	t, err := mo.currentProperty("tag")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Tag)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Tag")
	}
	return v, nil
}

// A set of alarm states for alarms triggered by this entity
// or by its descendants.
//
// Triggered alarms are propagated up the inventory hierarchy
// so that a user can readily tell when a descendant has triggered an alarm.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
// Required Privilege: System.View
func (mo *ManagedEntity) TriggeredAlarmState() ([]*AlarmState, error) {
	t, err := mo.currentProperty("triggeredAlarmState")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*AlarmState)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*AlarmState")
	}
	return v, nil
}

//
// Destroys this object, deleting its contents and removing it from its parent
// folder (if any).
//
// NOTE: The appropriate privilege must be held on the parent of the destroyed
// entity as well as the entity itself.
//
//
// This method can throw one of several exceptions. The exact set of exceptions
// depends on the kind of entity that is being removed.  See comments for
// each entity for more information on destroy behavior.
//
// Required Privileges
// When object is VirtualMachine - VirtualMachine.Inventory.DeleteWhen object is Datacenter - Datacenter.DeleteWhen object is Folder - Folder.DeleteWhen object is HostSystem - Host.Inventory.RemoveHostFromClusterWhen object is VirtualApp - VApp.DeleteWhen object is ResourcePool - Resource.DeletePoolWhen object is ComputeResource - Host.Inventory.RemoveHostFromClusterWhen object is ClusterComputeResource - Host.Inventory.DeleteClusterWhen object is DistributedVirtualSwitch - DVSwitch.DeleteWhen object is DistributedVirtualPortgroup - DVPortgroup.DeleteWhen object is Datastore - System.ReadWhen object is Network - System.Read
//
//
func (mo *ManagedEntity) Destroy_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Reload the entity state. Clients only need to call this method
// if they changed some external state that affects the service
// without using the Web service interface to perform the change.
// For example, hand-editing a virtual machine configuration file
// affects the configuration of the associated virtual machine but
// the service managing the virtual machine might not monitor the
// file for changes. In this case, after such an edit, a client
// would call "reload" on the associated virtual machine to ensure
// the service and its clients have current data for the
// virtual machine.
//
// Required Privileges
// System.Read
//
func (mo *ManagedEntity) Reload(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Renames this managed entity.
//
// Any % (percent) character used in this name parameter
// must be escaped, unless it is used to start an escape
// sequence. Clients may also escape any other characters in
// this name parameter.
//
// See name
//
//
// Required Privileges
// When object is VirtualMachine - VirtualMachine.Config.RenameWhen object is Datacenter - Datacenter.RenameWhen object is Folder - Folder.RenameWhen object is VirtualApp - VApp.RenameWhen object is ResourcePool - Resource.RenamePoolWhen object is ClusterComputeResource - Host.Inventory.RenameClusterWhen object is DistributedVirtualSwitch - DVSwitch.ModifyWhen object is DistributedVirtualPortgroup - DVPortgroup.ModifyWhen object is Datastore - Datastore.RenameWhen object is Network - System.Read
//
//
func (mo *ManagedEntity) Rename_Task(
	_this *ManagedObjectReference, newName string,
) (*Task, error) {

	return nil, nil

}

//
// The general event argument for a managed entity.
//
//
type ManagedEntityEventArgument struct {
	*EntityEventArgument

	// The managed entity.
	Entity *ManagedEntity
}

//
// The Status enumeration defines a general "health" value for a managed entity.
//
//
type ManagedEntityStatus struct {
}

//
// A ManagedObjectNotFound exception is thrown when a request refers to
// a managed object that no longer exists or has never existed.
//
//
type ManagedObjectNotFound struct {
	*RuntimeFault

	// The managed object reference that generated the error.
	Obj *ManagedObjectReference
}

//
// This class is used to refer to a server-side Managed Object.
//
//
type ManagedObjectReference struct {

	// The name of the Managed Object type this ManagedObjectReference refers to.
	// Allowable values are:
	//
	//
	// "Alarm" - Alarm Managed Object.
	//
	//
	// "AlarmManager" - AlarmManager Managed Object.
	//
	//
	// "AuthorizationManager" - AuthorizationManager Managed Object.
	//
	//
	// "ClusterComputeResource" - ClusterComputeResource Managed Object.
	//
	//
	// "ClusterProfile" - ClusterProfile Managed Object.
	//
	//
	// "ClusterProfileManager" - ClusterProfileManager Managed Object.
	//
	//
	// "ComputeResource" - ComputeResource Managed Object.
	//
	//
	// "ContainerView" - ContainerView Managed Object.
	//
	//
	// "CustomFieldsManager" - CustomFieldsManager Managed Object.
	//
	//
	// "CustomizationSpecManager" - CustomizationSpecManager Managed Object.
	//
	//
	// "Datacenter" - Datacenter Managed Object.
	//
	//
	// "Datastore" - Datastore Managed Object.
	//
	//
	// "DatastoreNamespaceManager" - DatastoreNamespaceManager Managed Object.
	//
	//
	// "DiagnosticManager" - DiagnosticManager Managed Object.
	//
	//
	// "DistributedVirtualPortgroup" - DistributedVirtualPortgroup Managed Object.
	//
	//
	// "DistributedVirtualSwitch" - DistributedVirtualSwitch Managed Object.
	//
	//
	// "DistributedVirtualSwitchManager" - DistributedVirtualSwitchManager Managed Object.
	//
	//
	// "EnvironmentBrowser" - EnvironmentBrowser Managed Object.
	//
	//
	// "EventHistoryCollector" - EventHistoryCollector Managed Object.
	//
	//
	// "EventManager" - EventManager Managed Object.
	//
	//
	// "ExtensibleManagedObject" - ExtensibleManagedObject Managed Object.
	//
	//
	// "ExtensionManager" - ExtensionManager Managed Object.
	//
	//
	// "FileManager" - FileManager Managed Object.
	//
	//
	// "Folder" - Folder Managed Object.
	//
	//
	// "GuestAuthManager" - GuestAuthManager Managed Object.
	//
	//
	// "GuestFileManager" - GuestFileManager Managed Object.
	//
	//
	// "GuestOperationsManager" - GuestOperationsManager Managed Object.
	//
	//
	// "GuestProcessManager" - GuestProcessManager Managed Object.
	//
	//
	// "HistoryCollector" - HistoryCollector Managed Object.
	//
	//
	// "HostActiveDirectoryAuthentication" - HostActiveDirectoryAuthentication Managed Object.
	//
	//
	// "HostAuthenticationManager" - HostAuthenticationManager Managed Object.
	//
	//
	// "HostAuthenticationStore" - HostAuthenticationStore Managed Object.
	//
	//
	// "HostAutoStartManager" - HostAutoStartManager Managed Object.
	//
	//
	// "HostBootDeviceSystem" - HostBootDeviceSystem Managed Object.
	//
	//
	// "HostCacheConfigurationManager" - HostCacheConfigurationManager Managed Object.
	//
	//
	// "HostCpuSchedulerSystem" - HostCpuSchedulerSystem Managed Object.
	//
	//
	// "HostDatastoreBrowser" - HostDatastoreBrowser Managed Object.
	//
	//
	// "HostDatastoreSystem" - HostDatastoreSystem Managed Object.
	//
	//
	// "HostDateTimeSystem" - HostDateTimeSystem Managed Object.
	//
	//
	// "HostDiagnosticSystem" - HostDiagnosticSystem Managed Object.
	//
	//
	// "HostDirectoryStore" - HostDirectoryStore Managed Object.
	//
	//
	// "HostEsxAgentHostManager" - HostEsxAgentHostManager Managed Object.
	//
	//
	// "HostFirewallSystem" - HostFirewallSystem Managed Object.
	//
	//
	// "HostFirmwareSystem" - HostFirmwareSystem Managed Object.
	//
	//
	// "HostGraphicsManager" - HostGraphicsManager Managed Object.
	//
	//
	// "HostHealthStatusSystem" - HostHealthStatusSystem Managed Object.
	//
	//
	// "HostImageConfigManager" - HostImageConfigManager Managed Object.
	//
	//
	// "HostKernelModuleSystem" - HostKernelModuleSystem Managed Object.
	//
	//
	// "HostLocalAccountManager" - HostLocalAccountManager Managed Object.
	//
	//
	// "HostLocalAuthentication" - HostLocalAuthentication Managed Object.
	//
	//
	// "HostMemorySystem" - HostMemorySystem Managed Object.
	//
	//
	// "HostNetworkSystem" - HostNetworkSystem Managed Object.
	//
	//
	// "HostPatchManager" - HostPatchManager Managed Object.
	//
	//
	// "HostPciPassthruSystem" - HostPciPassthruSystem Managed Object.
	//
	//
	// "HostPowerSystem" - HostPowerSystem Managed Object.
	//
	//
	// "HostProfile" - HostProfile Managed Object.
	//
	//
	// "HostProfileManager" - HostProfileManager Managed Object.
	//
	//
	// "HostServiceSystem" - HostServiceSystem Managed Object.
	//
	//
	// "HostSnmpSystem" - HostSnmpSystem Managed Object.
	//
	//
	// "HostStorageSystem" - HostStorageSystem Managed Object.
	//
	//
	// "HostSystem" - HostSystem Managed Object.
	//
	//
	// "HostVFlashManager" - HostVFlashManager Managed Object.
	//
	//
	// "HostVirtualNicManager" - HostVirtualNicManager Managed Object.
	//
	//
	// "HostVMotionSystem" - HostVMotionSystem Managed Object.
	//
	//
	// "HostVsanInternalSystem" - HostVsanInternalSystem Managed Object.
	//
	//
	// "HostVsanSystem" - HostVsanSystem Managed Object.
	//
	//
	// "HttpNfcLease" - HttpNfcLease Managed Object.
	//
	//
	// "InventoryView" - InventoryView Managed Object.
	//
	//
	// "IpPoolManager" - IpPoolManager Managed Object.
	//
	//
	// "IscsiManager" - IscsiManager Managed Object.
	//
	//
	// "LicenseAssignmentManager" - LicenseAssignmentManager Managed Object.
	//
	//
	// "LicenseManager" - LicenseManager Managed Object.
	//
	//
	// "ListView" - ListView Managed Object.
	//
	//
	// "LocalizationManager" - LocalizationManager Managed Object.
	//
	//
	// "ManagedEntity" - ManagedEntity Managed Object.
	//
	//
	// "ManagedObjectView" - ManagedObjectView Managed Object.
	//
	//
	// "Network" - Network Managed Object.
	//
	//
	// "OpaqueNetwork" - OpaqueNetwork Managed Object.
	//
	//
	// "OptionManager" - OptionManager Managed Object.
	//
	//
	// "OvfManager" - OvfManager Managed Object.
	//
	//
	// "PerformanceManager" - PerformanceManager Managed Object.
	//
	//
	// "Profile" - Profile Managed Object.
	//
	//
	// "ProfileComplianceManager" - ProfileComplianceManager Managed Object.
	//
	//
	// "ProfileManager" - ProfileManager Managed Object.
	//
	//
	// "PropertyCollector" - PropertyCollector Managed Object.
	//
	//
	// "PropertyFilter" - PropertyFilter Managed Object.
	//
	//
	// "ResourcePlanningManager" - ResourcePlanningManager Managed Object.
	//
	//
	// "ResourcePool" - ResourcePool Managed Object.
	//
	//
	// "ScheduledTask" - ScheduledTask Managed Object.
	//
	//
	// "ScheduledTaskManager" - ScheduledTaskManager Managed Object.
	//
	//
	// "SearchIndex" - SearchIndex Managed Object.
	//
	//
	// "ServiceInstance" - ServiceInstance Managed Object.
	//
	//
	// "ServiceManager" - ServiceManager Managed Object.
	//
	//
	// "SessionManager" - SessionManager Managed Object.
	//
	//
	// "SimpleCommand" - SimpleCommand Managed Object.
	//
	//
	// "StoragePod" - StoragePod Managed Object.
	//
	//
	// "StorageResourceManager" - StorageResourceManager Managed Object.
	//
	//
	// "Task" - Task Managed Object.
	//
	//
	// "TaskHistoryCollector" - TaskHistoryCollector Managed Object.
	//
	//
	// "TaskManager" - TaskManager Managed Object.
	//
	//
	// "UserDirectory" - UserDirectory Managed Object.
	//
	//
	// "View" - View Managed Object.
	//
	//
	// "ViewManager" - ViewManager Managed Object.
	//
	//
	// "VirtualApp" - VirtualApp Managed Object.
	//
	//
	// "VirtualDiskManager" - VirtualDiskManager Managed Object.
	//
	//
	// "VirtualizationManager" - VirtualizationManager Managed Object.
	//
	//
	// "VirtualMachine" - VirtualMachine Managed Object.
	//
	//
	// "VirtualMachineCompatibilityChecker" - VirtualMachineCompatibilityChecker Managed Object.
	//
	//
	// "VirtualMachineProvisioningChecker" - VirtualMachineProvisioningChecker Managed Object.
	//
	//
	// "VirtualMachineSnapshot" - VirtualMachineSnapshot Managed Object.
	//
	//
	// "VmwareDistributedVirtualSwitch" - VmwareDistributedVirtualSwitch Managed Object.
	Type string

	// The specific instance of Managed Object this ManagedObjectReference refers to.
	Value string
}

//
// ManagedObjectView is the base class for view objects that provide access
// to a set of ManagedEntity objects. ManagedObjectView defines
// a view list; the list contains references to objects in the view.
// To create a view use the ViewManager methods.
//
type ManagedObjectView struct {
	*ManagedObject
	*View

	view []*ManagedObjectReference
}

// The list of references to objects mapped by this view.
func (mo *ManagedObjectView) GetView() ([]*ManagedObjectReference, error) {
	t, err := mo.currentProperty("view")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ManagedObjectReference)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ManagedObjectReference")
	}
	return v, nil
}

//
// Thrown when memory cannot be hot-added or hot-removed from the virtual machine.
//
//
type MemoryHotPlugNotSupported struct {
	*VmConfigFault
}

//
// The memory amount of the virtual machine is not within the recommended
// memory bounds for the virtual machine's guest OS.
//
//
type MemorySizeNotRecommended struct {
	*VirtualHardwareCompatibilityIssue

	// The maximum recommended memory size.
	MaxMemorySizeMB int32

	// The configured memory size of the virtual machine.
	MemorySizeMB int32

	// The minimum recommended memory size.
	MinMemorySizeMB int32
}

//
// The memory amount of the virtual machine is not within the acceptable
// guest memory bounds supported by the virtual machine's host.
//
//
type MemorySizeNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The maximum acceptable memory size.
	MaxMemorySizeMB int32

	// The configured memory size of the virtual machine.
	MemorySizeMB int32

	// The minimum acceptable memory size.
	MinMemorySizeMB int32
}

//
// The memory amount of the virtual machine is not within the acceptable
// guest memory bounds supported by the virtual machine's datastore.
//
//
type MemorySizeNotSupportedByDatastore struct {
	*VirtualHardwareCompatibilityIssue

	// The datastore which does not support the requested memory size.
	Datastore *Datastore

	// The maximum acceptable memory size supported by the datastore.
	MaxMemorySizeMB int32

	// The configured memory size of the virtual machine.
	MemorySizeMB int32
}

//
// Thrown if a request to take a memory snapshot is issued
// on a virtual machine with an independent disk.
//
//
type MemorySnapshotOnIndependentDisk struct {
	*SnapshotFault
}

//
// This data object type defines an operation and its arguments, invoked
// on a particular entity.
//
//
type MethodAction struct {
	*Action

	// An array consisting of the arguments for the operation.
	Argument []*MethodActionArgument

	// Name of the operation.
	Name string
}

//
// This data object type defines a named argument for an operation.
//
//
type MethodActionArgument struct {
	*DynamicData

	// The value of the argument.
	Value interface{}
}

//
// A MethodAlreadyDisabledFault fault is thrown when an attempt
// is made to disable a method that is already disabled.
//
//
type MethodAlreadyDisabledFault struct {
	*RuntimeFault

	SourceId string
}

//
// Static strings used for describing an object model method.
//
//
type MethodDescription struct {
	*Description

	// Method being described.
	Key string
}

//
// A MethodDisabled fault is thrown if a disabled method
// is invoked by the client. The method denote an invalid state
// operation or may have been explicitly disabled.
//
//
type MethodDisabled struct {
	*RuntimeFault

	// Since vSphere API 4.1
	Source string
}

//
// The base data object type for all the object model faults
// that an application might handle.
//
//
type MethodFault struct {

	// Set of dynamic properties. This property is optional because only the
	// properties of an object that are unknown to a client will be part of this set.
	// This property is not readonly just in case we want to send such properties
	// from a client in the future.
	DynamicProperty []*DynamicProperty

	// Reserved.
	DynamicType string

	// Fault which is the cause of this fault.
	//
	// Since vSphere API 4.0
	FaultCause *LocalizedMethodFault

	// Message which has details about the error
	// Message can also contain a key to message catalogue which
	// can be used to generate better localized messages.
	//
	// Since vSphere API 4.0
	FaultMessage []*LocalizableMessage
}

//
// MethodNotFound is thrown to indicate that a method called on a managed
// object does not exist.
//
//
type MethodNotFound struct {
	*InvalidRequest

	// The method called.
	Method string

	// The receiver of the call
	Receiver *ManagedObjectReference
}

//
// An alarm expression that uses a metric as the condition that triggers an
// alarm. Base type.
//
// There are two alarm operands: yellow and red. At least one of them
// must be set. The value of the alarm expression is determined as follows:
//
//
//
// • If the host is not connected, the host metric expression is gray.
//
// • If the vm is not connected, the vm metric expression is gray.
//
// • If red is set but yellow is not, the expression is red when
// the metric is over (isAbove operator) or under (isBelow operator)
// the red value. Otherwise, the expression is green.
//
// • If yellow is set but red is not, the expression is yellow when
// the metric is over (isAbove) or under (isBelow)
// the yellow value. Otherwise, the expression is green.
//
// • If both yellow and red are set, the value of the expression is red
// when the metric is over (isAbove) or under (isBelow) the red value.
// Otherwise, the expression is yellow when the metric is over (isAbove)
// or under (isBelow) the yellow value. Otherwise, the expression is green.
//
//
//
//
//
type MetricAlarmExpression struct {
	*AlarmExpression

	// The instance of the metric.
	Metric *PerfMetricId

	// The operation to be tested on the metric.
	Operator *enum.MetricAlarmOperator

	// Whether or not to test for a red condition.
	// If not set, do not calculate red status.
	// If set, it contains the threshold value that triggers red status.
	Red int32

	// Time interval in seconds for which the red condition must be true
	// before the red status is triggered. If unset, the red status is
	// triggered immediately when the red condition becomes true.
	//
	// Since vSphere API 4.0
	RedInterval int32

	// Name of the object type containing the property.
	Type string

	// Whether or not to test for a yellow condition.
	// If not set, do not calculate yellow status.
	// If set, it contains the threshold value that triggers yellow status.
	Yellow int32

	// Time interval in seconds for which the yellow condition must be true
	// before the yellow status is triggered. If unset, the yellow status is
	// triggered immediately when the yellow condition becomes true.
	//
	// Since vSphere API 4.0
	YellowInterval int32
}

//
// The operation on the target metric item.
//
//
type MetricAlarmOperator struct {
}

//
// An MigrationDisabled fault is thrown if the
// migration failed due to disabled migration
//
//
type MigrationDisabled struct {
	*MigrationFault
}

//
// A migration error.
//
//
type MigrationErrorEvent struct {
	*MigrationEvent
}

//
// These are events used to describe migration warning and errors
//
//
type MigrationEvent struct {
	*VmEvent

	// The fault that describes the migration issue. This is typically either a
	// MigrationFault or a VmConfigFault.
	Fault *LocalizedMethodFault
}

//
// Base object type for issues that can occur when reassigning the execution
// host of a virtual machine using migrate or relocate. These issues are typically
// used as argument in the MigrationEvent. When a MigrationFault is used as a value
// in a MigrationEvent, the type of MigrationEvent determines if the issue is a
// warning or an error (for example, MigrationHostWarningEvent or
// MigrationHostErrorEvent). When thrown as an exception, the fault is an error.
//
// Issues are categorized as errors or warnings according to the following
// criteria:
//
//
// If the virtual machine is powered on:
//
//
// • Error for fatal problems with the VMotion interfaces or licensing.
//
// • Error if VMotion would fail.
//
// • Error if VMotion would in any way interrupt the continuous and consistent
// operation of the virtual machine.
//
// • Warning for potential performance or connectivity problems between the
// source and destination VMotion interfaces.
//
// • Warning if the virtual machine's currently disconnected devices may not
// be connectable after VMotion.
//
//
// If the virtual machine is powered off or suspended:
//
// • Error if the destination host cannot access all the files that comprise
// the virtual machine (including virtual disks).
//
// • Error if aspects of the virtual machine are not supported by the
// destination host's hardware or software.
//
// • Warning if problems would occur when powering on or resuming the
// virtual machine, if the usage/configuration of the destination
// host were to remain in its current state.
//
//
//
//
type MigrationFault struct {
	*VimFault
}

//
// A migration operation that requires feature support on source and
// destination hosts is lacking support on the host.
//
//
type MigrationFeatureNotSupported struct {
	*MigrationFault

	// Whether this error is for the source host.
	AtSourceHost bool

	// The host.
	FailedHost *HostSystem

	// The name of the host.
	FailedHostName string
}

//
// A migration error that includes the destination host.
//
//
type MigrationHostErrorEvent struct {
	*MigrationEvent

	// The name of the destination host.
	DstHost *HostEventArgument
}

//
// A migration warning that includes the destination host.
//
//
type MigrationHostWarningEvent struct {
	*MigrationEvent

	// The name of the destination host.
	DstHost *HostEventArgument
}

//
// The VM to be migrated is not ready for the migration operation. This might
// because the VM is still in the progress of powering on or resuming from a
// suspended state.
//
//
type MigrationNotReady struct {
	*MigrationFault

	Reason string
}

//
// A migration error that includes both the destination host and resource pool.
//
//
type MigrationResourceErrorEvent struct {
	*MigrationEvent

	// The name of the destination host.
	DstHost *HostEventArgument

	// The name of the destination resource pool.
	DstPool *ResourcePoolEventArgument
}

//
// A migration warning that includes both the destination host and resource pool.
//
//
type MigrationResourceWarningEvent struct {
	*MigrationEvent

	// The name of the destination host.
	DstHost *HostEventArgument

	// The name of the destination resource pool.
	DstPool *ResourcePoolEventArgument
}

//
// A migration warning.
//
//
type MigrationWarningEvent struct {
	*MigrationEvent
}

//
// A MismatchedBundle fault is thrown when the bundle supplied for
// RestoreFirmwareConfiguration does not match the
// specifications of the host
//
//
type MismatchedBundle struct {
	*VimFault

	// The build number of the host that the bundle was generated for
	BundleBuildNumber int32

	// The uuid of the host that the bundle was generated for
	BundleUuid string

	// The build number of the host
	HostBuildNumber int32

	// The uuid of the host
	HostUuid string
}

// Deprecated.
// As of vSphere API 5.5, use CannotUseNetwork with
// a correct reason for the fault.
//
//
// The virtual machine network uses different offload or security
// policies on the destination host than on the source host. This is an error
// if the virtual machine is currently connected to the network, and a warning
// otherwise.
//
//
type MismatchedNetworkPolicies struct {
	*MigrationFault

	// The name of the network.
	Backing string

	// The connected/disconnected state of the device.
	Connected bool

	// The label of the interface device.
	Device string
}

//
// The source and destination hosts do not use the same network name for
// their VMotion interfaces. This is a warning for migrating powered-on virtual
// machines.
//
//
type MismatchedVMotionNetworkNames struct {
	*MigrationFault

	// The name of the network used by the destination host VMotion interface.
	DestNetwork string

	// The name of the network used by the source host VMotion interface.
	SourceNetwork string
}

//
// A MissingBmcSuppport fault is thrown when a host's BMC doesn't support IPMI.
// BMC (Board Management Controller) is a piece of hardware required for IPMI.
//
//
type MissingBmcSupport struct {
	*VimFault
}

//
// A controller key has not been specified for a new device
// that requires a controller, such as a disk or CD-ROM device.
//
//
type MissingController struct {
	*InvalidDeviceSpec
}

//
// No IP pool is associated with a network.
//
//
type MissingIpPool struct {
	*VAppPropertyFault
}

//
// Usable open source components required for Linux customization were not found
// on the server.
//
//
type MissingLinuxCustResources struct {
	*CustomizationFault
}

//
// No IP configuration exists for network.
//
//
type MissingNetworkIpConfig struct {
	*VAppPropertyFault
}

//
// Used for reporting missing objects that were explicitly referenced by a
// filter spec. In other words, any of the objects referenced in objectSet
//
//
type MissingObject struct {
	*DynamicData

	// Fault describing the failure to lookup this object
	//
	// The possible faults for missing objects are:
	//
	// SystemError if there was some unknown problem
	// looking up the object
	//
	// ManagedObjectNotFound if the object is no
	// longer available
	Fault *LocalizedMethodFault

	// The object that is being reported missing
	Obj *ManagedObjectReference
}

//
// Attempting to power-off a vApp for which no virtual machines has been
// configured to power off.
//
//
type MissingPowerOffConfiguration struct {
	*VAppConfigFault
}

//
// Attempting to power-on a vApp service for which no virtual machines has been
// configured to power on.
//
//
type MissingPowerOnConfiguration struct {
	*VAppConfigFault
}

//
// Used for reporting properties for which values could not be retrieved.
//
//
type MissingProperty struct {
	*DynamicData

	// Fault describing the failure to retrieve the property value.
	//
	// The possible faults for missing properties are:
	//
	// SystemError if there was some unknown problem
	// reading the value
	//
	// SecurityError if the logged in session did
	// not have permission to read the value
	Fault *LocalizedMethodFault

	// Property for which a value could not be retrieved
	Path string
}

//
// A usable sysprep file was not found on the server.
//
//
type MissingWindowsCustResources struct {
	*CustomizationFault
}

//
// Thrown when a mouse-keyboard-screen connection ticket to a virtual machine
// cannot be granted because the configured connection limit has been reached.
//
//
type MksConnectionLimitReached struct {
	*InvalidState

	// MKS connection limit for the virtual machine.
	ConnectionLimit int32
}

//
// The FileAccess.Modes data object type defines the known access modes
// for a datastore. The property values specify how to interpret
// the "what" property for a FileAccess object.
//
//
type ModeInfo struct {
	*DynamicData

	// Can change permissions for a file.
	Admin string

	// Can see the existence of a file.
	Browse string

	// Can do anything to a file, including change permissions.
	Full string

	// Can read and write a file.
	Modify string

	// Can read a file.
	Read string

	// Can execute or operate a file or look inside a directory.
	Use string
}

//
// The MonthlyByDayTaskScheduler data object sets the time for monthly
// task execution. You can set the schedule for task execution
// on one day during the month, and you complete the schedule by
// setting the inherited properties for the hour and minute.
//
// By default the scheduler executes the task on the specified day
// every month. If you set the interval to a value greater than 1,
// the task will execute at the specified monthly interval.
// (For example, an interval of 2 will cause the task to execute
// on the specified day, hour, and minute every 2 months.)
//
//
//
type MonthlyByDayTaskScheduler struct {
	*MonthlyTaskScheduler

	// The day in every month to run the scheduled task.
	// Valid values are 1 to 31.
	//
	// In any month where the value of "day" exceeds the total number of days
	// in the month, the scheduled task will run on the last day of the month.
	Day int32
}

//
// The MonthlyByWeekdayTaskScheduler data object sets the time for
// monthly task execution. You identify a single day for task execution
// by specifying the week of the month and day of the week, and you
// complete the schedule by setting the inherited properties for the
// hour and minute.
//
// By default, the scheduler executes the task on the specified day
// every month. If you set the interval to a value greater than 1,
// the task will execute at the specified monthly interval. (For example,
// an interval of 2 will cause the task to execute on the specified
// day, hour, and minute every 2 months.)
//
//
//
type MonthlyByWeekdayTaskScheduler struct {
	*MonthlyTaskScheduler

	// The week in the month during which the scheduled task is to run.
	Offset *enum.WeekOfMonth

	// The day in the week when the scheduled task is to run.
	Weekday *enum.DayOfWeek
}

//
// The MonthlyTaskScheduler data object is the base type for
// the monthly schedulers (MonthlyByDayTaskScheduler and
// MonthlyByWeekdayTaskScheduler).
//
//
type MonthlyTaskScheduler struct {
	*DailyTaskScheduler
}

//
// Customization failed because the customization process was unable to mount a remote
// virtual disk file.
//
//
type MountError struct {
	*CustomizationFault

	// Index into the virtual machine's device list,
	// representing the key value that identifies the virtual device
	// that is the presumed boot disk.
	DiskIndex int32

	// The virtual machine to be customized.
	Vm *VirtualMachine
}

//
// The value of MTU configured in the vSphere Distributed Switch
// matches physical switch.
//
//
type MtuMatchEvent struct {
	*DvsHealthStatusChangeEvent
}

//
// The value of MTU configured in the vSphere Distributed Switch
// mismatches physical switch.
//
//
type MtuMismatchEvent struct {
	*DvsHealthStatusChangeEvent
}

//
// Set of constants defining the possible states of a multipath path.
//
//
type MultipathState struct {
}

//
// MultipleCertificatesVerifyFault is thrown by the host connect method
// ReconnectHost_Task as well as the methods to add a host to
// VirtualCenter (AddStandaloneHost_Task and
// AddHost_Task) if VirtualCenter detects that the
// host has different SSL certificates for different management ports. This
// can occur, for example, if an ESX 2.x host has different SSL certificates
// for the authd service (port 902) and the Management UI port (port 443).
// VirtualCenter is not able to manage such hosts. To fix this issue, the user
// should modify the host to ensure there is only one certificate for
// all services. Alternatively, different certificates are allowed as long as each
// certificate is verifiable (trusted) by the VirtualCenter server.
//
//
type MultipleCertificatesVerifyFault struct {
	*HostConnectFault

	// The thumbprints (and associated ports) used by the services on the host.
	ThumbprintData []*MultipleCertificatesVerifyFaultThumbprintData
}

type MultipleCertificatesVerifyFaultThumbprintData struct {
	*DynamicData

	// The port used by the service.
	Port int32

	// The SSL thumbprint of the host's certificate used by the service.
	Thumbprint string
}

//
// Fault thrown when an attempt is made to create a second snapshot on a VM that only
// supports a single snapshot at a time.
//
//
type MultipleSnapshotsNotSupported struct {
	*SnapshotFault
}

//
// This event records when a NAS datastore is created.
//
//
type NASDatastoreCreatedEvent struct {
	*HostEvent

	// The associated datastore.
	Datastore *DatastoreEventArgument
}

//
// NamePasswordAuthentication contains the information necessary to authenticate
// within a guest using a name and password. This is the typical method for
// authentication within a guest and the one currently used by VIX.
// This method of authentication is stateless.
//
// To use NamePasswordAuthentication, populate username and password with the
// appropriate login information. You should not use AcquireCredentialsInGuest
// or ReleaseCredentialsInGuest for NamePasswordAuthentication.
//
//
// Once populated, you can use NamePasswordAuthentication in any guest operations function call.
//
//
//
type NamePasswordAuthentication struct {
	*GuestAuthentication

	// The password for Name-Password authentication.
	Password string

	// The user name for Name-Password authentication.
	Username string
}

//
// A NamespaceFull fault is thrown when an operation
// on namespace requires more space to complete.
//
//
type NamespaceFull struct {
	*VimFault

	// Current maximum size.
	CurrentMaxSize int64

	// The namespace in question.
	Name string

	// Size necessary to complete operation.  If not present,
	// system was not able to determine how much space would
	// be necessary to complete operation.
	RequiredSize int64
}

//
// A NamespaceLimitReached fault is thrown when the maximum allowed
// namespaces for a virtual machine will be exceeded.
//
//
type NamespaceLimitReached struct {
	*VimFault

	// Allowed maximum number of namespaces per virtual machine.
	Limit int32
}

//
// A NamespaceWriteProtected fault is thrown when an operation
// on namespace fails because namespace is write-protected.
//
//
type NamespaceWriteProtected struct {
	*VimFault

	// The namespace in question.
	Name string
}

//
// Base class for all network-attached storage configuration faults.
//
//
type NasConfigFault struct {
	*HostConfigFault

	// Name of the Nas datastore being configured.
	Name string
}

//
// This fault is thrown when an operation to configure a CIFS volume fails
// because the request exceeds the maximum allowed connections on this host
// for the specified remote path.
//
//
type NasConnectionLimitReached struct {
	*NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string

	// The remote share.
	RemotePath string
}

//
// Information details about a network-attached storage
// (NAS) datastore.
//
//
type NasDatastoreInfo struct {
	*DatastoreInfo

	// The NFS mount information for the datastore.  May not
	// be available when the datastore is not accessible.
	Nas *HostNasVolume
}

//
// This fault is thrown when an operation to configure a CIFS volume fails
// when attempting to log on more than once with the same user name.
//
//
type NasSessionCredentialConflict struct {
	*NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string

	// The remote share.
	RemotePath string

	UserName string
}

//
// The NasStorageProfile data object represents one NAS datastore configuration.
// Use the policy list for access to configuration data
// for the NAS storage profile. Use the property list
// for access to subprofile configuration data, if any.
//
//
type NasStorageProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string
}

//
// This fault is thrown when an operation to configure a NAS datastore
// fails because the specified NFS volume is not mounted.
//
//
type NasVolumeNotMounted struct {
	*NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string

	// The remote share.
	RemotePath string
}

//
// The base class for any type of setting or configuration to which negation
// can be applied.
// When used in a configuration information object:
// if negate is true, then ~(objectValue) will be used for the
// configuration. If false, then objectValue will be used as it is.
//
//
type NegatableExpression struct {
	*DynamicData

	// Whether the configuration needs to be negated or not.
	Negate bool
}

//
// This data object type describes the NetBIOS configuration of
// an operating system.
//
//
type NetBIOSConfigInfo struct {
	*DynamicData

	// NetBIOS configuration mode. The supported values are described by
	// NetBIOSConfigInfoMode.
	Mode string
}

//
// NetBIOS configuration mode.
//
//
type NetBIOSConfigInfoMode struct {
}

//
// Dynamic Host Configuration Protocol reporting for IP version 4 and version 6.
//
//
type NetDhcpConfigInfo struct {
	*DynamicData

	// IPv4 DHCP client settings.
	Ipv4 *NetDhcpConfigInfoDhcpOptions

	// IPv6 DHCP client settings.
	Ipv6 *NetDhcpConfigInfoDhcpOptions
}

//
// Provides for reporting of DHCP client. This data object may be used
// at a per interface or per system scope.
//
//
type NetDhcpConfigInfoDhcpOptions struct {
	*DynamicData

	// Platform specific settings for DHCP Client.
	// The key part is a unique number, the value part
	// is the platform specific configuration command.
	// For example on Linux, BSD systems using the file dhclient.conf
	// output would be reported at system scope:
	// key='1', value='timeout 60;'
	// key='2', value='reboot 10;'
	//
	// output reported at per interface scope:
	// key='1', value='prepend domain-name-servers 192.0.2.1;'
	// key='2', value='equire subnet-mask, domain-name-servers;'
	Config []*KeyValue

	// Report state of dhcp client services.
	Enable bool
}

//
// Dynamic Host Configuration Protocol Configuration for IP version 4 and version 6.
//
//
type NetDhcpConfigSpec struct {
	*DynamicData

	// Configure IPv4 DHCP client settings.
	Ipv4 *NetDhcpConfigSpecDhcpOptionsSpec

	// Configure IPv6 DHCP client settings.
	Ipv6 *NetDhcpConfigSpecDhcpOptionsSpec
}

//
// Provides for configuration of IPv6
//
//
type NetDhcpConfigSpecDhcpOptionsSpec struct {
	*DynamicData

	// Platform specific settings for DHCP Client.
	// The key part is a unique number, the value part
	// is the platform specific configuration command.
	// See NetDhcpConfigInfo for value formatting.
	Config []*KeyValue

	// Enable or disable dhcp for IPv4.
	Enable bool

	// Requires one of the values from HostConfigChangeOperation.
	Operation string
}

//
// Domain Name Server (DNS) Configuration Specification -
// a data object for reporting the configuration of RFC 1034 client side DNS settings.
//
//
type NetDnsConfigInfo struct {
	*DynamicData

	// Indicates whether or not dynamic host control
	// protocol (DHCP) is used to configure DNS configuration.
	Dhcp bool

	// The domain name portion of the DNS name.  "example.com" part of
	// esx01.example.com.
	DomainName string

	// The host name portion of DNS name. For example, "esx01" part of
	// esx01.example.com.
	HostName string

	// The IP addresses of the DNS servers in order of use.
	// IPv4 addresses are specified using
	// dotted decimal notation.  For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as
	// eight fields of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress []string

	// The domain in which to search for hosts, placed in order of preference.
	SearchDomain []string
}

//
// Domain Name Server (DNS) Configuration Specification -
// a data object for configuring the RFC 1034 client side DNS settings.
//
// TBD: remove this section, only for discussing what goes into this object.
// Place properties here that are specific to the RFC/common to all systems.
// Properties that are platform specific should go into a separate config spec.
//
// http://technet.microsoft.com/en-us/library/cc778792.aspx
// http://en.wikipedia.org/wiki/Microsoft_DNS
//
//
type NetDnsConfigSpec struct {
	*DynamicData

	// The flag to indicate whether or not dynamic host control
	// protocol (DHCP) will be used to set DNS configuration automatically.
	// See vim.net.DhcpConfigSpec
	Dhcp bool

	// The domain name portion of the DNS name. This would be the
	// "example.com" part of  esx01.example.com. The rules for forming
	// a domain name are defined in RFC 1034.
	DomainName string

	// The host name portion of DNS name. For example,
	// "esx01" part of esx01.example.com. The rules for forming a hostname
	// are specified in RFC 1034.
	HostName string

	// Unicast IP address(s) of one or more DNS servers in order of use.
	// IPv4 addresses are specified using
	// dotted decimal notation.  For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as
	// eight fields of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress []string

	// The domain in which to search for hosts in order of preference.
	SearchDomain []string
}

//
// Protocol version independent address reporting data object for network
// interfaces.
//
//
type NetIpConfigInfo struct {
	*DynamicData

	// Enable or disable ICMPv6 router solictitation requests from a given interface
	// to acquire an IPv6 address and default gateway route from zero, one or more
	// routers on the connected network.
	//
	// If not set then ICMPv6 is not available on this system,
	// See vim.host.Network.Capabilities
	AutoConfigurationEnabled bool

	// Client side DHCP for a given interface.
	Dhcp *NetDhcpConfigInfo

	// Zero, one or more manual (static) assigned IP addresses to be configured
	// on a given interface.
	IpAddress []*NetIpConfigInfoIpAddress
}

//
// Information about a specific IP Address.
//
//
type NetIpConfigInfoIpAddress struct {
	*DynamicData

	// IPv4 address is specified using dotted decimal notation.
	// For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as eight fields
	// of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress string

	// The time when will this address expire. Durning this time
	// state may change states but is still visible
	// from the network.
	Lifetime time.Time

	// How this address was configured. This can be
	// one of the values from the enum IpAddressOrigin
	// See IpAddressOrigin for values.
	Origin string

	// Denotes the length of a generic Internet network address
	// prefix.
	// The prefix length for IPv4 the value range is 0-32.
	// For IPv6 prefixLength is a decimal value range 0-128.
	// A value of n corresponds to an IP address mask
	// that has n contiguous 1-bits from the most significant
	// bit (MSB), with all other bits set to 0.
	// A value of zero is valid only if the calling context defines
	// it.
	PrefixLength int32

	// The state of this ipAddress. Can be one of IpAddressStatus.
	State string
}

//
// This specifies how an IP address was obtained for a given interface.
// See RFC 4293 IpAddressOriginTC.
//
//
type NetIpConfigInfoIpAddressOrigin struct {
}

type NetIpConfigInfoIpAddressStatus struct {
}

//
// Internet Protocol Address Configuration for version 4 and version 6.
//
//
type NetIpConfigSpec struct {
	*DynamicData

	// Enable or disable ICMPv6 router solictitation requests from a given interface
	// to acquire an IPv6 address and default gateway route from zero, one or more
	// routers on the connected network.
	AutoConfigurationEnabled bool

	// Configure client side DHCP for a given interface.
	Dhcp *NetDhcpConfigSpec

	// A set of manual (static) IP addresses to be configured on a given interface.
	IpAddress []*NetIpConfigSpecIpAddressSpec
}

//
// Provides for configuration of IP Addresses.
//
//
type NetIpConfigSpecIpAddressSpec struct {
	*DynamicData

	// IPv4 address is specified using
	// dotted decimal notation.  For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses specified as
	// eight fields of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress string

	// Requires one of: "add" and "remove" or "change"
	// See HostConfigChangeOperation.
	Operation string

	// Denotes the length of a generic Internet network address
	// prefix.
	// The prefix length for IPv4 the value range is 0-32.
	// For IPv6 prefixLength is a decimal value range 0-128.
	// A value of n corresponds to an IP address mask
	// that has n contiguous 1-bits from the most significant
	// bit (MSB), with all other bits set to 0.
	// A value of zero is valid only if the calling context defines
	// it.
	PrefixLength int32
}

//
// This data object reports the IP Route Table.
//
//
type NetIpRouteConfigInfo struct {
	*DynamicData

	// IP routing table for all address families.
	IpRoute []*NetIpRouteConfigInfoIpRoute
}

//
// Next hop Gateway for a given route.
//
//
type NetIpRouteConfigInfoGateway struct {
	*DynamicData

	Device string

	IpAddress string
}

//
// IpRoute report an individual host, network or default destination network
// reachable through a given gateway.
//
//
type NetIpRouteConfigInfoIpRoute struct {
	*DynamicData

	// Where to send the packets for this route.
	Gateway *NetIpRouteConfigInfoGateway

	// IP Address of the destination IP network.
	// IPv6 addresses are 128-bit addresses represented
	// as eight fields of up to four hexadecimal digits. A colon separates each
	// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
	// also consist of  symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	Network string

	// The prefix length. For IPv4 the value range is 0-31.
	// For IPv6 prefixLength is a decimal value range 0-127. The property
	// represents the number of contiguous, higher-order bits of the address that make
	// up the network portion of the IP address.
	PrefixLength int32
}

//
// Address family independent IP Route Table Configuration data object.
//
//
type NetIpRouteConfigSpec struct {
	*DynamicData

	// The set of updates to apply to the routing table.
	IpRoute []*NetIpRouteConfigSpecIpRouteSpec
}

//
// IpRoute report an individual host, network or default destination network
// reachable through a given gateway.
//
//
type NetIpRouteConfigSpecGatewaySpec struct {
	*DynamicData

	Device string

	IpAddress string
}

//
// Specify an individual host, network or default destination network
// reachable through a given gateway.
//
//
type NetIpRouteConfigSpecIpRouteSpec struct {
	*DynamicData

	// Where to send the packets for this route.
	Gateway *NetIpRouteConfigSpecGatewaySpec

	// IP Address of the destination IP network.
	// IPv6 addresses are 128-bit addresses represented
	// as eight fields of up to four hexadecimal digits. A colon separates each
	// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
	// also consist of  symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	//
	// To Specify a default network use the value: 0 with prefixLenth 0.
	Network string

	// Requires one of the values from HostConfigChangeOperation.
	Operation string

	// The prefix length. For IPv4 the value range is 0-31.
	// For IPv6 prefixLength is a decimal value range 0-127. The property
	// represents the number of contiguous, higher-order bits of the address that make
	// up the network portion of the IP address.
	PrefixLength int32
}

//
// Protocol version independent reporting data object for IP stack.
//
//
type NetIpStackInfo struct {
	*DynamicData

	// Zero one or more entries of discovered IP routers that are directly
	// reachable from a an interface on this system.
	// This property maps to RFC 4293 ipDefaultRouterTable.
	DefaultRouter []*NetIpStackInfoDefaultRouter

	// Zero, one or more entries of neighbors discovered using ARP or NDP.
	// This information is used to help diagnose connectivity or performance
	// issues. This property maps to RFC 4293 ipNetToPhysicalTable.
	Neighbor []*NetIpStackInfoNetToMedia
}

type NetIpStackInfoDefaultRouter struct {
	*DynamicData

	// This value will contain the name of the interface as reported by the
	// operationg system.
	Device string

	// Unicast IP address of a next-hop router.
	IpAddress string

	// When this entry will no longer valid. For IPv6 this value
	// see For IPv6 RFC 2462 sections 4.2 and 6.3.4.
	Lifetime time.Time

	// Value of this entry compared to others that this IP stack uses
	// when making selection to route traffic on the default
	// route when there are multiple default routers. Value must be one of
	// NetIpStackInfoPreference
	Preference string
}

//
// IP Stack keeps state on entries in IpNetToMedia table to perform
// physical address lookups for IP addresses. Here are the standard
// states perSee RFC
//
//
type NetIpStackInfoEntryType struct {
}

//
// Information from an IP stack about known mappings betwwen an IP address
// and the underlying physical address it maps to as learned by:
// IPv4: Address Resolution Protocol (ARP) RFC 826
// IPv6: Neighbor Discovery Protocol (NDP) RFC 4861
//
//
type NetIpStackInfoNetToMedia struct {
	*DynamicData

	// The value will be the name of the interface as reported by the
	// operating system.
	Device string

	// A Unicast IP address of another system directly reachable w/o routing.
	// IPv4 address is specified using dotted decimal notation.
	// For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as eight fields
	// of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress string

	// The media-dependent of the address or empty string if not yet learned.
	// For Ethernet interfaces this is a MAC address reported in the format:
	// XX:XX:XX:XX:XX:XX where XX are hexadecimal numbers.
	PhysicalAddress string

	// The type/state of this entry as reported by the IP stack.
	// See EntryType for values.
	Type string
}

//
// The set of values used to determine ordering of default routers.
// See RFC 4293 ipDefaultRouterPreference.
//
//
type NetIpStackInfoPreference struct {
}

//
// The NetStackInstanceProfile data object represents a subprofile
// for a netStackInstance.
//
//
type NetStackInstanceProfile struct {
	*ApplyProfile

	// DnsConfigProfile for this instance of the stack.
	DnsConfig *NetworkProfileDnsConfigProfile

	// IpRouteProfile for this instance of the stack.
	IpRouteConfig *IpRouteProfile

	// Linkable identifier.
	Key string
}

//
// Represents a network accessible by either hosts or virtual machines. This can be a
// physical network or a logical network, such as a VLAN.
//
// Networks are created:
//
//
//
// • explicitly when configuring a host.
//
// • automatically when adding a host to VirtualCenter.
//
// • automatically when adding a new virtual machine to a host or to
// VirtualCenter.
//
//
//
//
// To configure network access for hosts and virtual machines, use
// DistributedVirtualSwitch and
// DistributedVirtualPortgroup managed objects.
//
//
//
type Network struct {
	*ManagedEntity

	host []*HostSystem

	name string

	summary *NetworkSummary

	vm []*VirtualMachine
}

// Hosts attached to this network.
func (mo *Network) Host() ([]*HostSystem, error) {
	t, err := mo.currentProperty("host")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*HostSystem)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*HostSystem")
	}
	return v, nil
}

// Name of this network.
func (mo *Network) Name() (string, error) {
	t, err := mo.currentProperty("name")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

// Properties of a network.
func (mo *Network) Summary() (*NetworkSummary, error) {
	t, err := mo.currentProperty("summary")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*NetworkSummary)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *NetworkSummary")
	}
	return v, nil
}

// Virtual machines using this network.
func (mo *Network) Vm() ([]*VirtualMachine, error) {
	t, err := mo.currentProperty("vm")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*VirtualMachine)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*VirtualMachine")
	}
	return v, nil
}

// Deprecated.
// As of VI API 2.5 do not use this method. This method throws
// ResourceInUse.  Networks are automatically
// removed when no longer in use, so this method is unnecessary.
//
//
// Removes a network. A network can be removed only if it is not used by any host or
// virtual machine.
//
// Required Privileges
// Network.Delete
//
func (mo *Network) DestroyNetwork(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// A network copy of the file failed.
//
//
type NetworkCopyFault struct {
	*FileFault
}

//
// Thrown if network configuration change disconnected the host from vCenter server
// and has been rolled back.
//
//
type NetworkDisruptedAndConfigRolledBack struct {
	*VimFault

	// The name of host on which the network configuration was rolled back.
	Host string
}

//
// The event argument is a Network object.
//
//
type NetworkEventArgument struct {
	*EntityEventArgument

	// The Network object.
	Network *Network
}

//
// This fault is thrown when an operation to configure a NAS volume fails
// because network access is unavailable.
//
//
type NetworkInaccessible struct {
	*NasConfigFault
}

//
// The NetworkPolicyProfile data object represents a
// network policy. The policy property
// contains network configuration data values.
//
//
type NetworkPolicyProfile struct {
	*ApplyProfile
}

//
// The NetworkProfile data object contains a set of subprofiles for
// network configuration.
//
//
type NetworkProfile struct {
	*ApplyProfile

	// Subprofile that describes the IP Route configuration
	// for the Service Console gateway.
	ConsoleIpRouteConfig *IpRouteProfile

	// DNS (Domain Name System) configuration subprofile.
	DnsConfig *NetworkProfileDnsConfigProfile

	// List of subprofiles for host Virtual NICs connected to a distributed virtual switch.
	// Use the DvsHostVNicProfile.key property
	// to access a subprofile in the list.
	DvsHostNic []*DvsHostVNicProfile

	// List of subprofiles for service console Virtual NICs connected to a distributed virtual switch.
	// Use the DvsServiceConsoleVNicProfile.key property
	// to access a subprofile in the list.
	DvsServiceConsoleNic []*DvsServiceConsoleVNicProfile

	// List of subprofiles for distributed virtual switches to which this host is connected.
	// Use the key property to access a subprofile in the list.
	Dvswitch []*DvsProfile

	// List of port groups for use by the host.
	// Use the HostPortGroupProfile.key property
	// to access port groups in the list.
	HostPortGroup []*HostPortGroupProfile

	// Subprofile that describes the IP Route
	// configuration for the VMKernel gateway.
	IpRouteConfig *IpRouteProfile

	// List of NetStackInstance subprofiles.
	// Use the key property to access
	// a subprofile in the list.
	//
	// Since vSphere API 5.5
	NetStackInstance []*NetStackInstanceProfile

	// List of subprofiles that represent physical NIC configuration.
	// Use the key property to access a
	// subprofile in the list.
	Pnic []*PhysicalNicProfile

	// List of port groups for use by the service console.
	// The Profile Engine uses this field only when applying a profile
	// to a host that has a service console.
	ServiceConsolePortGroup []*ServiceConsolePortGroupProfile

	// List of port groups for use by virtual machines.
	// Use the VmPortGroupProfile.key
	// property to access a port group in the list.
	VmPortGroup []*VmPortGroupProfile

	// List of virtual switch subprofiles.
	// Use the key property to access
	// a subprofile in the list.
	Vswitch []*VirtualSwitchProfile
}

//
// The NetworkProfileDnsConfigProfile data object represents DNS configuration
// for the host. Use the policy list for
// access to configuration data for the DNS profile. Use the
// property list for access to subprofiles, if any.
//
//
type NetworkProfileDnsConfigProfile struct {
	*ApplyProfile
}

//
// This event records when networking configuration on the host
// is rolled back as it disconnects the host from vCenter server.
//
//
type NetworkRollbackEvent struct {
	*Event

	// Method name which caused the disconnect
	MethodName string

	// Transaction ID for the method call that caused the disconnect
	TransactionId string
}

//
// General information about a network.
//
//
type NetworkSummary struct {
	*DynamicData

	// At least one host is configured to provide this network.
	Accessible bool

	// Identifier of the associated IP pool. Zero if the network is not associated
	// with an IP pool.
	//
	// Since vSphere API 5.1
	IpPoolId int32

	// Name of the associated IP pool. Empty if the network is not associated with an
	// IP pool.
	//
	// Since vSphere API 4.0
	IpPoolName string

	// Name of the network.
	Name string

	// Reference to the associated managed object.
	Network *Network
}

//
// Used as a warning if a virtual machine provisioning operation is done
// across datacenters.  This warns that the network used by the virtual
// machine before and after the operation may not be the same even though
// the two networks have the same name.  This is because network names
// are only unique within a datacenter.
//
//
type NetworksMayNotBeTheSame struct {
	*MigrationFault

	// The name of the network.
	Name string
}

//
// The number of network adapter settings in the customization specification
// does not match the number of network adapters present in the virtual machine.
//
//
type NicSettingMismatch struct {
	*CustomizationFault

	// The number of network adapter settings specified in the customization
	// specification.
	NumberOfNicsInSpec int32

	// The number of network adapters present in the virtual machine.
	NumberOfNicsInVM int32
}

//
// This event records a failed user logon due to insufficient access permission.
//
//
type NoAccessUserEvent struct {
	*SessionEvent

	// The IP address of the peer that initiated the connection. This may
	// be the client that originated the session, or it may be an intervening
	// proxy if the binding uses a protocol that supports proxies, such as HTTP.
	IpAddress string
}

//
// A NoActiveHostInCluster fault is thrown when there is no host in a valid
// state in the given compute resource to perform a specified operation. This
// can happen, for example, if all the hosts are disconnected or in maintenance
// mode.
//
//
type NoActiveHostInCluster struct {
	*InvalidState

	// The compute resource that does not have any active hosts.
	ComputeResource *ComputeResource
}

//
// There are no more IP addresses available on the given network.
//
//
type NoAvailableIp struct {
	*VAppPropertyFault

	// A reference to the network
	Network *Network
}

//
// This exception is thrown when a client has connected without supplying a
// certificate but the associated call expects that the client has done so.
//
//
type NoClientCertificate struct {
	*VimFault
}

//
// A NoCompatibleDatastore fault is thrown when Storage DRS cannnot find a compatible
// datastore in a given storage pod to place a disk or a virtual machine.
// a virtual machine.
//
//
type NoCompatibleDatastore struct {
	*VimFault
}

//
// The cluster contains no hosts satisfying the hard VM/host affinity rules
// constraint for the VM.
//
//
type NoCompatibleHardAffinityHost struct {
	*VmConfigFault

	// The vm for which there are no compatible hard-affine hosts in the cluster.
	VmName string
}

//
// A NoCompatibleHost fault is thrown when DRS cannnot find a compatible
// host in a given compute resource to run a virtual machine on.
//
//
type NoCompatibleHost struct {
	*VimFault

	// An error in this array indicates why the corresponding host in the
	// host array is incompatible.
	Error []*LocalizedMethodFault

	// The list of hosts that are not compatible, each element has a
	// corresponding fault in the error array.
	Host []*HostSystem
}

//
// This fault is used to report that a FT VM cannot be placed because there is
// no compatible host that can access all devices required to be connected when
// the VM powers on.
//
//
type NoCompatibleHostWithAccessToDevice struct {
	*NoCompatibleHost
}

//
// The cluster contains no hosts satisfying the soft VM/host affinity rules
// constraint for the VM.
//
//
type NoCompatibleSoftAffinityHost struct {
	*VmConfigFault

	// The vm for which there are no compatible soft-affine hosts in the cluster.
	VmName string
}

//
// The fault occurs when Storage DRS cannot move a virtual machine because
// the host it is registered on is not connected to any other datastore
// in the storage pod.
//
//
type NoConnectedDatastore struct {
	*VimFault
}

//
// No datastores have been configured on the host.
//
//
type NoDatastoresConfiguredEvent struct {
	*HostEvent
}

//
// This exception is thrown when a virtual machine
// which has no virtual disks is being upgraded or relaid out
// using the VirtualMachine.upgradeVirtualHardware or upgradeVmLayout
// commands.
//
//
type NoDiskFound struct {
	*VimFault
}

//
// This fault is thrown when an operation fails because of insufficient
// disk space.
//
//
type NoDiskSpace struct {
	*FileFault

	// The name of the datastore with insufficient disk space.
	Datastore string
}

//
// None of the disks attached to the VM are suitable for customization.
//
//
type NoDisksToCustomize struct {
	*CustomizationFault
}

//
// This error occurs when an operation fails because of vmkernel gateway
// is unset.
//
//
type NoGateway struct {
	*HostConfigFault
}

//
// A powered-on virtual machine has a guest OS with Tools installed, but it does not
// have a valid heartbeat.
//
//
type NoGuestHeartbeat struct {
	*MigrationFault
}

//
// A NoHostFault fault occurs when a host
// cannot be reached.
//
//
type NoHost struct {
	*HostConnectFault

	Name string
}

//
// The NoHostSuitableForFtSecondary fault is thrown when the system is unable to
// find a suitable host for the Fault Tolerance secondary virtual machine.
// This fault can be thrown when Virtual Center is trying to place or power on
// a Fault Tolerance Secondary, in both DRS or non-DRS cases.
//
//
type NoHostSuitableForFtSecondary struct {
	*VmFaultToleranceIssue

	// The primary virtual machine corresponding to the secondary virtual
	// machine.
	Vm *VirtualMachine

	// The name of the primary virtual machine corresponding to the secondary
	// virtual machine.
	VmName string
}

//
// These are events reported by License Manager.
//
// A NoLicenseEvent is reported if the required licenses could not be
// reserved. Each feature that is not fully licensed is reported.
//
//
//
type NoLicenseEvent struct {
	*LicenseEvent

	Feature *LicenseFeatureInfo
}

//
// The NoLicenseServerConfigured fault is thrown when there is no
// valid license server configured for the system and the system
// is not in evaluation mode. Any operation occurs that requires
// evaluation license or a valid license will throw the
// NoLicenseServerConfigured. This can happen with the new licensing
// scheme that is a hybrid of flex-based licensing and serial number
// based licensing. There can be cases where VirtualCenter is licensed
// by a serial number and there is no need for a flex license server.
// These cases are valid as long as no operation that requires flex-
// based license server is invoked, for example, adding a pre-4.0
// host that requires flex licenses. If however, such an operation is
// invoked, the NoLicenseServerConfigured fault is thrown.
//
//
type NoLicenseServerConfigured struct {
	*NotEnoughLicenses
}

//
// This event records that DRS did not recommend a migration for a
// powered on virtual machine, even though its host is going
// into maintenance mode.
//
// DRS may not be able to recommend a migration for a virtual machine
// for reasons, include but not limited to:
//
//
//
// •  No other connected host is compatible with this virtual machine.
//
// •  None of the other compatible hosts have sufficient resources
// to satisfy the reservation requirements of this virtual machine.
//
// •  Moving to any other host would violate a DRS rule. For example, all
// other compatible hosts have some incompatible virtual machines
// running.
//
// •  DRS is disabled on this virtual machine.
//
// •  This virtual machine was still in the process of migrating
// into the host going into maintenance mode and was not
// considered by DRS.
//
// •  This virtual machine was in the process of migrating to another
// host when the host tried to enter maintenance mode.
//
//
//
//
//
type NoMaintenanceModeDrsRecommendationForVM struct {
	*VmEvent
}

//
// This fault is thrown when no peer host is found to wake up this host.
//
//
type NoPeerHostFound struct {
	*HostPowerOpFailed
}

//
// Thrown when an operation is denied because of a privilege
// not held on a managed object.
//
//
type NoPermission struct {
	*SecurityError

	// The managed object on which permission is required
	Object *ManagedObjectReference

	// The privilege identifier required
	PrivilegeId string
}

//
// Fault indicating that the user account used to connect to the
// Active Directory doesn not have enough permissions for the action
// that was attempted.
//
//
type NoPermissionOnAD struct {
	*ActiveDirectoryFault
}

//
// This indicates that the user account used to connect to the host does
// not have enough permissions to enable VirtualCenter to manage the host.
//
//
type NoPermissionOnHost struct {
	*HostConnectFault
}

//
// This fault is thrown when an operation to configure a NAS volume fails
// because of insufficient user permissions.
//
// For CIFS volumes, this implies that the user specified in the
// spec does not have access to the
// network resource.
//
//
type NoPermissionOnNasVolume struct {
	*NasConfigFault

	UserName string
}

//
// This exception is thrown when an extension has attempted to use certificate-based
// authentication but the extension has been registered without a subject name.
//
//
type NoSubjectName struct {
	*VimFault
}

//
// The IP address of the VC server has not be configured, and a vApp
// property is requesting to use it.
//
//
type NoVcManagedIpConfigured struct {
	*VAppPropertyFault
}

//
// This error occurs when an operation fails because of
// no virtual NIC available.
//
//
type NoVirtualNic struct {
	*HostConfigFault
}

//
// Attempting to power-on or power-off a vApp that contains no
// virtual machines.
//
//
type NoVmInVApp struct {
	*VAppConfigFault
}

//
// Fault indicating that an operation must be executed by a
// non Active Directory user.
//
//
type NonADUserRequired struct {
	*ActiveDirectoryFault
}

//
// An operation on a powered-on virtual machine requests that an existing
// Raw Disk Mapping end up in a location other than the new home datastore
// for the virtual machine, but the host does not have that capability.
//
//
type NonHomeRDMVMotionNotSupported struct {
	*MigrationFeatureNotSupported

	// The label of an RDM device for which an unsupported move was requested.
	// This is not guaranteed to be the only such device.
	Device string
}

//
// The virtual machine has nonpersistent virtual disk.  This is an error for
// any powered-on migration which involves moving virtual disks.
//
//
type NonPersistentDisksNotSupported struct {
	*DeviceNotSupported
}

//
// This event records that non-VI workload is detected on the datastore.
//
//
type NonVIWorkloadDetectedOnDatastoreEvent struct {
	*DatastoreEvent
}

//
// The host does not support VM that has VPX assigned prefix or ranged based
// MAC address (i.e. MAC is not prefixed with 00:50:56:[80-BF])
//
//
type NonVmwareOuiMacNotSupportedHost struct {
	*NotSupportedHost

	// The name of the host.
	HostName string
}

//
// This fault is thrown when an operation fails because the specified object
// is not a directory.
//
//
type NotADirectory struct {
	*FileFault
}

//
// This fault is thrown when an operation fails because the specified object
// is not a file.
//
//
type NotAFile struct {
	*FileFault
}

//
// Thrown when an operation is denied because the session
// has not yet successfully logged in.
//
//
type NotAuthenticated struct {
	*NoPermission
}

//
// The host hardware does not have enough CPU cores to support the number of
// virtual CPUs in the virtual machine.
//
// If the host is using hyperthreading, NotEnoughLogicalCpus is
// employed instead of NotEnoughCpus.
//
//
//
type NotEnoughCpus struct {
	*VirtualHardwareCompatibilityIssue

	// The number of CPUs present on the host.
	NumCpuDest int32

	// The number of virtual CPUs present in the virtual machine.
	NumCpuVm int32
}

//
// A NotEnoughLicensesFault occurs when an operation
// fails because there are not enough licenses installed.
//
//
type NotEnoughLicenses struct {
	*RuntimeFault
}

//
// The host hardware does not have enough logical CPUs (hyperthreads) to
// support the number of virtual CPUs in the virtual machine.
//
//
type NotEnoughLogicalCpus struct {
	*NotEnoughCpus

	// The host that does not have enough logical CPUs.
	//
	// Since VI API 2.5
	Host *HostSystem
}

//
// This event records when the HA does not find sufficient resources to failover a
// virtual machine.
//
//
type NotEnoughResourcesToStartVmEvent struct {
	*VmEvent
}

//
// A NotFound error occurs when a referenced component of a managed
// object cannot be found.  The referenced component can be a data
// object type (such as a role or permission) or a primitive
// (such as a string).
//
// For example, if the missing referenced component is a data object, such as
// VirtualSwitch, the NotFound error is
// thrown.  The NotFound error is also thrown if the data object is found, but the referenced name
// (for example, "vswitch0") is not.
//
//
//
type NotFound struct {
	*VimFault
}

//
// NotImplemented exception is thrown if the method is not
// yet implemeneted.
//
//
type NotImplemented struct {
	*RuntimeFault
}

//
// Thrown if the method is not supported on the
// server. Not all methods are supported on all servers
// (for example, an ESX Server host supports less functionality than
// a VirtualCenter server). A feature might also be disabled
// due to missing liceneses.
//
//
type NotSupported struct {
	*RuntimeFault
}

//
// VMs with pvscsi or vmxnet3 virtual devices support Fault Tolerance only
// on 4.1 or later hosts.
//
//
type NotSupportedDeviceForFT struct {
	*VmFaultToleranceIssue

	// The device label
	DeviceLabel string

	// The device type
	DeviceType string

	// The host
	Host *HostSystem

	// The host name
	HostName string

	// The virtual machine
	Vm *VirtualMachine

	// The virtual machine name
	VmName string
}

type NotSupportedDeviceForFTDeviceType struct {
}

//
// A NotSupportedHostFault occurs when the host is of a type
// that is not supported.
//
//
type NotSupportedHost struct {
	*HostConnectFault

	// The name of the unsupported product if available;
	// for example, "VMware ESX Server".
	ProductName string

	// The version of the unsupported product; for example, "1.5.2"
	ProductVersion string
}

//
// The host does not support vFlash feature.
//
//
type NotSupportedHostForVFlash struct {
	*NotSupportedHost

	// The name of the host.
	HostName string
}

//
// The host does not support VSAN.
//
//
type NotSupportedHostForVsan struct {
	*NotSupportedHost

	// The name of the host.
	HostName string
}

//
// A NotSupportedHostInCluster fault occurs when the host does not support
// the necessary features to participate in the cluster.
//
//
type NotSupportedHostInCluster struct {
	*NotSupportedHost
}

//
// A NotSupportedHostInDvs fault occurs when the host does not support
// the necessary features to participate in the DVS.
//
//
type NotSupportedHostInDvs struct {
	*NotSupportedHost

	// The product spec of the DVS. This determines which host versions may
	// participate in the DVS; that information may be queried by using
	// QueryDvsCompatibleHostSpec.
	SwitchProductSpec *DistributedVirtualSwitchProductSpec
}

//
// A NotSupportedHostInHACluster fault occurs when the host does not support
// the necessary features to participate in the HA cluster.
//
//
type NotSupportedHostInHACluster struct {
	*NotSupportedHost

	// The product build number of the host.
	Build string

	// The name of the host.
	HostName string
}

//
// The property value cannot be changed since it is not
// user configurable.
//
//
type NotUserConfigurableProperty struct {
	*VAppPropertyFault
}

type NumPortsProfile struct {
	*ApplyProfile
}

//
// The host's software does not support enough cores per socket to
// accomodate the virtual machine. This is always an error.
//
//
type NumVirtualCoresPerSocketNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The maximum number of cores per socket supported on the host.
	MaxSupportedCoresPerSocketDest int32

	// The number of cores per socket in the virtual machine.
	NumCoresPerSocketVm int32
}

//
// This fault is thrown when the total number of virtual CPUs present or requested
// in virtual machines' configuration has exceeded the limit on the host.
//
//
type NumVirtualCpusExceedsLimit struct {
	*InsufficientResourcesFault

	// The maximum number of virtual CPUs supported on the host.
	MaxSupportedVcpus int32
}

//
// The number of virtual CPUs present or requested in the virtual machine's
// configuration is not supported for a specific feature.
//
//
type NumVirtualCpusIncompatible struct {
	*VmConfigFault

	// The number of virtual CPUs in the virtual machine.
	NumCpu int32

	// The reason for the incompatibility.
	// See NumVirtualCpusIncompatibleReason for valid values.
	Reason string
}

//
// Reasons why the number of virtual CPUs is incompatible.
//
//
type NumVirtualCpusIncompatibleReason struct {
}

//
// The host's software does not support enough virtual CPUs to
// accomodate the virtual machine. This is always an error.
//
//
type NumVirtualCpusNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The maximum number of virtual CPUs supported on the host.
	MaxSupportedVcpusDest int32

	// The number of virtual CPUs in the virtual machine.
	NumCpuVm int32
}

//
// The class that describe an integer range.
//
//
type NumericRange struct {
	*DynamicData

	// The ending number (inclusive).
	End int32

	// The starting number.
	Start int32
}

//
// The ObjectContent data object type contains the
// contents retrieved for a single managed object.
//
//
type ObjectContent struct {
	*DynamicData

	// Properties for which values could not be retrieved and the associated
	// fault.
	MissingSet []*MissingProperty

	// Reference to the managed object that contains properties of interest.
	Obj *ManagedObjectReference

	// Set of name-value pairs for the properties of the managed object.
	PropSet []*DynamicProperty
}

//
// Within a PropertyFilterSpec, the ObjectSpec data object type specifies the managed
// object at which the filter begins to collect the managed object
// references and properties specified by the associated PropertySpec set. If the "skip" property is present
// and set to true, then the filter does not check to see if the starting
// object's type matches any of the types listed in the associated sets of
// PropertySpec data objects.
//
// If the selectSet property is
// present, then this specifies additional objects to filter.  These objects
// are defined by one or more SelectionSpec
// objects.
//
//
//
type ObjectSpec struct {
	*DynamicData

	// Starting object.
	// Required Privilege: System.View
	Obj *ManagedObjectReference

	// Set of selections to specify additional objects to filter.
	SelectSet []*SelectionSpec

	// Flag to specify whether or not to report this managed object's
	// properties.  If the flag is true, the filter will not report this
	// managed object's properties.
	Skip bool
}

//
// The ObjectUpdate data object type contains
// information about changes to a particular managed object. We distinguish
// updates when an object is created, destroyed, or modified, as well as
// when the object enters or leaves the set of objects dynamically
// associated with a filter.
//
//
type ObjectUpdate struct {
	*DynamicData

	// Optional set of changes to the object.  Present only if the "kind" is
	// either "modify" or "enter".
	ChangeSet []*PropertyChange

	// Kind of update that caused the filter to report a change.
	Kind *enum.ObjectUpdateKind

	// Properties whose value could not be retrieved and their associated
	// faults.  Present only if the "kind" is either "modify" or "enter".
	MissingSet []*MissingProperty

	// Reference to the managed object to which this update applies.
	Obj *ManagedObjectReference
}

//
// Enumeration of different kinds of updates.
//
//
type ObjectUpdateKind struct {
}

//
// The OnceTaskScheduler data object establishes the time for running
// a scheduled task only once.
//
//
type OnceTaskScheduler struct {
	*TaskScheduler

	// The time a task will run.
	// If you do not set the time, it executes immediately.
	RunAt time.Time
}

//
// This interface defines an opaque network, in the sense that the detail and configuration
// of the network is unknown to vShpere and is managed by a management plane outside of
// vSphere. However, the identifier and name of these networks is made available to
// vSphere so that host and virtual machine virtual ethernet device can connect to them.
//
type OpaqueNetwork struct {
	*ManagedObject
	*Network
}

//
// The summary of a opaque network.
// An object of this class is returned by the summary property.
//
//
type OpaqueNetworkSummary struct {
	*NetworkSummary

	// The opaque network ID
	OpaqueNetworkId string

	// The opaque network type
	OpaqueNetworkType string
}

//
// This class describes an opaque network that a device backing
// can attached to.
//
//
type OpaqueNetworkTargetInfo struct {
	*VirtualMachineTargetInfo

	// Information about the opaque network
	Network *OpaqueNetworkSummary
}

//
// An OperationDisabledByGuest exception is thrown when an
// operation fails because the guest operations agent has been configured to
// disable the operation.
//
//
type OperationDisabledByGuest struct {
	*GuestOperationsFault
}

//
// An OperationDisallowedOnHost is thrown if an operation is diasllowed
// on host when a direct connection is used.
//
// Examples for such operations include VM powering on / memory hot-plug
// which could potentially violate hard-enforcement licenses if allowed
// on host.
//
// The functionality these operations provide is still available, but only
// through calls to an external entity.
//
//
type OperationDisallowedOnHost struct {
	*RuntimeFault
}

//
// An OperationNotSupportedByGuest exception is thrown when an
// operation fails because the guest OS does not support
// the operation (e.g., Registry manipulation in Linux guests.).
//
//
type OperationNotSupportedByGuest struct {
	*GuestOperationsFault
}

//
// Describes a user-defined option. The name of each option is identified by the
// "key" property, inherited from the ElementDescription
// data object type.
// You can indicate the property's position in a hierarchy by using a dot-separated
// notation. The string preceding the first dot is the top of the hierarchy. The
// hierarchy descends to a new sublevel with each dot.
// For example,  "Ethernet.NetworkConnection.Bridged".
//
//
type OptionDef struct {
	*ElementDescription

	// The option type which defines allowed values.
	OptionType *OptionType
}

//
// This managed object type is used for managing key/value pair
// options.
//
//
//
//
// • You can define options on the fly, in a logical tree using a dot notation
// for keys.  For example, "Ethernet.Connection" describes the Connection
// option as child of the Ethernet option.
//
// • You can use the queryMethod to retrieve a single property or
// a subset of properties based on the dot notation path.
//
//
//
//
type OptionManager struct {
	*ManagedObject

	setting []*OptionValue

	supportedOption []*OptionDef
}

// A list of the current settings for the key/value pair options.
func (mo *OptionManager) Setting() ([]*OptionValue, error) {
	t, err := mo.currentProperty("setting")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*OptionValue)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*OptionValue")
	}
	return v, nil
}

// A list of supported key/value pair options including their
// type information.
func (mo *OptionManager) SupportedOption() ([]*OptionDef, error) {
	t, err := mo.currentProperty("supportedOption")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*OptionDef)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*OptionDef")
	}
	return v, nil
}

//
// Returns a specific node or nodes in the option hierarchy.
//
//
// This method might require any of the following privileges depending
// on where the property fits in the inventory tree.
//
//
//
// • System.View on the root folder, if this is used to read settings
// in the "client" subtree.
//
// • System.Read on the root folder, if this is used to read all settings
// or any settings beside those in the "client" subtree.
//
// • System.Read on the host, if this is used to read the advanced
// options for a host configuration.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *OptionManager) QueryOptions(
	_this *ManagedObjectReference, name string,
) ([]*OptionValue, error) {

	return nil, nil

}

//
// Updates one or more properties. These properties are changed
// atomically: either all are applied or none are.
//
// A nested option setting can be named using a dot notation; for example,
// system.cacheSize.
//
//
//
// This method might require any of the following privileges depending
// on where the property fits in the inventory tree.
//
//
//
// • Global.Settings on the root folder, if this is used to modify the
// settings in the service node.
//
// • Host.Config.AdvancedConfig on the host, if this is used to set the
// advanced options in the host configuration.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *OptionManager) UpdateOptions(
	_this *ManagedObjectReference, changedValue []*OptionValue,
) error {

	return nil

}

//
// The OptionProfile data object encapsulates one advanced configuration.
// Use the policy list for access to configuration data
// for the option profile. Use the property list for access
// to subprofile configuration data, if any.
//
//
type OptionProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string
}

//
// The base data object type for all options.
//
//
type OptionType struct {
	*DynamicData

	// The flag to indicate whether or not a user
	// can modify a value belonging to this option type. If
	// the flag is not set, the value can be modified.
	ValueIsReadonly bool
}

//
// Describes the key/value pair of a configured option.
//
//
type OptionValue struct {
	*DynamicData

	// The name of the option using dot notation to reflect the
	// option's position in a hierarchy.  For example, you might
	// have an option called "Ethernet" and another option that is
	// a child of that called "Connection".  In this case, the key
	// for the latter could be defined as "Ethernet.Connection"
	Key string

	// The value of the option. The Any data object type enables you to
	// define any value for the option. Typically, however, the value
	// of an option is of type String or Integer.
	Value interface{}
}

//
// A data object type that links multiple alarm expressions with OR operators.
//
//
type OrAlarmExpression struct {
	*AlarmExpression

	// List of alarm expressions that define the overall status of the alarm.
	//
	//
	// The state of the alarm expression is gray if all subexpressions are gray.
	// Otherwise, gray subexpressions are ignored.
	// The state is red if any subexpression is red.
	// Otherwise, the state is yellow if any subexpression is yellow.
	// Otherwise, the state of the alarm expression is green.
	Expression []*AlarmExpression
}

//
// Thrown if a parameter exceeds the acceptable range of values.
//
//
type OutOfBounds struct {
	*VimFault

	// This should be the name of the field that holds the allowed maximum
	// (for example, Host.capability.maxSupportedVMs).
	ArgumentName string
}

//
// The list of hosts that have the DVS configuration on the host
// diverged from that of the Virtual Center Server.
//
//
type OutOfSyncDvsHost struct {
	*DvsEvent

	// The host that went out of sync.
	HostOutOfSync []*DvsOutOfSyncHostArgument
}

//
// An OVF descriptor Attribute base class.
//
//
type OvfAttribute struct {
	*OvfInvalidPackage

	// Attribute name
	AttributeName string

	// Element name where the attribute is defined
	ElementName string
}

type OvfConnectedDevice struct {
	*OvfHardwareExport
}

type OvfConnectedDeviceFloppy struct {
	*OvfConnectedDevice

	// The filename of the floppy image
	Filename string
}

type OvfConnectedDeviceIso struct {
	*OvfConnectedDevice

	// The filename of the ISO
	Filename string
}

//
// A base fault for Ovf descriptor constraints
//
//
type OvfConstraint struct {
	*OvfInvalidPackage

	// The name of the element
	Name string
}

//
// Superclass for all faults that can be thrown during the callback to an OVF
// consumer. The faultCause gives details about what went
// wrong.
//
//
type OvfConsumerCallbackFault struct {
	*OvfFault

	// The OVF consumer's extension key.
	ExtensionKey string

	// The OVF consumer's extension name.
	ExtensionName string
}

//
// A fault type indicating that network communication with an OVF consumer failed.
//
//
type OvfConsumerCommunicationError struct {
	*OvfConsumerCallbackFault

	// The network library error message.
	Description string
}

//
// Localized fault that may be thrown by an OVF consumer.
//
//
type OvfConsumerFault struct {
	*OvfConsumerCallbackFault

	// An error code that uniquely describes the fault within this extension.
	ErrorKey string

	// The error message, localized by the OVF consumer
	Message string

	// Additional parameters for this fault
	Params []*KeyValue
}

//
// A fault type indicating that the XML of a section appended by an OVF consumer was
// invalid.
//
//
type OvfConsumerInvalidSection struct {
	*OvfConsumerCallbackFault

	// The XML parser error message.
	Description string

	// The line number in the section on which the error was found.
	LineNumber int32
}

//
// A node in the OVF section tree.
//
// This class represents a node on which OVF sections can be defined. The possible
// node types are OstNodeType.envelope, OstNodeType.virtualSystem or
// OstNodeType.virtualSystemCollection, corresponding to the identically named OVF
// element types.
//
//
// Since the node contains a list of children, it can also be regarded as a tree. This
// tree mirrors the structure of the OVF descriptor. It is provided to OVF consumers
// as a more convenient way to navigate and modify the OVF than by working directly on
// the XML.
//
//
//
type OvfConsumerOstNode struct {
	*DynamicData

	// The list of child nodes. As dictated by OVF, this list is subject to the
	// following rules:
	//
	//
	// The Envelope node must have exactly one child.
	// VirtualSystemCollection nodes may have zero or more children.
	// VirtualSystem nodes must have no children.
	Child []*OvfConsumerOstNode

	// The VM or vApp corresponding to this node.
	//
	// This field is set when this OstNode represents an existing managed entity.
	//
	// The entity is unset on nodes of type OstNodeType.envelope.
	Entity *ManagedEntity

	// The OVF id of the Content (VirtualSystem or VirtualSystemCollection)
	// element. Empty on the envelope node.
	Id string

	// The list of sections on this node.
	Section []*OvfConsumerOvfSection

	// The type of the node. Possible values are defined in the OstNodeType enum.
	//
	// Since the OstNode tree structure mirrors the structure of the OVF descriptor,
	// only one Envelope node is defined, and it is always the root of the tree.
	Type string
}

//
// The type of an OST node.
//
// Each OST node corresponds to an element in the OVF descriptor. See OstNode
// for a description of the different node types.
//
//
//
type OvfConsumerOstNodeType struct {
}

//
// A self-contained OVF section
//
//
type OvfConsumerOvfSection struct {
	*DynamicData

	// The line number in the OVF descriptor on which this section starts.
	//
	// The line number is only present on sections that were imported as part of an OVF
	// descriptor (as opposed to sections that are about to be exported to OVF).
	//
	// The value is zero if the section did not originate from an OVF descriptor.
	LineNumber int32

	// The XML fragment for the section.
	//
	// The XML fragment must explicitly define all namespaces and namespace prefixes
	// that are used in the fragment, including the default namespace.
	Xml string
}

//
// A fault type indicating that the power on operation failed.
//
//
type OvfConsumerPowerOnFault struct {
	*InvalidState

	// A localized, human-readable description of the error.
	Description string

	// The OVF consumer's extension key.
	ExtensionKey string

	// The OVF consumer's extension name.
	ExtensionName string
}

//
// A fault type indicating that an OVF consumer appended an undeclared section to an OST.
//
// An undeclared section means a section with a qualified type that the OVF consumer was
// not registered as a handler of.
//
//
//
type OvfConsumerUndeclaredSection struct {
	*OvfConsumerCallbackFault

	// The undeclared qualified section type appended by the OVF consumer.
	QualifiedSectionType string
}

//
// A fault type indicating that an OVF consumer added a section with an unbound prefix.
//
//
type OvfConsumerUndefinedPrefix struct {
	*OvfConsumerCallbackFault

	// The prefix for which no namespace definition was found.
	Prefix string
}

//
// Thrown by an OVF consumer if an error occurred while validating an instantiation OST.
//
//
type OvfConsumerValidationFault struct {
	*VmConfigFault

	// The OVF consumer's extension key.
	ExtensionKey string

	// The OVF consumer's extension name.
	ExtensionName string

	// The error message, localized by the OVF consumer
	Message string
}

type OvfCpuCompatibility struct {
	*OvfImport

	// The desired register value return from the host
	DesiredRegisterValue string

	// The CpuId level where a problem was detected. Other levels may
	// also have problems
	Level int32

	// Possible register names are eax, ebx, ecx, or edx.
	RegisterName string

	// The register value where the problem was detected
	RegisterValue string
}

type OvfCpuCompatibilityCheckNotSupported struct {
	*OvfImport
}

//
// Collection of parameters for createDescriptor
//
//
type OvfCreateDescriptorParams struct {
	*DynamicData

	// The contents of the Annontation section of the top-level OVF Entity. If unset,
	// any existing annotation on the entity is left unchanged.
	Description string

	// An optional argument for modifying the export process.
	// The option is used to control what extra information that will be included in the
	// OVF descriptor.
	//
	// To get a list of supported keywords see ovfExportOption. Unknown
	// options will be ignored by the server.
	//
	// Since vSphere API 5.1
	ExportOption []string

	// Controls whether attached image files should be included in the descriptor.
	// This applies to image files attached to VirtualCdrom and VirtualFloppy.
	//
	// Since vSphere API 4.1
	IncludeImageFiles bool

	// The ovf:id to use for the top-level OVF Entity. If unset, the entity's
	// product name is used if available. Otherwise, the VI entity name is used.
	Name string

	// Contains information about the files of the entity, if they have already been
	// downloaded. Needed to construct the References section of the descriptor.
	//
	// OvfFile is a positive list of files to include in the export. An Empty list
	// will do no filtering.
	OvfFiles []*OvfFile

	// Snapshot reference from which the OVF descriptor should be based.
	//
	// If this parameter is set, the OVF descriptor is based off the
	// snapshot point. This means that the OVF descriptor will have the
	// same configuration as the virtual machine at the time the snapshot
	// was taken.
	//
	// The snapshot must be belong to the specified ManagedEntity in the
	// createDescriptor call.
	//
	// Since vSphere API 5.5
	Snapshot *VirtualMachineSnapshot
}

//
// The result of creating the OVF descriptor for the entity.
//
//
type OvfCreateDescriptorResult struct {
	*DynamicData

	// Errors that happened during processing.
	//
	// For example, unknown or unsupported devices could be found (in which case
	// this array will contain one or more instances of Unsupported-/UnknownDevice).
	Error []*LocalizedMethodFault

	// Returns true if there are ISO or Floppy images attached to one or more VMs.
	//
	// Since vSphere API 4.1
	IncludeImageFiles bool

	// The OVF descriptor for the entity.
	OvfDescriptor string

	// Non-fatal warnings from the processing.
	//
	// The result will be valid, but the user may choose to reject it based on these
	// warnings.
	Warning []*LocalizedMethodFault
}

//
// Parameters for deploying an OVF.
//
//
type OvfCreateImportSpecParams struct {
	*OvfManagerCommonParams

	// An optional disk provisioning. If set, all the disks in the deployed OVF will
	// have get the same specified disk type (e.g., thin provisioned).
	//
	// The valide values for disk provisioning are:
	//
	// monolithicSparse
	// monolithicFlat
	// twoGbMaxExtentSparse
	// twoGbMaxExtentFlat
	// thin
	// thick
	// sparse
	// flat
	// seSparse
	// See VirtualDiskMode
	//
	// Since vSphere API 4.1
	DiskProvisioning string

	// The name to set on the entity (more precisely, on the top-level vApp or
	// VM of the entity) as it appears in VI. If empty, the product name is obtained
	// from the ProductSection of the descriptor. If that name is not specified, the
	// ovf:id of the top-level entity is used.
	EntityName string

	// The host to validate the OVF descriptor against, if it cannot be deduced from
	// the resource pool.
	//
	// The privilege System.Read is required on the host.
	HostSystem *HostSystem

	// The instantiation OST to configure OVF consumers. This is created by the client
	// from the annotated OST. See OvfConsumer for details.
	//
	// Since vSphere API 5.0
	InstantiationOst *OvfConsumerOstNode

	// The IP allocation policy chosen by the caller.
	//
	// See VAppIPAssignmentInfo.
	IpAllocationPolicy string

	// The IP protocol chosen by the caller.
	//
	// See VAppIPAssignmentInfo.
	IpProtocol string

	// The mapping of network identifiers from the descriptor to networks in the VI
	// infrastructure.
	//
	// The privilege Network.Assign is required on all networks in the list.
	NetworkMapping []*OvfNetworkMapping

	// The assignment of values to the properties found in the descriptor. If no value
	// is specified for an option, the default value from the descriptor is used.
	PropertyMapping []*KeyValue

	// Deprecated.
	// As of vSphere API 5.1.
	//
	//
	// The resource configuration for the created vApp. This can be used to distribute
	// a vApp across  multiple resource pools (and create linked children).
	//
	// Since vSphere API 4.1
	ResourceMapping []*OvfResourceMap
}

//
// Types of disk provisioning that can be set for the disk in the deployed OVF
// package.
//
//
type OvfCreateImportSpecParamsDiskProvisioningType struct {
}

//
// The CreateImportSpecResult contains all information regarding the import that can
// be extracted from the OVF descriptor.
//
// For example, this includes the list of items that the caller must upload in order
// to complete the import, but not the list of URLs to which the files must be
// uploaded. These paths are not known until the VMs have been created, ie. until
// ResourcePool.importVApp has been
// called.
//
//
//
type OvfCreateImportSpecResult struct {
	*DynamicData

	// Errors that happened during processing. Something will be wrong with the
	// ImportSpec, or it is not present.
	Error []*LocalizedMethodFault

	// The files that must be uploaded by the caller as part of importing the entity.
	//
	// The files must be uploaded in order, because some of them may be delta files
	// that patch already-uploaded files.
	FileItem []*OvfFileItem

	// The ImportSpec contains information about which VirtualMachines
	// and VirtualApps are present in the entity and
	// how they relate to each other.
	ImportSpec *ImportSpec

	// Non-fatal warnings from the processing.  The ImportSpec will be valid, but the
	// user may choose to reject it based on these warnings.
	Warning []*LocalizedMethodFault
}

//
// A deployment option as defined in the OVF specfication.
//
// This corresponds to the Configuration element of the DeploymentOptionSection in the
// specification.
//
//
//
type OvfDeploymentOption struct {
	*DynamicData

	// A localizable description for the deployment option.
	Description string

	// The key of the deployment option, corresponding to the ovf:id attribute in the
	// OVF descriptor
	Key string

	// A localized label for the deployment option
	Label string
}

type OvfDiskMappingNotFound struct {
	*OvfSystemFault

	// The disk name that is not found
	DiskName string

	// The VM Name
	VmName string
}

//
// Class used to indicate that the Disks in a DiskSection was not defined
// in the same order as in the Reference section
//
//
type OvfDiskOrderConstraint struct {
	*OvfConstraint
}

//
// OvfDuplicateElement is thrown if Ovf descriptor contains an invalid duplicate element.
//
//
type OvfDuplicateElement struct {
	*OvfElement
}

//
// If the Ovf descriptor element have duplicated element bound.
//
//
type OvfDuplicatedElementBoundary struct {
	*OvfElement

	// Name of duplicated boundary
	Boundary string
}

//
// Two or more user-configurable properties are
// found with the same fully-qualified property
// name.
//
//
type OvfDuplicatedPropertyIdExport struct {
	*OvfExport

	// The fully qualified property id.
	Fqid string
}

//
// Two or more user-configurable properties are
// found with the same fully-qualified property
// name.
//
//
type OvfDuplicatedPropertyIdImport struct {
	*OvfExport
}

//
// A base fault for element exceptions in the Ovf XML descriptor.
//
//
type OvfElement struct {
	*OvfInvalidPackage

	// The name of the element
	Name string
}

//
// A class used if a element node is found to have an invalid value.
// Base class for OvfProperty errors.
//
//
type OvfElementInvalidValue struct {
	*OvfElement

	// The value of the element
	Value string
}

//
// A common base class to host all the Ovf Lib Export Exceptions.
//
//
type OvfExport struct {
	*OvfFault
}

//
// This fault is used if we fail to export an OVF package.
//
//
type OvfExportFailed struct {
	*OvfExport
}

//
// A common base type fault for all Ovf related faults.
//
// The structure of OvfFault is as listed.
//
//
//
//
// • OvfFault
//
//
//
// • OvfInvalidPackage
//
//
//
// • OvfXmlFormat
//
// • OvfWrongNamespace
//
// • OvfElement
//
//
//
// • OvfElementInvalidValue
//
// • OvfUnexpectedElement
//
// • OvfDuplicateElement
//
// • OvfMissingElement
//
// • OvfMissingElementNormalBoundary
//
// • OvfDuplicatedElementBoundary
//
//
//
// • OvfAttribute
//
//
//
// • OvfMissingAttribute
//
// • OvfInvalidValue
//
//
//
// • OvfInvalidValueFormatMalformed
//
// • OvfInvalidValueConfiguration
//
// • OvfInvalidValueReference
//
// • OvfInvalidValueEmpty
//
//
//
//
//
// • OvfProperty
//
//
//
// • OvfPropertyType
//
// • OvfPropertyValue
//
// • OvfPropertyNetwork
//
// • OvfPropertyQualifier
//
// • OvfPropertyQualifierWarning
//
//
//
//
//
// • OvfConstraint
//
//
//
// • OvfDiskOrderConstraint
//
// • OvfHostResourceConstraint
//
//
//
// • OvfUnsupportedPackage
//
//
//
// • OvfNoHostNic
//
// • OvfInvalidVmName
//
// • OvfUnsupportedAttribute
//
//
//
// • OvfUnsupportedAttributeValue
//
//
//
// • OvfUnsupportedElement
//
//
//
// • OvfUnsupportedElementValue
//
// • OvfUnsupportedSection
//
// • OvfNoSpaceOnController
//
//
//
// • OvfUnsupportedType
//
// • OvfUnsupportedSubType
//
// • OvfHardwareCheck
//
// • OvfNoSupportedHardwareFamily
//
//
//
// • OvfExport
//
//
//
// • OvfExportFailed
//
// • OvfHardwareExport
//
//
//
// • OvfUnsupportedDeviceExport
//
// • OvfUnknownDeviceBacking
//
// • OvfConnectedDevice
//
//
//
// • OvfConnectedDeviceISO
//
//
//
// • OvfUnableToExportDisk
//
//
//
// • OvfPropertyExport
//
// • OvfPropertyNetworkExport
//
// • OvfDuplicatedPropertyIdExport
//
//
//
// • OvfImport  (these are typically returned as warnings
// )
//
//
// • OvfImportFailed
//
// • OvfHardwareCheck
//
// • OvfMissingHardware
//
// • OvfCpuCompatibility
//
// • OvfCpuCompatibilityCheckNotSupported
//
// • OvfUnsupportedDiskProvisioning
//
// • OvfDuplicatedPropertyIdImport
//
// • OvfNetworkMappingNotSupported
//
//
//
// • OvfSystemFault
//
//
//
// • OvfDiskMappingNotFound
//
// • OvfHostValueNotParsed
//
// • OvfInternalError
//
// • OvfUnsupportedDeviceBackingOption
//
// • OvfUnsupportedDeviceBackingInfo
//
// • OvfToXmlUnsupportedElement
//
// • OvfUnknownDevice
//
// • OvfUnknownEntity
//
//
//
// • OvfConsumerCallbackFault
//
//
//
// • OvfConsumerFault
//
// • OvfConsumerCommunicationError
//
// • OvfConsumerInvalidSection
//
// • OvfConsumerUndeclaredSection
//
// • OvfConsumerUndefinedPrefix
//
//
//
//
//
//
//
//
// All messages go into the vimlocale
//
//
//
type OvfFault struct {
	*VimFault
}

//
// Represents a file that the caller has downloaded and stored somewhere appropriate.
//
// An instance of this class is used to tell OvfManager about the choices the caller
// made about a file. This information is needed when the OVF descriptor is generated
// with createDescriptor.
//
//
//
type OvfFile struct {
	*DynamicData

	// The capacity of the disk backed by this file. This should only be set if the
	// device backed by this file is a disk. This value will be written in the
	// "capacity" attribute of the corresponding "Disk" element in the OVF descriptor.
	//
	// Note that the "capacity" attribute is normally set to the capacity of the
	// corresponding VirtualDisk. Setting this variable
	// overrides the capacity from the VirtualDisk.
	//
	// Since vSphere API 4.1
	Capacity int64

	// The chunksize chosen by the caller.
	//
	// When using chunking, the caller must adhere to the method described in the OVF
	// specification.
	ChunkSize int64

	// The compression method the caller chose to employ for this file.
	CompressionMethod string

	// The ID of the device backed by this file. This ID uniquely identifies the
	// device within the entity hierarchy.
	//
	// The caller will have received this along with the URL needed to download the
	// file (this is handled by another service interface).
	DeviceId string

	// The path chosen by the caller for this file. This path becomes the value of the
	// "href" attribute of the corresponding "File" element in the OVF descriptor.
	//
	// This path must be relative to the path chosen for the OVF descriptor. This
	// implies that the caller must decide in advance on the path to which it will
	// write the OVF descriptor, once it is returned.
	//
	// The folder separator must be "/" (forward slash).
	//
	// The path must not begin with a slash - ie. it must not be an absolute path.
	Path string

	// The populated size of the disk backed by this file. This should only be set if
	// the device backed by this file is a disk. This value will be written in the
	// "populatedSize" attribute of the corresponding "Disk" element in the OVF
	// descriptor.
	//
	// Since vSphere API 4.1
	PopulatedSize int64

	// The file size, as observed by the caller during download.
	Size int64
}

//
// An FileItem represents a file that must be uploaded by the caller when the
// inventory objects has been created in VI. These objects are created by ResourcePool.importVApp.
//
// Files can either be new files, in which case the "create" flag will be true, or
// updates to existing files in VI. The latter is used to support the OVF parentRef
// mechanism for Disks.
//
//
//
type OvfFileItem struct {
	*DynamicData

	// The chunksize as specified by the OVF specification.
	//
	// If this attribute is set, the "path" attribute is a prefix to
	// each chunk of the complete file.
	//
	// For example, if chunksize is 2000000000 bytes, the actual files
	// might be:
	//
	// myfile.000000000  (2000000000 bytes)
	// myfile.000000001  (2000000000 bytes)
	// myfile.000000002  (1500000000 bytes)
	ChunkSize int64

	// The CIM type of the device for which this file provides
	// backing.
	//
	// For example, the value 17 means "Disk drive".
	CimType int32

	// The compression method as specified by the OVF
	// specification (for example "gzip" or "bzip2").
	CompressionMethod string

	// True if the item is not expected to exist in the infrastructure
	// and should therefore be created by the caller (for example using HTTP PUT).
	Create bool

	// Uniquely identifies the device (disk, CD-ROM etc.) within the entity hierarchy.
	//
	// When ResourcePool.importVApp is
	// called to create the VirtualMachines and VirtualApps, it returns a map,
	// device ID -> URL, of where to upload the backing files.
	DeviceId string

	// The path of the item to upload, relative to the path of the OVF descriptor.
	Path string

	// The complete size of the file, if it is specified in the
	// OVF descriptor.
	Size int64
}

type OvfHardwareCheck struct {
	*OvfImport
}

//
// A common base class to host all the OvfLib Export Exceptions for hardware.
//
//
type OvfHardwareExport struct {
	*OvfExport

	// The virtual device we are exporting to OVF
	Device *VirtualDevice

	// The path to the VM containing the device.
	//
	// This path shows the location of the VM in the vApp hierarchy, on the form:
	//
	// /ParentVApp/ChildVApp/VMName
	VmPath string
}

//
// Class used to indicate that the value in HostResoruce did not map to
// a valid reference element.
//
//
type OvfHostResourceConstraint struct {
	*OvfConstraint

	// Value of the element
	Value string
}

type OvfHostValueNotParsed struct {
	*OvfSystemFault

	// The host property field that could not be parsed.
	Property string

	// Value of the field that could not be parsed.
	Value string
}

//
// A common base class for errors that can happen during Import and
// that is not due to an invalid package (OvfInvalidPackage). These
// are typically issued as warnings.
//
//
type OvfImport struct {
	*OvfFault
}

//
// This fault is used if we fail to deploy an OVF package.
//
//
type OvfImportFailed struct {
	*OvfImport
}

//
// Disk mode not supported
//
//
type OvfInternalError struct {
	*OvfSystemFault
}

//
// Base fault class for all Invalid OVF package faults.
//
//
type OvfInvalidPackage struct {
	*OvfFault

	// XML OVF descriptor line numbers
	LineNumber int32
}

//
// If an invalid value is found in the Ovf descriptor we throw an OvfInvalidValue exception.
//
//
type OvfInvalidValue struct {
	*OvfAttribute

	// Attribute value
	Value string
}

//
// If an malformed ovf:configuration attribute value is found in the
// Ovf descriptor we throw an OvfInvalidValueConfiguration exception.
//
//
type OvfInvalidValueConfiguration struct {
	*OvfInvalidValue
}

//
// If an attribute is found with an empty value where it is not allowed.
//
//
type OvfInvalidValueEmpty struct {
	*OvfInvalidValue
}

//
// If an malformed value is found in the Ovf descriptor we throw an OvfInvalidValueFormatMalformed
// exception.
//
//
type OvfInvalidValueFormatMalformed struct {
	*OvfInvalidValue
}

//
// If a value refer to something that is not found is found in the Ovf descriptor
// we throw an OvfInvalidValueReference exception.
//
//
type OvfInvalidValueReference struct {
	*OvfInvalidValue
}

//
// This fault is used if we can not normalize the vm name
//
//
type OvfInvalidVmName struct {
	*OvfUnsupportedPackage

	// The name of the invalid Virtual Machine
	Name string
}

//
// Service interface to parse and generate OVF descriptors.
//
// The purpose of this interface is to make it easier for callers to import VMs and
// vApps from OVF packages and to export VI packages to OVF. In the following
// description, the term "client" is used to mean any caller of the interface.
//
//
// This interface only converts between OVF and VI types. To actually import and export
// entities, use ResourcePool.importVApp,
// VirtualMachine.exportVm and
// VirtualApp.exportVApp.
//
//
// Import
// For the import scenario, the typical sequence of events is as follows:
//
// The client calls parseDescriptor to obtain information about the OVF descriptor. This
// typically includes information (such as a list of networks) that must be mapped to VI
// infrastructure entities.
//
//
// The OVF descriptor is validated against the OVF Specification, and any errors or
// warnings are returned as part of the ParseResult. For example, the parser might
// encounter a section marked required that it does not understand, or the XML descriptor
// might be malformed.
//
//
// The client decides on network mappings, datastore, properties etc. It then calls
// createImportSpec to obtain the parameters needed to call
// ResourcePool.importVApp.
//
//
// If any warnings are present, the client will review these and decide whether to
// proceed or not. If errors are present, the ImportSpec will be missing, so
// the client is forced to give up or fix the problems and then try again.
//
//
// The client now calls ResourcePool.importVApp, passing the ImportSpec as a parameter. This will create
// the virtual machines and VirtualApp objects in VI and return locations
// to which the files of the entity can be uploaded. It also returns a lease that
// controls the duration of the lock taken on the newly created inventory objects. When
// all files have been uploaded, the client must release this lease.
//
//
// Export
// Creating the OVF descriptor is the last part of exporting an entity to OVF. At this
// point, the client has already downloaded all files for the entity, optionally
// compressing and/or chunking them (however, the client may do a "dry run" of creating
// the descriptor before downloading the files. See OvfManager.createDescriptor).
//
// In addition to the entity reference itself, information about the choices made on
// these files is passed to createDescriptor as a list of OvfFile instances.
//
//
// The client must inspect and act upon warnings and errors as previously described.
//
//
// No matter if the export succeeds or fails, the client is responsible for releasing the
// shared state lock taken on the entity (by VirtualMaching.exportVm or VirtualApp.exportVApp) during the export.
//
//
// Error handling
// All result types contain warning and error lists. Warnings do not cause processing to
// fail, but the caller (typically, the user of a GUI client) may choose to reject the
// result based on the warnings issued.
//
// Errors cause processing to abort by definition.
//
//
//
type OvfManager struct {
	*ManagedObject

	ovfExportOption []*OvfOptionInfo

	ovfImportOption []*OvfOptionInfo
}

// Returns an array of OvfOptionInfo object that specifies what options the server
// support for exporting an OVF descriptor.
//
//
// Since vSphere API 5.1
// Required Privilege: System.View
func (mo *OvfManager) OvfExportOption() ([]*OvfOptionInfo, error) {
	t, err := mo.currentProperty("ovfExportOption")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*OvfOptionInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*OvfOptionInfo")
	}
	return v, nil
}

// Returns an array of OvfOptionInfo object that specifies what options the server
// support for modifing/relaxing the OVF import process.
//
//
// Since vSphere API 5.1
// Required Privilege: System.View
func (mo *OvfManager) OvfImportOption() ([]*OvfOptionInfo, error) {
	t, err := mo.currentProperty("ovfImportOption")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*OvfOptionInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*OvfOptionInfo")
	}
	return v, nil
}

//
// Create an OVF descriptor for the specified ManagedEntity, which may be a
// VirtualMachine or a VirtualApp.
//
// To create the complete OVF descriptor, the client must already have downloaded the
// files that are part of the entity, because information about these files
// (compression, chunking, filename etc.) is part of the descriptor.
//
//
// However, these downloads can be quite time-consuming, so if the descriptor for some
// reason cannot be generated, the client will want to know this before downloading
// the files.
//
//
// For this reason, the client may do an initial "dry run" with the ovfFiles
// parameter unset. Default filenames will then be used in the descriptor, and the
// client can examine any warnings and/or errors before downloading the files.
//
//
// After the final call to this method, client must release the lock on the entity
// given to it by VirtualMachine.exportVm or VirtualApp.exportVApp.
//
//
// Required Privileges
// System.View
//
func (mo *OvfManager) CreateDescriptor(
	_this *ManagedObjectReference, obj *ManagedEntity, cdp *OvfCreateDescriptorParams,
) (*OvfCreateDescriptorResult, error) {

	return nil, nil

}

//
// Validate the OVF descriptor against the hardware supported by the
// host system. If the validation succeeds, return a result containing:
//
//
// • An ImportSpec to use when importing the entity.
//
// • A list of items to upload (for example disk backing files, ISO images etc.)
//
//
//
//
// Required Privileges
// System.View
//
func (mo *OvfManager) CreateImportSpec(
	_this *ManagedObjectReference, ovfDescriptor string, resourcePool *ResourcePool, datastore *Datastore, cisp *OvfCreateImportSpecParams,
) (*OvfCreateImportSpecResult, error) {

	return nil, nil

}

//
// Parse the OVF descriptor and return as much information about it as possible
// without knowing the host on which it will be imported.
//
// Typically, this method is called once without a deploymentOption parameter to
// obtain the values for the default deployment option. Part of the result is the list
// of possible deployment options. To obtain the values for a particular deployment
// option, call this method again, specifying that option.
//
//
// Required Privileges
// System.View
//
func (mo *OvfManager) ParseDescriptor(
	_this *ManagedObjectReference, ovfDescriptor string, pdp *OvfParseDescriptorParams,
) (*OvfParseDescriptorResult, error) {

	return nil, nil

}

//
// Validate that the given OVF can be imported on the host.
//
// More specifically, this means whether or not the host supports the virtual hardware
// required by the OVF descriptor.
//
//
// Required Privileges
// System.View
//
func (mo *OvfManager) ValidateHost(
	_this *ManagedObjectReference, ovfDescriptor string, host *HostSystem, vhp *OvfValidateHostParams,
) (*OvfValidateHostResult, error) {

	return nil, nil

}

//
// A common super-class for basic OVF descriptor parameters
//
//
type OvfManagerCommonParams struct {
	*DynamicData

	// The key of the chosen deployment option. If empty, the default option is
	// chosen. The list of possible deployment options is returned in the result of
	// parseDescriptor.
	DeploymentOption string

	// An optional argument for modifing the OVF parsing. When the server parses an OVF
	// descriptor a set of options can be used to modify the parsing. The argument is a list
	// of keywords.
	//
	// To get a list of supported keywords see ovfImportOption. Unknown
	// options will be ignored by the server.
	//
	// Since vSphere API 5.1
	ImportOption []string

	// The locale-identifier to choose from the descriptor. If empty, the
	// default locale on the server is used.
	Locale string

	// An optional set of localization strings to be used. The server will use
	// these message strings to localize information in the result and in
	// error and warning messages.
	//
	// This argument allows a client to pass messages from external
	// string bundles. The client is responsible for selecting the right string
	// bundle (based on locale) and parsing the external string bundle. The
	// passed in key/value pairs are looked up before any messages
	// included in the OVF descriptor itself.
	MsgBundle []*KeyValue
}

type OvfMappedOsId struct {
	*OvfImport

	// The OS description specified in the OVF descriptor.
	OvfDescription string

	// The operating system id specified in the OVF descriptor.
	OvfId int32

	// The display name of the target OS
	TargetDescription string
}

//
// If the Ovf descriptor is missing an attribute this exception is thrown.
//
//
type OvfMissingAttribute struct {
	*OvfAttribute
}

//
// If the Ovf descriptor is missing an Element this exception is thrown.
//
//
type OvfMissingElement struct {
	*OvfElement
}

//
// If the Ovf descriptor element normal boundary is not met this exception is thrown.
//
//
type OvfMissingElementNormalBoundary struct {
	*OvfMissingElement

	// The missing bound
	Boundary string
}

type OvfMissingHardware struct {
	*OvfImport

	// Name of the missing hardware.
	Name string

	// OVF rasd resource type of the missing hardware.
	ResourceType int32
}

//
// The name and description of a network as specified by the OVF descriptor.
//
//
type OvfNetworkInfo struct {
	*DynamicData

	Description string

	Name string
}

//
// A NetworkMapping is a choice made by the caller about which VI network to use for a
// specific network in the OVF descriptor.
//
//
type OvfNetworkMapping struct {
	*DynamicData

	Name string

	Network *Network
}

//
// The network mapping provided for OVF Import
// is not supported by any hosts
//
//
type OvfNetworkMappingNotSupported struct {
	*OvfImport
}

//
// This fault is used if there is no network defined on host
//
//
type OvfNoHostNic struct {
	*OvfUnsupportedPackage
}

//
// If the hardware element (RASD) point to a parent controller where there is no
// space left.
//
//
type OvfNoSpaceOnController struct {
	*OvfUnsupportedElement

	// The parent reference
	Parent string
}

type OvfNoSupportedHardwareFamily struct {
	*OvfUnsupportedPackage

	// Version found that was not supported
	Version string
}

//
// Represents the OVF options the server support for import and export of
// OVFs
//
//
type OvfOptionInfo struct {
	*DynamicData

	// A description of the OVF option
	Description *LocalizableMessage

	// The name of the OVF option that is supported by the server
	Option string
}

type OvfParseDescriptorParams struct {
	*OvfManagerCommonParams
}

type OvfParseDescriptorResult struct {
	*DynamicData

	// The annotated OST for the OVF descriptor, generated by OVF
	// consumers. See OvfConsumer for details.
	//
	// Since vSphere API 5.0
	AnnotatedOst *OvfConsumerOstNode

	// The annotation info contained in the OVF
	Annotation string

	// The OVF Manager's best guess as to the total amount
	// of data that must be transferred to download the entity.
	//
	// This may be inaccurate due to disk compression etc.
	ApproximateDownloadSize int64

	// The OVF Manager's best guess as to the total amount of space required to deploy
	// the entity if using flat disks.
	ApproximateFlatDeploymentSize int64

	// The OVF Manager's best guess as to the total amount of space required to deploy
	// the entity using sparse disks.
	ApproximateSparseDeploymentSize int64

	// The key of the default deployment option. Empty only if there are no
	// deployment options.
	DefaultDeploymentOption string

	// The default name to use for the entity, if a product name is not
	// specified. This is the ID of the OVF top-level entity, or taken from a
	// ProductSection.
	DefaultEntityName string

	// The list of possible deployment options.
	DeploymentOption []*OvfDeploymentOption

	// A list of the child entities contained in this package
	// and their location in the vApp hierarchy. Each entry is a
	// (key,value) pair, where the key is the display name, and
	// the value is a unique path identifier for the entity in
	// the vApp. The path is constructed by appending the id
	// of each entity of the path down to the entity, separated
	// by slashes. For example, the path for a child of the root
	// entity with id = "vm1", would simply be "vm1". If the vm is
	// the child of a VirtualSystemCollection called "webTier", then
	// the path would be "webTier/vm".
	//
	// Since vSphere API 4.1
	EntityName []*KeyValue

	// Errors that happened during processing. Something
	// will be wrong with the result.
	//
	// For example, during export, devices could be
	// missing (in which case this array will contain one
	// or more instances of Unsupported-/UnknownDevice).
	Error []*LocalizedMethodFault

	// The list of all EULAs contained in the OVF
	Eula []string

	// The kind of IP allocation supported by the guest.
	//
	// See VAppIPAssignmentInfo.
	IpAllocationScheme []string

	// The IP protocols supported by the guest.
	//
	// See VAppIPAssignmentInfo.
	IpProtocols []string

	// The list of networks required by the OVF
	Network []*OvfNetworkInfo

	// The product info contained in the OVF
	ProductInfo *VAppProductInfo

	// Metadata about the properties contained in the OVF
	Property []*VAppPropertyInfo

	// True if the OVF contains a vApp (containing one or more vApps
	// and/or virtual machines), as opposed to a single virtual machine.
	VirtualApp bool

	// Non-fatal warnings from the processing.
	// The result will be valid, but the
	// user may choose to reject it based on these
	// warnings.
	Warning []*LocalizedMethodFault
}

//
// A base fault for property faults in the property section of the Ovf XML descriptor.
//
//
type OvfProperty struct {
	*OvfInvalidPackage

	// The type of the property
	Type string

	// The value of the property
	Value string
}

//
// VIM property type that can not be converted to OVF
//
//
type OvfPropertyExport struct {
	*OvfExport

	// VIM type
	Type string

	// VIM value
	Value string
}

//
// A class used indicate there was a property network error
//
//
type OvfPropertyNetwork struct {
	*OvfProperty
}

//
// VIM property type that refers to a network that
// does not exist in the package since no virtual machines
// are hooked up to it.
//
//
type OvfPropertyNetworkExport struct {
	*OvfExport

	// name of network
	Network string
}

//
// A class used to indicate there was a property qualifier error
//
//
type OvfPropertyQualifier struct {
	*OvfProperty

	// qualifiers
	Qualifier string
}

//
// Indicate that a property qualifier was duplicated.
//
//
type OvfPropertyQualifierDuplicate struct {
	*OvfProperty

	// qualifiers
	Qualifier string
}

//
// Indicate that the was qualifier was ignored
//
//
type OvfPropertyQualifierIgnored struct {
	*OvfProperty

	// qualifiers
	Qualifier string
}

//
// A class used to indicate there was a property type error
//
//
type OvfPropertyType struct {
	*OvfProperty
}

//
// A class used indicate there was a property value error
//
//
type OvfPropertyValue struct {
	*OvfProperty
}

// Deprecated.
// As of vSphere API 5.1.
//
//
// Maps source child entities to destination resource pools
// and resource settings. If a mapping is not specified,
// a child is copied as a direct child of the parent.
//
//
type OvfResourceMap struct {
	*DynamicData

	// A client can optionally specify a datastore location in the resource map to
	// override the default datastore passed into CreateImportSpec field.
	// This enables importing to different compute resources that do not have shared
	// datastores.
	// Required Privilege: Datastore.AllocateSpace
	Datastore *Datastore

	// The parent resource pool to use for the entity. This must specify a
	// resource pool that is not part of the vApp. If this is specified, a linked
	// child (as opposed to a direct child) is created for the vApp.
	Parent *ResourcePool

	// An optional resource configuration for the created entity. If
	// not specified, the resource configuration given in the OVF descriptor
	// is used.
	ResourceSpec *ResourceConfigSpec

	// Identifies a source VirtualSystem or VirtualSystemCollection in an OVF
	// descriptor. The source cannot be the root VirtualSystem or
	// VirtualSystemCollection of the OVF.
	// This is a path created by concatenating the OVF ids for each entity, e.g., "vm1",
	// "WebTier/vm2", etc.
	Source string
}

//
// A common base class to host all the OVF subsystems's system  faults.
//
// This is a class of fault that can be thrown because of
// some api changes, new hardware that are not supported by
// the host.
//
//
//
type OvfSystemFault struct {
	*OvfFault
}

//
// Unsupported element to export to XML
//
//
type OvfToXmlUnsupportedElement struct {
	*OvfSystemFault

	// The name of the xml element we could not write to the xml descriptor
	Name string
}

type OvfUnableToExportDisk struct {
	*OvfHardwareExport

	// disk name
	DiskName string
}

//
// Class used to indicate an unexpected element in the Ovf descriptor
//
//
type OvfUnexpectedElement struct {
	*OvfElement
}

type OvfUnknownDevice struct {
	*OvfSystemFault

	// The unknown device
	Device *VirtualDevice

	// The name of the Virtual Machine containing the unkown device
	VmName string
}

type OvfUnknownDeviceBacking struct {
	*OvfHardwareExport

	// The VirtualDevice BackingInfo that is not supported by OVF export.
	Backing *VirtualDeviceBackingInfo
}

type OvfUnknownEntity struct {
	*OvfSystemFault

	// line number where the unknown entity was found
	LineNumber int32
}

//
// If the Ovf descriptor have an unsupported attribute.
//
//
type OvfUnsupportedAttribute struct {
	*OvfUnsupportedPackage

	// The name of the unsupported attribute
	AttributeName string

	// The name of the element with the unsupported attribute
	ElementName string
}

//
// Used when an OVF descriptor attribute has an unsupported value.
//
//
type OvfUnsupportedAttributeValue struct {
	*OvfUnsupportedAttribute

	// Unsupported attribute value
	Value string
}

type OvfUnsupportedDeviceBackingInfo struct {
	*OvfSystemFault

	// The name of the VirtualDevice Backing Info not supported on the device.
	BackingName string

	// The device name
	DeviceName string

	// The element name
	ElementName string

	// The InstanceId on the hardware description
	InstanceId string
}

type OvfUnsupportedDeviceBackingOption struct {
	*OvfSystemFault

	// The name of the VirtualDevice Backing Option not supported on the device.
	BackingName string

	// The device name
	DeviceName string

	// The element name
	ElementName string

	// The InstanceId for the hardware element
	InstanceId string
}

type OvfUnsupportedDeviceExport struct {
	*OvfHardwareExport
}

//
// Disk provisioning not supported
//
//
type OvfUnsupportedDiskProvisioning struct {
	*OvfImport

	// The disk provisioning that was not supported.
	DiskProvisioning string

	// Disk modes supported by the host.
	SupportedDiskProvisioning string
}

//
// If the Ovf descriptor has an unsupported element where it is not allowed.
//
//
type OvfUnsupportedElement struct {
	*OvfUnsupportedPackage

	// The name of the unsupported element
	Name string
}

//
// If the Ovf descriptor has an unsupported value of a element in the
// OVF descriptor.
//
//
type OvfUnsupportedElementValue struct {
	*OvfUnsupportedElement

	// The unsupported element value
	Value string
}

//
// A common base class to host all the Ovf Lib Unsupported Package faults
//
//
type OvfUnsupportedPackage struct {
	*OvfFault

	// OVF descriptor linenumber
	LineNumber int32
}

//
// If the Ovf descriptor has an unsupported required section.
//
//
type OvfUnsupportedSection struct {
	*OvfUnsupportedElement

	// The info of the unsupported section
	Info string
}

type OvfUnsupportedSubType struct {
	*OvfUnsupportedPackage

	// The device subtype that is unsupported
	DeviceSubType string

	// The device type
	DeviceType int32

	// The name of the element with the unsupported type
	ElementName string

	// The OVF RASD InstanceId for the hardware description
	InstanceId string
}

type OvfUnsupportedType struct {
	*OvfUnsupportedPackage

	// The device type that is unsupported
	DeviceType int32

	// The OVF RASD InstanceId for the hardware description
	InstanceId string

	// The name of the element with the unsupported type
	Name string
}

type OvfValidateHostParams struct {
	*OvfManagerCommonParams
}

type OvfValidateHostResult struct {
	*DynamicData

	// The total amount of data that must be transferred to download the entity.
	//
	// This may be inaccurate due to disk compression etc.
	DownloadSize int64

	// Errors that happened during validation. The presence of faults in this list
	// indicates that the validation failed.
	Error []*LocalizedMethodFault

	// The total amount of space required to deploy the entity if using flat disks.
	FlatDeploymentSize int64

	// The total amount of space required to deploy the entity using sparse disks,
	// if known.
	SparseDeploymentSize int64

	// An array of the disk provisioning type supported by the target host system.
	//
	// Since vSphere API 4.1
	SupportedDiskProvisioning []string

	// Non-fatal warnings from the validation.
	Warning []*LocalizedMethodFault
}

//
// If the Ovf descriptor has an element that is not accepted, this exception is thrown.
//
//
type OvfWrongElement struct {
	*OvfElement
}

//
// A OvfWrongNamespace exception is throw if the ovf descriptor has a
// Namespace error as defined in the Ovf spec
//
//
type OvfWrongNamespace struct {
	*OvfInvalidPackage

	// The name of the invalid namespace
	NamespaceName string
}

//
// Class used to specify if the Ovf XML descriptor could not be parsed
//
//
type OvfXmlFormat struct {
	*OvfInvalidPackage

	// Description of the XML parser error
	//
	// High level error description
	Description string
}

//
// ParaVirtualSCSIController is the data object that represents
// a paravirtualized SCSI controller.
//
//
type ParaVirtualSCSIController struct {
	*VirtualSCSIController
}

//
// ParaVirtualSCSIControllerOption is the data object that contains
// the options for a a paravirtualized SCSI controller.
//
//
type ParaVirtualSCSIControllerOption struct {
	*VirtualSCSIControllerOption
}

//
// DataObject which represents a Password field.
//
// Password is functionally equivalent to String.
//
//
type PasswordField struct {
	*DynamicData

	Value string
}

//
// This fault is thrown if a patch install fails because the patch
// is already installed on the host.
//
//
type PatchAlreadyInstalled struct {
	*PatchNotApplicable
}

//
// This fault is thrown if a patch install fails
// because the binaries associated with the patch are not found.
//
//
type PatchBinariesNotFound struct {
	*VimFault

	// The binaries that are not found.
	Binary []string

	// The patch whose associated binaries are not found.
	PatchID string
}

//
// This is a general-purpose fault indicating that some error has
// occurred regarding a patch install.  Data about the fault is
// available and is presented as a platform specific string.
//
//
type PatchInstallFailed struct {
	*PlatformConfigFault

	// Whether or not the patch install has been rolled back. If not,
	// a manual rollback is required.
	RolledBack bool
}

//
// This fault is thrown if a patch operation fails because the signature of
// the patch did not check out.
//
//
type PatchIntegrityError struct {
	*PlatformConfigFault
}

//
// This fault is thrown if the metadata associated with a patch is
// corrupted or unreadable when a patch query or install is attempted.
//
//
type PatchMetadataCorrupted struct {
	*PatchMetadataInvalid
}

//
// This fault is thrown if a patch query or
// installation operation fails because of a problem with the metadata
// associated with the patch. Typically, a subclass of this exception is
// thrown, indicating a problem such as the metadata is not found or the
// metadata is corrupted.
//
//
type PatchMetadataInvalid struct {
	*VimFault

	// The metadata file that is not available or corrupted.
	MetaData []string

	// The patch ID whose associated metadata is invalid.
	PatchID string
}

//
// This fault is thrown if the metadata associated with a patch is not
// found when a patch query or install is attempted.
//
//
type PatchMetadataNotFound struct {
	*PatchMetadataInvalid
}

//
// This fault is thrown if a patch install fails because the patch
// requires other patches or libraries that are not installed on the host.
//
//
type PatchMissingDependencies struct {
	*PatchNotApplicable

	// The names of required libraries or RPMs.
	PrerequisiteLib []string

	// The ID of required patches.
	PrerequisitePatch []string
}

//
// This fault is thrown if a patch install fails because the patch is not
// applicable to the host. Typically, a subclass of this exception is
// thrown, indicating a problem such as the patch is superseded, already
// installed, or has dependencies missing, and so on.
//
//
type PatchNotApplicable struct {
	*VimFault

	// The ID of the patch that is not applicable to the host.
	PatchID string
}

//
// This fault is thrown if a patch install fails because the patch is
// superseded by patches already installed.
//
//
type PatchSuperseded struct {
	*PatchNotApplicable

	// The patches that supersede this patch.
	Supersede []string
}

//
// PerfCompositeMetric includes an optional
// aggregated entity performance statistics and a list of composite entities
// performance statistics. The aggregated entity statistics are optional
// because some entities, such as folders, do not have their own
// statistics.
//
//
type PerfCompositeMetric struct {
	*DynamicData

	// A list of metrics of
	// performance providers that comprise the aggregated entity. For
	// example, Host is an aggregated entity for virtual machines and
	// virtual machine Folders. ResourcePools are aggregate entities for
	// virtual machines. Host, Folder, and Cluster are aggregate entities
	// for hosts in the cluster or folder.
	ChildEntity []*PerfEntityMetricBase

	// The aggregated entity performance metrics. If it exists, the PerfSampleInfo list of the aggregate entity is a
	// complete list of PerfSampleInfo that could
	// be contained in PerfSampleInfo lists of
	// child entities.
	Entity *PerfEntityMetricBase
}

//
// This data object type contains metadata for a performance counter. See
// PerformanceManager for definitions of available counters.
//
//
type PerfCounterInfo struct {
	*DynamicData

	// Deprecated.
	// As of VI API 2.5, this property is not used.
	//
	//
	// The counter IDs associated with the same performance counter name for
	// the same device type. For example, the rollup types for CPU Usage for
	// a host are average, minimum, and maximum. Therefore, their counter
	// IDs are associated.
	AssociatedCounterId []int32

	// The group of the performance counter with its label and summary
	// details. Counter groups include "cpu," "mem," "net," "disk," "system,"
	// "rescpu," and "clusterServices," for example.
	GroupInfo *ElementDescription

	// A system-generated number that uniquely identifies the counter in the
	// context of the system. The performance counter ID.
	Key int32

	// Minimum level at which metrics of this type will be collected by
	// VirtualCenter Server. The value for this property for any performance
	// counter is a number from 1 to 4. The higher the setting, the more data
	// is collected by VirtualCenter Server. The default setting for
	// VirtualCenter Server is 1, which collects the minimal amount of
	// performance data that is typically useful to administrators and
	// developers alike. The specific level of each counter is documented in
	// the respective counter-documentation pages, by group. See PerformanceManager for links to the counter group pages.
	//
	// Since VI API 2.5
	Level int32

	// The name of the counter with label and summary details. For example,
	// the counter with name "usage" for the "cpu" group of performance
	// counters.
	NameInfo *ElementDescription

	// Minimum level at which the per device metrics of this type will be
	// collected by vCenter Server. The value for this property for any
	// performance counter is a number from 1 to 4. By default all per device
	// metrics are calculated at level 3 or more. If a certain per device
	// counter is collected at a certain level, the aggregate metric is also
	// calculated at that level, i.e., perDeviceLevel is greater than or
	// equal to level.
	//
	// Since vSphere API 4.1
	PerDeviceLevel int32

	// The counter type. Valid values include average, maximum, minimum,
	// latest, summation, or none. This determines the type of statistical
	// values that are returned for the counter. None means that the counter
	// is never rolled up.
	RollupType *enum.PerfSummaryType

	// Statistics type for the counter. Valid values include absolute, delta,
	// or rate.
	StatsType *enum.PerfStatsType

	// The unit for the values of the performance counter with its label and
	// summary details. See PerformanceManagerUnit for a
	// description of the valid values.
	UnitInfo *ElementDescription
}

//
// This data object type stores values and metadata for metrics associated
// with a specific entity, in 'normal'  format.
//
//
type PerfEntityMetric struct {
	*PerfEntityMetricBase

	// A list of objects containing information (an interval and a timestamp)
	// about the samples collected.
	SampleInfo []*PerfSampleInfo

	// A list of values that corresponds to the samples collected.
	Value []*PerfMetricSeries
}

//
// Base type for the various PerfEntityMetric
// encodings.
//
//
type PerfEntityMetricBase struct {
	*DynamicData

	// Performance provider ID.
	Entity *ManagedObjectReference
}

//
// This data object type stores metric values for a specific entity in CSV
// format.
//
//
type PerfEntityMetricCSV struct {
	*PerfEntityMetricBase

	// The PerfSampleInfo encoded in the following CSV
	// format: [interval1], [date1], [interval2], [date2], and so on.
	SampleInfoCSV string

	// Metric values corresponding to the samples collected in this list.
	Value []*PerfMetricSeriesCSV
}

//
// The format in which performance counter data is returned.
//
//
type PerfFormat struct {
}

//
// This data object type contains metadata about a performance interval.
//
//
//
// •  For VirtualCenter Server systems, instances of this data object are
// referred to as “historical intervals” because they control
// how data collected from the ESX systems will be aggregated and stored
// in the database.
//
//
// •  For ESX system, this data object is typically referred to simply as the
// “interval” or “performance interval” because ESX
// does not aggregate statistical data.
//
//
//
//
//
// For ESX systems, a single instance of this data object exists. It cannot
// be modified. It has these properties:
//
//
//
//
// key
// samplingPeriod
// length
// name
// level
// enabled
//
//
//
// 1
// 300
// 129600
// PastDay
// null
// true
//
//
//
//
//
// VirtualCenter Server system provides four instances of this data object
// by default, that apply globally to all system entities.
//
//
// Example Collection LevelsVirtualCenter Server
// uses the specifications configured in its historical intervals to collect metrics
// from the ESX systems that it manages. The quantity of data collected depends on
// the level settings for the server, and the level associated with a specific counter.
// Both factors may change from one version of the products to the next. In general,
// the lower the number, the smaller the amount of data collected. For VirtualCenter
// Server 2.5, for example, the levels 1 through 4 collected data as follows:
//
//
// •  Basic counters defined with "average" rollup type for CPU, Memory,
// Disk, and Network; plus counters for System Uptime, System Heartbeat,
// and DRS (Distributed Resource Scheduler, tracked in the
// "clusterServices" group). Does not include counters for devices.
//
//
// •  Counters defined with "average," "summation," and "latest" rollup types for CPU,
// Memory, Disk, and Network; plus counters for System Uptime, System
// Heartbeat, and DRS (clusterServices). Does not include counters for
// devices.
//
//
// •  Counters defined with "average," "summmation," and "latest" rollup types for CPU,
// Memory, Disk, Network, and all devices; plus counters for System
// Uptime, System Heartbeat, and DRS (clusterServices).
//
//
// •  All counters defined for all entities and devices, for every rollup type, including
// “minimum” and “maximum.”
//
//
//
//
// Default properties for the four built-in historical intervals
// include:
//
//
//
//
// key
// samplingPeriod
// length
// name
// level
// enabled
//
//
//
// 1
// 300
// 86400
// Past day
// 1
// true
//
//
//
// 2
// 1800
// 604800
// Past week
// 1
// true
//
//
//
// 3
// 7200
// 2592000
// Past month
// 1
// true
//
//
//
// 4
// 66400
// 31536000
// Past year
// 1
// true
//
//
//
//
//
// All values are in seconds. The default setting for vCenter Server is
// level 1, which retains sampled statistical data as follows:
//
//
// •  5-minute samples for the past day
//
// •  30-minute samples for the past week
//
// •  2-hour samples for the past month
//
// •  1-day samples for the past year
//
//
//
//
// Data older than a year is purged from the vCenter Server database.
//
//
// Prior to version 2.5 of the API, this data object could be used in
// conjunction with the CreatePerfInterval
// operation, to define new, custom historical intervals. That operation has
// been deprecated: Adding and deleting objects of this type is no longer
// supported. However, the default historical intervals can be enabled or
// disabled, and can be modified within certain limits (with the UpdatePerfInterval operation).
//
//
//
type PerfInterval struct {
	*DynamicData

	// Indicates whether the interval is enabled (true) or disabled (false).
	// Disabling a historical interval prevents vCenter Server from collecting
	// metrics for that interval and all higher (longer) intervals.
	//
	// For example, disabling the "Past Month" interval disables both "Past
	// Month" and "Past Year" intervals. The system will aggregate and retain
	// performance data using the "Past Day" and "Past Week" intervals only.
	//
	// Since VI API 2.5
	Enabled bool

	// A unique identifier for the interval.
	//
	// Since VI API 2.5
	Key int32

	// Number of seconds that the statistics corresponding to this interval are
	// kept on the system.
	Length int32

	// Statistics collection level for this historical interval. vCenter Server
	// will aggregate only those statistics that match the value of this
	// property for this historical interval. For ESX, the value of this
	// property is null. For vCenter Server, the value will be a number from 1
	// to 4.
	//
	// Since VI API 2.5
	Level int32

	// The name of the historical interval. A localized string that provides a
	// name for the interval. Names include:
	// "Past Day"
	// "Past Week"
	// "Past Month"
	// "Past Year"
	//
	// The name is not meaningful in terms of system behavior. That is, the
	// interval named “Past Week” works as it does because of its
	// length, level, and so on, not because of the value of this string.
	Name string

	// Number of seconds that data is sampled for this interval. The real-time
	// samplingPeriod is 20 seconds.
	SamplingPeriod int32
}

//
// This data object type contains information that associates a performance
// counter with a performance metric. When constructing this data object for
// the metricId property of the PerfQuerySpec to submit to one of the PerformanceManager query operations, the instance property
// supports these special characters:
//
//
// •  An asterisk (*) to specify all instances of the metric for the
// specified counterId
//
//
// •  Double-quotes ("") to specify aggregated statistics
//
//
//
//
//
//
type PerfMetricId struct {
	*DynamicData

	// The ID of the counter for
	// the metric.
	CounterId int32

	// An identifier that is derived from configuration names for the device
	// associated with the metric. It identifies the instance of the metric
	// with its source. This property may be empty.
	//
	// For memory and aggregated statistics, this property is empty.
	//
	// For host and virtual machine devices, this property contains the
	// name of the device, such as the name of the host-bus adapter or
	// the name of the virtual Ethernet adapter. For example,
	// “mpx.vmhba33:C0:T0:L0” or
	// “vmnic0:”
	//
	// For a CPU, this property identifies the numeric position within
	// the CPU core, such as 0, 1, 2, 3.
	//
	// For a virtual disk, this property identifies the file type:
	//
	// DISKFILE, for virtual machine base-disk files
	// SWAPFILE, for virtual machine swap files
	// DELTAFILE, for virtual machine snapshot overhead files
	// OTHERFILE, for all other files of a virtual machine
	Instance string
}

//
// This data object type describes integer metric values. The size of the
// array must match the size of sampleInfo property in the PerfEntityMetric that contains this series.
//
//
type PerfMetricIntSeries struct {
	*PerfMetricSeries

	// An array of 64-bit integer values. The size of the array matches the
	// size as the PerfSampleInfo, because the values
	// can only be interpreted in the context of the sample that generated
	// the value.
	Value []int64
}

//
// This is a generic data object type that stores values for a specific
// performance metric. Useful data objects that store actual metric values
// extend this data object (see PerfMetricIntSeries).
//
//
type PerfMetricSeries struct {
	*DynamicData

	// An identifier for the performance metric.
	Id *PerfMetricId
}

//
// This data object type represents a PerfMetricSeries encoded in CSV format.
//
//
type PerfMetricSeriesCSV struct {
	*PerfMetricSeries

	// An array of sample values in CSV format
	Value string
}

//
// This data object type contains information about a performance provider,
// the type of statistics it generates, and the refreshRate for
// statistics generation. A performance provider is any managed object that generates real-time or
// historical statistics (or both—the currentSupported and
// summarySupported properties are not mutually exclusive).
//
//
type PerfProviderSummary struct {
	*DynamicData

	// True if this entity supports real-time (current) statistics; false if
	// it does not. If this property is true for an entity, a client application
	// can set the intervalId of the
	// PerfQuerySpec (passed to the
	// QueryPerf operation) to the refreshRate to obtain the maximum information possible for the
	// entity.
	CurrentSupported bool

	// Reference to the performance provider, the managed object that provides real-time or
	// historical metrics. The managed objects include but are not limited to
	// managed entities, such as host systems, virtual machines, and resource pools.
	Entity *ManagedObjectReference

	// Number of seconds between the generation of each counter. This value
	// applies only to entities that support real-time (current)
	// statistics.
	RefreshRate int32

	// True if this entity supports historical (aggregated) statistics; false
	// if it does not. When this property is true for an entity, a client
	// application can set the intervalId of QueryPerf to one of the historical intervals to obtain historical statistics for this
	// entity.
	SummarySupported bool
}

//
// This data object specifies the query parameters, including the managed
// object reference to the target entity for statistics retrieval.
//
//
// •  If the optional intervalId is omitted, the metrics are
// returned in their originally sampled interval.
//
//
// •  When an intervalId is specified, the server tries to
// summarize the information for the specified intervalId.
// However, if that interval does not exist or has no data, the
// server summarizes the information using the best interval
// available.
//
//
//
//
//
//
// •  If the range between startTime and endTime crosses
// multiple sample interval periods, the result contains data from the
// longest interval in the period.
//
//
//
//
//
//
type PerfQuerySpec struct {
	*DynamicData

	// The time up to which statistics are retrieved. Corresponds to server
	// time. When endTime is omitted, the returned result includes up to the
	// most recent metric value. When an endTime is specified, the returned
	// samples include the sample at endTime.
	EndTime time.Time

	// The managed object whose performance statistics are being queried.
	Entity *ManagedObjectReference

	// The format to be used while returning the statistics.See PerfFormat
	Format string

	// The interval (samplingPeriod), in seconds,
	// for the performance statistics. For aggregated information, use
	// one of the historical intervals for this property. See PerfInterval for more information.
	//
	// To obtain the greatest detail, use the provider’s refreshRate for this
	// property.
	IntervalId int32

	// Limits the number of samples returned. Defaults to the most recent
	// sample (or samples), unless a time range is specified. Use this
	// property only in conjunction with the intervalId to obtain
	// real-time statistics (set the intervalId to the refreshRate. This property is
	// ignored for historical statistics, and is not valid for the QueryPerfComposite operation.
	MaxSample int32

	// The performance metrics to be retrieved. This property is required for
	// the QueryPerfComposite operation.
	MetricId []*PerfMetricId

	// The server time from which to obtain counters. If not specified,
	// defaults to the first available counter. When a startTime is
	// specified, the returned samples do not include the sample at
	// startTime.
	StartTime time.Time
}

//
// This data object type describes information contained in a sample
// collection, its timestamp, and sampling interval.
//
//
type PerfSampleInfo struct {
	*DynamicData

	// The interval in seconds for which performance statistics were
	// collected. This can be the refreshRate of the managed object for which
	// this statistics was collected or one of the intervals for historical
	// statistics configured in the system. See UpdatePerfInterval for more information about the intervals
	// configured in the system.
	Interval int32

	// The time at which the sample was collected.
	Timestamp time.Time
}

//
// Indicates the type of statistical measurement that a counter’s
// value represents. Valid types are “absolute”,
// “delta”, or “rate”.
//
//
type PerfStatsType struct {
}

//
// Indicates how multiple samples of a specific counter type are
// transformed into a single statistical value.
//
//
type PerfSummaryType struct {
}

//
// Static strings for performance metrics.
//
//
type PerformanceDescription struct {
	*DynamicData

	// Identifies the type of
	// the counter.
	CounterType []*ElementDescription

	// Identifies the type
	// of statistic.
	StatsType []*ElementDescription
}

//
// This managed object type provides the service interface for obtaining
// statistical data about various aspects of system performance, as generated
// and maintained by the system's performance providers. A "performance
// provider" (PerfProviderSummary) is any managed object
// that generates utilization or other performance metrics. Performance
// providers include managed entities, such as hosts, virtual machines, compute resources, resource
// pools, datastores, and networks.
// Performance providers also include physical or virtual devices associated
// with these objects, such as virtual host-bus adapters and network-interface
// controllers (NICs)
//
// Performance Counters  Each
// performance provider—the instrumented device or entity—has its own
// set of counters that provides
// metadata about its available metrics. Each counter has a unique key, referred to as the counterId. The
// actual performance metrics generated at runtime are identified by this
// counterId. Counters are organized by
// groups of finite system
// resources, such as memory, CPU, disk, and
// so on. The links in this list contain documentation for performance
// counters, by group. Each
// page contains a table that includes data extracted from instances of the
// PerfCounterInfo data object, including the counter
// name, its Label, Unit, StatsType, RollupType, and Level:
//
//
//
// •  Cluster Services
//
// •  CPU
//
// •  Host-Based Replication
//
// •  Management Agent
//
// •  Memory
//
// •  Network
//
// •  Power
//
// •  Resource Scheduler
//
// •  Storage Capacity:
//
// •  Datastore / Virtual
// Machine
//
//
//
//
// •  Storage I/O:
//
// •  Datastore
//
// •  Disk
//
// •  Virtual Disk
//
// •  Storage Adapter
//
// •  Storage Path
//
//
//
//
// • System
//
// • vCenter Resource
//
// • Virtual Machine Operations
//
//
//
//
// Other performance-counter groups, in addition to those listed here,
// exist on the system. However, only the counter groups listed are considered
// of possible interest to third-party developers.
//
//
// Obtaining Metadata and Metrics This interface provides these
// query operations:
//
//
//
// •  QueryPerfProviderSummary, for obtaining metatdata about performance providers
//
//
// •  QueryPerfCounter and QueryPerfCounterByLevel for obtaining
// metadata about supported counters.
//
//
// •  QueryPerf, QueryAvailablePerfMetric, and QueryPerfComposite for obtaining statistics for one or more
// entities:
//
//
// •  Use QueryPerf to obtain metrics for multiple entities in a
// single call.
//
//
// •  Use QueryPerfComposite to obtain statistics for a single
// entity with its descendent objects—statistics for a host and all its virtual
// machines, for example.
//
//
//
//
//
//
//
//
//
// Product and Version Specifics Some differences between ESX
// and vCenter Server implementations of this interface include:
//
//
//
// •  For ESX systems, this interface provides access to real-time data, and
// to real-time data that has been rolled up into "PastDay" statistics (if
// applicable for the specific counter).
//
//
// •  For vCenter Server systems, this interface provides access to real-time
// and historical data. vCenter Server collects statistics on a regular
// basis from all ESX systems that it manages, and aggregates the results
// based on the level settings for the server.
//
//
// •  Default sampling interval is product- and version-specific:
//
//
// •  ESX 3.x (and subsequent) systems: 20 second interval
//
//
// •  ESX 2.x systems: 60 second interval
//
//
//
//
//
//
// •  VirtualCenter Server 2.5 (and subsequent vCenter Server) systems
// initially collect statistics data 10 minutes after system startup, and
// then hourly thereafter.
//
//
//
//
//
// See the Programming Guide for more information about using PerformanceManager.
//
//
//
type PerformanceManager struct {
	*ManagedObject

	description *PerformanceDescription

	historicalInterval []*PerfInterval

	perfCounter []*PerfCounterInfo
}

// The static description strings.
// Required Privilege: System.View
func (mo *PerformanceManager) Description() (*PerformanceDescription, error) {
	t, err := mo.currentProperty("description")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*PerformanceDescription)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *PerformanceDescription")
	}
	return v, nil
}

// A list of intervals configured on the
// system.
// Required Privilege: System.View
func (mo *PerformanceManager) HistoricalInterval() ([]*PerfInterval, error) {
	t, err := mo.currentProperty("historicalInterval")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*PerfInterval)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*PerfInterval")
	}
	return v, nil
}

// A list of all supported performance counters in the system.
// Required Privilege: System.View
func (mo *PerformanceManager) PerfCounter() ([]*PerfCounterInfo, error) {
	t, err := mo.currentProperty("perfCounter")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*PerfCounterInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*PerfCounterInfo")
	}
	return v, nil
}

// Deprecated.
// As of API 2.5, use UpdatePerfInterval. The
// default historical intervals can be modified, but they cannot be created.
//
//
// Adds a new historical interval. Sampling period for new interval must be
// a multiple of an existing interval; must comprise a longer period of
// time; and must be uniquely named.
//
// Required Privileges
// Performance.ModifyIntervals
//
func (mo *PerformanceManager) CreatePerfInterval(
	_this *ManagedObjectReference, intervalId *PerfInterval,
) error {

	return nil

}

//
// Retrieves all performance counters for the specified managed object generated during a specified
// period of time. The time period can be specified using beginTime,
// endTime, or by interval ID.
//
// Required Privileges
// System.Read
//
func (mo *PerformanceManager) QueryAvailablePerfMetric(
	_this *ManagedObjectReference, entity *ManagedObjectReference, beginTime time.Time, endTime time.Time, intervalId int32,
) ([]*PerfMetricId, error) {

	return nil, nil

}

//
// Retrieves the performance metrics for the specified entity (or entities)
// based on the properties specified in the PerfQuerySpec data object.
//
// Query Performance for VirtualCenter Server
//
//
// Required Privileges
// System.View
//
func (mo *PerformanceManager) QueryPerf(
	_this *ManagedObjectReference, querySpec []*PerfQuerySpec,
) ([]*PerfEntityMetricBase, error) {

	return nil, nil

}

//
// Retrieves a PerfCompositeMetric data object
// that comprises statistics for the specified entity and its children
// entities. Only metrics for the first level of descendents are included in
// the PerfCompositeMetric object.
//
// Use this operation to obtain statistics for a host and its associated virtual machines, for
// example.
//
//
// Requires system.read privilege for every virtual machine on
// the target host, or the query fails with the “NoPermission”
// fault. Suported for HostSystem managed entities only.
//
//
// Required Privileges
// System.View
//
func (mo *PerformanceManager) QueryPerfComposite(
	_this *ManagedObjectReference, querySpec *PerfQuerySpec,
) (*PerfCompositeMetric, error) {

	return nil, nil

}

//
// Retrieves counter information for the specified list of counter IDs.
//
// Required Privileges
// System.View
//
func (mo *PerformanceManager) QueryPerfCounter(
	_this *ManagedObjectReference, counterId []int32,
) ([]*PerfCounterInfo, error) {

	return nil, nil

}

//
// Retrieves the set of counters that are available at a specified
// collection level. The collection level
// determines the statistics that get stored in VirtualCenter. See PerfInterval for more information about VirtualCenter Server
// historical statistics collection.
//
// Required Privileges
// System.View
// Since
// VI API 2.5
//
func (mo *PerformanceManager) QueryPerfCounterByLevel(
	_this *ManagedObjectReference, level int32,
) ([]*PerfCounterInfo, error) {

	return nil, nil

}

//
// Retrieves the PerfProviderSummary data object that
// defines the capabilities of the specified managed object with respect to
// statistics, such as whether it supports current or summary
// statistics.
//
// Required Privileges
// System.Read
//
func (mo *PerformanceManager) QueryPerfProviderSummary(
	_this *ManagedObjectReference, entity *ManagedObjectReference,
) (*PerfProviderSummary, error) {

	return nil, nil

}

// Deprecated.
// As of API 2.5, use UpdatePerfInterval.
// Historical intervals cannot be removed.
//
//
// Removes an interval from the list.
//
// Required Privileges
// Performance.ModifyIntervals
//
func (mo *PerformanceManager) RemovePerfInterval(
	_this *ManagedObjectReference, samplePeriod int32,
) error {

	return nil

}

//
// Restores a set of performance counters to the default level of data
// collection. See the performance counter
// tables for the default collection level for individual counters.
//
// Required Privileges
// Performance.ModifyIntervals
// Since
// vSphere API 5.0
//
func (mo *PerformanceManager) ResetCounterLevelMapping(
	_this *ManagedObjectReference, counters []int32,
) error {

	return nil

}

//
// Changes the level of data collection for a set of performance counters.
// See the performance counter tables
// for the default collection level for individual counters.
//
// Important:
//
//
// Consider the performance and storage consequences of using this
// method. You may cause a significant increase in data collection and
// storage, along with a corresponding decrease in performance. vCenter
// Server performance and database storage requirements depend on the
// collection levels defined for the performance intervals
// (PerformanceManager.historicalInterval)
// and the collection levels specified for individual performance counters
// (PerfCounterInfo.level).
//
//
// Performance Counter Data Collection
//
//
// vSphere defines four levels of data collection for performance
// counters. Each performance counter specifies a level for collection. The
// historical performance intervals (PerformanceManager.historicalInterval) define the sampling period
// and length for a particular collection level.
//
//
// The amount of data collected for a performance counter depends
// on the performance interval and on the type of entity for which
// the counter is defined. For example, a datastore counter such as
// datastoreIops (the aggregate number of IO operations on the datastore)
// will generate a data set that corresponds to the number of datastores
// on a host. If a vCenter Server manages a large number of hosts
// with a large number of datastores, the Server will collect
// a large amount of data.
//
//
// There are other counters for which the vCenter Server collects
// a relatively smaller amount of data. For example, memory counters
// are collected as a single counter per virtual machine and a single
// counter per host.
//
//
// Performance Counter Data Storage
//
//
// The performance interval collection level defines the set of counters for
// which the vCenter Server stores performance data. The Server will store
// data for counters at the specified level and for counters at all lower
// levels.
//
//
// By default, all the performance intervals specify collection level
// one. Using these defaults, the vCenter Server stores performance counter
// data in the vCenter database for all counters that specify collection
// level one. It does not store data for counters that specify collection
// levels two through four.
//
//
// Performance Manager Method Interaction
//
//
// You can use the UpdateCounterLevelMapping method to change the
// collection level for individual counters. You can also use the UpdatePerfInterval method to change the
// collection level for the system-defined performance intervals. These
// methods can cause a significant increase in the amount of data collected
// and stored in the vCenter database.
//
//
// You may cause a significant increase in data collection and storage
// along with a corresponding decrease in performance under the following
// conditions:
//
//
//
// •  By default the system-defined performance intervals use collection
// level one, storing data for all counters that specify collection
// level one. If you use the UpdateCounterLevelMapping method to change
// the collection level of performance counters to level one, you will
// increase the amount of stored performance data.
//
//
// •  If you use the UpdatePerfInterval method to increase
// the collection level for the system-defined performance intervals,
// you will increase the amount of stored performance data.
//
//
//
//
//
// To restore counter levels to default settings use the ResetCounterLevelMapping method.
//
//
// Required Privileges
// Performance.ModifyIntervals
// Since
// vSphere API 5.0
//
func (mo *PerformanceManager) UpdateCounterLevelMapping(
	_this *ManagedObjectReference, counterLevelMap []*PerformanceManagerCounterLevelMapping,
) error {

	return nil

}

//
// Modifies VirtualCenter Server's built-in historical intervals, within certain limits.
//
// Supported Modifications
//
//
//
//
// key
// samplingPeriod
// length
// name
// level [1]
// enabled [2]
//
//
//
// 1
// 300 [3]
// 86400 [4]
// Past day
// 1
// true
//
//
//
// 2
// 1800
// 604800
// Past week
// 1
// true
//
//
//
// 3
// 7200
// 2592000
// Past month
// 1
// true
//
//
//
// 4
// 66400
// 31536000 [5]
// Past year
// 1
// true
//
//
//
//
//
//
//
// [1]  The collection level for the historical intervals can be changed. However,
// the level specified for a lower-numbered interval cannot be smaller
// than that of a larger interval.
//
// [2]  An interval can be disabled. By default, all four
// intervals are enabled. Disabling an interval disables all higher
// intervals. For example, disabling interval 3 (“Past month”)
// also disables interval 4 (“Past year”).
//
// [3]  Can reduce this interval’s samplingPeriod from 5 minutes to 1, 2, or 3
// minutes.
//
// [4]  Can increase this interval’s length from 1 day to 2 or 3 days.
//
// [5]  Can increase interval’s length from 1 year to 2 or 3 years.
//
//
// See PerfInterval for information about the four default
// intervals for VirtualCenter Server.
//
//
// Required Privileges
// Performance.ModifyIntervals
//
func (mo *PerformanceManager) UpdatePerfInterval(
	_this *ManagedObjectReference, interval *PerfInterval,
) error {

	return nil

}

//
// PerformanceManagerCounterLevelMapping class captures the counter
// and level mapping. Any counter has two aspects: aggregate value or the
// per-device value. For example, cpu.usage.average on a host is an
// aggregate counter and cpu.usage.average on pcpus in a host is a
// per-device counters. There is a need to be able to specify different
// levels for the two versions. Currently, all per-device stats are
// collected at level greater than or equal to 3.
//
// In order to be able to configure the level of collections for
// aggregate and per-device counters we have two optional level fields.
// PerformanceManagerCounterLevelMapping is used to update the
// levels for a counter.
//
//
//
type PerformanceManagerCounterLevelMapping struct {
	*DynamicData

	// Level for the aggregate counter. If not set then the value is not
	// changed when updateCounterLevelMapping is called.
	AggregateLevel int32

	// The counter Id
	CounterId int32

	// Level for the per device counter. If not set then the value is not
	// changed when updateCounterLevelMapping is called.
	PerDeviceLevel int32
}

//
// Indicates the unit of measure represented by a counter or statistical
// value.
//
//
type PerformanceManagerUnit struct {
}

//
// Data object to capture all information needed to
// describe a sample inventory.
//
//
type PerformanceStatisticsDescription struct {
	*DynamicData

	// Historic interval setting.
	// Default value is the same as the historic
	// interval settings of the current instance
	// of running VC.
	Intervals []*PerfInterval
}

//
// This data object type provides assignment of some role access to
// a principal on a specific entity.  A ManagedEntity is limited to
// one permission per principal.
//
//
type Permission struct {
	*DynamicData

	// Managed entity the permission is defined on.  Left unset
	// when calling setPermissions or resetPermissions, but present
	// for the results of permission queries.
	Entity *ManagedEntity

	// Whether principal refers to a user or a group.  True for
	// a group and false for a user.
	Group bool

	// User or group receiving access in the form of
	// "login" for local or "DOMAIN\login" for users in a Windows domain.
	Principal string

	// Whether or not this permission propagates down the hierarchy
	// to sub-entities.
	Propagate bool

	// Reference to the role providing the access.
	RoleId int32
}

//
// This event records the creation of a permission.
//
//
type PermissionAddedEvent struct {
	*PermissionEvent

	// Whether or not the permission applies to sub-entities.
	Propagate bool

	// The associated role.
	Role *RoleEventArgument
}

//
// This event records a permission operation.
//
//
type PermissionEvent struct {
	*AuthorizationEvent

	// The entity to which the permission applied.
	Entity *ManagedEntityEventArgument

	// Whether or not the principal was a group.
	Group bool

	// The user name or group to which the permission was granted.
	Principal string
}

//
// The PermissionProfile data object represents the profile
// for a permission rule. Use the policy list for
// access to configuration data for the permission profile. Use the
// property list for access to subprofiles, if any.
//
//
type PermissionProfile struct {
	*ApplyProfile

	Key string
}

//
// This event records the removal of a permission.
//
//
type PermissionRemovedEvent struct {
	*PermissionEvent
}

//
// This event records the update of a permission.
//
//
type PermissionUpdatedEvent struct {
	*PermissionEvent

	// Whether or not the permission applies to sub-entities.
	Propagate bool

	// The associated role.
	Role *RoleEventArgument
}

//
// The virtual machine is configured with a Raw Disk Mapping in physical compatibility mode.
// This mode is not supported on the host.
//
//
type PhysCompatRDMNotSupported struct {
	*RDMNotSupported
}

//
// This data object type describes the physical network adapter
// as seen by the primary operating system.
//
//
type PhysicalNic struct {
	*DynamicData

	// If set the flag indicates if the physical network adapter supports
	// autonegotiate.
	//
	// Since vSphere API 4.1
	AutoNegotiateSupported bool

	// The device name of the physical network adapter.
	Device string

	// The name of the driver.
	Driver string

	// The FCoE configuration of the physical network adapter.
	//
	// Since vSphere API 5.0
	FcoeConfiguration *FcoeConfig

	// The linkable identifier.
	Key string

	// The current link state of the physical network adapter.
	// If this object is not set, then the link is down.
	LinkSpeed *PhysicalNicLinkInfo

	// The media access control (MAC) address of the physical
	// network adapter.
	//
	// Since VI API 2.5
	Mac string

	// Device hash of the PCI device corresponding to this
	// physical network adapter.
	Pci string

	// Flag indicating whether the NIC allows resource pool based scheduling
	// for network I/O control.
	//
	// Since vSphere API 4.1
	ResourcePoolSchedulerAllowed bool

	// If resourcePoolSchedulerAllowed is false, this property
	// advertises the reason for disallowing resource scheduling on
	// this NIC. The reasons may be one of
	// PhysicalNicResourcePoolSchedulerDisallowedReason
	//
	// Since vSphere API 4.1
	ResourcePoolSchedulerDisallowedReason []string

	// The specification of the physical network adapter.
	Spec *PhysicalNicSpec

	// The valid combinations of speed and duplexity for this
	// physical network adapter.
	// The speed and the duplex settings usually must be configured
	// as a pair.  This array lists all the valid combinations available
	// for a physical network adapter.
	//
	// Autonegotiate is not listed as one of the combinations supported.
	// If is implicitly supported by the physical network adapter
	// unless autoNegotiateSupported is set to false.
	ValidLinkSpecification []*PhysicalNicLinkInfo

	// Flag indicating whether the NIC supports VMDirectPath Gen 2. Note that
	// this is only an indicator of the capabilities of this NIC, not of the
	// whole host.
	//
	// If the host software is not capable of VMDirectPath Gen 2,
	// this property will be unset, as the host cannot provide information on
	// the NIC capability.See vmDirectPathGen2Supported
	//
	// Since vSphere API 4.1
	VmDirectPathGen2Supported bool

	// If vmDirectPathGen2Supported is true, this property advertises
	// the VMDirectPath Gen 2 mode supported by this NIC (chosen from
	// PhysicalNicVmDirectPathGen2SupportedMode).
	// A mode may require that the associated vSphere Distributed Switch have
	// a particular ProductSpec in order for network passthrough to be possible.
	//
	// Since vSphere API 4.1
	VmDirectPathGen2SupportedMode string

	// Flag indicating whether the NIC is wake-on-LAN capable
	//
	// Since VI API 2.5
	WakeOnLanSupported bool
}

//
// The capability of the CDP-awared device that connects to a Physical NIC.
// PhysicalNicCdpInfo
//
//
type PhysicalNicCdpDeviceCapability struct {
	*DynamicData

	// The CDP-awared device has the capability of a host, which
	// Sends and receives packets for at least one network layer protocol.
	Host bool

	// The CDP-awared device is IGMP-enabled, which does not forward IGMP
	// Report packets on nonrouter ports.
	IgmpEnabled bool

	// The CDP-awared device has the capability of switching. The
	// difference between this capability and transparentBridge is
	// that a switch does not run the Spanning-Tree Protocol. This
	// device is assumed to be deployed in a physical loop-free topology.
	NetworkSwitch bool

	// The CDP-awared device has the capability of a repeater
	Repeater bool

	// The CDP-awared device has the capability of a routing for
	// at least one network layer protocol
	Router bool

	// The CDP-awared device has the capability of source-route
	// bridging
	SourceRouteBridge bool

	// The CDP-awared device has the capability of transparent
	// bridging
	TransparentBridge bool
}

//
// CDP (Cisco Discovery Protocol) is a link level protocol that allows
// for discovering the CDP-awared network hardware at either end of a
// DIRECT connection. It's only good for direct connection because CDP
// doesn't get forwarded through switches.
//
// It's a simple advertisement protocol which beacons information about
// the switch or host along with some port information. The CDP information
// allows ESX Server admins to know which Cisco switch port is connected to
// any given virtual switch uplink (PNIC).
//
//
type PhysicalNicCdpInfo struct {
	*DynamicData

	// The advertised IP address that is assigned to the interface of the device
	// on which the CDP message is sent. The device can advertise all addresses for
	// a given protocol suite and, optionally, can advertise one or more loopback
	// IP addresses. But this property only show the first address.
	Address string

	// CDP version. The value is always 1.
	CdpVersion int32

	// Device Capability
	// PhysicalNicCdpDeviceCapability
	DeviceCapability *PhysicalNicCdpDeviceCapability

	// Device ID which identifies the device. By default, the device ID is
	// either the device's fully-qualified host name (including the domain
	// name) or the device's hardware serial number in ASCII.
	DevId string

	// Half/full duplex setting of the advertising port.
	FullDuplex bool

	// Hardware platform. An ASCII character string that describes the
	// hardware platform of the device , e.g. "cisco WS-C2940-8TT-S"
	HardwarePlatform string

	// IP prefix. Each IP prefix represents one of the directly connected
	// IP network segments of the local route.
	IpPrefix string

	// ipPrefix length.
	IpPrefixLen int32

	// The configured location of the device.
	Location string

	// The configured IP address of the SNMP management interface for the
	// device.
	MgmtAddr string

	// MTU, the maximum transmission unit for the advertising port. Possible
	// values are 1500 through 18190.
	Mtu int32

	// Port ID. An ASCII character string that identifies the port on which
	// the CDP message is sent, e.g. "FastEthernet0/8"
	PortId string

	// The number of CDP messages we have received from the device.
	Samples int32

	// Software version on the device. A character string that provides
	// information about the software release version that the device is
	// running. e.g. "Cisco Internetwork Operating Syscisco WS-C2940-8TT-S"
	SoftwareVersion string

	// The configured SNMP system name of the device.
	SystemName string

	// The configured SNMP system OID of the device.
	SystemOID string

	// This is the periodicity of advertisement, the time between two
	// successive CDP message transmissions
	Timeout int32

	// Time-To-Live.  the amount of time, in seconds, that a receiver should
	// retain the information contained in the CDP packet.
	Ttl int32

	// The native VLAN of advertising port. The native VLAN is the VLAN to
	// which a port returns when it is not trunking. Also, the native VLAN
	// is the untagged VLAN on an 802.1Q trunk.
	Vlan int32
}

//
// The configuration of the physical network adapter containing
// both the configurable properties and identification information.
//
//
type PhysicalNicConfig struct {
	*DynamicData

	// PhysicalNic device to which configuration applies.
	Device string

	// The specification of the physical network adapter.
	Spec *PhysicalNicSpec
}

//
// This data object type describes each network of a physical
// network adapter's network hint.
//
//
type PhysicalNicHint struct {
	*DynamicData

	// The optional VLAN Id of the network.
	VlanId int32
}

//
// The NetworkHint data object type is some information about
// the network to which the
// physical network adapter is attached.
//
//
type PhysicalNicHintInfo struct {
	*DynamicData

	// If the uplink directly connects to a CDP-awared network device
	// and the device's CDP broadcast is enabled, this property will be
	// set to return the CDP information that vmkernel received on this
	// Physical NIC. CDP data contains the device information and port ID that
	// the Physical NIC connects to. If the uplink is not connecting to a
	// CDP-awared device or CDP is not enabled on the device, this
	// property will be unset.
	// PhysicalNicCdpInfo
	//
	// Since VI API 2.5
	ConnectedSwitchPort *PhysicalNicCdpInfo

	// The physical network adapter device to which
	// this hint applies.
	Device string

	// If the uplink directly connects to an LLDP-aware network device and
	// the device's LLDP broadcast is enabled, this property will be set to
	// return the LLDP information that is received on this physical network
	// adapter. If the uplink is not connecting to a LLDP-aware device or
	// LLDP is not enabled on the device, this property will be unset.
	//
	// Since vSphere API 5.0
	LldpInfo *LinkLayerDiscoveryProtocolInfo

	// The list of network names that were detected on this
	// physical network adapter.
	Network []*PhysicalNicNameHint

	// The list of subnets that were detected on this
	// physical network adapter.
	Subnet []*PhysicalNicIpHint
}

//
// This data object type describes a network in network hint where
// the network is specified using IP addresses, for example,
// 10.27.49.1-10.27.49.254
//
//
type PhysicalNicIpHint struct {
	*PhysicalNicHint

	// The network IP addresses.
	IpSubnet string
}

//
// The PhysicalNicLinkInfo data object describes
// the link speed and the type of duplex communication.  The link speed indicates
// the bit rate in megabits per second.  The duplex boolean indicates if the link
// is capable of full-duplex or half-duplex communication.
//
//
type PhysicalNicLinkInfo struct {
	*DynamicData

	// Flag to indicate whether or not the link is capable of
	// full-duplex ("true") or only half-duplex ("false").
	Duplex bool

	// Bit rate on the link.
	SpeedMb int32
}

//
// This data object type describes a network in network hint where
// the network describes the color, label, or the name of the
// network.
//
//
type PhysicalNicNameHint struct {
	*PhysicalNicHint

	// The network name.
	Network string
}

//
// The PhysicalNicProfile data object represents physical NIC configuration.
// Use the policy list for access to configuration data
// for the physical NIC profile. Use the property list
// for access to subprofile configuration data, if any.
//
//
type PhysicalNicProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string
}

type PhysicalNicResourcePoolSchedulerDisallowedReason struct {
}

//
// This data object type describes the physical network adapter specification
// representing the properties on a physical network adapter that
// can be configured once the object exists.
//
//
type PhysicalNicSpec struct {
	*DynamicData

	// The IP configuration on the physical network adapter (applies
	// only to a hosted network adapter).
	// The data object will be NULL on an ESX Server system.
	Ip *HostIpConfig

	// The link speed and duplexity that this physical network
	// adapter is currently
	// configured to use.  If this property is not set, the physical
	// network adapter autonegotiates its proper settings.
	LinkSpeed *PhysicalNicLinkInfo
}

//
// Set of possible values for vmDirectPathGen2SupportedMode.
//
//
type PhysicalNicVmDirectPathGen2SupportedMode struct {
}

//
// A PlatformConfigFault is a catch-all fault indicating that some error has
// occurred regarding the configuration of the host.  Data about the fault is
// available and will be presented as a platform specific string.
//
// This information carried by this fault cannot be localized.  Most likely
// this information will already have been localized to the locale of the
// server that generated this fault.  Where possible, a more specific fault
// will be thrown.
//
//
//
type PlatformConfigFault struct {
	*HostConfigFault

	// Platform specific text string describing this error.
	Text string
}

//
// The PnicUplinkProfile data object specifies the mapping between
// a physical NIC and an uplink port.
// The policy property contains
// the configuration data values.
//
//
type PnicUplinkProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string
}

//
// The disk locator class.
//
//
type PodDiskLocator struct {
	*DynamicData

	// The disk backing info.
	DiskBackingInfo *VirtualDeviceBackingInfo

	// The disk ID.
	DiskId int32

	// The disk move type.
	DiskMoveType string

	// Virtual Disk Profile requirement.
	//
	// Profiles are solution specific.
	//
	// Profile Based Storage Management is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with it.
	//
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	//
	// Since vSphere API 5.5
	Profile []*VirtualMachineProfileSpec
}

//
// An entry containing storage DRS configuration, runtime
// results, and history for a pod StoragePod.
//
//
//
//
type PodStorageDrsEntry struct {
	*DynamicData

	// The set of actions that have been performed recently.
	ActionHistory []*ClusterActionHistory

	// A collection of the DRS faults generated in the last Storage DRS invocation.
	// Each element of the collection is the set of faults generated in one
	// recommendation.
	DrsFault []*ClusterDrsFaults

	// List of recommended actions for the Storage Pod. It is
	// possible that the current set of recommendations may be empty,
	// either due to not having any running dynamic recommendation
	// generation module, or since there may be no recommended actions
	// at this time.
	Recommendation []*ClusterRecommendation

	// Storage DRS configuration.
	StorageDrsConfig *StorageDrsConfigInfo
}

//
// The PolicyOption data object represents one or more configuration
// values. A policy option is one of the configuration options from the
// ProfilePolicyMetadata.possibleOption
// list.
//
//
type PolicyOption struct {
	*DynamicData

	// Identifier for the policy option. This value matches one of the
	// keys from the list of possible options in the policy metadata
	// (ProfilePolicyMetadata.possibleOption[].id.key).
	Id string

	// Parameters for the policy option.
	// This list must include all parameters that are not marked as optional
	// in the policy option metadata parameter list
	// (ProfilePolicyMetadata.possibleOption[].parameter[].optional).
	Parameter []*KeyAnyValue
}

//
// The type of component connected to a port group.
//
//
type PortGroupConnecteeType struct {
}

//
// PortGroupProfile is the base class for the different port group
// subprofile objects.
//
//
type PortGroupProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string

	// Name of the portgroup.
	Name string

	// The network policy applicable on the port group.
	NetworkPolicy *NetworkPolicyProfile

	// VLAN identifier for the port group.
	Vlan *VlanProfile

	// Virtual switch to which the port group is connected.
	Vswitch *VirtualSwitchSelectionProfile
}

//
// Searching for users and groups on POSIX systems provides
// User ID and Group ID information, in addition to that
// defined in UserSearchResult.
//
//
type PosixUserSearchResult struct {
	*UserSearchResult

	// If the search result is for a user, then id refers to User ID. For a group,
	// the value of Group ID is assigned to id.
	Id int32

	// If the search result is for a user, shellAccess indicates whether shell
	// access has been granted or not.
	ShellAccess bool
}

//
// The PowerOnFtSecondaryFailed fault is thrown when the system is unable to
// power on a Fault Tolerance secondary virtual machine. It includes a list
// of failures on different hosts.
//
//
type PowerOnFtSecondaryFailed struct {
	*VmFaultToleranceIssue

	// Information on why the system can not power on a Fault Tolerance
	// secondary virtual machine on specific hosts. Everything in the array
	// should be FtIssuesOnHost.
	HostErrors []*LocalizedMethodFault

	// The host selection type
	HostSelectionBy *enum.FtIssuesOnHostHostSelectionType

	// The reason why powering on secondary failed.
	RootCause *LocalizedMethodFault

	// The primary virtual machine corresponding to the secondary that is to
	// be powered on
	Vm *VirtualMachine

	// The name of the primary virtual machine corresponding to the secondary
	// that is to be powered on.
	VmName string
}

//
// PowerOnFtSecondaryTimedout exception is thrown when Virtual Center
// fails the operation to power on a Fault Tolerance secondary virtual
// machine because it is taking longer than expected.
//
//
type PowerOnFtSecondaryTimedout struct {
	*Timedout

	// The time out value in seconds
	Timeout int32

	// The primary virtual machine corresponding to the secondary that is to
	// be powered on
	Vm *VirtualMachine

	// The name of the primary virtual machine corresponding to the secondary
	// that is to be powered on.
	VmName string
}

//
// Power System Capability data object.
//
//
//
// Exposes policies available in power management system.
//
//
type PowerSystemCapability struct {
	*DynamicData

	// List of available host power policies.
	AvailablePolicy []*HostPowerPolicy
}

//
// Power System Info data object.
//
//
//
// Shows current state of power management system.
//
//
type PowerSystemInfo struct {
	*DynamicData

	// Currently selected host power management policy.
	//
	// This property can have one of the values from
	//
	// availablePolicy.
	CurrentPolicy *HostPowerPolicy
}

//
// This class defines whether a specific privilege is granted.
//
//
type PrivilegeAvailability struct {
	*DynamicData

	// True if the privilege is granted.
	IsGranted bool

	// The privilege ID.
	PrivId string
}

//
// Describes a basic privilege policy.
//
//
type PrivilegePolicyDef struct {
	*DynamicData

	// Name of privilege required for creation.
	CreatePrivilege string

	// Name of privilege required for deleting.
	DeletePrivilege string

	// Name of privilege required for reading.
	ReadPrivilege string

	// Name of privilege required for updating.
	UpdatePrivilege string
}

//
// ProductComponentInfo data object type describes installed components.
// Product component is defined as a software module that is released
// and versioned independently but has dependency relationship with other products.
// If one product, for usability or any other reason, bundles other products,
// ProductComponentInfo type may be used to describe installed components.
// For example, ESX product may bundle VI Client in its releases.
//
//
type ProductComponentInfo struct {
	*DynamicData

	// Opaque identifier that is unique for this product component
	Id string

	// Canonical name of product component
	Name string

	// Release property is a number which increments with each
	// new release of product. Product release may not rev version
	// but release number is always incremented.
	Release int32

	// Version of product component
	Version string
}

//
// The Profile managed object is the base class for host and cluster
// profiles.
//
type Profile struct {
	*ManagedObject

	complianceStatus string

	config *ProfileConfigInfo

	createdTime time.Time

	description *ProfileDescription

	entity []*ManagedEntity

	modifiedTime time.Time

	name string
}

// Overall compliance of entities associated with this profile.
// If one of the entities is out of compliance, the profile is nonCompliant.
// If all entities are in compliance, the profile is compliant.
// If the compliance status of one of the entities is not known, compliance status
// of the profile is unknown.
// See ComplianceResultStatus.
func (mo *Profile) ComplianceStatus() (string, error) {
	t, err := mo.currentProperty("complianceStatus")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

// Configuration data for the profile.
// Required Privilege: Profile.Edit
func (mo *Profile) Config() (*ProfileConfigInfo, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ProfileConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ProfileConfigInfo")
	}
	return v, nil
}

// Time at which the profile was created.
func (mo *Profile) CreatedTime() (time.Time, error) {
	t, err := mo.currentProperty("createdTime")
	if err != nil {
		return time.Now(), err
	}

	v, ok := t.(time.Time)
	if !ok {
		return time.Now(), errors.New("Unable to make type assertion to: time.Time")
	}
	return v, nil
}

// Deprecated.
// As of vSphere API 5.0. use RetrieveDescription instead.
//
//
// Localizable description of the profile
func (mo *Profile) Description() (*ProfileDescription, error) {
	t, err := mo.currentProperty("description")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ProfileDescription)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ProfileDescription")
	}
	return v, nil
}

// List of managed entities associated with the profile.
func (mo *Profile) Entity() ([]*ManagedEntity, error) {
	t, err := mo.currentProperty("entity")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ManagedEntity)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ManagedEntity")
	}
	return v, nil
}

// Time at which the profile was last modified.
func (mo *Profile) ModifiedTime() (time.Time, error) {
	t, err := mo.currentProperty("modifiedTime")
	if err != nil {
		return time.Now(), err
	}

	v, ok := t.(time.Time)
	if !ok {
		return time.Now(), errors.New("Unable to make type assertion to: time.Time")
	}
	return v, nil
}

// Name of the profile.
func (mo *Profile) Name() (string, error) {
	t, err := mo.currentProperty("name")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

//
// Associate a profile with a managed entity. You can check the compliance of
// entities associated with a profile by calling the
// CheckProfileCompliance_Task method.
//
// Required Privileges
// Profile.Edit
//
func (mo *Profile) AssociateProfile(
	_this *ManagedObjectReference, entity []*ManagedEntity,
) error {

	return nil

}

//
// Check compliance of an entity against a Profile.
//
// Required Privileges
// System.View
//
func (mo *Profile) CheckProfileCompliance_Task(
	_this *ManagedObjectReference, entity []*ManagedEntity,
) (*Task, error) {

	return nil, nil

}

//
// Destroy the profile.
//
// Required Privileges
// Profile.Delete
//
func (mo *Profile) DestroyProfile(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Remove the association between a profile and a managed entity.
//
// Required Privileges
// Profile.Edit
//
func (mo *Profile) DissociateProfile(
	_this *ManagedObjectReference, entity []*ManagedEntity,
) error {

	return nil

}

//
// Export the profile in a serialized form. To use the serialized string to create a profile,
// specify a ProfileSerializedCreateSpec when you call the
// HostProfileManager.CreateProfile
// method.
//
// Required Privileges
// Profile.Export
//
func (mo *Profile) ExportProfile(
	_this *ManagedObjectReference,
) (string, error) {

	return "", nil

}

//
// Returns the localizable description for the profile.
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *Profile) RetrieveDescription(
	_this *ManagedObjectReference,
) (*ProfileDescription, error) {

	return nil, nil

}

//
// DataObject which represents an ApplyProfile element.
// An ApplyProfile element is an ApplyProfile for a set of host
// configuration settings which may be instanced.
// For example, there may be multiple virtual switch instances
// represented by individual ApplyProfileElement DataObjects.
//
//
type ProfileApplyProfileElement struct {
	*ApplyProfile

	// The linkable identifier.
	Key string
}

//
// The ProfileApplyProfileProperty data object defines one or more subprofiles.
//
//
type ProfileApplyProfileProperty struct {
	*DynamicData

	// Flag indicating whether this property is an array of profiles.
	Array bool

	// Subprofiles that define policies and nested subprofiles.
	Profile []*ApplyProfile

	// Name of the property.
	PropertyName string
}

//
// This event records that a Profile was associated with a managed entitiy.
//
//
type ProfileAssociatedEvent struct {
	*ProfileEvent
}

//
// This event records that the profile has beed edited
//
//
type ProfileChangedEvent struct {
	*ProfileEvent
}

//
// Interface handling the Compliance aspects of entities.
//
type ProfileComplianceManager struct {
	*ManagedObject
}

//
// Check compliance of an entity against a Profile.
//
// Required Privileges
// System.View
//
func (mo *ProfileComplianceManager) CheckCompliance_Task(
	_this *ManagedObjectReference, profile []*Profile, entity []*ManagedEntity,
) (*Task, error) {

	return nil, nil

}

//
// Clear the saved ComplianceResult based on profile and entity filtering criteria.
//
// Required Privileges
// Profile.Clear
//
func (mo *ProfileComplianceManager) ClearComplianceStatus(
	_this *ManagedObjectReference, profile []*Profile, entity []*ManagedEntity,
) error {

	return nil

}

//
// Query the compliance status based on Profile and Entity filter.
//
// Required Privileges
// System.View
//
func (mo *ProfileComplianceManager) QueryComplianceStatus(
	_this *ManagedObjectReference, profile []*Profile, entity []*ManagedEntity,
) ([]*ComplianceResult, error) {

	return nil, nil

}

//
// Query the metadata for the expressions.
//
// Required Privileges
// System.View
//
func (mo *ProfileComplianceManager) QueryExpressionMetadata(
	_this *ManagedObjectReference, expressionName []string, profile *Profile,
) ([]*ProfileExpressionMetadata, error) {

	return nil, nil

}

//
// DataObject to Compose expressions. It is used to group expressions
// together. They are similar to a parentheses in an expression.
//
//
type ProfileCompositeExpression struct {
	*ProfileExpression

	// List of expression names that will be used for this composition.
	// The individual expressions will return a boolean. The return values
	// of the individual expressions will be used to compute the final
	// return value of the CompositeExpression.
	//
	// The expressions specified in the list can themselves be
	// CompositeExpressions.
	ExpressionName []string

	// Logical operator to be applied between the expressions in
	// the composite expression. e.g: or, and
	Operator string
}

//
// The ProfileCompositePolicyOptionMetadata data object represents the metadata information
// for a composite PolicyOption. The user will retrieve metadata
// information about a composite policy and then combine policy options to produce
// the composite policy option.
//
//
type ProfileCompositePolicyOptionMetadata struct {
	*ProfilePolicyOptionMetadata

	// List of optional policy option identifiers that could be combined
	// in this composite policy option. The policy options should already be
	// part of the possible policy options for the policy. See the
	// ProfilePolicyMetadata.possibleOption
	// list.
	Option []string
}

type ProfileConfigInfo struct {
	*DynamicData

	// User Provided description of the profile
	Annotation string

	// Flag indicating if the Profile is enabled
	Enabled bool

	// Name of the profile
	Name string
}

//
// Specification describing the parameters during Profile creation
//
//
type ProfileCreateSpec struct {
	*DynamicData

	// User Provided description of the profile
	Annotation string

	// Flag indicating if the Profile is enabled
	Enabled bool

	// Name of the profile
	Name string
}

//
// This event records that a Profile was created.
//
//
type ProfileCreatedEvent struct {
	*ProfileEvent
}

//
// The ProfileDeferredPolicyOptionParameter data object contains
// information about a single deferred parameter for host configuration.
//
//
//
//
// • The Server verifies deferred parameter data when it calls the
// HostProfile.ExecuteHostProfile
// method.
//
// • The client supplies deferred parameter data for host configuration when it calls the
// HostProfileManager.ApplyHostConfig_Task
// method.
//
// • The vCenter Server stores deferred parameter data in answer files
// (AnswerFile.userInput).
//
//
//
//
//
//
type ProfileDeferredPolicyOptionParameter struct {
	*DynamicData

	// Complete path to the PolicyOption that defines the parameters.
	InputPath *ProfilePropertyPath

	// List that contains values for the policy parameters.
	//
	// During parameter verification, this property is unspecified
	// if the client has not provided the values for this parameter.
	// See ProfileExecuteResult.requireInput.
	Parameter []*KeyAnyValue
}

//
// The ProfileDescription data object describes a profile.
// The description contains multiple sections. Each section
// describes a part of the profile.
//
//
type ProfileDescription struct {
	*DynamicData

	// Sections which make up the profile description.
	Section []*ProfileDescriptionSection
}

//
// The ProfileDescriptionSection data object
// contains a profile element description and any messages that may
// be associated with the profile section.
//
//
type ProfileDescriptionSection struct {
	*DynamicData

	// Localized message data.
	Description *ExtendedElementDescription

	// List of messages that make up the section.
	Message []*LocalizableMessage
}

//
// This event records that a Profile was dissociated from a  managed entity
//
//
type ProfileDissociatedEvent struct {
	*ProfileEvent
}

//
// This event records a Profile specific event.
//
//
type ProfileEvent struct {
	*Event

	// Link to the profile to which this event applies
	Profile *ProfileEventArgument
}

//
// The event argument is a Profile object
//
//
type ProfileEventArgument struct {
	*EventArgument

	Name string

	Profile *Profile
}

//
// The ProfileExecuteError data object
// describes an error encountered during host profile execution.
//
//
type ProfileExecuteError struct {
	*DynamicData

	// Message describing the error.
	Message *LocalizableMessage

	// Path to the profile or policy with which the error is associated.
	Path *ProfilePropertyPath
}

//
// The ProfileExecuteResult data object contains the results from a
// HostProfile.ExecuteHostProfile
// operation.
//
//
type ProfileExecuteResult struct {
	*DynamicData

	// Host configuration specification. This data is valid only if
	// the status value is success.
	// See ProfileExecuteResultStatus.
	//
	// Use this data object when you apply the configuration
	// to a host. See the configSpec parameter to the
	// HostProfileManager.ApplyHostConfig_Task
	// method.
	ConfigSpec *HostConfigSpec

	// List of errors that were encountered during execute.
	// This field will be set if status is set to error.
	Error []*ProfileExecuteError

	// List of property paths. Each path identifies a policy that does not apply
	// to this host. For example, if the precheck policies for a port group are not satisfied,
	// the port group will not be created when you apply the profile to the host.
	// Based on this information, the client might not display that part of the profile tree.
	InapplicablePath []string

	// List that describes the required input for host configuration and identifies
	// any policy options that still require parameter data. Each entry in the list
	// specifies the path to a policy and a parameter list. If the call to
	// ExecuteHostProfile includes deferred parameters,
	// the requireInput entries
	// (requireInput[].parameter[])
	// will be populated with the parameter data that was passed to the execute method.
	// For policies that still require input data, the parameter list in the corresponding
	// entry will be null.
	//
	// A vSphere client that displays a GUI can use this information to show the host-specific
	// configuration policy options. The client can highlight required input fields
	// and ask the user for data in increments instead of collecting all of the input at once.
	// For example, in the first pass, the client collects a minimum of user input and
	// sends that to the Server. The Server evaluates the profile and might decide to
	// invalidate a particular part of the subtree or enable a new
	// subtree in the profile. This would result in a new set of invalid paths
	// (inapplicablePath[]) and
	// required input property paths
	// (ProfileDeferredPolicyOptionParameter.inputPath).
	// The client can make a series of calls to the method until it achieves a success status.
	//
	// When ExecuteHostProfile returns a success status,
	// the requireInput list contains the complete list of parameters,
	// consisting of the following data:
	//
	//
	// Deferred parameter values resolved through successive calls to
	// ExecuteHostProfile.
	// Default parameter values from the host configuration.
	// User-specified values that override the defaults.
	//
	//
	// You can specify the returned requireInput list in the
	// userInput parameter to the
	// HostProfileManager.ApplyHostConfig_Task
	// method. The Server will use the list to update the AnswerFile
	// associated with the host.
	RequireInput []*ProfileDeferredPolicyOptionParameter

	// Status of the profile execution operation. The value is a string that contains
	// one of the ProfileExecuteResultStatus enumerations.
	Status string
}

//
// Defines the result status values for a
// HostProfile.ExecuteHostProfile
// operation. The result data is contained in the
// ProfileExecuteResult data object.
//
//
type ProfileExecuteResultStatus struct {
}

type ProfileExpression struct {
	*DynamicData

	// User visible display name
	DisplayName string

	// Identifier of this expression. The id has to be unique within a Profile.
	// The id can be used as a key while building composite expressions.
	Id string

	// Flag indicating if the condition of the expression should be negated.
	// e.g: conditions like VSwitch0 has vmnic0 connected to it can be turned into
	// VSwitch0 doesn't have vmnic0 connected to it.
	Negated bool
}

//
// DataObject to represent the metadata associated with a SimpleExpression.
//
//
type ProfileExpressionMetadata struct {
	*DynamicData

	// Id of the SimpleExpression
	ExpressionId *ExtendedElementDescription

	// Parameters that can be specified for this SimpleExpression
	Parameter []*ProfileParameterMetadata
}

//
// This Class is responsible for managing Profiles.
//
type ProfileManager struct {
	*ManagedObject

	profile []*Profile
}

// A list of profiles known to this ProfileManager.
// Required Privilege: Profile.View
func (mo *ProfileManager) Profile() ([]*Profile, error) {
	t, err := mo.currentProperty("profile")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Profile)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Profile")
	}
	return v, nil
}

//
// Create a profile from the specified CreateSpec.
//
// Required Privileges
// Profile.Create
//
func (mo *ProfileManager) CreateProfile(
	_this *ManagedObjectReference, createSpec *ProfileCreateSpec,
) (*Profile, error) {

	return nil, nil

}

//
// Get the profile(s) to which this entity is associated.
// The list of profiles will only include profiles known to this
// profileManager.
//
// Required Privileges
// System.View
//
func (mo *ProfileManager) FindAssociatedProfile(
	_this *ManagedObjectReference, entity *ManagedEntity,
) ([]*Profile, error) {

	return nil, nil

}

//
// Get the Metadata information for the policyNames.
// PolicyNames are available with the defaultProfile obtained by invoking the
// method createDefaultProfile.
//
// Required Privileges
// System.View
//
func (mo *ProfileManager) QueryPolicyMetadata(
	_this *ManagedObjectReference, policyName []string, profile *Profile,
) ([]*ProfilePolicyMetadata, error) {

	return nil, nil

}

//
// This data object represents the metadata information of a Profile.
//
//
type ProfileMetadata struct {
	*DynamicData

	// Property which describes the profile
	Description *ExtendedDescription

	// Type of the Profile
	Key string

	// Identifies the profile category that this subprofile is a part of. The
	// value of this string should correspond to the key value of a
	// ProfileCategoryMetadata object's key
	// in its id property.
	//
	// Since vSphere API 5.1
	ProfileCategory string

	// Property indicating that the subprofile described by this
	// ProfileMetadata object is declared in the
	// profileTypeNames of the specified
	// profile component. The value of this property should correspond to the key
	// value of the ProfileComponentMetadata object's
	// key in its
	// id property.
	//
	// This property should not be present for subprofiles that are not directly
	// declared in the profileTypeNames
	// property of a ProfileComponentMetadata object.
	//
	// Since vSphere API 5.1
	ProfileComponent string

	// Type identifier for the ApplyProfile
	//
	// Since vSphere API 5.0
	ProfileTypeName string

	// Property that determines a sorting order for display purposes. If
	// the list contains more than one sort spec, then the precedence should
	// be determined by the list order (i.e. sort first by the first spec in
	// the list, then sort by the second spec in the list, etc).
	//
	// Since vSphere API 5.0
	SortSpec []*ProfileMetadataProfileSortSpec
}

type ProfileMetadataProfileSortSpec struct {
	*DynamicData

	// The parameter to be used for sorting. Note that if the policy to be
	// used for sorting has multiple possible policy options, all possible
	// policy options defined for that policy type must have this parameter.
	Parameter string

	// The id of the policy used to sort instances of the profile
	PolicyId string
}

//
// Enumerates different operations supported for comparing
// numerical values.
//
//
type ProfileNumericComparator struct {
}

//
// The ProfileParameterMetadata data object represents the metadata information
// for expressions, policy options, and host-specific configuration data.
//
//
type ProfileParameterMetadata struct {
	*DynamicData

	// Default value that can be used for the parameter.
	DefaultValue interface{}

	// Identifier for the parameter.
	Id *ExtendedElementDescription

	// Whether the parameter is optional.
	Optional bool

	// Type of the parameter.
	Type string
}

//
// The ProfilePolicy data object represents a policy.
//
//
type ProfilePolicy struct {
	*DynamicData

	// Identifier for the policy.
	Id string

	// Configuration parameters.
	PolicyOption *PolicyOption
}

//
// The ProfilePolicyMetadata data object represents the metadata information
// for a ProfilePolicy.
//
//
type ProfilePolicyMetadata struct {
	*DynamicData

	// Identifier for the policy.
	Id *ExtendedElementDescription

	// Possible policy options that can be set for a policy of the
	// given kind. HostProfiles and subprofiles
	// will contain selected policy options from this list. See
	// PolicyOption.
	PossibleOption []*ProfilePolicyOptionMetadata
}

//
// The ProfilePolicyOptionMetadata data object contains the metadata information
// for a PolicyOption.
//
//
type ProfilePolicyOptionMetadata struct {
	*DynamicData

	// Identifier for the policy option.
	//
	// The id.key value
	// (ExtendedElementDescription.key)
	// identifies the policy option type.
	// The id.label property
	// (ExtendedElementDescription.label)
	// contains a brief localizable message describing the policy option.
	// The id.summary property
	// (ExtendedElementDescription.summary)
	// contains a localizable summary of the policy option.
	// Summary information can contain embedded variable names which can
	// be replaced with values from the parameter property.
	Id *ExtendedElementDescription

	// Metadata about the parameters for the policy option.
	Parameter []*ProfileParameterMetadata
}

type ProfileProfileStructure struct {
	*DynamicData

	// SubProfile properties available for this profile
	Child []*ProfileProfileStructureProperty

	// Identifier for the profile type
	ProfileTypeName string
}

type ProfileProfileStructureProperty struct {
	*DynamicData

	// Flag indicating if this property is an Array of profiles
	Array bool

	// Details about the profile contained within this property
	Element *ProfileProfileStructure

	// Name of the property where this ProfileStructureProperty is being used
	PropertyName string
}

//
// The ProfilePropertyPath data object represents
// the path to a profile, policy option, or specific parameter. If profilePath,
// policyId, and parameterId are all specified, the
// combination of the three identifies a particular parameter. If only profilePath
// and policyId are specified, the combination identifies a
// specific profile policy option. If just the profilePath is
// specified, the data object identifies a profile instance.
//
//
type ProfilePropertyPath struct {
	*DynamicData

	// Key for a parameter in the policy specified by policyId.
	// See PolicyOption.parameter
	// and key.
	//
	// Since vSphere API 5.1
	ParameterId string

	// Policy option identifier. See PolicyOption.id.
	PolicyId string

	// Complete path to the leaf profile, relative to the root of the host profile
	// document.
	ProfilePath string
}

//
// This event records that the reference host associated with this profile has changed
//
//
type ProfileReferenceHostChangedEvent struct {
	*ProfileEvent

	// The newly associated reference host with this profile
	ReferenceHost *HostSystem
}

//
// This event records that a Profile was removed.
//
//
type ProfileRemovedEvent struct {
	*ProfileEvent
}

//
// The ProfileSerializedCreateSpec data object
// defines a string that contains a serialized representation of a host profile.
//
//
type ProfileSerializedCreateSpec struct {
	*ProfileCreateSpec

	// Representation of the profile in the string form.
	ProfileConfigString string
}

//
// DataObject represents a pre-defined expression
//
//
type ProfileSimpleExpression struct {
	*ProfileExpression

	// Type of the simple expression to instantiate.
	// The expressionType should be derived from the available expressions as
	// listed in the metadata.
	ExpressionType string

	// The parameters for the expressionType.
	// The list of parameters needed for a simple expression can
	// be obtained from the metadata.
	Parameter []*KeyAnyValue
}

//
// Errors were detected during Profile update.
//
//
type ProfileUpdateFailed struct {
	*VimFault

	// Failures encountered during update
	Failure []*ProfileUpdateFailedUpdateFailure
}

type ProfileUpdateFailedUpdateFailure struct {
	*DynamicData

	// Message which explains the problem encountered
	ErrMsg *LocalizableMessage

	// Location in the profile which has the error
	ProfilePath *ProfilePropertyPath
}

//
// Describes a change to a property.
//
//
type PropertyChange struct {
	*DynamicData

	// Property or nested property to which the change applies.  Nested
	// properties are specified by paths; for example,
	//
	//
	// foo.bar
	// foo.arProp["key val"]
	// foo.arProp["key val"].baz
	Name string

	// Change operation for the property. Valid values are:
	// addThe property is a collection and the change inserts an element
	// into the collection.removeThe property is a collection and the change deletes an element
	// from the collection.assignThe change is a new value for the property.indirectRemoveThe property was removed because a containing property was removed
	// or unset
	Op *enum.PropertyChangeOp

	// New value for the property when "op" is either "add" or "assign".
	Val interface{}
}

//
// Enumeration of possible changes to a property.
//
//
type PropertyChangeOp struct {
}

//
// The PropertyCollector managed object retrieves and detects changes
// to the properties of other managed objects. The RetrievePropertiesEx method provides one-time property retrieval. The
// WaitForUpdatesEx method provides incremental change detection and
// supports both polling and notification.
//
// For change detection a client creates one or more filters to specify the
// subset of managed objects in which the client is interested. Filters keep
// per-session state to track incremental changes. Because this state is
// per-session:
//
//
//
// •  A session cannot share its PropertyCollector filters with other
// sessions
//
//
// •  two different clients can share the same session, and so can
// share the same filters, but this is not recommended
//
//
// •  When a session terminates, the associated PropertyCollector filters
// are automatically destroyed.
//
//
//
//
//
type PropertyCollector struct {
	*ManagedObject

	filter []*PropertyFilter
}

// The filters that this PropertyCollector uses to determine the list of
// properties for which it detects incremental changes.
// Required Privilege: System.View
func (mo *PropertyCollector) Filter() ([]*PropertyFilter, error) {
	t, err := mo.currentProperty("filter")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*PropertyFilter)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*PropertyFilter")
	}
	return v, nil
}

//
// Discards remaining results from a retrieval started by RetrievePropertiesEx on the same session on the same PropertyCollector.
//
// Required Privileges
// System.Anonymous
// Since
// vSphere API 4.1
//
func (mo *PropertyCollector) CancelRetrievePropertiesEx(
	_this *ManagedObjectReference, token string,
) error {

	return nil

}

//
// Attempts to cancel outstanding calls to WaitForUpdates or WaitForUpdatesEx in the current session.  If an update calculation is
// in process this method has no effect. If an update calculation is not in
// process any waiting calls complete quickly and report a RequestCanceled fault.
//
// Required Privileges
// System.View
//
func (mo *PropertyCollector) CancelWaitForUpdates(
	_this *ManagedObjectReference,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 4.1, use
// WaitForUpdatesEx with a
// maxWaitSeconds of 0.
//
//
// Checks for updates on properties specified by the union of all current
// filters. If no updates are pending, this method returns null.
//
// Required Privileges
// System.View
//
func (mo *PropertyCollector) CheckForUpdates(
	_this *ManagedObjectReference, version string,
) (*UpdateSet, error) {

	return nil, nil

}

//
// Retrieves additional results from a retrieval started by RetrievePropertiesEx on the same session on the same PropertyCollector.
//
// Required Privileges
// System.Anonymous
// Since
// vSphere API 4.1
//
func (mo *PropertyCollector) ContinueRetrievePropertiesEx(
	_this *ManagedObjectReference, token string,
) (*RetrieveResult, error) {

	return nil, nil

}

//
// Creates a new filter for the given set of managed objects.
//
// Required Privileges
// System.View
//
func (mo *PropertyCollector) CreateFilter(
	_this *ManagedObjectReference, spec *PropertyFilterSpec, partialUpdates bool,
) (*PropertyFilter, error) {

	return nil, nil

}

//
// Creates a new session-specific PropertyCollector that can
// be used to retrieve property updates independent of any other
// PropertyCollector.  The newly created PropertyCollector
// is not tied to the creating PropertyCollector in any way and
// exists until it is destroyed
// by a call to DestroyPropertyCollector or until the session
// on which the PropertyCollector was created is closed.  This is in contrast
// to the default PropertyCollector, which always exists, but still has
// session-specific data such as filters and unfinished update calculations
// that are discarded when the associated session is closed.
//
// A new PropertyCollector can be useful when multiple modules or even
// multiple clients that share the
// same session need to create their own PropertyFilter
// objects and process updates independently.  They may also be useful
// to allow important updates to be seen on one PropertyCollector while
// a large update is being calculated on another.  The underlying
// issue that this addresses is that any call to WaitForUpdates,
// CheckForUpdates, or WaitForUpdatesEx does updates on all the
// filters created on a given PropertyCollector on a given session.
//
//
// A more subtle use of multiple PropertyCollector objects is implied
// by the fact that the returned version value for the various updates
// calculations is strongly ordered.  The only way this can make sense is that
// two different versions calculated on the same PropertyCollector on
// the same session cannot ever be created in parallel.  This means that multiple
// calls to WaitForUpdates, CheckForUpdates, or
// WaitForUpdatesEx made to the same PropertyCollector on the
// same session on different threads of the same client, or even on different
// clients that share the same session are still handled on the server serially.
// Use of different PropertyCollector instances allows the server to
// handle these calculations in parallel.
//
//
// Typically a service that supports the PropertyCollector managed
// object type will automatically create a default PropertyCollector
// and provide some way to obtain a reference to this
// PropertyCollector.  If not, it will have to provide some
// service-specific way to create the a PropertyCollector.
//
//
// Required Privileges
// System.View
// Since
// vSphere API 4.1
//
func (mo *PropertyCollector) CreatePropertyCollector(
	_this *ManagedObjectReference,
) (*PropertyCollector, error) {

	return nil, nil

}

//
// Destroys this PropertyCollector.
//
// A PropertyCollector that was created by
// CreatePropertyCollector is automatically destroyed when the
// session on which it was created is closed. This method can be used to
// destroy them explicitly.
//
//
// An automatically created PropertyCollector provided by a service
// is not session specific and may not be destroyed.
//
//
// Required Privileges
// System.View
// Since
// vSphere API 4.1
//
func (mo *PropertyCollector) DestroyPropertyCollector(
	_this *ManagedObjectReference,
) error {

	return nil

}

// Deprecated.
// As of vSphere API 4.1, use RetrievePropertiesEx.
//
//
// Retrieves the specified properties of the specified managed objects.
//
// This method is similar to creating the filters, receiving the
// property values, and destroying the filters. The main difference is that
// the output blends the results from all the filters and reports a given
// managed object at most once no matter how many filters apply.
//
//
// The filter creation step can throw all of the same faults as CreateFilter.
//
//
// Required Privileges
// System.Anonymous
//
func (mo *PropertyCollector) RetrieveProperties(
	_this *ManagedObjectReference, specSet []*PropertyFilterSpec,
) ([]*ObjectContent, error) {

	return nil, nil

}

//
// Retrieves the specified properties of the specified managed objects.
//
// This method is similar to creating the filters, receiving the
// property values, and destroying the filters. The main difference is that
// the output blends the results from all the filters and reports a given
// managed object at most once no matter how many filters apply.
//
//
// The filter creation step can throw all of the same faults as CreateFilter.
//
//
// Required Privileges
// System.Anonymous
// Since
// vSphere API 4.1
//
func (mo *PropertyCollector) RetrievePropertiesEx(
	_this *ManagedObjectReference, specSet []*PropertyFilterSpec, options *RetrieveOptions,
) (*RetrieveResult, error) {

	return nil, nil

}

// Deprecated.
// As of vSphere API 4.1, use WaitForUpdatesEx.
//
//
// Calculate the set of updates for each existing filter in the session,
// returning when at least one filter has updates.
//
// Required Privileges
// System.View
//
func (mo *PropertyCollector) WaitForUpdates(
	_this *ManagedObjectReference, version string,
) (*UpdateSet, error) {

	return nil, nil

}

//
// Calculate the set of updates for each existing filter in the session.
//
// WaitForUpdatesEx may return only partial update
// calculations. See truncated for a
// more detailed explanation. WaitForUpdatesEx may also return null
// after a timeout, either as requested by maxWaitSeconds or due to PropertyCollector
// policy.
//
//
// If an application uses waitForUpdatesEx it is strongly recommended
// that it not make concurrent calls to WaitForUpdates, CheckForUpdates, or WaitForUpdatesEx in the same
// session. Concurrent calls may cause suspended change calculations to be
// discarded.
//
//
// Required Privileges
// System.View
// Since
// vSphere API 4.1
//
func (mo *PropertyCollector) WaitForUpdatesEx(
	_this *ManagedObjectReference, version string, options *WaitOptions,
) (*UpdateSet, error) {

	return nil, nil

}

//
// The PropertyFilter managed object type defines a filter
// that controls the properties for which a PropertyCollector detects
// incremental changes.  Filters are subordinate objects; they are part of the PropertyCollector and do not have independent lifetimes.  A Filter
// is automatically destroyed when the session on which it was created is
// closed or the PropertyCollector on which it was created is
// destroyed.
//
type PropertyFilter struct {
	*ManagedObject

	partialUpdates bool

	spec *PropertyFilterSpec
}

// Flag to indicate if a change to a nested property reports only the
// nested change or the entire specified property value.  If the value is
// true, a change reports only the nested property.  If the value is
// false, a change reports the enclosing property named in the filter.
func (mo *PropertyFilter) PartialUpdates() (bool, error) {
	t, err := mo.currentProperty("partialUpdates")
	if err != nil {
		return false, err
	}

	v, ok := t.(bool)
	if !ok {
		return false, errors.New("Unable to make type assertion to: bool")
	}
	return v, nil
}

// Specifications for this filter.
func (mo *PropertyFilter) Spec() (*PropertyFilterSpec, error) {
	t, err := mo.currentProperty("spec")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*PropertyFilterSpec)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *PropertyFilterSpec")
	}
	return v, nil
}

//
// Destroys this filter.
//
// This operation can be called explicitly, or it can take place
// implicitly when the session that created the filter is closed.
//
//
// Required Privileges
// None
//
func (mo *PropertyFilter) DestroyPropertyFilter(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Specify the property data that is included in a filter. A filter can
// specify part of a single managed object, or parts of multiple related
// managed objects in an inventory hierarchy - for example, to collect
// updates from all virtual machines in a given folder.
//
//
type PropertyFilterSpec struct {
	*DynamicData

	// Set of specifications that determine the objects to filter.
	ObjectSet []*ObjectSpec

	// Set of properties to include in the filter, specified for each object
	// type.
	PropSet []*PropertySpec

	// Control how to report missing objects during filter creation.
	//
	// If false or unset and objectSet refers to missing objects,
	// filter creation will fail with a ManagedObjectNotFound fault.
	//
	// If true and objectSet refers
	// to missing objects, filter creation will not fail and missing objects
	// will be reported via filter results. This is the recommended setting
	// when objectSet refers to
	// transient objects.
	//
	// In an UpdateSet missing objects will
	// appear in the missingSet field.
	//
	// In a RetrieveResult missing objects will
	// simply be omitted from the objects field.
	//
	// For a call to RetrieveProperties missing objects will simply
	// be omitted from the results.
	//
	// Since vSphere API 4.1
	ReportMissingObjectsInResults bool
}

//
// The PropertyFilterUpdate data object type contains a
// list of updates to data visible through a specific filter. Note that if a
// property changes through multiple filters, then a client receives an
// update for each filter.
//
//
type PropertyFilterUpdate struct {
	*DynamicData

	// Filter that was updated.
	Filter *PropertyFilter

	// Objects that could not be found on the server, but were specified in a
	// objectSet.
	//
	// This field will only be populated for objects that were determined
	// to be missing since the data version passed to CheckForUpdates, WaitForUpdates, or WaitForUpdatesEx and will not contain objects that were missing
	// prior to that data version.
	MissingSet []*MissingObject

	// Set of changes to object properties in the filter.
	ObjectSet []*ObjectUpdate
}

//
// Within a PropertyFilterSpec, A PropertySpec specifies which properties should be
// reported to the client for objects of the given managed object type that
// are visited and not skipped.  One more subtle side effect is that if a
// managed object is visited and not skipped, but there is no PropertySpec associated with the managed object's
// type, the managed object will not be reported to the client.
//
// Also, the set of properties applicable to a given managed object type
// is the union of the properties implied by the PropertySpec objects even, in the case of a RetrieveResult, where there may be an applicable
// PropertySpec in more than one filter.
//
//
//
type PropertySpec struct {
	*DynamicData

	// Specifies whether or not all properties of the object are read. If
	// this property is set to true, the pathSet property is ignored.
	All bool

	// Specifies which managed object properties are retrieved. If the pathSet is empty, then the
	// PropertyCollector retrieves references to the managed objects
	// and no managed object properties are collected.
	PathSet []string

	// Name of the managed object type being collected.
	// Allowable values are:
	//
	//
	// "Alarm" - Alarm Managed Object.
	//
	//
	// "AlarmManager" - AlarmManager Managed Object.
	//
	//
	// "AuthorizationManager" - AuthorizationManager Managed Object.
	//
	//
	// "ClusterComputeResource" - ClusterComputeResource Managed Object.
	//
	//
	// "ClusterProfile" - ClusterProfile Managed Object.
	//
	//
	// "ClusterProfileManager" - ClusterProfileManager Managed Object.
	//
	//
	// "ComputeResource" - ComputeResource Managed Object.
	//
	//
	// "ContainerView" - ContainerView Managed Object.
	//
	//
	// "CustomFieldsManager" - CustomFieldsManager Managed Object.
	//
	//
	// "CustomizationSpecManager" - CustomizationSpecManager Managed Object.
	//
	//
	// "Datacenter" - Datacenter Managed Object.
	//
	//
	// "Datastore" - Datastore Managed Object.
	//
	//
	// "DatastoreNamespaceManager" - DatastoreNamespaceManager Managed Object.
	//
	//
	// "DiagnosticManager" - DiagnosticManager Managed Object.
	//
	//
	// "DistributedVirtualPortgroup" - DistributedVirtualPortgroup Managed Object.
	//
	//
	// "DistributedVirtualSwitch" - DistributedVirtualSwitch Managed Object.
	//
	//
	// "DistributedVirtualSwitchManager" - DistributedVirtualSwitchManager Managed Object.
	//
	//
	// "EnvironmentBrowser" - EnvironmentBrowser Managed Object.
	//
	//
	// "EventHistoryCollector" - EventHistoryCollector Managed Object.
	//
	//
	// "EventManager" - EventManager Managed Object.
	//
	//
	// "ExtensibleManagedObject" - ExtensibleManagedObject Managed Object.
	//
	//
	// "ExtensionManager" - ExtensionManager Managed Object.
	//
	//
	// "FileManager" - FileManager Managed Object.
	//
	//
	// "Folder" - Folder Managed Object.
	//
	//
	// "GuestAuthManager" - GuestAuthManager Managed Object.
	//
	//
	// "GuestFileManager" - GuestFileManager Managed Object.
	//
	//
	// "GuestOperationsManager" - GuestOperationsManager Managed Object.
	//
	//
	// "GuestProcessManager" - GuestProcessManager Managed Object.
	//
	//
	// "HistoryCollector" - HistoryCollector Managed Object.
	//
	//
	// "HostActiveDirectoryAuthentication" - HostActiveDirectoryAuthentication Managed Object.
	//
	//
	// "HostAuthenticationManager" - HostAuthenticationManager Managed Object.
	//
	//
	// "HostAuthenticationStore" - HostAuthenticationStore Managed Object.
	//
	//
	// "HostAutoStartManager" - HostAutoStartManager Managed Object.
	//
	//
	// "HostBootDeviceSystem" - HostBootDeviceSystem Managed Object.
	//
	//
	// "HostCacheConfigurationManager" - HostCacheConfigurationManager Managed Object.
	//
	//
	// "HostCpuSchedulerSystem" - HostCpuSchedulerSystem Managed Object.
	//
	//
	// "HostDatastoreBrowser" - HostDatastoreBrowser Managed Object.
	//
	//
	// "HostDatastoreSystem" - HostDatastoreSystem Managed Object.
	//
	//
	// "HostDateTimeSystem" - HostDateTimeSystem Managed Object.
	//
	//
	// "HostDiagnosticSystem" - HostDiagnosticSystem Managed Object.
	//
	//
	// "HostDirectoryStore" - HostDirectoryStore Managed Object.
	//
	//
	// "HostEsxAgentHostManager" - HostEsxAgentHostManager Managed Object.
	//
	//
	// "HostFirewallSystem" - HostFirewallSystem Managed Object.
	//
	//
	// "HostFirmwareSystem" - HostFirmwareSystem Managed Object.
	//
	//
	// "HostGraphicsManager" - HostGraphicsManager Managed Object.
	//
	//
	// "HostHealthStatusSystem" - HostHealthStatusSystem Managed Object.
	//
	//
	// "HostImageConfigManager" - HostImageConfigManager Managed Object.
	//
	//
	// "HostKernelModuleSystem" - HostKernelModuleSystem Managed Object.
	//
	//
	// "HostLocalAccountManager" - HostLocalAccountManager Managed Object.
	//
	//
	// "HostLocalAuthentication" - HostLocalAuthentication Managed Object.
	//
	//
	// "HostMemorySystem" - HostMemorySystem Managed Object.
	//
	//
	// "HostNetworkSystem" - HostNetworkSystem Managed Object.
	//
	//
	// "HostPatchManager" - HostPatchManager Managed Object.
	//
	//
	// "HostPciPassthruSystem" - HostPciPassthruSystem Managed Object.
	//
	//
	// "HostPowerSystem" - HostPowerSystem Managed Object.
	//
	//
	// "HostProfile" - HostProfile Managed Object.
	//
	//
	// "HostProfileManager" - HostProfileManager Managed Object.
	//
	//
	// "HostServiceSystem" - HostServiceSystem Managed Object.
	//
	//
	// "HostSnmpSystem" - HostSnmpSystem Managed Object.
	//
	//
	// "HostStorageSystem" - HostStorageSystem Managed Object.
	//
	//
	// "HostSystem" - HostSystem Managed Object.
	//
	//
	// "HostVFlashManager" - HostVFlashManager Managed Object.
	//
	//
	// "HostVirtualNicManager" - HostVirtualNicManager Managed Object.
	//
	//
	// "HostVMotionSystem" - HostVMotionSystem Managed Object.
	//
	//
	// "HostVsanInternalSystem" - HostVsanInternalSystem Managed Object.
	//
	//
	// "HostVsanSystem" - HostVsanSystem Managed Object.
	//
	//
	// "HttpNfcLease" - HttpNfcLease Managed Object.
	//
	//
	// "InventoryView" - InventoryView Managed Object.
	//
	//
	// "IpPoolManager" - IpPoolManager Managed Object.
	//
	//
	// "IscsiManager" - IscsiManager Managed Object.
	//
	//
	// "LicenseAssignmentManager" - LicenseAssignmentManager Managed Object.
	//
	//
	// "LicenseManager" - LicenseManager Managed Object.
	//
	//
	// "ListView" - ListView Managed Object.
	//
	//
	// "LocalizationManager" - LocalizationManager Managed Object.
	//
	//
	// "ManagedEntity" - ManagedEntity Managed Object.
	//
	//
	// "ManagedObjectView" - ManagedObjectView Managed Object.
	//
	//
	// "Network" - Network Managed Object.
	//
	//
	// "OpaqueNetwork" - OpaqueNetwork Managed Object.
	//
	//
	// "OptionManager" - OptionManager Managed Object.
	//
	//
	// "OvfManager" - OvfManager Managed Object.
	//
	//
	// "PerformanceManager" - PerformanceManager Managed Object.
	//
	//
	// "Profile" - Profile Managed Object.
	//
	//
	// "ProfileComplianceManager" - ProfileComplianceManager Managed Object.
	//
	//
	// "ProfileManager" - ProfileManager Managed Object.
	//
	//
	// "PropertyCollector" - PropertyCollector Managed Object.
	//
	//
	// "PropertyFilter" - PropertyFilter Managed Object.
	//
	//
	// "ResourcePlanningManager" - ResourcePlanningManager Managed Object.
	//
	//
	// "ResourcePool" - ResourcePool Managed Object.
	//
	//
	// "ScheduledTask" - ScheduledTask Managed Object.
	//
	//
	// "ScheduledTaskManager" - ScheduledTaskManager Managed Object.
	//
	//
	// "SearchIndex" - SearchIndex Managed Object.
	//
	//
	// "ServiceInstance" - ServiceInstance Managed Object.
	//
	//
	// "ServiceManager" - ServiceManager Managed Object.
	//
	//
	// "SessionManager" - SessionManager Managed Object.
	//
	//
	// "SimpleCommand" - SimpleCommand Managed Object.
	//
	//
	// "StoragePod" - StoragePod Managed Object.
	//
	//
	// "StorageResourceManager" - StorageResourceManager Managed Object.
	//
	//
	// "Task" - Task Managed Object.
	//
	//
	// "TaskHistoryCollector" - TaskHistoryCollector Managed Object.
	//
	//
	// "TaskManager" - TaskManager Managed Object.
	//
	//
	// "UserDirectory" - UserDirectory Managed Object.
	//
	//
	// "View" - View Managed Object.
	//
	//
	// "ViewManager" - ViewManager Managed Object.
	//
	//
	// "VirtualApp" - VirtualApp Managed Object.
	//
	//
	// "VirtualDiskManager" - VirtualDiskManager Managed Object.
	//
	//
	// "VirtualizationManager" - VirtualizationManager Managed Object.
	//
	//
	// "VirtualMachine" - VirtualMachine Managed Object.
	//
	//
	// "VirtualMachineCompatibilityChecker" - VirtualMachineCompatibilityChecker Managed Object.
	//
	//
	// "VirtualMachineProvisioningChecker" - VirtualMachineProvisioningChecker Managed Object.
	//
	//
	// "VirtualMachineSnapshot" - VirtualMachineSnapshot Managed Object.
	//
	//
	// "VmwareDistributedVirtualSwitch" - VmwareDistributedVirtualSwitch Managed Object.
	Type string
}

//
// Thrown when an operation cannot be performed on a virtual machine
// because it has a pending question requiring user input.
//
//
type QuestionPending struct {
	*InvalidState

	// Text of the question from the virtual machine.
	Text string
}

//
// A QuiesceDatastoreIOForHAFailed fault occurs when the HA agent on a host
// cannot quiesce file activity on a datastore to be unmouonted or removed.
//
//
type QuiesceDatastoreIOForHAFailed struct {
	*ResourceInUse

	// The datastore.
	Ds *Datastore

	// Name of the datastore.
	DsName string

	// The host.
	Host *HostSystem

	// Name of the host.
	HostName string
}

//
// The virtual machine is using an RDM device with compatibility
// mode set to 'physicalMode' and operation is unable to convert
// the disk to a different type.
//
//
type RDMConversionNotSupported struct {
	*MigrationFault

	// The name of the disk device using the RDM.
	Device string
}

//
// The virtual machine is configured with a Raw Disk Mapping. The host only supports Raw
// Disk Mappings in a limited fashion. After the migration, the RDM will function correctly,
// but it will be indistinguishable from a virtual disk when viewing the virtual machine's
// properties. This change will persist even if the virtual machine is migrated
// back to a host with full RDM support.
//
// This is a warning only for migrations to ESX 2.1.x hosts.
//
//
//
type RDMNotPreserved struct {
	*MigrationFault

	// The name of the disk device using the RDM.
	Device string
}

//
// The virtual machine is configured with a Raw Disk Mapping. This is not
// supported on the host.
//
//
type RDMNotSupported struct {
	*DeviceNotSupported
}

//
// The virtual machine is configured with a Raw Disk Mapping. This is not
// supported on the datastore.
//
//
type RDMNotSupportedOnDatastore struct {
	*VmConfigFault

	// The datastore.
	Datastore *Datastore

	// The name of the datastore.
	DatastoreName string

	// The label of the RDM device that would have its backing placed on
	// the datastore.
	// This is not guaranteed to be the only such device.
	Device string
}

//
// One of the virtual machine's virtual disks is a Raw Disk Mapping
// that is itself accessible, but points to a LUN that is inaccessible.
//
//
type RDMPointsToInaccessibleDisk struct {
	*CannotAccessVmDisk
}

//
// The virtual machine has a raw disk attached that is not supported. This is often
// used as a subfault for DisallowedMigrationDeviceAttached or
// DisallowedSnapshotDeviceAttached.
//
//
type RawDiskNotSupported struct {
	*DeviceNotSupported
}

//
// Fault thrown on host connect if we were unable to correctly read the
// existing tree on the root. This is bad because then we don't know the
// available resources on the host, and all kinds of admission control will
// fail.
//
// This just allows for more robust error handling - we should be able to
// read the existing hierarchy under normal conditions.
//
//
type ReadHostResourcePoolTreeFailed struct {
	*HostConnectFault
}

//
// The virtual machine uses read-only (undoable or nonpersistent) disks that
// can cause a slower power on at the migration destination. As a result, VMtion
// could slow down considerably or timeout. This is an issue only for migration of
// powered-on virtual machines from an ESX host with version greater
// than 2.0.x to an ESX host with version 2.0.x. It will be an error if the
// number of such disks is great enough to cause timeout ( &gt;= 3 ), or a warning
// otherwise.
//
//
type ReadOnlyDisksWithLegacyDestination struct {
	*MigrationFault

	// The number of read-only disks in use.
	RoDiskCount int32

	// Whether this number of disks will cause a timeout failure.
	TimeoutDanger bool
}

//
// This fault is thrown if a patch install fails because an installed
// nonchainable patch has not taken effect.
//
//
type RebootRequired struct {
	*VimFault

	// The nonchainable patch installed.
	Patch string
}

//
// List of defined migration reason codes:
//
//
type RecommendationReasonCode struct {
}

//
// Pre-defined constants for possible recommendation types. Virtual Center
// uses this information to coordinate with the clients.
//
//
type RecommendationType struct {
}

//
// Fault thrown if a record or replay operation cannot be performed
// because these capabilities have been disabled on the virtual machine.
//
//
type RecordReplayDisabled struct {
	*VimFault
}

//
// This event is generated when recovery takes place on a management vmknic
//
//
type RecoveryEvent struct {
	*DvsEvent

	// The uuid of the DVS
	DvsUuid string

	// The host on which recovery happened
	HostName string

	// The key of the new port
	PortKey string

	// The virtual management NIC device where recovery was done
	Vnic string
}

//
// The RecurrentTaskScheduler data object is the base type for
// the hierarchy that includes hourly, daily, weekly, and monthly task schedulers.
//
//
type RecurrentTaskScheduler struct {
	*TaskScheduler

	// How often to run the scheduled task. The value must be greater than
	// or equal to 1 and less than 1000. The default value is 1.
	// The interval acts as a multiplier for the unit of time associated
	// with a particular scheduler (hours, days, weeks, or months).
	// For example, setting the HourlyTaskScheduler interval
	// to 4 causes the task to run every 4 hours.
	Interval int32
}

//
// The virtual machine has a currently connected device with a remote backing.
// This is an error when migrating a powered-on virtual machine, and can be returned
// as a subfault of DisallowedMigrationDeviceAttached.
//
//
type RemoteDeviceNotSupported struct {
	*DeviceNotSupported
}

//
// Remote Tech Support Mode for the host has been enabled.
//
//
type RemoteTSMEnabledEvent struct {
	*HostEvent
}

//
// This fault is thrown when the client attempts to remove an object that has
// active related objects (for example, a role that has active permissions).
//
//
type RemoveFailed struct {
	*VimFault
}

//
// Base type for Replication-related configuration errors.
//
//
type ReplicationConfigFault struct {
	*ReplicationFault
}

//
// A ReplicationDiskConfigFault is thrown when there is an issue with
// configuring disk replication properties.
//
//
type ReplicationDiskConfigFault struct {
	*ReplicationConfigFault

	// The disk (device) key in the parent VM for identification
	// purposes.
	Key int32

	// The reason for the failure. One of the above.
	Reason string

	// The virtual machine, for identification purposes.
	VmRef *VirtualMachine
}

type ReplicationDiskConfigFaultReasonForFault struct {
}

//
// Base type for Replication-related errors.
//
//
type ReplicationFault struct {
	*VimFault
}

//
// Used to indicate that FT cannot be enabled on a replicated virtual machine
// (returned by QueryFaultToleranceCompatibility).
//
//
type ReplicationIncompatibleWithFT struct {
	*ReplicationFault
}

//
// The ReplicationConfigSpec.DiskSettings object type encapsulates
// the replication properties of a replicated disk of a replicated
// virtual machine.
//
//
type ReplicationInfoDiskSettings struct {
	*DynamicData

	// An opaque identifier that uniquely identifies a replicated
	// disk between primary and secondary sites.
	DiskReplicationId string

	// The disk's device key in the VM's configuration. Used to
	// uniquely identify the disk to be configured for replication
	// in the primary VM.
	Key int32
}

//
// A ReplicationInvalidOptions fault is thrown when the options
// string passed contains invalid characters or broken format.
//
//
type ReplicationInvalidOptions struct {
	*ReplicationFault

	// Entity, if any, that has invalid options.
	Entity *ManagedEntity

	// The invalid options string.
	Options string
}

//
// Thrown if the replication module is not loaded in the host.
//
//
type ReplicationNotSupportedOnHost struct {
	*ReplicationFault
}

//
// A ReplicationVmConfigFault is thrown when there is an issue with
// configuring VM-wide replication properties.
//
//
type ReplicationVmConfigFault struct {
	*ReplicationConfigFault

	// The reason for the failure. One of the above.
	Reason string

	// The virtual machine, for identification purposes.
	VmRef *VirtualMachine
}

type ReplicationVmConfigFaultReasonForFault struct {
}

//
// A ReplicationVmFault is thrown when there is an issue with
// an operation performed on a replicated VirtualMachine
//
//
type ReplicationVmFault struct {
	*ReplicationFault

	// The name of the instance currently being created.
	InstanceId string

	// The reason for the failure. One of the above.
	Reason string

	// The current ReplicationVmState of the
	// VirtualMachine
	State string

	// The virtual machine, for identification purposes.
	Vm *VirtualMachine
}

type ReplicationVmFaultReasonForFault struct {
}

//
// A set of statistics related to the progress of the current
// operation (full sync or lwd).
//
//
type ReplicationVmProgressInfo struct {
	*DynamicData

	// The total number of bytes to be transferred.
	//
	// For lwd operations, this is the total size of the disk images that
	// are transferring. This is known from the start and will not change
	// during a lwd operation.
	//
	// For sync operations, this is the total size of the blocks that have
	// been found not to match between the primary and secondary (by
	// comparing checksums). It starts from 0 and grows as the checksum
	// operations advance. The value includes (i.e. counts multiple times)
	// areas that will end up being transferred more than once (due to
	// stopping and continuing the operation, or for some errors).
	BytesToTransfer int64

	// Number of bytes transferred so far.
	//
	// For sync operations, this value includes (i.e. counts multiple
	// times) areas that were transferred multiple times (due to stopping
	// and continuing the operation, or for some errors).
	BytesTransferred int64

	// The total number of bytes that were checksummed, only present for
	// sync tasks.
	ChecksumComparedBytes int64

	// The total number of bytes to be checksummed, only present for sync
	// tasks. This is the total size of all disks.
	ChecksumTotalBytes int64

	// An estimation of the operation progress as a percentage completed,
	// from 0 to 100.
	Progress int32
}

//
// Describes the current state of a replicated VirtualMachine
//
//
type ReplicationVmState struct {
}

//
// A RequestCanceled fault is thrown if the user canceled the task.
//
//
type RequestCanceled struct {
	*RuntimeFault
}

//
// The ResourceAllocationInfo data object specifies the reserved resource
// requirement as well as the limit (maximum allowed usage) for a given
// kind of resource. This is specified for both memory
// allocation (specified in MB) and CPU allocation (specified in MHz).
//
// For a ResourcePool, the ResourceAllocationInfo object describes
// both the guaranteed amount of the resource (reservation)
// and whether or not it is expandable
// (expandableReservation).
// If expandableReservation is true, then the resource pool can grow its reservation
// dynamically by  borrowing unreserved resources from its parent resource pool.
// For the methods CreateResourcePool,
// CreateVApp and ImportVApp,
// you must provide values for all properties except overheadLimit; they are not optional.
// (Currently, overheadLimit is for vCenter Server use only.)
//
//
// If the limit is configured, it must be greater than or equal to the
// reservation.
//
//
//
type ResourceAllocationInfo struct {
	*DynamicData

	// In a resource pool with an expandable reservation, the reservation on a resource
	// pool can grow beyond the specified value, if the parent resource pool has
	// unreserved resources.  A non-expandable reservation is called a fixed
	// reservation. This property is ignored for virtual machines.
	ExpandableReservation bool

	// The utilization of a virtual machine/resource pool will not exceed this limit, even
	// if there are available resources. This is typically used to ensure a consistent
	// performance of virtual machines / resource pools independent of available resources.
	// If set to -1, then there is no fixed limit on resource usage (only bounded by available
	// resources and shares). Units are MB for memory, MHz for CPU.
	Limit int64

	// The maximum allowed overhead memory. For a powered on virtual
	// machine, the overhead memory reservation cannot be larger than its
	// overheadLimit. This property is only applicable to powered on
	// virtual machines and is not persisted across reboots. This property
	// is not applicable for resource pools.  If set to -1, then there is
	// no limit on reservation. Units are MB.
	//
	// Note: For vCenter Server use only. Not available for other clients
	// at this time.
	// The server will throw an exception if you attempt to set
	// this property.
	//
	// Since VI API 2.5
	OverheadLimit int64

	// Amount of resource that is guaranteed available to the virtual machine or
	// resource pool. Reserved resources are not wasted if they are not used. If
	// the utilization is less than the reservation, the resources can be utilized by
	// other running virtual machines. Units are MB for memory, MHz for CPU.
	Reservation int64

	// Memory shares are used in case of resource contention.
	Shares *SharesInfo
}

//
// The ResourceAllocationOption data object specifies value ranges and
// default values for ResourceAllocationInfo.
//
//
type ResourceAllocationOption struct {
	*DynamicData

	// Default value and value range for shares.
	SharesOption *SharesOption
}

//
// This data object type is a default value and value range specification
// for ResourceConfigSpec object.
//
//
type ResourceConfigOption struct {
	*DynamicData

	// Resource allocation options for CPU.See ResourceAllocationInfo
	CpuAllocationOption *ResourceAllocationOption

	// Resource allocation options for memory.See ResourceAllocationInfo
	MemoryAllocationOption *ResourceAllocationOption
}

//
// This data object type is a specification for a set of resources
// allocated to a virtual machine or a resource pool.
//
//
type ResourceConfigSpec struct {
	*DynamicData

	// The changeVersion is a unique identifier for a given version
	// of the configuration. Each change to the configuration will
	// update this value. This is typically implemented as an ever
	// increasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	//
	// If specified when updating the resource config., the
	// changes will only be applied if the current changeVersion matches the
	// specified changeVersion. This field can be used to guard against updates that
	// has happened between the configInfo was read and until it is applied.
	ChangeVersion string

	// Resource allocation for CPU.
	CpuAllocation *ResourceAllocationInfo

	// Reference to the entity with this resource specification:
	// either a VirtualMachine or a ResourcePool.
	Entity *ManagedEntity

	// Timestamp when the resources were last modified. This is ignored when
	// the object is used to update a configuration.
	LastModified time.Time

	// Resource allocation for memory.
	MemoryAllocation *ResourceAllocationInfo
}

//
// A ResourceInUse fault indicating that some error has occurred because a
// resource was in use.  Information about the resource that is in use may
// be supplied.
//
//
type ResourceInUse struct {
	*VimFault

	// Name of the instance of the resource that is in use.
	Name string

	// Type of resource that is in use.
	Type string
}

//
// A ResourceNotAvailable fault indicating that some error has occurred because a
// resource was not available.  Information about the resource that is in use may
// be supplied.
//
//
type ResourceNotAvailable struct {
	*VimFault

	// Name of container that contains the resource. .
	ContainerName string

	// Type of container that contains the resource.
	ContainerType string

	// Type of resource that is not available.
	Type string
}

type ResourcePlanningManager struct {
	*ManagedObject
}

//
// Estimates the database size required to store VirtualCenter data.
//
//
//
// Required Privileges
// System.Read
//
func (mo *ResourcePlanningManager) EstimateDatabaseSize(
	_this *ManagedObjectReference, dbSizeParam *DatabaseSizeParam,
) (*DatabaseSizeEstimate, error) {

	return nil, nil

}

//
// Represents a set of physical resources: a single host,
// a subset of a host's resources, or resources spanning multiple hosts.
// Resource pools can be subdivided by creating child resource pools. In
// order to run, a virtual machine must be associated as a child of a resource
// pool.
//
// In a parent/child hierarchy of resource pools and virtual machines, the
// single resource pool that has no parent pool is known as the root resource
// pool.
//
//
// Configuration
//
//
// A resource pool is configured with a set of CPU (in MHz) and memory (in MB)
// resources. These resources are specified in absolute terms with a resource
// reservation and a resource limit, along with a shares setting. The shares
// are used during resource contention, to ensure graceful degradation.
//
//
// For the root resource pool, the values of the reservation and
// the limit are set by the system and are not configurable. The
// reservation and limit are set to the same value, indicating the total amount
// of resources the system has available to run virtual machines. This is
// computed as the aggregated CPU and memory resources provided by the set
// of current available hosts in the parent compute resource minus the
// overhead of the virtualization layer.
//
//
// Since the resource pool configuration is absolute (in MHz or MB), the
// configuration can become invalid when resources are removed.  This can
// happen if a host is removed from the cluster, if a host becomes
// unavailable, or if a host is placed in maintenance mode. When this
// happens, the system flags misconfigured resource pools and displays the
// reservations and limits that are in effect. Further, in a DRS enabled cluster,
// the tree can be misconfigured if the user bypasses VirtualCenter and powers on
// VMs directly on the host.
//
//
// A General Discussion of Resource pool states and admission control
//
// There are three states that the resource pool tree can be in: undercommited
// (green), overcommited (yellow), and inconsistent (red). Depending on the
// state, different resource pool configuration policies are enforced. The
// states are described in more detail below:
//
//
//
// •  GREEN (aka undercommitted): We have a tree that is
// in a good state. Every node has a reservation greater than the sum of
// the reservations for its children. We have enough capacity at the root to
// satisfy all the resources reserved by the children. All operations
// performed on the tree, such as powering on virtual machines, creating
// new resource pools, or reconfiguring resource settings, will ensure
// that the above constraints are maintained.
//
//
// •  RED (aka. inconsistent): One or more nodes in the
// tree has children whose reservations are greater than the node is configured to
// support. For example, i) a resource pool with a fixed reservation has a running
// virtual machine with a reservation that is higher than the reservation on
// resource pool itself., or ii) the child reservations are greater than the limit.
//
// In this state, the DRS algorithm is disabled until the resource pool tree's
// configuration has  been brought back into a consistent state. We also restrict
// the resources that such invalid nodes request from their parents to the
// configured reservation/limit, in an attempt to isolate the problem to a small
// subtree. For the rest of the tree, we determine whether the cluster is
// undercommitted or overcommitted according to the existing rules and perform
// admission control accordingly.
//
//
// Note that since all changes to the resource settings are validated on the
// VirtualCenter server, the system cannot be brought into this state by simply
// manipulating a cluster resource pool tree through  VirtualCenter. It can only
// happen if a virtual machine gets powered on directly on a host that is part of
// a DRS cluster.
//
//
//
//
// •  YELLOW (aka overcommitted): In this state, the tree is
// consistent internally, but the root resource pool does not have the capacity at
// to meet the reservation of its children. We can only go from GREEN -&gt; YELLOW if
// we lose resources at the root. For example, hosts becomes unavailable or is
// put into maintenance mode. Note that we will always have enough capacity at the root
// to run all currently powered on VMs. However, we may not be able to satisfy all
// resource pool reservations in the tree. In this state, the reservation configured for
// a resource pool is no longer guaranteed, but the limits are still enforced.
// This provides additional flexibility for bringing the tree back into a
// consistent state, without risking bringing the tree into a RED state. In
// more detail:
//
//
// •  Resource Pool The root is considered to have unlimited
// capacity. You can reserve resources without any check except the
// requirement that the tree remains consistent. This means that
// nodes whose parents are all configured with expandable reservations and no limit
// will have unlimited available resources. However, if there is an ancestor with
// a fixed reservation or an expandable reservation with a limit somewhere, then the
// node will be limited by the reservation/limit of the ancestor.
//
//
// •  Virtual Machine Virtual machines are limited by ancestors
// with a fixed reservation and the capacity at the root.
//
//
//
//
//
//
//
//
//
//
// Destroying a ResourcePool
//
//
// When a ResourcePool is destroyed, all the virtual machines are reassigned to its
// parent pool. The root resource pool cannot be destroyed, and invoking destroy
// on it will throw an InvalidType fault.
//
//
// Any vApps in the ResourcePool will be moved to the ResourcePool's parent
// before the pool is destroyed.
//
//
// The Resource.DeletePool privilege must be held on the pool as well as the parent
// of the resource pool.  Also, the Resource.AssignVMToPool privilege must be held
// on the resource pool's parent pool and any virtual machines that are reassigned.
//
//
//
type ResourcePool struct {
	*ManagedEntity

	childConfiguration []*ResourceConfigSpec

	config *ResourceConfigSpec

	owner *ComputeResource

	resourcePool []*ResourcePool

	runtime *ResourcePoolRuntimeInfo

	summary *ResourcePoolSummary

	vm []*VirtualMachine
}

// The resource configuration of all direct children (VirtualMachine and
// ResourcePool) of this resource group.
func (mo *ResourcePool) ChildConfiguration() ([]*ResourceConfigSpec, error) {
	t, err := mo.currentProperty("childConfiguration")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ResourceConfigSpec)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ResourceConfigSpec")
	}
	return v, nil
}

// Configuration of this resource pool.
func (mo *ResourcePool) Config() (*ResourceConfigSpec, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ResourceConfigSpec)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ResourceConfigSpec")
	}
	return v, nil
}

// The ComputeResource to which this set of one or more nested resource pools
// belong.
// Required Privilege: System.View
func (mo *ResourcePool) Owner() (*ComputeResource, error) {
	t, err := mo.currentProperty("owner")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ComputeResource)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ComputeResource")
	}
	return v, nil
}

// The set of child resource pools.
// Required Privilege: System.View
func (mo *ResourcePool) ResourcePool() ([]*ResourcePool, error) {
	t, err := mo.currentProperty("resourcePool")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ResourcePool)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ResourcePool")
	}
	return v, nil
}

// Runtime information about a resource pool.
// The ResourcePoolResourceUsage information within
// ResourcePoolRuntimeInfo can be transiently stale.
// Use RefreshRuntime method to
// update the information.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
func (mo *ResourcePool) Runtime() (*ResourcePoolRuntimeInfo, error) {
	t, err := mo.currentProperty("runtime")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ResourcePoolRuntimeInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ResourcePoolRuntimeInfo")
	}
	return v, nil
}

// Basic information about a resource pool.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
func (mo *ResourcePool) Summary() (*ResourcePoolSummary, error) {
	t, err := mo.currentProperty("summary")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ResourcePoolSummary)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ResourcePoolSummary")
	}
	return v, nil
}

// The set of virtual machines associated with this resource pool.
// Required Privilege: System.View
func (mo *ResourcePool) Vm() ([]*VirtualMachine, error) {
	t, err := mo.currentProperty("vm")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*VirtualMachine)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*VirtualMachine")
	}
	return v, nil
}

//
// Creates a new virtual machine in a vApp container.
//
// This method supports creating a virtual machine directly in a vApp. A
// virtual  machine in a vApp is not associated with a VM folder and therefore
// cannot be created using the method on a Folder.
//
//
// This method can only be called directly on a vApp
// or on a resource pool that is a child of a vApp.
//
//
// The privilege VirtualMachine.Inventory.Create is required on this entity. Further,
// if this is a resource pool, the privilege Resource.AssignVMToPool is required. If
// this is a vApp, the privilege VApp.AssignVM is required.
//
//
// Depending on the properties of the virtual machine bring created, additional
// privileges may be required. See CreateVM_Task for a description of
// these privileges.
//
//
// Required Privileges
// VirtualMachine.Inventory.Create
// Since
// vSphere API 4.0
//
func (mo *ResourcePool) CreateChildVM_Task(
	_this *ManagedObjectReference, config *VirtualMachineConfigSpec, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Creates a new resource pool.
//
// In the ResourceConfigSpec, all values in ResourceAllocationInfo must be supplied;
// they are not optional.
//
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// Required Privileges
// Resource.CreatePool
//
func (mo *ResourcePool) CreateResourcePool(
	_this *ManagedObjectReference, name string, spec *ResourceConfigSpec,
) (*ResourcePool, error) {

	return nil, nil

}

//
// Creates a new vApp container.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// Required Privileges
// VApp.Create
// Since
// vSphere API 4.0
//
func (mo *ResourcePool) CreateVApp(
	_this *ManagedObjectReference, name string, resSpec *ResourceConfigSpec, configSpec *VAppConfigSpec, vmFolder *Folder,
) (*VirtualApp, error) {

	return nil, nil

}

//
// Removes all child resource pools recursively. All virtual machines and vApps
// associated with the child resource pools get associated with this resource pool.
//
//
// Note that resource pools contained in child vApps are not affected.
//
//
//
// The privilege checks performed are the following.
//
//
//
//
// • Resource.DeletePool privilege must be held on this object and each of it's
// immediate children to be destroyed.
//
// • If VMs are being moved, the privilege Resource.AssignVMToPool must be held
// on this resource pool as well as on any virtual machines being moved.
//
// • If vApps are being moved, the privilege Resource.AssignVAppToPool
// must be held on this resource pool as well as on any vApps being
// moved.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *ResourcePool) DestroyChildren(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Creates a new entity in this resource pool. The import process consists of two
// steps:
//
//
// • Create the VMs and/or vApps that make up the entity.
//
// • Upload virtual disk contents.
//
//
// In step 1, the client must wait for the server to create all inventory
// objects. It does that by monitoring the state
// property on the HttpNfcLease object returned from this call.
// When the server is done creating objects, the lease will change to the
// ready state, and step 2 begins. If an error occurs while the server is
// creating inventory objects, the lease will change to the error state, and
// the import process is aborted.
//
//
// In step 2, the client uploads disk contents using the URLs provided in the
// info property of the lease. The client must call
// HttpNfcLeaseProgress on the lease periodically to keep the
// lease alive and report progress to the server. Failure to do so will cause
// the lease to time out, and the import process will be aborted.
//
//
//
// When the client is done uploading disks, it completes the lease by calling
// HttpNfcLeaseComplete. The client can also abort the import
// process by calling HttpNfcLeaseAbort.
//
//
//
// If the import process fails, is aborted, or times out, all created inventory
// objects are removed, including all virtual disks.
//
//
//
// This operation only works if the folder's childType includes VirtualMachine.
//
//
// Depending on the properties of the virtual machine bring imported, additional
// privileges may be required. See CreateVM_Task for a description of
// these privileges.
//
//
// Required Privileges
// VApp.Import
// Since
// vSphere API 4.0
//
func (mo *ResourcePool) ImportVApp(
	_this *ManagedObjectReference, spec *ImportSpec, folder *Folder, host *HostSystem,
) (*HttpNfcLease, error) {

	return nil, nil

}

//
// Moves a set of resource pools, vApps or virtual machines into this pool.  The
// pools, vApps and virtual machines must be part of the cluster or standalone
// host that contains this pool.
//
// For each entity being moved, the move is subject to the following privilege
// checks:
//
//
//
// • If the object being moved is a ResourcePool, then Resource.MovePool must be
// held on the pool being moved and it's former parent pool or vApp. If the
// target is a vApp, the privilege VApp.AssignResourcePool must be held on
// it. If the target is a ResourcePool, Resource.MovePool must be held on it.
//
//
// • If the object being moved is a VirtualApp, VApp.Move must be held on
// the vApp being moved and it's former parent pool or vApp. If the target
// entity is a resource pool, Resource.AssignVAppToPool must be held on the
// target. If the target is a vApp, the privilege VApp.AssignVApp must
// be held on the target vApp.
//
//
// • If the object being moved is a VirtualMachine, then if the target is a
// ResourcePool, Resource.AssignVMToPool is required on the VirtualMachine and the
// target pool.  If the target is a vApp, VApp.AssignVM is required on both
// the VirtualMachine and the target pool.
//
//
//
//
//
// This operation is typically used by clients when they implement a drag-and-drop
// interface to move a set of objects into a folder.
//
//
// This operation is only transactional with respect to each individual entity.
// The set of entities is moved sequentially, as specified in the list,
// and committed one at a time. If a failure is detected, then the method
// terminates with an exception.
//
//
// The root resource pool cannot be moved.
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *ResourcePool) MoveIntoResourcePool(
	_this *ManagedObjectReference, list []*ManagedEntity,
) error {

	return nil

}

//
// Get a value range and default values for ResourceConfigSpec.
//
// Required Privileges
// Resource.EditPool
// Since
// vSphere API 4.1
//
func (mo *ResourcePool) QueryResourceConfigOption(
	_this *ManagedObjectReference,
) (*ResourceConfigOption, error) {

	return nil, nil

}

//
// Refreshes the resource usage data that is available in
// ResourcePoolRuntimeInfo.
// The latest runtime resource usage of this resource pool may not be
// available immediately after operations that alter resource usage,
// such as powering on a virtual machine. Invoke this method when resource
// usage may have recently changed, and the most up-to-date value in the
// ResourcePoolRuntimeInfo is needed.
//
// Required Privileges
// System.View
// Since
// vSphere API 4.1
//
func (mo *ResourcePool) RefreshRuntime(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Adds an existing virtual machine to this resource pool or vApp.
//
// This operation only works for vApps or resource pools that are children of
// vApps. To register a VM in a folder, see RegisterVM_Task.
//
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
// In addition to the VirtualMachine.Inventory.Register privilege, it
// requires System.Read privilege on the datastore that the existing virtual
// machine resides on.
//
//
// Required Privileges
// VirtualMachine.Inventory.Register
// Since
// vSphere API 4.0
//
func (mo *ResourcePool) RegisterChildVM_Task(
	_this *ManagedObjectReference, path string, name string, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Changes resource configuration of a set of children of this resource pool. The
// method allows bulk modifications of the set of the direct children
// (virtual machines and resource pools).
//
// Bulk modifications are not transactional. Each modification is made individually.
// If a failure is encountered while applying the changes, then the processing stops,
// meaning at least one and as many as all of the changes are not applied.
//
//
// A set can include a subset of the resources. Children that are not
// mentioned in the list are not changed.
//
//
// For each ResourceConfigSpec, the following privilege checks apply:
//
//
//
// • If the ResourceConfigSpec refers to a child resource pool or a child
// vApp, the privileges required are the same as would be required for
// calling UpdateConfig on that entity.
//
// • If the ResourceConfigSpec refers to a virtual machine,
// VirtualMachine.Config.Resource must be held on the virtual machine.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *ResourcePool) UpdateChildResourceConfiguration(
	_this *ManagedObjectReference, spec []*ResourceConfigSpec,
) error {

	return nil

}

//
// Updates the configuration of the resource pool.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// The privilege checks for this operation are as follows:
//
//
//
// • If this is a resource pool, the privilege Resource.EditPool is required on
// this and on the parent pool or vApp.
//
// • If this is a vApp, the privilege VApp.ResourceConfig is required on
// this and on the parent pool or vApp.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *ResourcePool) UpdateConfig(
	_this *ManagedObjectReference, name string, config *ResourceConfigSpec,
) error {

	return nil

}

//
// This event records when a new resource pool is created.
//
//
type ResourcePoolCreatedEvent struct {
	*ResourcePoolEvent

	// The parent resource pool that new resource pool belongs to.
	Parent *ResourcePoolEventArgument
}

//
// This event records when a resource pool is destroyed.
//
//
type ResourcePoolDestroyedEvent struct {
	*ResourcePoolEvent
}

//
// This event is the base class for all resource pool events.
//
//
type ResourcePoolEvent struct {
	*Event

	ResourcePool *ResourcePoolEventArgument
}

//
// The event argument is a ResourcePool object.
//
//
type ResourcePoolEventArgument struct {
	*EntityEventArgument

	// The ResourcePool object.
	ResourcePool *ResourcePool
}

//
// This event records when a resource pool is moved.
//
//
type ResourcePoolMovedEvent struct {
	*ResourcePoolEvent

	// The new parent of the resource Pool.
	NewParent *ResourcePoolEventArgument

	// The old parent of the resource Pool.
	OldParent *ResourcePoolEventArgument
}

//
// A set of statistics that are typically updated with near real-time regularity.
// These statistics are aggregates of the corresponding statistics of all virtual
// machines in the given resource pool, and unless otherwise noted, only make sense
// when at least one virtual machine in the given resource pool is powered on.
// This data object type does not support notification, for scalability reasons.
// Therefore, changes in QuickStats do not generate property collector updates. To
// monitor statistics values, use the statistics and alarms modules instead.
//
//
type ResourcePoolQuickStats struct {
	*DynamicData

	// The size of the balloon driver in a virtual machine, in MB. The host will
	// inflate the balloon driver to reclaim physical memory from a virtual machine.
	// This is a sign that there is memory pressure on the host.
	BalloonedMemory int64

	// The amount of compressed memory currently consumed by VM, in KB.
	//
	// Since vSphere API 4.1
	CompressedMemory int64

	// The amount of overhead memory, in MB, currently being consumed to run a VM.
	// This value is limited by the overhead memory reservation for a VM, stored
	// in overheadMemory.
	ConsumedOverheadMemory int64

	// This is the amount of CPU resource, in MHz, that this VM is entitled to, as
	// calculated by DRS. Valid only for a VM managed by DRS.
	DistributedCpuEntitlement int64

	// This is the amount of memory, in MB, that this VM is entitled to, as
	// calculated by DRS. Valid only for a VM managed by DRS.
	DistributedMemoryEntitlement int64

	// Guest memory utilization statistics, in MB. This
	// is also known as active guest memory. The number
	// can be between 0 and the configured memory size of
	// a virtual machine.
	GuestMemoryUsage int64

	// Host memory utilization statistics, in MB. This
	// is also known as consummed host memory. This is between 0 and
	// the configured resource limit. Valid while a virtual machine is
	// running. This includes the overhead memory of a virtual machine.
	HostMemoryUsage int64

	// Basic CPU performance statistics, in MHz.
	OverallCpuDemand int64

	// Basic CPU performance statistics, in MHz.
	OverallCpuUsage int64

	// The amount of memory resource (in MB) that will be used by
	// a virtual machine above its guest memory requirements.
	// This value is set if and only if a virtual machine is registered
	// on a host that supports memory resource allocation features.
	//
	// For powered off VMs, this is the minimum overhead required to
	// power on the VM on the registered host.
	//
	// For powered on VMs, this is the current overhead reservation, a
	// value which is almost always larger than the minimum overhead, and
	// which grows with time.See QueryMemoryOverheadEx
	OverheadMemory int64

	// The portion of memory, in MB, that is granted to a virtual machine from
	// non-shared host memory.
	PrivateMemory int64

	// The portion of memory, in MB, that is granted to a virtual machine from host
	// memory that is shared between VMs.
	SharedMemory int64

	// The static CPU resource entitlement for a virtual machine. This value is
	// calculated based on this virtual machine's resource reservations, shares
	// and limit, and doesn't take into account current usage. This is the worst
	// case CPU allocation for this virtual machine, that is, the amount of CPU
	// resource this virtual machine would receive if all virtual machines running
	// in the cluster went to maximum consumption. Units are MHz.
	StaticCpuEntitlement int32

	// The static memory resource entitlement for a virtual machine. This value is
	// calculated based on this virtual machine's resource reservations, shares
	// and limit, and doesn't take into account current usage. This is the worst
	// case memory allocation for this virtual machine, that is, the amount of
	// memory this virtual machine would receive if all virtual machines running
	// in the cluster went to maximum consumption. Units are MB.
	StaticMemoryEntitlement int32

	// The portion of memory, in MB, that is granted to a virtual machine from the
	// host's swap space. This is a sign that there is memory pressure on the host.
	SwappedMemory int64
}

//
// This event records when a resource pool configuration is changed.
//
//
type ResourcePoolReconfiguredEvent struct {
	*ResourcePoolEvent
}

//
// Specifies the resource usage for either memory
// or CPU. For CPU the unit is MHz, for memory the unit is bytes.
//
// In the typical case, where a resourcepool is in a consistent state,
// unreservedForVm will be equal to unreservedForPool. Hence, we
// can simply say talk about unreserved resources.
//
//
// If the reservation on the resource pool is not expandable, then
// the following is true:
//
// reservation = reservationUsed + unreserved
//
// If the reservation on the resource pool is expandable, then
// the following is true:
// reservation + parent.unreserved = reservationUsed + unreserved
//
//
//
type ResourcePoolResourceUsage struct {
	*DynamicData

	// Current upper-bound on usage. The upper-bound is based on the limit configured
	// on this resource pool, as well as limits configured on any parent resource
	// pool.
	MaxUsage int64

	// Close to real-time resource usage of all running child virtual machines,
	// including virtual machines in child resource pools.
	OverallUsage int64

	// Total amount of resources that have been used to satisfy the
	// reservation requirements of all descendants of this
	// resource pool (includes both resource pools and virtual
	// machines).
	ReservationUsed int64

	// Total amount of resources that have been used to satisfy the reservation
	// requirements of running virtual machines in this resource pool or any of its
	// child resource pools.
	ReservationUsedForVm int64

	// Total amount of resources available to satisfy a reservation
	// for a child resource pool. In the undercommitted state, this is
	// limited by the capacity at the root node. In the overcommitted case,
	// this could be higher since we do not perform the dynamic capacity
	// checks.
	UnreservedForPool int64

	// Total amount of resources available to satisfy a reservation for
	// a child virtual machine. In general, this should be the same as
	// unreservedForPool. However, in the overcommitted case, this
	// is limited by the remaining available resources at the root
	// node.
	UnreservedForVm int64
}

//
// Current runtime resource usage and state of the resource pool
//
//
type ResourcePoolRuntimeInfo struct {
	*DynamicData

	// Runtime resource usage for CPU. Values are in Mhz.
	Cpu *ResourcePoolResourceUsage

	// Runtime resource usage for memory. Values are in bytes.
	Memory *ResourcePoolResourceUsage

	// Overall health of the tree. See header for description of various
	// statuses and when they are set
	OverallStatus *enum.ManagedEntityStatus
}

//
// This data object type encapsulates a typical set of resource
// pool information that is useful for list views and summary pages.
//
//
type ResourcePoolSummary struct {
	*DynamicData

	// Current configuration of the resource pool.
	Config *ResourceConfigSpec

	// Total configured memory of all virtual machines in the resource pool, in MB.
	//
	// Since vSphere API 4.0
	ConfiguredMemoryMB int32

	// Name of resource pool.
	Name string

	// A set of statistics that are typically updated with near real-time regularity.
	// This data object type does not support notification, for scalability reasons.
	// Therefore, changes in QuickStats do not generate property collector updates.
	// To monitor statistics values, use the statistics and alarms modules instead.
	//
	// Since vSphere API 4.0
	QuickStats *ResourcePoolQuickStats

	// Current runtime state of the resource pool.
	Runtime *ResourcePoolRuntimeInfo
}

//
// This event records when a conflict with a resource pool's resource
// configuration is detected.
//
//
type ResourceViolatedEvent struct {
	*ResourcePoolEvent
}

//
// Thrown when the caller is not permitted to perform the specified
// operation due to product versioning restrictions.
//
//
type RestrictedVersion struct {
	*SecurityError
}

//
// Options for RetrievePropertiesEx.
//
//
type RetrieveOptions struct {
	*DynamicData

	// The maximum number of ObjectContent data
	// objects that should be returned in a single result from RetrievePropertiesEx.
	//
	// An unset value indicates that there is no maximum. In this
	// case PropertyCollector policy may still limit the number
	// of objects. Any remaining objects may be retrieved with ContinueRetrievePropertiesEx.
	//
	// A positive value causes RetrievePropertiesEx to
	// suspend the retrieval when the count of objects reaches the
	// specified maximum. PropertyCollector policy may still
	// limit the count to something less than maxObjects. Any remaining
	// objects may be retrieved with ContinueRetrievePropertiesEx.
	//
	// A value less than or equal to 0 is illegal.
	MaxObjects int32
}

//
// Result of RetrievePropertiesEx and ContinueRetrievePropertiesEx
//
//
type RetrieveResult struct {
	*DynamicData

	// retrieved objects.
	Objects []*ObjectContent

	// A token used to retrieve further retrieve results.
	//
	// If set, the token should be passed to ContinueRetrievePropertiesEx to retrieve more results. Each token
	// may be passed to continueRetrievePropertiesEx only once, and only in
	// the same session in which it was returned and to the same
	// PropertyCollector object that returned it.
	//
	// If unset, there are no further results to retrieve after this
	// RetrieveResult.
	Token string
}

//
// This event records the creation of a role.
//
//
type RoleAddedEvent struct {
	*RoleEvent

	// The privileges granted to the role.
	PrivilegeList []string
}

//
// This event records a role operation.
//
//
type RoleEvent struct {
	*AuthorizationEvent

	// The associated role.
	Role *RoleEventArgument
}

//
// The event argument is a Role object.
//
//
type RoleEventArgument struct {
	*EventArgument

	// The name of the role.
	Name string

	// The ID of the role.
	RoleId int32
}

//
// This class records the removal of a role.
//
//
type RoleRemovedEvent struct {
	*RoleEvent
}

//
// This event records the creation of a role.
//
//
type RoleUpdatedEvent struct {
	*RoleEvent

	// The privileges granted to the role.
	PrivilegeList []string
}

//
// This event is generated when network configuration rollback
// occurs on a host due configuration change that disconnected
// the host from vSphere server
//
//
type RollbackEvent struct {
	*DvsEvent

	// The host on which rollback happened
	HostName string

	// The API method that was rolled back
	MethodName string
}

//
// Thrown if a Rollback operation fails
//
//
type RollbackFailure struct {
	*DvsFault

	// The entity name on which rollback failed
	EntityName string

	// The entity type on which rollback failed
	EntityType string
}

//
// The virtual machine if powered on, would violate an
// affinity/anti-affinity rule. In this case, the VM can still be powered
// on manually by a user who knows what they are doing, but VirtualCenter
// will never automatically move or power on a VM such that it triggers
// the violation.
//
//
type RuleViolation struct {
	*VmConfigFault

	// The host that the virtual machine can not be powered on without
	// violate a rule.
	//
	// Since VI API 2.5
	Host *HostSystem

	// The rule that is violated. It can be an affinity or anti-affinity rule.
	//
	// Since vSphere API 4.0
	Rule *ClusterRuleInfo
}

//
// This data object type specifies a script that is triggered by an alarm.
// You can use any elements of the
// ActionParameter enumerated list
// as part of your script to provide information available at runtime.
//
//
type RunScriptAction struct {
	*Action

	// The fully-qualified path to a shell script that runs on the
	// VirtualCenter server as a result of an alarm.
	Script string
}

//
// The base data object type for all runtime faults that can be
// thrown by a method.
//
//
type RuntimeFault struct {
	*MethodFault
}

//
// A SSLDisabledFault fault occurs when a host does not have ssl enabled.
//
//
type SSLDisabledFault struct {
	*HostConnectFault
}

//
// SSLVerifyFault is thrown by the host connect method if the VC
// server could not verify the authenticity of the host's SSL
// certificate.
//
// Currently, we do not distinguish the various possible reasons why
// the certificate could not be verified because we don't provide a
// way for the user to overwrite these reasons other than turning off
// SSL certificate verification completely.
//
// The only exception is the case when the certificate was rejected
// because it was self-signed. This is the most likely case when the
// user may want to overwrite the behavior by specifying the
// certificate's thumbprint in the ConnectSpec the next time the user
// connects to the host.
//
//
type SSLVerifyFault struct {
	*HostConnectFault

	// Whether the host's certificate was self signed
	SelfSigned bool

	// The thumbprint of the host's certificate
	Thumbprint string
}

//
// SSPIAuthentication contains the information necessary to
// initiate a ticketed authentication session in the guest
// using SSPI credentials.
// The ticketed session is not stateless and stores state inside of the guest.
//
// To use SSPIAuthentication, populate sspiToken with a base64 encoded SSPI token.
// Then call AcquireCredentialsInGuest with
// the SSPIAuthentication object and no sessionID.
//
// After issuing the AcquireCredentialsInGuest call, a
// GuestAuthenticationChallenge will be thrown.
// Use the serverChallenge sspiToken in GuestAuthenticationChallenge
// to generate the proper SSPI response token.
//
// Populate an SSPIAuthentication object with the base64 encoded SSPI response token, and
// call AcquireCredentialsInGuest with the SSPIAuthentication object and
// the sessionID found in GuestAuthenticationChallenge.
//
//
// Successful authentication will result in a TicketedSessionAuthentication
// object being returned. You can use the TicketedSessionAuthentication in any
// guest operations function call. You should NOT attempt to use SSPIAuthentication in any guest
// operations function call.
//
//
// When you no longer need the TicketedSessionAuthentication object, you should
// call ReleaseCredentialsInGuest to free associated resources
// and session data.
//
//
// Usage notes: SSPI authentication has the same limitations as a duplicated primary token obtained
// from the Windows API function LogonUser with the LOGON32_LOGON_NETWORK logon type. This will affect
// programs started with StartProgramInGuest. For example, launched
// programs will be unable to use WMI functions unless the "Remote Enable" privilege is enabled for
// the user. Similarly, access to network resources may fail due to the limitations of the token.
//
//
//
type SSPIAuthentication struct {
	*GuestAuthentication

	// This contains a base64 encoded SSPI Token.
	SspiToken string
}

//
// Thrown during SSPI pass-through authentication if further
// negotiation is required.
//
//
type SSPIChallenge struct {
	*VimFault

	// The opaque server response token, base-64 encoded.
	Base64Token string
}

//
// Data object type containing settings for the scheduled hardware upgrades.
//
//
type ScheduledHardwareUpgradeInfo struct {
	*DynamicData

	// Contains information about the failure of last attempt to run
	// scheduled hardware upgrade.
	Fault *LocalizedMethodFault

	// Status for last attempt to run scheduled hardware upgrade.See ScheduledHardwareUpgradeInfoHardwareUpgradeStatus
	ScheduledHardwareUpgradeStatus string

	// Scheduled hardware upgrade policy setting for the virtual machine.See ScheduledHardwareUpgradeInfoHardwareUpgradePolicy
	UpgradePolicy string

	// Key for target hardware version to be used on next scheduled upgrade
	// in the format of key.
	VersionKey string
}

//
// The policy setting used to determine when to perform scheduled
// upgrades for a virtual machine.
//
//
type ScheduledHardwareUpgradeInfoHardwareUpgradePolicy struct {
}

//
// Status for last attempt to run scheduled hardware upgrade.
//
//
type ScheduledHardwareUpgradeInfoHardwareUpgradeStatus struct {
}

//
// The scheduled task object.
//
type ScheduledTask struct {
	*ExtensibleManagedObject

	info *ScheduledTaskInfo
}

// Information about the current scheduled task.
func (mo *ScheduledTask) Info() (*ScheduledTaskInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ScheduledTaskInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ScheduledTaskInfo")
	}
	return v, nil
}

//
// Reconfigures the scheduled task properties.
//
// Required Privileges
// ScheduledTask.Edit
//
func (mo *ScheduledTask) ReconfigureScheduledTask(
	_this *ManagedObjectReference, spec *ScheduledTaskSpec,
) error {

	return nil

}

//
// Removes the scheduled task.
//
// Required Privileges
// ScheduledTask.Delete
//
func (mo *ScheduledTask) RemoveScheduledTask(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Runs the scheduled task immediately.
// The schedule for future runs remains in effect.
//
// Required Privileges
// ScheduledTask.Run
//
func (mo *ScheduledTask) RunScheduledTask(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// This event records the completion of a scheduled task.
//
//
type ScheduledTaskCompletedEvent struct {
	*ScheduledTaskEvent
}

//
// This event records the creation of a scheduled task.
//
//
type ScheduledTaskCreatedEvent struct {
	*ScheduledTaskEvent
}

//
// Static strings for scheduled tasks.  These strings are locale-specific.
//
//
type ScheduledTaskDescription struct {
	*DynamicData

	// Action class descriptions for a scheduled task.
	Action []*TypeDescription

	// MonthlyByWeekdayTaskScheduler Days of the week enum description
	DayOfWeek []*ElementDescription

	// Scheduler class description details.
	SchedulerInfo []*ScheduledTaskDetail

	// TaskInfo State enum
	State []*ElementDescription

	// MonthlyByWeekdayTaskScheduler Week of the month enum description
	WeekOfMonth []*ElementDescription
}

//
// Descriptive detail for each scheduler type.
//
//
type ScheduledTaskDetail struct {
	*TypeDescription

	// Scheduler frequency description.
	Frequency string
}

//
// This event records the sending of a notification via email for a scheduled task.
//
//
type ScheduledTaskEmailCompletedEvent struct {
	*ScheduledTaskEvent

	// The destination email address.
	To string
}

//
// This event records the failure of an attempt to send a notification via email
// for a scheduled task.
//
//
type ScheduledTaskEmailFailedEvent struct {
	*ScheduledTaskEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault

	// The destination email address.
	To string
}

//
// These events are scheduled task events.
//
//
type ScheduledTaskEvent struct {
	*Event

	// The entity on which the scheduled task registered.
	Entity *ManagedEntityEventArgument

	// The scheduled task object.
	ScheduledTask *ScheduledTaskEventArgument
}

//
// The event argument is a scheduled task object.
//
//
type ScheduledTaskEventArgument struct {
	*EntityEventArgument

	// The scheduled task object.
	ScheduledTask *ScheduledTask
}

//
// This event records the failure of a scheduled task.
//
//
type ScheduledTaskFailedEvent struct {
	*ScheduledTaskEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// The scheduled task details.
//
//
type ScheduledTaskInfo struct {
	*ScheduledTaskSpec

	// The running task instance when the scheduled task state is "running".
	ActiveTask *Task

	// The entity on which related events will be logged.
	// If the task is scheduled on a ManagedEntity, this
	// field will also reflect the same ManagedEntity.
	// If task is scheduled on a ManagedObject, this field
	// will have information about the entity on which
	// the events will be logged on behalf of the ManagedObject.
	// ManagedObject itself will be denoted by taskObject
	Entity *ManagedEntity

	// The fault code when the scheduled task state is "error".
	Error *LocalizedMethodFault

	// The time the scheduled task is created or modified.
	LastModifiedTime time.Time

	// Last user that modified the scheduled task.
	LastModifiedUser string

	// The next time the scheduled task will run.
	NextRunTime time.Time

	// The last time the scheduled task ran.
	PrevRunTime time.Time

	// The task progress when the scheduled task state is "running".
	Progress int32

	// The operation result when the scheduled task state is "success".
	Result interface{}

	// Scheduled task object.
	ScheduledTask *ScheduledTask

	// Scheduled task state.
	State *enum.TaskInfoState

	// The object on which the scheduled task is defined.
	// This field will have information about either the
	// ManagedEntity or the ManagedObject on which the scheduled
	// task is defined.
	//
	// Since vSphere API 4.0
	TaskObject *ManagedObjectReference
}

//
// Object manager for scheduled tasks.
//
type ScheduledTaskManager struct {
	*ManagedObject

	description *ScheduledTaskDescription

	scheduledTask []*ScheduledTask
}

// Static descriptive strings used in scheduled tasks.
// Required Privilege: System.View
func (mo *ScheduledTaskManager) Description() (*ScheduledTaskDescription, error) {
	t, err := mo.currentProperty("description")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ScheduledTaskDescription)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ScheduledTaskDescription")
	}
	return v, nil
}

// All available scheduled tasks.
// Required Privilege: System.View
func (mo *ScheduledTaskManager) ScheduledTask() ([]*ScheduledTask, error) {
	t, err := mo.currentProperty("scheduledTask")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ScheduledTask)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ScheduledTask")
	}
	return v, nil
}

//
// Creates a scheduled task.
//
// Required Privileges
// None
// Since
// vSphere API 4.0
//
func (mo *ScheduledTaskManager) CreateObjectScheduledTask(
	_this *ManagedObjectReference, obj *ManagedObjectReference, spec *ScheduledTaskSpec,
) (*ScheduledTask, error) {

	return nil, nil

}

//
// Creates a scheduled task.
//
// Required Privileges
// None
//
func (mo *ScheduledTaskManager) CreateScheduledTask(
	_this *ManagedObjectReference, entity *ManagedEntity, spec *ScheduledTaskSpec,
) (*ScheduledTask, error) {

	return nil, nil

}

//
// Available scheduled tasks defined on the entity.
//
//
//
// Required Privileges
// System.View
//
func (mo *ScheduledTaskManager) RetrieveEntityScheduledTask(
	_this *ManagedObjectReference, entity *ManagedEntity,
) ([]*ScheduledTask, error) {

	return nil, nil

}

//
// Available scheduled tasks defined on the object.
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 4.0
//
func (mo *ScheduledTaskManager) RetrieveObjectScheduledTask(
	_this *ManagedObjectReference, obj *ManagedObjectReference,
) ([]*ScheduledTask, error) {

	return nil, nil

}

//
// This event records the reconfiguration of a scheduled task.
//
//
type ScheduledTaskReconfiguredEvent struct {
	*ScheduledTaskEvent
}

//
// This event records the removal of a scheduled task.
//
//
type ScheduledTaskRemovedEvent struct {
	*ScheduledTaskEvent
}

//
// Parameters for scheduled task creation.
//
//
type ScheduledTaskSpec struct {
	*DynamicData

	// The action of the scheduled task, to be done when the scheduled task runs.
	Action *Action

	// Description of the scheduled task.
	Description string

	// Flag to indicate whether the scheduled task is enabled or disabled.
	Enabled bool

	// Name of the scheduled task.
	Name string

	// The email notification.
	// If not set, this property is set to empty string, indicating no notification.
	Notification string

	// The time scheduler that determines when the scheduled task runs.
	Scheduler *TaskScheduler
}

//
// This event records when a scheduled task started.
//
//
type ScheduledTaskStartedEvent struct {
	*ScheduledTaskEvent
}

//
// The ScsiLun data object describes a SCSI logical unit.
// A SCSI logical unit is a host device that an ESX Server or virtual machine
// can use for I/O operations.
//
// An ESX Server creates SCSI logical unit objects to represent
// devices in the host configuration. (See the definition of
// ScsiLunType for a list of the supported device types.)
// The vSphere API uses one of two object types to represent a SCSI
// logical unit, depending on the device type.
//
//
//
// • Disks containing file system volumes or parts of volumes for hosts
// or raw disks for virtual machines. To represent disks, the ESX Server
// creates a HostScsiDisk object, which inherits properties from
// the ScsiLun base class.
//
//
// • Other SCSI devices, for example SCSI passthrough devices
// for virtual machines. To represent one of these devices,
// the ESX Server creates a ScsiLun object.
//
//
//
//
//
// When the Server creates a HostScsiDisk or ScsiLun object,
// it specifies a valid device name and type:
//
//
//
// • deviceName - A string representing the name of the device
// that is meaningful to the host. The following are some examples of
// device names.
// /dev/cdrom
// /vmkdev/vmhba0:0:1:0
// PhysicalDrive0
//
//
// • deviceType - A string describing the type of device.
// The following are some examples of device types.
// scsi-cdrom
// scsi-tape
// scsi-disk
// scsi-processor
// scsi-unknown
//
//
//
//
//
//
type ScsiLun struct {
	*HostDevice

	// Alternate durable names.
	// Records all available durable names derived from page 80h of the Vital
	// Product Data (VPD) and the Identification Vital Product Data (VPD) page
	// 83h as defined by the SCSI-3 Primary Commands. For devices that are not
	// SCSI-3 compliant this property is not defined.
	//
	// Since VI API 2.5
	AlternateName []*ScsiLunDurableName

	// Canonical name of the SCSI logical unit.
	//
	// Disk partition or extent identifiers refer to this name when
	// referring to a disk.  Use this property to correlate a partition
	// or extent to a specific SCSI disk.
	// See diskName
	CanonicalName string

	// Capabilities of SCSI device.
	//
	// Since vSphere API 4.0
	Capabilities *ScsiLunCapabilities

	// List of descriptors that can be used to identify the LUN object.  The
	// uuid will also appear as a descriptor.
	//
	// The id field in the descriptor is a string that can be used to correlate
	// the ScsiLun across multiple servers.  A ScsiLun may have multiple
	// descriptors.  The choice and order of these descriptors may be different
	// on different servers.
	//
	// Not all descriptors are suitable for correlation.  Some descriptors are
	// only sufficient to identify the ScsiLun within a single host.  Each
	// descriptor contains a quality property that indicates whether or not
	// the descriptor is suitable for correlation.
	//
	// Since vSphere API 4.0
	Descriptor []*ScsiLunDescriptor

	// User configurable display name of the SCSI logical unit.  A default
	// display name will be used if available.  If the display name is not
	// supported, it will be unset.  The display name does not have to be
	// unique but it is recommended that it be unique.
	//
	// Since vSphere API 4.0
	DisplayName string

	// The durable name of the SCSI device.
	// For a SCSI-3 compliant device this property is derived from the
	// payloads of pages 80h and 83h of the Vital Product Data (VPD) as
	// defined by the T10 and SMI standards. For devices that do not provide
	// this information, this property is not defined.
	DurableName *ScsiLunDurableName

	// Linkable identifier
	Key string

	// The type of SCSI device.  Must be one of the values of
	// ScsiLunType.
	LunType string

	// The model number of the SCSI device.
	Model string

	// The operational states of the LUN.
	// When more than one item is present in the array, the first state
	// should be considered the primary state.  For example, a LUN may
	// be "ok" and "degraded" indicating I/O is still possible to the LUN, but
	// it is operating in a degraded mode.See ScsiLunState
	OperationalState []string

	// The queue depth of SCSI device.
	QueueDepth int32

	// The revision of the SCSI device.
	Revision string

	// The SCSI level of the SCSI device.
	ScsiLevel int32

	// The serial number of the SCSI device.
	// For a device that is SCSI-3 compliant, this property is derived
	// from page 80h of the Vital Product Data (VPD), as defined by the
	// SCSI-3 Primary Commands (SPC-3) spec.  Not all SCSI-3 compliant
	// devices provide this information.  For devices that are not
	// SCSI-3 compliant, this property is not defined.
	SerialNumber string

	// Standard Inquiry payload.
	// For a SCSI-3 compliant device this property is derived from the
	// standard inquiry data. For devices that are not SCSI-3 compliant this
	// property is not defined.
	//
	// Since VI API 2.5
	StandardInquiry []int8

	// Universally unique identifier for the LUN used to identify ScsiLun across
	// multiple servers.
	//
	// This identifier can be used to identify analogous objects in other views
	// such as HostMultipathInfoLogicalUnit and HostScsiTopologyLun.
	// See HostMultipathInfoLogicalUnitSee HostScsiTopologyLun
	Uuid string

	// The vendor of the SCSI device.
	Vendor string

	// vStorage hardware acceleration support status. This property
	// represents storage acceleration provided by the SCSI logical unit.
	// See ScsiLunVStorageSupportStatus for valid values.
	//
	// If a storage device supports hardware acceleration,
	// the ESX host can offload specific virtual machine management
	// operations to the storage device. With hardware assistance,
	// the host performs storage operations faster and consumes
	// less CPU, memory, and storage fabric bandwidth.
	//
	// For vSphere 4.0 or earlier hosts, this value will be unset.
	//
	// Since vSphere API 4.1
	VStorageSupport string
}

//
// Scsi device specific capabilities.
//
//
type ScsiLunCapabilities struct {
	*DynamicData

	// Can the display name of the SCSI device be updated?
	UpdateDisplayNameSupported bool
}

//
// A structure that encapsulates an identifier and its properties for the
// ScsiLun object.
//
//
type ScsiLunDescriptor struct {
	*DynamicData

	// The identifier represented as a string.
	Id string

	// An indicator of the utility of the descriptor as an identifier that
	// is stable, unique, and correlatable.See DescriptorQuality
	Quality string
}

//
// An indicator of the utility of Descriptor in being used as an
// identifier that is stable, unique, and correlatable.
//
//
type ScsiLunDescriptorQuality struct {
}

//
// This data object type represents an SMI-S "Correlatable and
// Durable Name" which is an
// identifier for a logical unit number (LUN) that is generated using
// a common algorithm.  The algorithm divides the identifier into
// multiple namespaces where each
// namespace uses a different set of properties of the LUN to generate
// the identifier.  The namespace itself is encoded in the identifier.
//
//
type ScsiLunDurableName struct {
	*DynamicData

	// The variable length byte array containing the namespace-specific data.
	// For a SCSI-3 compliant device this field is the descriptor header
	// along with the payload for data obtained from page 83h, and is the
	// payload for data obtained from page 80h of the Vital Product Data
	// (VPD).
	Data []int8

	// The string describing the namespace used for the durable name.
	Namespace string

	// The byte used by the ESX Server product to represent the namespace.
	NamespaceId int8
}

//
// The Operational state of the LUN
//
//
type ScsiLunState struct {
}

//
// The list of SCSI device types.  These values correspond to values
// published in the SCSI specification.
//
//
type ScsiLunType struct {
}

//
// Storage array hardware acceleration support status.
// When a host boots, the support status is unknown.
// As a host attempts hardware-accelerated operations,
// it determines whether the storage device supports hardware acceleration
// and sets the vStorageSupport property accordingly.
//
//
type ScsiLunVStorageSupportStatus struct {
}

//
// Specification used to create an Flex-SE based virtual disk
//
//
type SeSparseVirtualDiskSpec struct {
	*FileBackedVirtualDiskSpec

	// The grain size in kB for Flex-SE disk types. Default value will
	// be used if unset.
	GrainSizeKb int32
}

//
// The SearchIndex service allows a client to efficiently query the
// inventory for a specific managed entity by attributes such as UUID, IP address, DNS
// name, or datastore path. Such searches typically return a VirtualMachine or a
// HostSystem. While searching, only objects for which the user has sufficient
// privileges are considered. The findByInventoryPath and findChild operations only
// search on entities for which the user has view privileges; all other SearchIndex
// find operations only search virtual machines and hosts for which the user has
// read privileges. If the user does not have sufficient privileges for an object that
// matches the search criteria, that object is not returned.
//
type SearchIndex struct {
	*ManagedObject
}

//
// Finds all virtual machines or hosts by DNS name. The DNS name for a virtual
// machine is the one returned from VMware tools, hostName.
//
// Required Privileges
// System.View
// Since
// vSphere API 4.0
//
func (mo *SearchIndex) FindAllByDnsName(
	_this *ManagedObjectReference, datacenter *Datacenter, dnsName string, vmSearch bool,
) ([]*ManagedEntity, error) {

	return nil, nil

}

//
// Finds all virtual machines or hosts by IP address, where the IP address is
// in dot-decimal notation. For example, 10.17.12.12. The IP address for a virtual
// machine is the one returned from VMware tools, ipAddress.
//
// Required Privileges
// System.View
// Since
// vSphere API 4.0
//
func (mo *SearchIndex) FindAllByIp(
	_this *ManagedObjectReference, datacenter *Datacenter, ip string, vmSearch bool,
) ([]*ManagedEntity, error) {

	return nil, nil

}

//
// Finds all virtual machines or hosts by UUID.
//
// Required Privileges
// System.View
// Since
// vSphere API 4.0
//
func (mo *SearchIndex) FindAllByUuid(
	_this *ManagedObjectReference, datacenter *Datacenter, uuid string, vmSearch bool, instanceUuid bool,
) ([]*ManagedEntity, error) {

	return nil, nil

}

//
// Finds a virtual machine by its location on a datastore.
//
// Required Privileges
// System.View
//
func (mo *SearchIndex) FindByDatastorePath(
	_this *ManagedObjectReference, datacenter *Datacenter, path string,
) (*VirtualMachine, error) {

	return nil, nil

}

//
// Finds a virtual machine or host by DNS name. The DNS name for a virtual
// machine is the one returned from VMware tools, hostName.
//
// Required Privileges
// System.View
//
func (mo *SearchIndex) FindByDnsName(
	_this *ManagedObjectReference, datacenter *Datacenter, dnsName string, vmSearch bool,
) (*ManagedEntity, error) {

	return nil, nil

}

//
// Finds a managed entity based on its location in the inventory. The path is
// separated by slashes ('/'). For example, a path should be of the form
// "My Folder/My Datacenter/vm/Discovered VM/VM1". A leading slash or trailing
// slash is ignored. Thus, the following paths all represents the same object:
// "a/b", "/a/b", "a/b/", and '/a/b/'. Slashes in names must be represented using
// %2f, following the standard URL syntax. Any object in the inventory can be
// retrieved using this method, including resource pools and hosts.
//
// Required Privileges
// System.View
//
func (mo *SearchIndex) FindByInventoryPath(
	_this *ManagedObjectReference, inventoryPath string,
) (*ManagedEntity, error) {

	return nil, nil

}

//
// Finds a virtual machine or host by IP address, where the IP address is in
// dot-decimal notation. For example, 10.17.12.12. The IP address for a virtual
// machine is the one returned from VMware tools, ipAddress.
//
// Required Privileges
// System.View
//
func (mo *SearchIndex) FindByIp(
	_this *ManagedObjectReference, datacenter *Datacenter, ip string, vmSearch bool,
) (*ManagedEntity, error) {

	return nil, nil

}

//
// Finds a virtual machine or host by BIOS or instance UUID.
//
// Required Privileges
// System.View
//
func (mo *SearchIndex) FindByUuid(
	_this *ManagedObjectReference, datacenter *Datacenter, uuid string, vmSearch bool, instanceUuid bool,
) (*ManagedEntity, error) {

	return nil, nil

}

//
// Finds a particular child based on a managed entity
// name. This only searches the immediate children of a managed entity.
// For a Datacenter, the host and vm folders are
// considered children. For a ComputeResource,
// the hosts and root ResourcePool are considered
// children.
//
// Required Privileges
// System.View
//
func (mo *SearchIndex) FindChild(
	_this *ManagedObjectReference, entity *ManagedEntity, name string,
) (*ManagedEntity, error) {

	return nil, nil

}

//
// This fault is thrown when an attempt is made to disable a secondary
// virtual machine that has already been disabled.
//
//
type SecondaryVmAlreadyDisabled struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// This fault is thrown when an attempt is made to enable a secondary
// virtual machine that has already been enabled.
//
//
type SecondaryVmAlreadyEnabled struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// This fault is thrown when an attempt is made to register a secondary
// virtual machine with a primary virtual machine with whom it is
// already registered.
//
//
type SecondaryVmAlreadyRegistered struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// This fault is thrown when an attempt is made to unregister a secondary
// virtual machine from a primary virtual machine with whom it has not
// been previously registered.
//
//
type SecondaryVmNotRegistered struct {
	*VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string
}

//
// Thrown when the client is not allowed access to the property or method.
//
//
type SecurityError struct {
	*RuntimeFault
}

//
// The SecurityProfile data object represents host security configuration.
// If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type SecurityProfile struct {
	*ApplyProfile

	// Permission configuration.
	//
	// Since vSphere API 4.1
	Permission []*PermissionProfile
}

//
// Base class for selecting entities
//
//
type SelectionSet struct {
	*DynamicData
}

//
// The SelectionSpec is the base type for data
// object types that specify what additional objects to filter. The base
// type contains only an optional "name" field, which allows a selection to
// be named for future reference. More information is available in the
// subtype.
//
// Named selections support recursive specifications on an object
// hierarchy.  When used by a derived object, the "name" field allows other
// SelectionSpec objects to refer to the object by
// name. When used as the base type only, the "name" field indicates
// recursion to the derived object by name.
//
//
// Names are meaningful only within the same FilterSpec.
//
//
//
type SelectionSpec struct {
	*DynamicData

	// Name of the selection specification.
	Name string
}

//
// This data object type defines an email that is triggered by an
// alarm. You can use any
// elements of the ActionParameter
// enumerated list as part of your strings to provide information available
// at runtime.
//
//
type SendEmailAction struct {
	*Action

	// Content of the email notification.
	Body string

	// A comma-separated list of addresses that are cc'ed on the email notification.
	CcList string

	// Subject of the email notification.
	Subject string

	// A comma-separated list of addresses to which the email notification is sent.
	ToList string
}

//
// This data object type specifies an SNMP trap that is triggered by an alarm.
//
//
type SendSNMPAction struct {
	*Action
}

//
// This event records an expired VirtualCenter server license.
//
//
type ServerLicenseExpiredEvent struct {
	*LicenseEvent

	Product string
}

//
// This event records the starting of the VirtualCenter server.
//
//
type ServerStartedSessionEvent struct {
	*SessionEvent
}

//
// The ServiceConsolePortGroupProfile data object represents
// the profile for a port group that will be used by the service console.
// If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type ServiceConsolePortGroupProfile struct {
	*PortGroupProfile

	// IP address configuration for the service console network.
	IpConfig *IpAddressProfile
}

//
// The ServiceConsoleReservationInfo data object type describes the
// amount of memory that is being reserved by the service console.
// Memory reserved for use by the service console is a hard reservation
// that cannot be changed except across hardware restarts.
//
// This memory that is reserved for the service console is used primarily
// to provide system management services.  In addition, a small overhead
// is needed by each virtual machine on the service console.
//
//
// The only property of the data object that can be changed directly is the
// serviceConsoleReservedCfg property.  This property indicates how much
// memory should be reserved for the service console on the next boot.  In
// most cases, this amount is the same as the current reservation.
//
//
//
type ServiceConsoleReservationInfo struct {
	*DynamicData

	// The amount of memory that is currently reserved for the service console.
	ServiceConsoleReserved int64

	// The amount of memory that should be reserved for the service console on
	// the next boot.
	ServiceConsoleReservedCfg int64

	// The amount of memory that is not reserved for use by the service console.
	Unreserved int64
}

//
// The ServiceContent data object defines properties for the ServiceInstance
// managed object. The ServiceInstance itself does not have directly-accessible
// properties because reading the properties of a managed object requires
// the use of a property collector, and the property collector itself
// is a property of the ServiceInstance.
//
// For this reason, use the method RetrieveServiceContent
// to retrieve the ServiceContent object.
//
//
type ServiceContent struct {
	*DynamicData

	// Information about the service, such as the software version.
	About *AboutInfo

	// A singleton managed object that manages host local user and group accounts.
	AccountManager *HostLocalAccountManager

	// A singleton managed object that manages alarms.
	AlarmManager *AlarmManager

	// Manages permissions for managed entities in the service.
	AuthorizationManager *AuthorizationManager

	// A singleton managed object that manages the cluster profiles.
	//
	// Since vSphere API 4.0
	ClusterProfileManager *ClusterProfileManager

	// A singleton managed object that manages compliance aspects of entities.
	//
	// Since vSphere API 4.0
	ComplianceManager *ProfileComplianceManager

	// A singleton managed object that managed custom fields.
	CustomFieldsManager *CustomFieldsManager

	// A singleton managed object that manages saved guest customization
	// specifications.
	CustomizationSpecManager *CustomizationSpecManager

	// Datastore Namespace manager.
	//
	// A singleton managed object that is used to manage manipulations
	// related to datastores' namespaces.
	//
	// Since vSphere API 5.5
	DatastoreNamespaceManager *DatastoreNamespaceManager

	// A singleton managed object that provides access to low-level log files.
	DiagnosticManager *DiagnosticManager

	// A singleton managed object that provides relevant information of
	// DistributedVirtualSwitch.
	//
	// Since vSphere API 4.0
	DvSwitchManager *DistributedVirtualSwitchManager

	// A singleton managed object that manages events.
	EventManager *EventManager

	// A singleton managed object that manages extensions.
	//
	// Since VI API 2.5
	ExtensionManager *ExtensionManager

	// A singleton managed object that allows management of files present
	// on datastores.
	//
	// Since VI API 2.5
	FileManager *FileManager

	// A singleton managed object that provides methods for guest operations.
	//
	// Since vSphere API 5.0
	GuestOperationsManager *GuestOperationsManager

	// A singleton managed object that manages the host profiles.
	//
	// Since vSphere API 4.0
	HostProfileManager *HostProfileManager

	// A singleton managed object that supports management of IpPool objects. IP pools are
	// used when allocating IPv4 and IPv6 addresses to vApps.
	//
	// Since vSphere API 4.0
	IpPoolManager *IpPoolManager

	// A singleton managed object that manages licensing
	LicenseManager *LicenseManager

	// A singleton managed object that provides methods for retrieving message
	// catalogs for client-side localization support.
	//
	// Since vSphere API 4.0
	LocalizationManager *LocalizationManager

	// A singleton managed object that can generate OVF descriptors (export) and create
	// vApps (single-VM or vApp container-based) from OVF descriptors (import).
	//
	// Since vSphere API 4.0
	OvfManager *OvfManager

	// A singleton managed object that manages the collection and reporting
	// of performance statistics.
	PerfManager *PerformanceManager

	// Reference to a per-session object for retrieving properties and updates.
	PropertyCollector *PropertyCollector

	// Reference to the top of the inventory managed by this service.
	RootFolder *Folder

	// A singleton managed object that manages scheduled tasks.
	ScheduledTaskManager *ScheduledTaskManager

	// A singleton managed object that allows search of the inventory
	SearchIndex *SearchIndex

	// A singleton managed object that manages local services.
	//
	// Since vSphere API 5.1
	ServiceManager *ServiceManager

	// Managed object for logging in and managing sessions.
	SessionManager *SessionManager

	// Generic configuration for a management server. This is for example by
	// vCenter to store the vCenter Settings. This is not used for a
	// stand-alone host, instead the vim.host.ConfigManager.advancedOption is used.See HostConfigManager
	Setting *OptionManager

	// A singleton managed object that allows SNMP configuration.
	// Not set if not supported on a particular platform.
	//
	// Since vSphere API 4.0
	SnmpSystem *HostSnmpSystem

	// A singleton managed object that provides methods for storage resource
	// management.
	//
	// Since vSphere API 4.1
	StorageResourceManager *StorageResourceManager

	// A singleton managed object that manages tasks.
	TaskManager *TaskManager

	// A user directory managed object.
	UserDirectory *UserDirectory

	// A singleton managed object for tracking custom sets of objects.
	//
	// Since VI API 2.5
	ViewManager *ViewManager

	// A singleton managed object that allows management of virtual disks
	// on datastores.
	//
	// Since VI API 2.5
	VirtualDiskManager *VirtualDiskManager

	// Deprecated.
	// As of VI API 2.5, use the VMware vCenter Converter plug-in.
	//
	//
	// A singleton managed object that manages the discovery, analysis,
	// recommendation and virtualization of physical machines
	//
	// Since VI API 2.5
	VirtualizationManager *VirtualizationManager

	// A singleton managed object that can answer questions about compatibility
	// of a virtual machine with a host.
	//
	// Since vSphere API 4.0
	VmCompatibilityChecker *VirtualMachineCompatibilityChecker

	// A singleton managed object that can answer questions about the
	// feasibility of certain provisioning operations.
	//
	// Since vSphere API 4.0
	VmProvisioningChecker *VirtualMachineProvisioningChecker
}

//
// The ServiceInstance managed object is the singleton root object of the inventory
// on both vCenter servers and servers running on standalone host agents.
// The server creates the ServiceInstance automatically, and also automatically
// creates the various manager entities that provide services in the virtual
// environment. Some examples of manager entities are LicenseManager,
// PerformanceManager, and ViewManager. You can
// access the manager entities through the content property.
//
// A vSphere API client application begins by connecting to a server
// and obtaining a reference to the ServiceInstance. The client can then use
// the RetrieveServiceContent method to gain
// access to the various vSphere manager entities and to the root folder
// of the inventory.
//
//
//
// When you create managed objects, the server adds them to the inventory.
// The inventory of managed objects includes instances the following object types:
//
//
//
//
// • ServiceInstance  -- Root of the inventory; created by vSphere.
//
// • Datacenter       -- A container that represents a virtual
// data center. It contains hosts, network entities,
// virtual machines and virtual applications,
// and datastores.
//
// • Folder           -- A container used for hierarchical
// organization of the inventory.
//
// • VirtualMachine   -- A virtual machine.
//
// • VirtualApp       -- A virtual application.
//
// • ComputeResource  -- A compute resource
// (either a cluster or a stand-alone host).
//
// • ResourcePool     -- A subset of resources provided by a ComputeResource.
//
// • HostSystem       -- A single host (ESX Server or VMware Server).
//
// • Network          -- A network available to either hosts or virtual
// machines.
//
// • DistributedVirtualSwitch -- A distributed virtual switch.
//
// • DistributedVirtualPortgroup -- A distributed virtual port group.
//
// • Datastore        -- Platform-independent, host-independent storage
// for virtual machine files.
//
//
//
//
// The following figure shows the organization of managed objects in the
// vCenter hierarchy:
//
//
//
//
// Every Datacenter has the following set of dedicated folders.
// These folders are empty until you create entities for the Datacenter.
//
//
//
// •  A folder for any combination of VirtualMachine
// and/or VirtualApp objects. VirtualApp objects can be nested,
// but only the parent VirtualApp can be visible in the folder.
// Virtual machines that are children of virtual applications are not
// associated with a VirtualMachine/VirtualApp folder.
//
// •  A folder for a ComputeResource hierarchy.
//
// •  A folder for network entities - any combination
// of Network, DistributedVirtualSwitch, and/or
// DistributedVirtualPortgroup objects.
//
// •  A folder for Datastore objects.
//
//
//
//
// The host agent hierarchy has the same general form as the vCenter hierarchy,
// but most of the objects are limited to one instance:
//
//
//
//
//
//
type ServiceInstance struct {
	*ManagedObject

	capability *Capability

	content *ServiceContent

	serverClock time.Time
}

// API-wide capabilities.
// Required Privilege: System.View
func (mo *ServiceInstance) Capability() (*Capability, error) {
	t, err := mo.currentProperty("capability")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*Capability)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *Capability")
	}
	return v, nil
}

// The properties of the ServiceInstance managed object. The content property
// is identical to the return value from the
// RetrieveServiceContent method.
//
// Use the content property with the PropertyCollector
// to perform inventory traversal that includes the ServiceInstance.
// (In the absence of a content property, a traversal that encounters
// the ServiceInstance would require calling
// the RetrieveServiceContent method,
// and then invoking a second traversal to continue.)
// Required Privilege: System.Anonymous
func (mo *ServiceInstance) Content() (*ServiceContent, error) {
	t, err := mo.currentProperty("content")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ServiceContent)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ServiceContent")
	}
	return v, nil
}

// Contains the time most recently obtained from the server.
// The time is not necessarily current. This property is intended for use
// with the PropertyCollector WaitForUpdates
// method. The PropertyCollector will provide notification if some event occurs
// that changes the server clock time in a non-linear fashion.
//
// You should not rely on the serverClock property to get the current time
// on the server; instead, use the CurrentTime method.
// Required Privilege: System.View
func (mo *ServiceInstance) ServerClock() (time.Time, error) {
	t, err := mo.currentProperty("serverClock")
	if err != nil {
		return time.Now(), err
	}

	v, ok := t.(time.Time)
	if !ok {
		return time.Now(), errors.New("Unable to make type assertion to: time.Time")
	}
	return v, nil
}

//
// Returns the current time on the server. To monitor non-linear time changes,
// use the serverClock property.
//
// Required Privileges
// System.View
//
func (mo *ServiceInstance) CurrentTime(
	_this *ManagedObjectReference,
) (time.Time, error) {

	return time.Now(), nil

}

// Deprecated.
// As of vSphere API 4.0, use
// QueryVMotionCompatibilityEx_Task instead.
//
//
// Investigates the general VMotion compatibility of a virtual machine with
// a set of hosts. The virtual machine may be in any power state. Hosts
// may be in any connection state and also may be in maintenance mode.
//
// Required Privileges
// Resource.QueryVMotion
//
func (mo *ServiceInstance) QueryVMotionCompatibility(
	_this *ManagedObjectReference, vm *VirtualMachine, host []*HostSystem, compatibility []string,
) ([]*HostVMotionCompatibility, error) {

	return nil, nil

}

//
// Component information for bundled products
//
// Required Privileges
// System.Anonymous
// Since
// VI API 2.5
//
func (mo *ServiceInstance) RetrieveProductComponents(
	_this *ManagedObjectReference,
) ([]*ProductComponentInfo, error) {

	return nil, nil

}

//
// Retrieves the properties of the service instance.
//
// Required Privileges
// System.Anonymous
//
func (mo *ServiceInstance) RetrieveServiceContent(
	_this *ManagedObjectReference,
) (*ServiceContent, error) {

	return nil, nil

}

// Deprecated.
// As of vSphere API 4.0, use VirtualMachineProvisioningChecker
// instead.
//
//
// Checks the validity of a set of proposed migrations. A migration
// is the act of changing the assigned execution host of a virtual
// machine, which can result from invoking
// MigrateVM_Task or
// RelocateVM_Task.
//
// Required Privileges
// System.View
//
func (mo *ServiceInstance) ValidateMigration(
	_this *ManagedObjectReference, vm []*VirtualMachine, state *enum.VirtualMachinePowerState, testType []string, pool *ResourcePool, host *HostSystem,
) ([]*Event, error) {

	return nil, nil

}

//
// The ServiceManager managed object is a singleton object that is used to present
// services that are optional and not necessarily formally defined.
//
// This directory makes available a list of such services and provides an easy way
// to locate them. The service being represented can take arbitrary form here and
// is thus represented by a generic ManagedObject. The expectation is that the
// client side is knowledgeable of the instance type of the specific service it
// is interested in using.
//
type ServiceManager struct {
	*ManagedObject

	service []*ServiceManagerServiceInfo
}

// The full list of services available in this directory.
// Required Privilege: Global.ServiceManagers
func (mo *ServiceManager) Service() ([]*ServiceManagerServiceInfo, error) {
	t, err := mo.currentProperty("service")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*ServiceManagerServiceInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*ServiceManagerServiceInfo")
	}
	return v, nil
}

//
// A query interface that returns a list of services that match certain criteria.
// Besides a basic service name entry, an arbitrary list of matching locations
// can also be specified. The location array is assumed to be a list of AND expressions,
// ie, all locations must match for an entry to be considered a match.
//
// Regular expressions are not allowed in the query service.
//
// Required Privileges
// Global.ServiceManagers
//
func (mo *ServiceManager) QueryServiceList(
	_this *ManagedObjectReference, serviceName string, location []string,
) ([]*ServiceManagerServiceInfo, error) {

	return nil, nil

}

//
// This data object represents essential information about a particular service.
// The information is sufficient to be able to identify the service and retrieve
// the object implementing it.
//
//
type ServiceManagerServiceInfo struct {
	*DynamicData

	// A description of the service. Provides help text on how
	// to use the service.
	Description string

	// A list of data that can be used to uniquely identify a particular instance of a service.
	// Multiple instances of a service can exist across different domains (for instance, a service
	// that is associated with a particular virtual machine or a particular host). In such cases,
	// the service name is insufficient to identify the service and location data can be used
	// to identify the instance of interest. A service may publish as much location data
	// as is needed to identify it (e.g, vmware.host. or vmware.vm. or both).
	// The particular choice of locations have to be agreed upon by
	// the client and the service.
	Location []string

	// The managed object that presents this service.
	Service *ManagedObjectReference

	// A service name. Each service is expected to create a unique name
	// for itself that can be used to locate the service. This name
	// does not need to be unique across hosts or other such locations though.
	ServiceName string
}

//
// The ServiceProfile data object controls the configuration of a service.
// Use the policy list for access to configuration data
// for the service profile. Use the property list for access
// to subprofiles, if any.
//
//
type ServiceProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string
}

//
// These are session events.
//
//
type SessionEvent struct {
	*Event
}

//
// This managed object type includes methods for logging on and
// logging off clients, determining which clients are currently
// logged on, and forcing clients to log off.
//
type SessionManager struct {
	*ManagedObject

	currentSession *UserSession

	defaultLocale string

	message string

	messageLocaleList []string

	sessionList []*UserSession

	supportedLocaleList []string
}

// This property contains information about the client's current session.
// If the client is not logged on, the value is null.
// Required Privilege: System.Anonymous
func (mo *SessionManager) CurrentSession() (*UserSession, error) {
	t, err := mo.currentProperty("currentSession")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*UserSession)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *UserSession")
	}
	return v, nil
}

// This is the default server locale.
// Required Privilege: System.Anonymous
func (mo *SessionManager) DefaultLocale() (string, error) {
	t, err := mo.currentProperty("defaultLocale")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

// The system global message from the server.
// Required Privilege: System.View
func (mo *SessionManager) Message() (string, error) {
	t, err := mo.currentProperty("message")
	if err != nil {
		return "", err
	}

	v, ok := t.(string)
	if !ok {
		return "", errors.New("Unable to make type assertion to: string")
	}
	return v, nil
}

// Provides the list of locales for which the server has localized messages.
// Required Privilege: System.Anonymous
func (mo *SessionManager) MessageLocaleList() ([]string, error) {
	t, err := mo.currentProperty("messageLocaleList")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]string)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []string")
	}
	return v, nil
}

// The list of currently active sessions.
// Required Privilege: Sessions.TerminateSession
func (mo *SessionManager) SessionList() ([]*UserSession, error) {
	t, err := mo.currentProperty("sessionList")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*UserSession)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*UserSession")
	}
	return v, nil
}

// Provides the list of locales that the server supports.
// Listing a locale ensures that some standardized information such as dates appear
// in the appropriate format. Other localized information, such as error messages,
// are displayed, if available. If localized information is not available, the
// message is returned using the system locale.
// Required Privilege: System.Anonymous
func (mo *SessionManager) SupportedLocaleList() ([]string, error) {
	t, err := mo.currentProperty("supportedLocaleList")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]string)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []string")
	}
	return v, nil
}

//
// Acquire a session-specific ticket string which can be used to clone
// the current session. The caller of this operation can pass the ticket
// value to another entity on the client. The recipient can then call
// CloneSession with the ticket string on an unauthenticated
// session and avoid having to re-enter credentials.
//
// The ticket may only be used once and becomes invalid after use. The
// ticket is also invalidated when the corresponding session is closed or
// expires.  The ticket is only valid on the server which issued it.
//
//
// This sequence of operations is conceptually similar to the
// functionality provided by AcquireLocalTicket, however the
// methods can be used by remote clients and do not require a shared
// filesystem for transport.See CloneSession
//
//
// Required Privileges
// System.View
// Since
// vSphere API 4.0
//
func (mo *SessionManager) AcquireCloneTicket(
	_this *ManagedObjectReference,
) (string, error) {

	return "", nil

}

//
// Creates and returns a one-time credential that may be used to make the
// specified request.
//
// Required Privileges
// System.Anonymous
// Since
// vSphere API 5.0
//
func (mo *SessionManager) AcquireGenericServiceTicket(
	_this *ManagedObjectReference, spec *SessionManagerServiceRequestSpec,
) (*SessionManagerGenericServiceTicket, error) {

	return nil, nil

}

//
// Acquires a one-time ticket for mutual authentication between a server and client.
//
// The caller of this operation can use the user name and file content of
// the returned object as the userName and password arguments for login
// operation.  The local ticket that is returned becomes invalid either
// after it is used or after a server-determined ticket expiration time
// passes. This operation can be used by servers and clients to avoid
// re-entering user credentials after authentication by the operating
// system has already happened.
//
//
// For example, service console utilities that connect to a host agent
// should not require users to re-enter their passwords every time the
// utilities run. Since the one-time password file is readable only by
// the given user, the identity of the one-time password user is protected
// by the operating system file permission.
//
//
// Only local clients are allowed to call this operation. Remote clients
// receive an InvalidRequest fault upon calling this operation.
//
//
// Required Privileges
// System.Anonymous
//
func (mo *SessionManager) AcquireLocalTicket(
	_this *ManagedObjectReference, userName string,
) (*SessionManagerLocalTicket, error) {

	return nil, nil

}

//
// Clone the session specified by the clone ticket and associate it with
// the current connection. The current session will take on the identity
// and authorization level of the UserSession associated with the
// specified cloning ticket.See AcquireCloneTicketSee AcquireGenericServiceTicket
//
// Required Privileges
// System.Anonymous
// Since
// vSphere API 4.0
//
func (mo *SessionManager) CloneSession(
	_this *ManagedObjectReference, cloneTicket string,
) (*UserSession, error) {

	return nil, nil

}

//
// Converts current session to impersonate the specified user.
// The current session will take on the identity and authorization level of
// the user. That user must have a currently-active session.
// If the given userName is an extension key and this key does
// not overlap with a user name of any currently-active session, it will
// take on the identity and  authorization level of that extension provided
// the current session has the same authorization level of that extension.
//
// Required Privileges
// Sessions.ImpersonateUser
// Since
// VI API 2.5
//
func (mo *SessionManager) ImpersonateUser(
	_this *ManagedObjectReference, userName string, locale string,
) (*UserSession, error) {

	return nil, nil

}

//
// Log on to the server.  This method fails if the user name and password are
// incorrect, or if the user is valid but has no permissions granted.
//
// Required Privileges
// System.Anonymous
//
func (mo *SessionManager) Login(
	_this *ManagedObjectReference, userName string, password string, locale string,
) (*UserSession, error) {

	return nil, nil

}

//
// Log on to the server using SSPI pass-through authentication.
//
// This method provides support for passing credentials of the calling
// process to the server without using a password, by leveraging the
// Windows Security Support Provider Interface (SSPI) library.
//
//
// If the function is not supported, this throws a NotSupported fault.
//
//
// The client first calls AcquireCredentialsHandle().  If Kerberos is
// used, this should include the desired credential to pass.  The client then
// calls InitializeSecurityContext().  The resulting partially-formed
// context is passed in Base-64 encoded form to this method.
//
//
// If the context has been successfully formed, the server proceeds with
// login and behaves like Login.  If further
// negotiation is needed, the server throws an SSPIChallenge fault with
// a challenge token, which the client should again pass to
// InitializeSecurityContext(), followed by calling this method again.
//
//
// For more information, see the MSDN documentation on SSPI.
//
//
// Required Privileges
// System.Anonymous
// Since
// VI API 2.5
//
func (mo *SessionManager) LoginBySSPI(
	_this *ManagedObjectReference, base64Token string, locale string,
) (*UserSession, error) {

	return nil, nil

}

//
// Log on to the server through token representing principal identity.
// The token is obtained from SSO (single sign-on) service. This method
// fails if the token is not valid, or the principal has no permissions
// granted. Two type of sso tokens are supported by this method: Bearer
// and Holder-of-Key (HoK). If the token type obliges the method caller
// to prove his rights to present this token (HoK), then a signature is
// supplied as well. The token and the security signature if available
// are provided in a transport specific way.
//
//
// If the communication with the VirtualCenter is SOAP based read the
// WS-Security specification (SAML Token profile) to understand how
// to transport the SSO token and signature.
//
//
//
// Usual login scenario:
//
//
// • Acquire HoK token from the SSO service. Different authentication
// mechanisms are available for acquiring token (user/password,
// certificate, SSPI and so on). For more details consult the SSO
// documentation. To find the location of your SSO service consult the
// Virtual Infrastructure documentation.
//
//
//
// • Once SSO token is acquired successfully LoginByToken could be
// invoked.
//
//
//
//
// Required Privileges
// System.Anonymous
// Since
// vSphere API 5.1
//
func (mo *SessionManager) LoginByToken(
	_this *ManagedObjectReference, locale string,
) (*UserSession, error) {

	return nil, nil

}

//
// Creates a special privileged session that includes
// the Sessions.ImpersonateUser privilege. Requires that the client connect
// over SSL and provide an X.509 certificate for which they hold the private key.
// The certificate must match the certificate used in an earlier call to
// SetExtensionCertificate.
//
// NOTE: Verification of the received certificate (such as expiry, revocation,
// and trust chain) is not required for successful authentication using
// this method.  If certificate verification is desired, use the
// LoginExtensionBySubjectName method instead.
//
//
// Required Privileges
// System.Anonymous
// Since
// vSphere API 4.0
//
func (mo *SessionManager) LoginExtensionByCertificate(
	_this *ManagedObjectReference, extensionKey string, locale string,
) (*UserSession, error) {

	return nil, nil

}

//
// Creates a special privileged session that includes
// the Sessions.ImpersonateUser privilege. Requires that the extension connected
// using SSL, with a certificate that has a subject name that matches the subject
// name registered for the extension.
//
// As of vSphere API 4.0, the NotFound fault is no longer thrown.  Instead, InvalidLogin
// is thrown if the specified extension is not registered.
//
//
// Required Privileges
// System.Anonymous
// Since
// vSphere API 4.0
//
func (mo *SessionManager) LoginExtensionBySubjectName(
	_this *ManagedObjectReference, extensionKey string, locale string,
) (*UserSession, error) {

	return nil, nil

}

//
// Log out and terminate the current session.
//
// Required Privileges
// System.View
//
func (mo *SessionManager) Logout(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Validates that a currently-active session exists with the specified
// sessionID and userName associated with it. Returns true
// if session exists.
//
// Required Privileges
// Sessions.ValidateSession
// Since
// VI API 2.5
//
func (mo *SessionManager) SessionIsActive(
	_this *ManagedObjectReference, sessionID string, userName string,
) (bool, error) {

	return false, nil

}

//
// Sets the session locale.
//
// Required Privileges
// System.View
//
func (mo *SessionManager) SetLocale(
	_this *ManagedObjectReference, locale string,
) error {

	return nil

}

//
// Log off and terminate the provided list of sessions.
//
// This method is only transactional for each session ID. The set of sessions
// are terminated sequentially, as specified in the list. If a failure
// occurs, for example, because of an unknown sessionID, the method aborts with
// an exception. When the method aborts, any sessions that have not yet been
// terminated are left in their unterminated state.
//
//
// Required Privileges
// Sessions.TerminateSession
//
func (mo *SessionManager) TerminateSession(
	_this *ManagedObjectReference, sessionId []string,
) error {

	return nil

}

//
// Updates the system global message. If not blank, the message is immediately
// displayed to currently logged-on users. When set, the message is shown by new
// clients upon logging in.
//
// Required Privileges
// Sessions.GlobalMessage
//
func (mo *SessionManager) UpdateServiceMessage(
	_this *ManagedObjectReference, message string,
) error {

	return nil

}

//
// This data object represents a ticket which grants access to some service.
// The ticket may be used only once and is valid only for the
// SessionManagerServiceRequestSpec with which it was acquired.
//
// For HTTP service requests (when spec is of type HttpServiceRequestSpec)
// the returned ticket must be used by setting
// id
// as the value of a special cookie in the HTTP request.
// For CGI requests the name of this cookie is 'vmware_cgi_ticket'.
//
// The use of the returned ticket for other services is to be defined.
//
//
type SessionManagerGenericServiceTicket struct {
	*DynamicData

	// The name of the host that the service is running on
	//
	// Since vSphere API 5.1
	HostName string

	// A unique string identifying the ticket.
	Id string

	// The expected thumbprint of the SSL certificate of the host.
	// If it is empty, the host must be authenticated by name.
	//
	// Since vSphere API 5.1
	SslThumbprint string
}

//
// This data object type describes a request to an HTTP or HTTPS service.
//
//
type SessionManagerHttpServiceRequestSpec struct {
	*SessionManagerServiceRequestSpec

	// The HTTP method used for the request.
	// If null, then any method is assumed.
	// See SessionManagerHttpServiceRequestSpecMethod
	Method string

	// URL of the HTTP request.
	// E.g. 'https://127.0.0.1:8080/cgi-bin/vm-support.cgi?n=val'.
	//
	// For ESXi CGI service requests:
	// only the path and query parts of the URL are used
	// (e.g. "/cgi-bin/vm-support.cgi?n=val").
	// This is so because the scheme is not known to the CGI service,
	// and the port may not be the same if using a proxy.
	Url string
}

//
// HTTP request methods.
//
//
type SessionManagerHttpServiceRequestSpecMethod struct {
}

//
// This data object type contains the user name
// and location of the file containing the password that
// clients can use for one-time logon to a server.
//
//
type SessionManagerLocalTicket struct {
	*DynamicData

	// Absolute local path to the file containing a one-time password.
	PasswordFilePath string

	// User name to be used for logon.
	UserName string
}

//
// This data object type describes a request to a service.
// It is used as argument to
// AcquireGenericServiceTicket.
//
// This is the base class for more specific service request specifications.
// E.g. for HTTP services the derived class will provide a URL property.
//
//
type SessionManagerServiceRequestSpec struct {
	*DynamicData
}

//
// This data object type describes a request to invoke a specific method
// in a VMOMI service.
//
// It currenly only supports {link vim.SessionManager#cloneSession} method.
// The GenericServiceTicket.id returned from
// AcquireGenericServiceTicket for this request
// can be use for CloneSession to clone a session
//
//
type SessionManagerVmomiServiceRequestSpec struct {
	*SessionManagerServiceRequestSpec

	// Name of the method identified by this request spec
	Method string
}

//
// This event records the termination of a session.
//
//
type SessionTerminatedEvent struct {
	*SessionEvent

	// The unique identifier of the terminated session.
	SessionId string

	// The name of the user owning the terminated session.
	TerminatedUsername string
}

//
// The virtual machine has one or more SCSI controllers that are engaged
// in bus sharing. This is an error when migrating a powered-on virtual machine,
// and can be returned as a subfault of DisallowedMigrationDeviceAttached.
//
//
type SharedBusControllerNotSupported struct {
	*DeviceNotSupported
}

//
// Specification of shares.
//
// Shares are used to determine relative allocation between resource consumers.
// In general, a consumer with more shares gets proportionally more of
// the resource, subject to certain other constraints.
//
//
//
type SharesInfo struct {
	*DynamicData

	// The allocation level.  The level is a simplified view of shares.
	// Levels map to a pre-determined set of numeric values for shares.
	// If the shares value does not map to a predefined size, then
	// the level is set as custom.
	Level *enum.SharesLevel

	// The number of shares allocated. Used to determine resource allocation in case of
	// resource contention. This value is only set if level is set to custom. If level is
	// not set to custom, this value is ignored. Therefore, only shares with custom
	// values can be compared.
	//
	// There is no unit for this value. It is a relative measure based on the settings
	// for other resource pools.
	Shares int32
}

//
// Simplified shares notation.
// These designations have different meanings for different resources.
//
//
type SharesLevel struct {
}

//
// Specification of shares.
//
// Object of this class specifies value ranges for object of
// instance SharesInfo
//
//
//
type SharesOption struct {
	*DynamicData

	// Default value for level
	DefaultLevel *enum.SharesLevel

	// Value range which can be used for share definition
	// in shares
	SharesOption *IntOption
}

//
// This exception is thrown when VirtualMachine.shrinkDisk
// encounters an error
//
//
type ShrinkDiskFault struct {
	*VimFault

	// Disk Id of the virtual disk that caused the fault
	DiskId int32
}

//
// A managed object that wraps the execution of a single arbitrary
// command. The specific command executed is assumed to be known from
// the service name by the client invoking this command.  This object
// presents a generic interface for such services.
//
type SimpleCommand struct {
	*ManagedObject

	encodingType *enum.SimpleCommandEncoding

	entity *ServiceManagerServiceInfo
}

// The encoding type used in the result.
func (mo *SimpleCommand) EncodingType() (*SimpleCommandEncoding, error) {
	t, err := mo.currentProperty("encodingType")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*SimpleCommandEncoding)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *SimpleCommandEncoding")
	}
	return v, nil
}

// A description of the service.
func (mo *SimpleCommand) Entity() (*ServiceManagerServiceInfo, error) {
	t, err := mo.currentProperty("entity")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ServiceManagerServiceInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ServiceManagerServiceInfo")
	}
	return v, nil
}

//
// The single function execution point for this simple command. The actual effects of
// this command depend upon the service handler registered for this instance.
//
// Required Privileges
// Global.ServiceManagers
//
func (mo *SimpleCommand) ExecuteSimpleCommand(
	_this *ManagedObjectReference, arguments []string,
) (string, error) {

	return "", nil

}

//
// The encoding of the resultant return data. This is a hint to the client side
// to indicate the format of the information being returned.
//
//
type SimpleCommandEncoding struct {
}

//
// This class specifies a single IP address.
//
//
type SingleIp struct {
	*IpAddress

	// The IP address. The value of this property should either be an
	// IPv4 address such as "192.168.0.1" or an IPv6 address such as
	// "fc00:192:168:0:6cd9:a132:e889:b612"
	Address string
}

//
// This class defines a Single MAC address.
//
//
type SingleMac struct {
	*MacAddress

	// The MAC address. The value for this property should be in the form
	// like "00:50:56:bc:ef:ab".
	Address string
}

//
// The available SLP discovery methods.
//
//
type SlpDiscoveryMethod struct {
}

//
// An attempt is being made to copy a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host under any circumstances. This is a warning.
//
//
type SnapshotCloneNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// An attempt is being made to move or copy a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported
// because of some aspect of the virtual machine configuration, virtual
// machine power state, or the requested disk placement.  This is an error
// for move operations (where the source is deleted after the copy) and a
// warning for clones (where the source is preserved).
//
//
type SnapshotCopyNotSupported struct {
	*MigrationFault
}

//
// Fault thrown if a snapshot operation cannot be performed because
// snapshots are disabled on the virtual machine.
//
//
type SnapshotDisabled struct {
	*SnapshotFault
}

//
// Base type for Snapshot-related errors.
//
//
type SnapshotFault struct {
	*VimFault
}

//
// Thrown if a snapshot operation cannot be performed on account
// of an incompatible device. This fault can be thrown for instance
// if a virtual machine uses a raw disk or a shared bus controller.
//
//
type SnapshotIncompatibleDeviceInVm struct {
	*SnapshotFault

	// A fault specifies the particular device issue. This is typically
	// a subclass of VirtualHardwareCompatibilityIssue, such as
	// RawDiskNotSupported, or SharedBusControllerNotSupported.
	Fault *LocalizedMethodFault
}

//
// Fault thrown when an attempt is made to create or delete a snapshot on a
// virtual machine that has its snapshot locked.
//
//
type SnapshotLocked struct {
	*SnapshotFault
}

//
// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the disk is currently located somewhere other than the virtual
// machine's home datastore.
//
//
type SnapshotMoveFromNonHomeNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host under any circumstances.
//
//
type SnapshotMoveNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the disk is being moved to some location other than the new
// home datastore for the virtual machine.
//
//
type SnapshotMoveToNonHomeNotSupported struct {
	*SnapshotCopyNotSupported
}

//
// This fault is for a snapshot request on a virtual machine whose state
// has not changed since a previous successful snapshot. For example, this
// occurs when you suspend the virtual machine, create a snapshot, and
// then request another snapshot of the suspended virtual machine.
//
//
type SnapshotNoChange struct {
	*SnapshotFault
}

//
// If the virtual machine is migrated to the destination host, there may be
// a problem reverting to one of its snapshots. This is a warning.  If the
// snapshot name is not set and the event array is empty, then it the snapshot
// might possibly revert correctly.  If the name is set and the event array is not
// empty then there surely will be a problem reverting to the snapshot.
//
//
type SnapshotRevertIssue struct {
	*MigrationFault

	// True if any of the events above are error events.
	Errors bool

	// The problem(s) that would occur on reverting to the snapshot. This
	// is determined similarly to invoking validateMigration on a powered-off
	// virtual machine with the snapshot's state.  However, not all errors
	// or warnings for virtual machine migration are guaranteed to be
	// detected for snapshots.
	Event []*Event

	// The name of the problematic snapshot.
	SnapshotName string
}

//
// The current DRS migration priority setting prevents generating
// a recommendation to correct the soft VM/Host affinity rules constraint
// violation for the VM so the violation will not be corrected.
//
//
type SoftRuleVioCorrectionDisallowed struct {
	*VmConfigFault

	// The vm for which the VM/Host soft affinity rules constraint violation
	// is not being corrected by DRS.
	VmName string
}

//
// DRS has determined that correcting the soft VM/Host affinity rules
// constraint violation for the VM impacts respecting cluster constraints
// or performance goals so the violation will not be corrected.
//
//
type SoftRuleVioCorrectionImpact struct {
	*VmConfigFault

	// The vm for which the VM/Host soft affinity rules constraint violation
	// is not being corrected by DRS.
	VmName string
}

//
// A SsdDiskNotAvailable fault indicating that the specified SSD
// disk is not available. The disk either has been used or not a
// SSD disk.
//
//
type SsdDiskNotAvailable struct {
	*VimFault

	// The device path of the disk.See devicePath
	DevicePath string
}

//
// An alarm expression that uses the running state of either a virtual machine or
// a host as the condition that triggers the alarm. Base type.
//
// There are two alarm operands: yellow and red. At least one of them
// must be set. The value of the alarm expression is determined as follows:
//
//
//
// • If the red state is set but the yellow state is not: the expression is red when
// the state operand matches (isEqual operator) or does not match (isUnequal operator)
// the state of the managed entity. The expression is green otherwise.
//
// • If yellow is set but red is not: the expression is yellow when
// the state operand matches (isEqual) or does not match (isUnequal)
// the state of the managed entity. The expression is green otherwise.
//
// • If both yellow and red are set, the value of the expression is red when
// the red state operand matches (isEqual) or does not match (isUnequal)
// the state of the managed entity. Otherwise, the expression is
// yellow when the yellow state operand matches (isEqual) or does not match (isUnequal)
// the state of the managed entity. Otherwise, the expression is green.
//
//
//
//
//
type StateAlarmExpression struct {
	*AlarmExpression

	// The operation to be tested on the target state.
	Operator *enum.StateAlarmOperator

	// Whether or not to test for a red condition.
	// If this property is not set, do not calculate red status.
	Red string

	// Path of the state property.
	//
	// The supported values:
	//
	// for vim.VirtualMachine type:
	// runtime.powerState or summary.quickStats.guestHeartbeatStatus
	// for vim.HostSystem type: runtime.connectionState
	StatePath string

	// Name of the object type containing the property.
	Type string

	// Whether or not to test for a yellow condition.
	// If this property is not set, do not calculate yellow status.
	Yellow string
}

//
// The operation on the target state.
//
//
type StateAlarmOperator struct {
}

//
// The StaticRouteProfile data object represents a single static IP route.
// The policy property contains
// data values for static route configuration.
//
//
type StaticRouteProfile struct {
	*ApplyProfile

	// Linkable identifier.
	//
	// Since vSphere API 5.1
	Key string
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate one or more virtual disks of a VM because the disk has
// multi-writer mode enabled.
//
//
type StorageDrsCannotMoveDiskInMultiWriterMode struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate Fault Tolerant VMs across datastores.
//
//
type StorageDrsCannotMoveFTVm struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate an independent disk.
//
//
type StorageDrsCannotMoveIndependentDisk struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VM because it has a manually selected fixed location for its
// swap file.
//
//
type StorageDrsCannotMoveManuallyPlacedSwapFile struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate a Vm that is placed by user to a specific datastore.
//
//
type StorageDrsCannotMoveManuallyPlacedVm struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate a shared virtual disk that is attached to more than one Vm.
//
//
type StorageDrsCannotMoveSharedDisk struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate template VMs across datastores.
//
//
type StorageDrsCannotMoveTemplate struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs placed in user-specified folders.
//
//
type StorageDrsCannotMoveVmInUserFolder struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs that have a CD-ROM device mounted.
//
//
type StorageDrsCannotMoveVmWithMountedCDROM struct {
	*VimFault
}

//
// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs that have no files in its file layout.
//
//
type StorageDrsCannotMoveVmWithNoFilesInLayout struct {
	*VimFault
}

//
// The StorageDrsConfigInfo data object describes storage DRS configuration
// for a pod StoragePod.
//
//
//
//
type StorageDrsConfigInfo struct {
	*DynamicData

	// Pod-wide configuration of the storage DRS service.
	PodConfig *StorageDrsPodConfigInfo

	// List of virtual machine configurations for the storage DRS
	// service. Each entry applies to all the virtual disks of the virtual machine
	// on this pod.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	VmConfig []*StorageDrsVmConfigInfo
}

//
// The StorageDrsConfigSpec data object provides a set of update
// specifications for storage DRS configuration. To support
// incremental changes, these properties are all optional.
//
//
//
//
type StorageDrsConfigSpec struct {
	*DynamicData

	// Changes to the configuration of the storage DRS service.
	PodConfigSpec *StorageDrsPodConfigSpec

	// Changes to the per-virtual-machine storage DRS settings.
	VmConfigSpec []*StorageDrsVmConfigSpec
}

//
// This fault is thrown when one datastore using Storage DRS is added to two
// different datacenters.
//
//
type StorageDrsDatacentersCannotShareDatastore struct {
	*VimFault
}

//
// This fault is thrown when Storage DRS cannot move disks of a virtual machine
// because Storage DRS is disabled on it.
//
//
type StorageDrsDisabledOnVm struct {
	*VimFault
}

//
// Storage DRS configuration for I/O load balancing.
//
//
//
//
type StorageDrsIoLoadBalanceConfig struct {
	*DynamicData

	// Storage DRS makes storage migration recommendations if
	// I/O latency on one (or more) of the datastores is higher than
	// the specified threshold.
	//
	// Unit: millisecond.
	// The valid values are in the range of 5 to 100. If not specified,
	// the default value is 15.
	IoLatencyThreshold int32

	// Storage DRS makes storage migration recommendations if
	// I/O load imbalance level is higher than the specified threshold.
	//
	// Unit: a number.
	// The valid values are in the range of 1 to 100. If not specified,
	// the default value is 5.
	IoLoadImbalanceThreshold int32
}

//
// The fault occurs when Storage DRS disables IO Load balancing internally
// even though it is enabled by the user. This can happen due to one of the
// following reasons:
// 1. SIOC couldn't get enabled on at least one of the datastores
// 2. The connectivity between hosts and datastores is not uniform for all datastores.
// 3. Some statistics are not available to run IO load balancing
//
//
type StorageDrsIolbDisabledInternally struct {
	*VimFault
}

//
// An incremental update to the advance settings.
//
//
//
//
type StorageDrsOptionSpec struct {
	*ArrayUpdateSpec

	Option *OptionValue
}

//
// The StorageDrsPodConfigInfo data object contains pod-wide configuration information
// for the storage DRS service.
//
//
//
//
type StorageDrsPodConfigInfo struct {
	*DynamicData

	// Specifies whether or not each virtual machine in this pod should have its virtual
	// disks on the same datastore by default. If set to true, virtual machines will have
	// all their virtual disks on the same datastore. If set to false, the virtual disks
	// of a virtual machine may or may not be placed on the same datastore.
	// If not set, the default value is true.
	// You can override the default behavior for a virtual machine
	// by using the StorageDrsVmConfigInfo object.
	DefaultIntraVmAffinity bool

	// Specifies the pod-wide default storage DRS behavior for virtual machines.
	// For currently supported storage DRS behavior, see Behavior.
	// You can override the default behavior for a virtual machine
	// by using the StorageDrsVmConfigInfo object.
	DefaultVmBehavior string

	// Flag indicating whether or not storage DRS is enabled.
	Enabled bool

	// The configuration settings for load balancing I/O workload.
	// This takes effect only if ioLoadBalanceEnabled is true.
	IoLoadBalanceConfig *StorageDrsIoLoadBalanceConfig

	// Flag indicating whether or not storage DRS takes into account storage I/O
	// workload when making load balancing and initial placement recommendations.
	IoLoadBalanceEnabled bool

	// Specify the interval that storage DRS runs to load balance among datastores
	// within a storage pod.
	//
	// Unit: minute.
	// The valid values are from 60 (1 hour) to 43200 (30 days).
	// If not specified, the default value is 480 (8 hours).
	LoadBalanceInterval int32

	// Advanced settings.
	Option []*OptionValue

	// Pod-wide rules.
	Rule []*ClusterRuleInfo

	// The configuration settings for load balancing storage space.
	SpaceLoadBalanceConfig *StorageDrsSpaceLoadBalanceConfig
}

//
// Storage DRS behavior.
//
//
type StorageDrsPodConfigInfoBehavior struct {
}

//
// The StorageDrsPodConfigSpec data object provides a set of update
// specifications for pod-wide storage DRS configuration. To support
// incremental changes, these properties are all optional.
//
//
//
//
type StorageDrsPodConfigSpec struct {
	*DynamicData

	// Specifies whether or not each virtual machine in this pod should have its virtual
	// disks on the same datastore by default.
	DefaultIntraVmAffinity bool

	// Specifies the pod-wide default storage DRS behavior for virtual machines.
	// For currently supported storage DRS behavior, see StorageDrsPodConfigInfoBehavior.
	// You can override the default behavior for a virtual machine
	// by using the StorageDrsVmConfigInfo object.
	DefaultVmBehavior string

	// Flag indicating whether or not storage DRS is enabled.
	Enabled bool

	// The configuration settings for load balancing I/O workload.
	// This takes effect only if ioLoadBalanceEnabled is true.
	IoLoadBalanceConfig *StorageDrsIoLoadBalanceConfig

	// Flag indicating whether or not storage DRS takes into account storage I/O
	// workload when making load balancing and initial placement recommendations.
	IoLoadBalanceEnabled bool

	// Specify the interval that storage DRS runs to load balance among datastores
	// within a storage pod.
	LoadBalanceInterval int32

	// Changes to advance settings.
	Option []*StorageDrsOptionSpec

	// Changes to the set of rules.
	Rule []*ClusterRuleSpec

	// The configuration settings for load balancing storage space.
	SpaceLoadBalanceConfig *StorageDrsSpaceLoadBalanceConfig
}

//
// Specification for moving or copying a virtual machine to a different Storage Pod.
//
//
//
//
type StorageDrsPodSelectionSpec struct {
	*DynamicData

	// An optional list that allows specifying the storage pod location
	// for each virtual disk and the VM configurations and overrides to be
	// used during placement.
	InitialVmConfig []*VmPodConfigForPlacement

	// The storage pod where the virtual machine should be located.
	StoragePod *StoragePod
}

//
// Storage DRS configuration for space load balancing.
//
//
//
//
type StorageDrsSpaceLoadBalanceConfig struct {
	*DynamicData

	// Storage DRS considers making storage migration recommendations if
	// the difference in space utilization between the source and destination datastores
	// is higher than the specified threshold.
	//
	// The valid values are in the range of 1 (i.e., 1%) to 50 (i.e., 50%).
	// If not specified, the default value is 5%.
	MinSpaceUtilizationDifference int32

	// Storage DRS makes storage migration recommendations if
	// space utilization on one (or more) of the datastores is higher than
	// the specified threshold.
	//
	// The valid values are in the range of 50 (i.e., 50%) to 100 (i.e., 100%).
	// If not specified, the default value is 80%.
	SpaceUtilizationThreshold int32
}

//
// This fault is thrown when Storage DRS cannot generate recommendations
// to move VM files due to pre-existing cross datastore disk backings.
//
//
type StorageDrsUnableToMoveFiles struct {
	*VimFault
}

//
// Storage DRS configuration for a single virtual machine. This makes it possible
// to override the default behavior for an individual virtual machine.
//
//
//
//
type StorageDrsVmConfigInfo struct {
	*DynamicData

	// Specifies the particular storage DRS behavior for this virtual machine.
	//
	// For supported values, see StorageDrsPodConfigInfoBehavior.
	Behavior string

	// Flag to indicate whether or not VirtualCenter is allowed to perform any
	// storage migration or initial placement recommendations for this virtual
	// machine on the pod StoragePod.
	// If this flag is false, the virtual machine is effectively excluded from
	// storage DRS.
	//
	// If no individual DRS specification exists for a virtual machine,
	// this property defaults to true.
	Enabled bool

	// Specifies whether or not to have the affinity rule for the virtual disks
	// of this virtual machine. If not set, the default value is derived from
	// the pod-wide default defaultIntraVmAffinity.
	IntraVmAffinity bool

	// Specifies the disks for this virtual machine that should be placed
	// on different datastores. A VM cannot have both an affinity and an
	// anti-affinity rule at the same time. Virtual machine disks that are
	// not in this rule are unconstrained and can be placed either on the
	// same datastore or on a different datastore as other disks from this virtual machine.
	IntraVmAntiAffinity *VirtualDiskAntiAffinityRuleSpec

	// Reference to the virtual machine. Can be NULL during initial placement.
	Vm *VirtualMachine
}

//
// Updates the per-virtual-machine storage DRS configuration.
//
//
//
//
type StorageDrsVmConfigSpec struct {
	*ArrayUpdateSpec

	Info *StorageDrsVmConfigInfo
}

//
// The IOAllocationInfo specifies the shares, limit and reservation
// for storage I/O resource.
//
// The storage I/O resource is allocated to virtual machines based on their
// shares, limit and reservation. The reservation is currently exposed only
// at the host level for local datastores.
// And we do not support storage I/O resource management on resource pools.
//
//
// Each virtual machine has one IOAllocationInfo object per virtual
// disk. For example, we can specify that a virtual machine has 500 shares on
// the first virtual disk, 1000 shares on the second virtual disk, etc.
//
//
//
type StorageIOAllocationInfo struct {
	*DynamicData

	// The utilization of a virtual machine will not exceed this limit, even
	// if there are available resources. This is typically used to ensure a consistent
	// performance of virtual machines independent of available resources.
	// If set to -1, then there is no fixed limit on resource usage (only
	// bounded by available resources and shares). The unit is number of
	// I/O per second.
	// While setting the limit for storage I/O resource, if the property is unset,
	// it is treated as no change and the property is not updated. While reading
	// back the limit information of storage I/O resource, if the property is unset,
	// a default value of -1 will be returned, which indicates that there is no
	// limit on resource usage.
	Limit int64

	// Reservation control is used to provide guaranteed allocation in terms
	// of IOPS. Large IO sizes are considered as multiple IOs using a chunk
	// size of 32 KB as default. This control is initially supported only
	// at host level for local datastores. It future, it may get supported
	// on shared storage based on integration with Storage IO Control.
	// Also right now we don't do any admission control based on IO
	// reservation values.
	//
	// Since vSphere API 5.5
	Reservation int32

	// Shares are used in case of resource contention.
	// The value should be within a range of 200 to 4000.
	// While setting shares for storage I/O resource, if the property is unset,
	// it is treated as no change and the property is not updated. While reading
	// back the shares information of storage I/O resource, if the property is unset,
	// a default value of level = normal,
	// shares = 1000 will be returned.
	Shares *SharesInfo
}

//
// The IOAllocationOption specifies value ranges that can be used
// to initialize IOAllocationInfo object.
//
//
type StorageIOAllocationOption struct {
	*DynamicData

	// limitOptions defines a range of values allowed to be used for
	// storage IO limit limit.
	LimitOption *LongOption

	// sharesOption defines a range of values allowed to be used to
	// specify allocated io shares shares.
	SharesOption *SharesOption
}

//
// Configuration setting ranges for IORMConfigSpec object.
//
//
type StorageIORMConfigOption struct {
	*DynamicData

	// congestionThresholdOption defines value range which can be used for
	// congestionThreshold
	CongestionThresholdOption *IntOption

	// enabledOption provides default state value for
	// enabled
	EnabledOption *BoolOption

	// statsCollectionEnabledOption provides default value for
	// statsCollectionEnabled
	//
	// Since vSphere API 5.0
	StatsCollectionEnabledOption *BoolOption
}

//
// Configuration settings used for creating or reconfiguring
// storage I/O resource management.
//
// All fields are defined as optional. If a field is unset,
// the property is not changed.
//
//
//
type StorageIORMConfigSpec struct {
	*DynamicData

	// The latency beyond which the storage array is considered congested.
	//
	// For more information, see
	// congestionThreshold
	CongestionThreshold int32

	// Mode of congestion threshold specification
	// For more information, see
	// StorageIORMThresholdMode
	//
	// Since vSphere API 5.1
	CongestionThresholdMode string

	// Flag indicating whether or not the service is enabled.
	Enabled bool

	// The percentage of peak throughput to be used for setting threshold latency
	// of a datastore. Valid values are between 50 to 100.
	//
	// For more information, see
	// congestionThreshold
	//
	// Since vSphere API 5.1
	PercentOfPeakThroughput int32

	// Flag indicating whether stats aggregation is disabled.
	//
	// Since vSphere API 5.0
	StatsAggregationDisabled bool

	// Flag indicating whether the service is enabled in stats collection mode.
	//
	// Since vSphere API 5.0
	StatsCollectionEnabled bool
}

//
// Configuration of storage I/O resource management.
//
//
type StorageIORMInfo struct {
	*DynamicData

	// The latency beyond which the storage array is considered congested.
	//
	// If storage I/O resource management is enabled on a datastore,
	// the algorithm tries to maintain the latency to be below or
	// close to this value. The unit is millisecond. The range of
	// this value is between 5 to 100 milliseconds.
	CongestionThreshold int32

	// Mode of congestion threshold specification
	// For more information, see
	// StorageIORMThresholdMode
	//
	// Since vSphere API 5.1
	CongestionThresholdMode string

	// Flag indicating whether or not the service is enabled.
	Enabled bool

	// The percentage of peak throughput to be used for setting congestion threshold
	// of a datastore. Valid values are between 50 to 100. Default value is 90%
	//
	// For more information, see
	// congestionThreshold
	//
	// Since vSphere API 5.1
	PercentOfPeakThroughput int32

	// Flag indicating whether stats aggregation is disabled.
	//
	// Since vSphere API 5.0
	StatsAggregationDisabled bool

	// Flag indicating whether service is running in stats collection mode.
	//
	// Since vSphere API 5.0
	StatsCollectionEnabled bool
}

//
// User specification of congestion threshold mode on a given datastore
//
// For more information, see
// congestionThreshold
//
//
//
type StorageIORMThresholdMode struct {
}

//
// Describes a single storage migration action. The storage migration
// action applies either to a virtual machine or a set of virtual disks.
//
//
//
//
type StorageMigrationAction struct {
	*ClusterAction

	// Destination datastore.
	Destination *Datastore

	// I/O latency on the destination datastore before storage migration.
	// Unit: millisecond.
	// If not set, the value is not available.
	IoLatencyDstBefore float32

	// I/O latency on the source datastore before storage migration.
	// Unit: millisecond.
	// If not set, the value is not available.
	IoLatencySrcBefore float32

	// Specification for moving a virtual machine or a set of virtual disks
	// to a different datastore.
	RelocateSpec *VirtualMachineRelocateSpec

	// The amount of data to be transferred.
	// Unit: KB.
	SizeTransferred int64

	// Source datastore.
	Source *Datastore

	// Expected space utilization on the destination datastore after storage migration.
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilDstAfter float32

	// Space utilization on the destination datastore before storage migration.
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilDstBefore float32

	// Expected space utilization on the source datastore after storage migration.
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilSrcAfter float32

	// Space utilization on the source datastore before storage migration.
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilSrcBefore float32

	// Virtual machine reference.
	Vm *VirtualMachine
}

//
// Summary statistics for datastore performance
// The statistics are reported in aggregated quantiles over a time period
//
//
type StoragePerformanceSummary struct {
	*DynamicData

	// Aggregated datastore Read IO rate (Reads/second)
	DatastoreReadIops []float64

	// Aggregated datastore latency in milliseconds for read operations
	DatastoreReadLatency []float64

	// Aggregated datastore latency as observed by Vms using the datastore
	// The reported latency is in milliseconds.
	DatastoreVmLatency []float64

	// Aggregated datastore Write IO rate (Writes/second)
	DatastoreWriteIops []float64

	// Aggregated datastore latency in milliseconds for write operations
	DatastoreWriteLatency []float64

	// Time period over which statistics are aggregated
	// The reported time unit is in seconds
	Interval int32

	// Metric percentile specification. A percentile is a value
	// between 1 and 100. The metric value reported in the
	// aggregated statistics corresponds with the percentile values
	// in this field. For example, if the value of percentile[0] is
	// P, and the value of the datastoreReadLatency[0] is L, then
	// P% of all the read IOs performed during observation interval
	// is less than L milliseconds.
	Percentile []int32

	// Cumulative SIOC activity to satisfy SIOC latency threshold
	// setting.  This metric indicates the total time that SIOC is
	// actively throttling IO requests. The SIOC throttling
	// activity occurs whenever the datastore latency exceeds the
	// SIOC latency threshold. If SIOC is not enabled on the
	// datastore, the metric indicates the total time that SIOC
	// would have been active. The unit of reporting is in
	// milliseconds.
	SiocActivityDuration int32
}

//
// Describes a single storage initial placement action for placing a virtual
// machine or a set of virtual disks on a datastore.
//
//
//
//
type StoragePlacementAction struct {
	*ClusterAction

	// Target datastore.
	Destination *Datastore

	// Current I/O latency on the target datastore.
	// Unit: millisecond.
	// If not set, the value is not available.
	IoLatencyBefore float32

	// Specification for placing a virtual machine or a set of virtual disks
	// to a datastore.
	RelocateSpec *VirtualMachineRelocateSpec

	// Expected space utilization on the target datastore after placing the virtual disk.
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilAfter float32

	// Current space utilization on the target datastore.
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilBefore float32

	// Virtual machine reference.
	// It is possible that the VM has not been created, in which case,
	// this property is left unset.
	Vm *VirtualMachine
}

//
// Both RecommendDatastores and
// DatastoreEnterMaintenanceMode methods may invoke Storage DRS
// for recommendations on placing or evacuating virtual disks.
// StoragePlacementResult is the class of the result returned by
// the methods.
//
//
//
//
type StoragePlacementResult struct {
	*DynamicData

	// Information about any fault in case Storage DRS failed to make a recommendation.
	DrsFault *ClusterDrsFaults

	// The list of recommendations that the client needs to approve manually.
	Recommendations []*ClusterRecommendation

	// The ID of the task, which monitors the storage placement or datastore entering
	// maintennace mode operation.
	Task *Task
}

//
// StoragePlacementSpec encapsulates all of the inputs passed to the
// RecommendDatastores method.
//
//
//
//
type StoragePlacementSpec struct {
	*DynamicData

	// Name for cloned virtual machine.
	CloneName string

	// Specification for a virtual machine cloning operation.
	CloneSpec *VirtualMachineCloneSpec

	// Configuration for the virtual machine.
	ConfigSpec *VirtualMachineConfigSpec

	// Specification for whether to disable pre-requisite storage vmotions
	// for storage placements. If unset, default behavior is to allow such
	// prerequisite moves.
	//
	// Since vSphere API 5.1
	DisallowPrerequisiteMoves bool

	// The target virtual machine folder for the virtual machine.
	// Note that this is a different folder than the pod(s) that the virtual
	// machine belongs to. The pod mapping represents the storage view of
	// the virtual machine, while the virtual machine folder mapping
	// represents an inventory view of the virtual machine.
	//
	// For manual VM provisioning operations, this is specified implicitly
	// as the object that the CreateVM_Task method is invoked on.
	Folder *Folder

	// The target host for the virtual machine.
	Host *HostSystem

	// Specification for moving a virtual machine or a set of virtual disks
	// to a different storage pod.
	PodSelectionSpec *StorageDrsPodSelectionSpec

	// Priority of this placement operation.
	Priority *enum.VirtualMachineMovePriority

	// Specification for relocating a virtual machine.
	RelocateSpec *VirtualMachineRelocateSpec

	// Resource lease duration in seconds. If the duration is within bounds,
	// Storage DRS will hold onto resources needed for applying recommendations
	// generated as part of that call.
	// Only initial placement recommendations generated by storage DRS can reserve
	// resources this way.
	//
	// Since vSphere API 5.1
	ResourceLeaseDurationSec int32

	// The resource pool to which this virtual machine should be attached.
	ResourcePool *ResourcePool

	// The storage placement type. The set of possible values is described in
	// StoragePlacementSpecPlacementType
	Type string

	// The relevant virtual machine.
	Vm *VirtualMachine
}

//
// Defines the storage placement operation type.
//
//
//
//
type StoragePlacementSpecPlacementType struct {
}

//
// The StoragePod data object aggregates the storage
// resources of associated Datastore objects into a single
// storage resource for use by virtual machines. The storage services
// such as Storage DRS (Distributed Resource Scheduling),
// enhance the utility of the storage pod.
//
// Use the Folder.CreateStoragePod method
// to create an instance of this object.
//
//
//
//
//
type StoragePod struct {
	*ManagedObject
	*Folder

	podStorageDrsEntry *PodStorageDrsEntry

	summary *StoragePodSummary
}

// Storage DRS related attributes of the Storage Pod.
// Required Privilege: System.Read
func (mo *StoragePod) PodStorageDrsEntry() (*PodStorageDrsEntry, error) {
	t, err := mo.currentProperty("podStorageDrsEntry")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*PodStorageDrsEntry)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *PodStorageDrsEntry")
	}
	return v, nil
}

// Storage pod summary.
// Required Privilege: System.View
func (mo *StoragePod) Summary() (*StoragePodSummary, error) {
	t, err := mo.currentProperty("summary")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*StoragePodSummary)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *StoragePodSummary")
	}
	return v, nil
}

//
// The StoragePodSummary data object
// encapsulates runtime properties of a StoragePod.
//
//
//
//
type StoragePodSummary struct {
	*DynamicData

	// Total capacity of this storage pod, in bytes. This value is the sum of the
	// capacity of all datastores that are part of this storage pod, and is updated
	// periodically by the server.
	Capacity int64

	// Total free space on this storage pod, in bytes. This value is the sum of the
	// free space on all datastores that are part of this storage pod, and is updated
	// periodically by the server.
	FreeSpace int64

	// The name of the storage pod.
	Name string
}

//
// The StorageProfile data object represents the host storage configuration.
// If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type StorageProfile struct {
	*ApplyProfile

	// List of NAS storage subprofiles. Use the key property
	// to access a subprofile in the list.
	NasStorage []*NasStorageProfile
}

//
// Describes the storage requirment to perform a consolidation
// operation.
//
//
type StorageRequirement struct {
	*DynamicData

	// The datastore.
	Datastore *Datastore

	// Space required.
	FreeSpaceRequiredInKb int64
}

//
// This managed object type provides a way to configure resource usage for
// storage resources.
//
type StorageResourceManager struct {
	*ManagedObject
}

//
// Applies a recommendation from the recommendation list. Each recommendation can be
// applied only once. In the case of CreateVm and CloneVm a VirtualMachine is returned.
// Other workflows don't have a return value.
//
// Requires Resource.ApplyRecommendation privilege on the storage pod.
// Additionally, depending on the workflow where this API is called from, it may require
// the privileges of invoking one of following APIs:
//
//
//
// • CreateVm CreateVM_Task
//
// • AddDisk ReconfigVM_Task
//
// • RelocateVm RelocateVM_Task
//
// • CloneVm CloneVM_Task
//
//
//
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *StorageResourceManager) ApplyStorageDrsRecommendation_Task(
	_this *ManagedObjectReference, key []string,
) (*Task, error) {

	return nil, nil

}

//
// Applies a recommendation from the recommendation list. Each recommendation can be
// applied only once.
//
// Requires Resource.ApplyRecommendation privilege on the storage pod. And requires
// Resource.ColdMigrate privilege on the virtual machine(s) that are relocated.
// Additionally requires Resource.HotMigrate privilege if the virtual machine is
// powered on (for Storage VMotion). Also requires Datastore.AllocateSpace on any
// datastore the virtual machine or its disks are relocated to.
//
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *StorageResourceManager) ApplyStorageDrsRecommendationToPod_Task(
	_this *ManagedObjectReference, pod *StoragePod, key string,
) (*Task, error) {

	return nil, nil

}

//
// Cancels a recommendation. Currently only initial placement
// recommendations can be cancelled. Migration recommendations cannot.
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *StorageResourceManager) CancelStorageDrsRecommendation(
	_this *ManagedObjectReference, key []string,
) error {

	return nil

}

//
// Changes configuration of storage I/O resource management for a given datastore.
// The changes are applied to all the backing storage devices for the datastore.
// Currently we only support storage I/O resource management on VMFS volumes.
// In order to enable storage I/O resource management on a datstore, we require
// that all the hosts that are attached to the datastore support this feature.
//
// This method is only supported by vCenter server.
//
//
//
//
// Required Privileges
// None
//
func (mo *StorageResourceManager) ConfigureDatastoreIORM_Task(
	_this *ManagedObjectReference, datastore *Datastore, spec *StorageIORMConfigSpec,
) (*Task, error) {

	return nil, nil

}

//
// Change the storage DRS configuration for a pod StoragePod.
//
//
//
// Required Privileges
// None
// Since
// vSphere API 5.0
//
func (mo *StorageResourceManager) ConfigureStorageDrsForPod_Task(
	_this *ManagedObjectReference, pod *StoragePod, spec *StorageDrsConfigSpec, modify bool,
) (*Task, error) {

	return nil, nil

}

//
// Returns datastore summary performance statistics.
//
// This is an experimental interface that is not intended for
// use in production code.
//
//
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.1
//
func (mo *StorageResourceManager) QueryDatastorePerformanceSummary(
	_this *ManagedObjectReference, datastore *Datastore,
) ([]*StoragePerformanceSummary, error) {

	return nil, nil

}

//
// Query configuration options for storage I/O resource management.
//
//
//
// Required Privileges
// Datastore.Config
//
func (mo *StorageResourceManager) QueryIORMConfigOption(
	_this *ManagedObjectReference, host *HostSystem,
) (*StorageIORMConfigOption, error) {

	return nil, nil

}

//
//
// This method returns a StoragePlacementResult object.
//
// This API is intended to replace the following existing APIs for
// SDRS-enabled pods:
//
// CreateVm: StoragePlacementSpec::type == create =
// CreateVM_Task
//
// AddDisk: StoragePlacementSpec::type == reconfigure =
// ReconfigVM_Task
//
// RelocateVm: StoragePlacementSpec::type == relocate =
// RelocateVM_Task
//
// CloneVm: StoragePlacementSpec::type == clone =
// CloneVM_Task
//
// The PodSelectionSpec parameter in StoragePlacementSpec is required
// for all workflows. It specifies which SDRS-enabled pod the user
// has selected for the VM and/or for each disk.
//
// For CreateVm, RelocateVm and CloneVm, PodSelectionSpec.storagePod is
// the user selected SDRS pod for the VM, i.e., its system files.
//
// For all workflows, PodSelectionSpec.disk.storagePod is the
// user selected SDRS pod for the given disk. Note that a
// DiskLocator must be specified for each disk that the user
// requests to create, migrate or clone into an SDRS pod, even if it's
// the same pod as the VM or the user has manually selected a datastore
// within the pod. If the user has manually selected a datastore, the
// datastore must be specified in the workflow specific fields as described below.
//
// For CreateVm and AddDisk, the manually selected datastore must be specified in
// ConfigSpec.files or ConfigSpec.deviceChange.device.backing.datastore, the fields
// should will be unset if the user wants SDRS to recommend the datastore.
// For RelocateVm, the manually selected datastore must be specified in
// RelocateSpec.datastore or RelocateSpec.disk.datastore; the fields should be
// unset iff the user wants SDRS recommendations. For CloneVm, the manually selected
// datastore must be specified in CloneSpec.location.datastore or
// CloneSpec.location.disk[].datastore; the fields should be unset
// iff the user wants SDRS recommendations.
//
// The remaining expected input parameters in StoragePlacementSpec
// will be the same as those for the existing API as determined by
// StoragePlacementSpec::type. If a parameter is optional in the
// existing API, it will also be optional in the new API.
//
//
//
//
// •
// For CreateVm, the Folder, ConfigSpec, ResourcePool and HostSystem
// parameters will be expected in StoragePlacementSpec. The disks
// to be created can be determined by ConfigSpec -&gt;
// VirtualDeviceSpec[] (deviceChange) -&gt; VirtualDevice (device) -&gt;
// VirtualDisk (subclass).
//
// •
// For AddDisk, the VirtualMachine and ConfigSpec parameters will
// be expected. The use of the ConfigSpec for determining the disks
// to add will be the same as that in CreateVm.
//
// •
// For RelocateVm, the VirtualMachine, RelocateSpec and
// MovePriority parameters will be expected.
//
// •
// For CloneVm, the VirtualMachine, CloneSpec, Folder and cloneName
// parameters will be expected.
//
//
//
//
// SDRS takes into account constraints such as space usages,
// (anti-) affinity rules, datastore maintenance mode, etc. when
// making placement recommendations. Given that the constraints are
// satisfied, SDRS tries to balance space usages and I/O loads in
// the placement.
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *StorageResourceManager) RecommendDatastores(
	_this *ManagedObjectReference, storageSpec *StoragePlacementSpec,
) (*StoragePlacementResult, error) {

	return nil, nil

}

//
// Make Storage DRS invoke again on the specified pod StoragePod
// and return a new list of recommendations. Concurrent "refresh" requests may be combined
// together and trigger only one Storage DRS invocation.
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 5.0
//
func (mo *StorageResourceManager) RefreshStorageDrsRecommendation(
	_this *ManagedObjectReference, pod *StoragePod,
) error {

	return nil

}

//
// An operation on a powered-on virtual machine requests a change of storage
// location, but the host does not have that capability.
//
//
type StorageVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// This fault is thrown when Storage DRS tries to migrate disks of a virtual machine to a datastore,
// but finds that the datastore is incompatible with the given virtual machine.
//
//
type StorageVmotionIncompatible struct {
	*VirtualHardwareCompatibilityIssue

	// The datastore that is incompatible with a given virtual machine.
	Datastore *Datastore
}

//
// The string type of setting or configuration that may get a
// negated value.
//
//
type StringExpression struct {
	*NegatableExpression

	// The String value that is either used as it is or negated.
	Value string
}

//
// The StringOption data object type is used to define an open-ended
// string value based on an optional subset of valid characters.
//
//
type StringOption struct {
	*OptionType

	// The default value.
	DefaultValue string

	// The string containing the set of valid characters. If a string
	// option is not specified, all strings are allowed.
	ValidCharacters string
}

//
// The string type of setting or configuration that may get an
// inherited value.
//
//
type StringPolicy struct {
	*InheritablePolicy

	// The String value that is either set or inherited.
	Value string
}

//
// Either the source host product or the destination host product does not support
// relocation of suspended VMs.  It must be supported on both, in order for the
// relocation to succeed.  This fault is only applicable to suspended virtual machines.
//
//
type SuspendedRelocateNotSupported struct {
	*MigrationFault
}

//
// The compute resource and/or virtual machine configurations indicate that
// when executing on the host the virtual machine should use a specific
// datastore, but host does not have read/write access to that datastore.
// (It may have no access at all, or read-only access.)  If executing on the
// host the virtual machine would instead use its own directory for swapfile
// placement.  This is a compatibility warning, not an error.
//
//
type SwapDatastoreNotWritableOnHost struct {
	*DatastoreNotWritableOnHost
}

//
// The compute resource and/or virtual machine configurations indicate that
// when executing on the host the virtual machine should use a swap
// datastore, but the host does not have a swap datastore configured.  If
// executing on the host the virtual machine would instead use its own directory
// for swapfile placement.  This is a compatibility warning, not an error.
// Note it is actually the common case for a host to not have a configured
// swap datastore, and the problem may rest with the compute resource and/or
// virtual machine configuration; therefore this is not a HostConfigFault.
//
//
type SwapDatastoreUnset struct {
	*VimFault
}

//
// The virtual machine is configured to override the default swapfile placement
// policy, which is not supported on the host.
//
//
type SwapPlacementOverrideNotSupported struct {
	*InvalidVmConfig
}

//
// The distributed virtual switch received a reconfiguration request to
// activate a feature that requires a switch IP address. However, the IP
// address for the switch has not been specified.
//
//
type SwitchIpUnset struct {
	*DvsFault
}

//
// Thrown if an operation is not supported while the DistributedVirtualSwitch
// is not in upgrade mode.
//
//
type SwitchNotInUpgradeMode struct {
	*DvsFault
}

//
// Exception type for reporting a low-level operating system
// error.
//
//
type SystemError struct {
	*RuntimeFault

	// A message to indicate detailed information about the error.
	// This property is not internationalization friendly and
	// normally reported by the underlying operating system.
	Reason string
}

//
// Defines a tag that can be associated with a managed entity.
//
//
type Tag struct {
	*DynamicData

	// The tag key in human readable form.
	Key string
}

//
// A task is used to monitor and potentially cancel long
// running operations.
//
type Task struct {
	*ExtensibleManagedObject

	info *TaskInfo
}

// Detailed information about this task.
func (mo *Task) Info() (*TaskInfo, error) {
	t, err := mo.currentProperty("info")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*TaskInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *TaskInfo")
	}
	return v, nil
}

//
// Cancels a running or queued task.  A task may only be canceled if it is
// cancelable.  Multiple cancel requests will be treated as a single
// cancelation request.  Canceling a completed or already canceled task
// will throw an InvalidState exception.
//
// If a task is canceled, its runtime state will be set to error and its
// error state will be set to RequestCanceled.
//
//
// A cancel operation is asynchronous.  The operation may return before
// the task is canceled.
//
//
// Required Privileges
// Global.CancelTask
//
func (mo *Task) CancelTask(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Updates task description to describe the current phase of the task.
//
//
//
// Required Privileges
// Task.Update
// Since
// vSphere API 4.0
//
func (mo *Task) SetTaskDescription(
	_this *ManagedObjectReference, description *LocalizableMessage,
) error {

	return nil

}

//
// Sets task state and optionally sets results or fault,
// as appropriate for state
//
//
//
// Required Privileges
// Task.Update
// Since
// VI API 2.5
//
func (mo *Task) SetTaskState(
	_this *ManagedObjectReference, state *enum.TaskInfoState, result interface{}, fault *MethodFault,
) error {

	return nil

}

//
// Sets percentage done for this task and recalculates overall
// percentage done. If a percentDone value of less than zero or
// greater than 100 is specified, a value of zero or 100
// respectively is used.
//
//
//
// Required Privileges
// Task.Update
// Since
// VI API 2.5
//
func (mo *Task) UpdateProgress(
	_this *ManagedObjectReference, percentDone int32,
) error {

	return nil

}

//
// Static strings for task objects. These strings are locale-specific.
//
//
type TaskDescription struct {
	*DynamicData

	// Display label and summary for all tasks
	MethodInfo []*ElementDescription

	// Kind of entity responsible for creating this task.
	Reason []*TypeDescription

	// TaskInfo State enum
	State []*ElementDescription
}

//
// This event records the creation of a Task.
//
// Note that the embedded TaskInfo object is a snapshot of the
// Task state at the time of its creation, so its state will always be
// "queued".  To find the current status of the task, query for the
// current state of the Task using the eventChainId in the embedded
// TaskInfo object.
//
//
type TaskEvent struct {
	*Event

	// The information about the task.
	Info *TaskInfo
}

//
// This data object type defines the specification for the task filter used
// to query tasks in the history collector database. The client creates a task
// history collector with a filter specification, then retrieves the tasks from
// the task history collector.
//
//
type TaskFilterSpec struct {
	*DynamicData

	// This property, if provided, limits the set of collected tasks to those
	// associated with the specified alarm.
	// If not provided, tasks are collected regardless of their association with alarms.
	Alarm *Alarm

	// The filter specification for retrieving tasks by managed entity.
	// If not provided, then the tasks attached to all managed entities are
	// collected.
	Entity *TaskFilterSpecByEntity

	// The filter specification for retrieving tasks by chain ID. If it is set,
	// tasks not with the given eventChainId will be
	// filtered out. If the property is not set, tasks' chain ID is disregarded
	// for filtering purposes.
	//
	// Since vSphere API 4.0
	EventChainId []int32

	// The filter specification for retrieving tasks by
	// parentTaskKey. If it is set, tasks not with the
	// given parentTaskKey(s) will be filtered out. If the property is not set,
	// tasks' parentTaskKey is disregarded for filtering purposes.
	//
	// Since vSphere API 4.0
	ParentTaskKey []string

	// The filter specification for retrieving tasks by
	// rootTaskKey. If it is set, tasks not with the
	// given rootTaskKey(s) will be filtered out. If the property is not set,
	// tasks' rootTaskKey is disregarded for filtering purposes.
	//
	// Since vSphere API 4.0
	RootTaskKey []string

	// This property, if provided, limits the set of collected tasks to those
	// associated with the specified scheduled task.
	// If not provided, tasks are collected regardless of their association with any
	// scheduled task.
	ScheduledTask *ScheduledTask

	// This property, if provided, limits the set of collected tasks by their states.
	// Task states are enumerated in State.
	// If not provided, tasks are collected regardless of their state.
	State []*enum.TaskInfoState

	// The filter specification for retrieving tasks by
	// tag. If it is set, tasks not with the given tag(s)
	// will be filtered out. If the property is not set, tasks' tag is disregarded for
	// filtering purposes. If it is set, and includes an empty string, tasks without a
	// tag will be returned.
	//
	// Since vSphere API 4.0
	Tag []string

	// The filter specification for retrieving tasks by time.
	// If not provided, then the tasks with any time stamp are collected.
	Time *TaskFilterSpecByTime

	// The filter specification for retrieving tasks by user name.
	// If not provided, then the tasks belonging to any user are collected.
	UserName *TaskFilterSpecByUsername
}

//
// This data object type specifies a managed entity used to
// filter task history.
//
//
type TaskFilterSpecByEntity struct {
	*DynamicData

	// The managed entity to which the task pertains.
	// Required Privilege: System.View
	Entity *ManagedEntity

	// Specification of related managed entities in the inventory hierarchy.
	Recursion *enum.TaskFilterSpecRecursionOption
}

//
// This data object type specifies a time range used to filter task history.
//
//
type TaskFilterSpecByTime struct {
	*DynamicData

	// The beginning of the time range.
	// If this property is not specified, then tasks are collected from
	// the earliest time in the database.
	//
	// When this property is specified, the time type field must also be specified.
	BeginTime time.Time

	// The end of the time range.
	// If this property is not specified, then tasks are collected up to
	// the latest time in the database.
	//
	// When this property is specified, the time type field must also be specified.
	EndTime time.Time

	// The time stamp to filter: queued, started, or completed time.
	TimeType *enum.TaskFilterSpecTimeOption
}

//
// This data object type enables you to filter task history according to
// the users who performed the tasks.
//
//
type TaskFilterSpecByUsername struct {
	*DynamicData

	// Whether or not to filter by system user.
	// If set to true, filters for system user event.
	SystemUser bool

	// Specifies the username list to use in the filter.
	// If not set, then all regular user tasks are collected.
	UserList []string
}

//
// This option specifies how to select tasks based on child relationships
// in the inventory hierarchy. If a managed entity has children, their tasks
// can be retrieved with this filter option.
//
//
type TaskFilterSpecRecursionOption struct {
}

//
// This option specifies a time stamp governing the selection of tasks.
//
//
type TaskFilterSpecTimeOption struct {
}

//
// TaskHistoryCollector provides a mechanism for
// retrieving historical data and updates when the server appends new
// tasks.
//
type TaskHistoryCollector struct {
	*ManagedObject
	*HistoryCollector

	latestPage []*TaskInfo
}

// The items in the 'viewable latest page'. As new tasks that match the
// collector's TaskFilterSpec are created, they are added to this
// page, and the oldest tasks are removed from the collector to keep the
// size of the page to that allowed by
// SetCollectorPageSize.
//
// The "oldest task" is the one with the oldest creation time. The
// tasks in the returned page are unordered.
func (mo *TaskHistoryCollector) LatestPage() ([]*TaskInfo, error) {
	t, err := mo.currentProperty("latestPage")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*TaskInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*TaskInfo")
	}
	return v, nil
}

//
// Reads the 'scrollable view' from the current position. The scrollable
// position is moved to the next newer page after the read. No item is
// returned when the end of the collector is reached.
//
//
//
// Required Privileges
// None
//
func (mo *TaskHistoryCollector) ReadNextTasks(
	_this *ManagedObjectReference, maxCount int32,
) ([]*TaskInfo, error) {

	return nil, nil

}

//
// Reads the 'scrollable view' from the current position. The scrollable
// position is then moved to the next older page after the read. No item is
// returned when the head of the collector is reached.
//
//
//
// Required Privileges
// None
//
func (mo *TaskHistoryCollector) ReadPreviousTasks(
	_this *ManagedObjectReference, maxCount int32,
) ([]*TaskInfo, error) {

	return nil, nil

}

//
// The TaskInProgress data object type represents a fault when an operation tries
// to access an entity that already has another (long) operation in progress.
//
//
type TaskInProgress struct {
	*VimFault

	// The task already in progress when the operation was attempted.
	Task *Task
}

//
// This data object type contains all information about a task. A task
// represents an operation performed by VirtualCenter or ESX.
//
//
type TaskInfo struct {
	*DynamicData

	// Flag to indicate whether or not the cancel task operation is supported.
	Cancelable bool

	// Flag to indicate whether or not the client requested
	// cancellation of the task.
	Cancelled bool

	// The user entered tag to identify the operations and their side effects
	//
	// Since vSphere API 4.0
	ChangeTag string

	// Time stamp when the task was completed (whether success or failure).
	CompleteTime time.Time

	// The description field of the task describes the current phase of
	// operation of the task. For a task that does a single monolithic
	// activity, this will be fixed and unchanging.
	// For tasks that have various substeps, this field will change
	// as the task progresses from one phase to another.
	//
	// Since vSphere API 4.0
	Description *LocalizableMessage

	// An identifier for this operation. This includes publicly visible
	// internal tasks and is a lookup in the TaskDescription methodInfo
	// data object.
	DescriptionId string

	// Managed entity to which the operation applies.
	Entity *ManagedEntity

	// The name of the managed entity, locale-specific, retained for the
	// history collector database.
	EntityName string

	// If the task state is "error", then this property contains the fault code.
	Error *LocalizedMethodFault

	// Event chain ID that leads to the corresponding events.
	EventChainId int32

	// The unique key for the task.
	Key string

	// If the state of the task is "running", then this property is a list of
	// managed entities that the operation has locked, with a shared lock.
	Locked []*ManagedEntity

	// The name of the operation that created the task. This is not set
	// for internal tasks.
	Name string

	// Tasks can be cretaed by another task. This shows key of the task spun off this task. This is to
	// track causality between tasks.
	//
	// Since vSphere API 4.0
	ParentTaskKey string

	// If the task state is "running", then this property contains a
	// progress measurement, expressed as percentage completed, from 0 to 100.
	//
	// If this property is not set, then the command does not report progress.
	Progress int32

	// Time stamp when the task was created.
	QueueTime time.Time

	// Kind of entity responsible for creating this task.
	Reason *TaskReason

	// If the task state is "success", then this property may be used
	// to hold a return value.
	Result interface{}

	// Tasks can be cretaed by another task and such creation can go on for
	// multiple levels. This is the key of the task
	// that started the chain of tasks.
	//
	// Since vSphere API 4.0
	RootTaskKey string

	// Time stamp when the task started running.
	StartTime time.Time

	// Runtime status of the task.
	State *enum.TaskInfoState

	// The managed object that represents this task.
	Task *Task
}

//
// List of possible states of a task.
//
//
type TaskInfoState struct {
}

//
// The TaskManager managed object provides an interface for creating and managing
// Task managed objects. Many operations are non-blocking,
// returning a Task managed object that can be monitored by a
// client application. Task managed objects may also be
// accessed through the TaskManager.
//
type TaskManager struct {
	*ManagedObject

	description *TaskDescription

	maxCollector int32

	recentTask []*Task
}

// Locale-specific, static strings that describe Task
// information to users.
// Required Privilege: System.View
func (mo *TaskManager) Description() (*TaskDescription, error) {
	t, err := mo.currentProperty("description")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*TaskDescription)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *TaskDescription")
	}
	return v, nil
}

// Maximum number of TaskHistoryCollector
// data objects that can exist concurrently, per client.
// Required Privilege: System.View
func (mo *TaskManager) MaxCollector() (int32, error) {
	t, err := mo.currentProperty("maxCollector")
	if err != nil {
		return int32(0), err
	}

	v, ok := t.(int32)
	if !ok {
		return int32(0), errors.New("Unable to make type assertion to: int32")
	}
	return v, nil
}

// A list of Task managed objects that completed recently,
// that are currently running, or that are queued to run.
//
//
// The list contains only Task objects that the client
// has permission to access, which is determined by having permission to
// access the Task object's managed entity.
//
// The completed Task objects by default include only
// Task objects that completed within the past 10 minutes.
// When connected to vCenter Server, there is an additional default limitation
// that each of the completed Task objects in this list is one
// of the last 200 completed Task objects.
//
// This property should not be used for tracking Task
// completion. Generally, a ListView is a better way to
// monitor a specific set of Task objects.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
// Required Privilege: System.View
func (mo *TaskManager) RecentTask() ([]*Task, error) {
	t, err := mo.currentProperty("recentTask")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Task)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Task")
	}
	return v, nil
}

//
// Creates a TaskHistoryCollector, a
// specialized HistoryCollector that gathers
// TaskInfo data objects.
//
// A TaskHistoryCollector does not persist
// beyond the current client session.
//
//
// Required Privileges
// System.View
//
func (mo *TaskManager) CreateCollectorForTasks(
	_this *ManagedObjectReference, filter *TaskFilterSpec,
) (*TaskHistoryCollector, error) {

	return nil, nil

}

//
// Creates a new Task, specifying the object with which
// the Task is associated, the type of task,
// and whether the task is cancelable. Use this operation in conjunction
// with the ExtensionManager.
//
//
//
// Required Privileges
// Task.Create
// Since
// VI API 2.5
//
func (mo *TaskManager) CreateTask(
	_this *ManagedObjectReference, obj *ManagedObjectReference, taskTypeId string, initiatedBy string, cancelable bool, parentTaskKey string,
) (*TaskInfo, error) {

	return nil, nil

}

//
// Base type for all task reasons.
// Task reasons represent the kind of entity responsible for a task's creation.
//
//
type TaskReason struct {
	*DynamicData
}

//
// Indicates that the task was queued by an alarm.
//
//
type TaskReasonAlarm struct {
	*TaskReason

	// The alarm object that queued the task.
	Alarm *Alarm

	// The name of the alarm that queued the task, retained in the history
	// collector database.
	AlarmName string

	// The managed entity object on which the alarm is triggered.
	Entity *ManagedEntity

	// The name of the managed entity on which the alarm is triggered,
	// retained in the history collector database.
	EntityName string
}

//
// Indicates that the task was queued by a scheduled task.
//
//
type TaskReasonSchedule struct {
	*TaskReason

	// The name of the scheduled task that queued this task.
	Name string

	// The scheduledTask object that queued this task.
	ScheduledTask *ScheduledTask
}

//
// Indicates that the task was started by the system (a default task).
//
//
type TaskReasonSystem struct {
	*TaskReason
}

//
// Indicates that the task was queued by a specific user.
//
//
type TaskReasonUser struct {
	*TaskReason

	// Name of the user that queued the task.
	UserName string
}

//
// The TaskScheduler data object is the base type for the scheduler objects.
// The hierarchy of scheduler objects is as follows:
//
// TaskScheduler
// AfterStartupTaskScheduler
// OnceTaskScheduler
// RecurrentTaskScheduler
// HourlyTaskScheduler
// DailyTaskScheduler
// WeeklyTaskScheduler
// MonthlyTaskScheduler
// MonthlyByDayTaskScheduler
// MonthlyByWeekdayTaskScheduler
//
//
// Use a scheduler object to set the time(s) for task execution.
// You can use two scheduling modes - single execution or
// recurring execution:
//
//
//
// • Use the AfterStartupTaskScheduler or the OnceTaskScheduler
// to schedule a single instance of task execution.
//
// • Use one of the recurrent task schedulers to schedule
// hourly, daily, weekly, or monthly task execution.
//
//
//
//
// After you have established the task timing, use the scheduler
// object for the ScheduledTaskSpec
// scheduler property value.
//
//
//
type TaskScheduler struct {
	*DynamicData

	// The time that the schedule for the task takes effect.
	// Task activation is distinct from task execution.
	// When you activate a task, its schedule starts,
	// and when the next execution time occurs, the task will run.
	// If you do not set activeTime, the activation time defaults to
	// the time that you create the scheduled task.
	ActiveTime time.Time

	// The time the schedule for the task expires.
	// If you do not set expireTime, the schedule does not expire.
	ExpireTime time.Time
}

//
// This event records when a task is cleaned up b/c of timeout
//
//
type TaskTimeoutEvent struct {
	*TaskEvent
}

//
// The teaming configuration of the uplink ports in the DVS matches
// physical switch configuration.
//
//
type TeamingMatchEvent struct {
	*DvsHealthStatusChangeEvent
}

//
// The teaming configuration of the uplink ports in the DVS
// does not match physical switch configuration.
//
//
type TeamingMisMatchEvent struct {
	*DvsHealthStatusChangeEvent
}

//
// This event records the start of a template upgrade.
//
//
type TemplateBeingUpgradedEvent struct {
	*TemplateUpgradeEvent
}

//
// This data object type describes a template virtual machine configuration file.
//
//
type TemplateConfigFileInfo struct {
	*VmConfigFileInfo
}

//
// This data object type describes the query specification for a template virtual
// machine configuration file.
//
//
type TemplateConfigFileQuery struct {
	*VmConfigFileQuery
}

//
// This event is the base class for all the template upgrade events.
//
//
type TemplateUpgradeEvent struct {
	*Event

	LegacyTemplate string
}

//
// This event records that the template upgrade failed.
//
//
type TemplateUpgradeFailedEvent struct {
	*TemplateUpgradeEvent

	Reason *LocalizedMethodFault
}

//
// This event records that the template upgrade succeeded.
//
//
type TemplateUpgradedEvent struct {
	*TemplateUpgradeEvent
}

//
// A ThirdPartyLicenseAssignmentFailed fault is thrown when
// the license assignment to a 3rd party module fails.
//
// The 3rd-party modules are installed and ran on ESX hosts,
// so this fault provides both host and module IDs.
//
//
type ThirdPartyLicenseAssignmentFailed struct {
	*RuntimeFault

	// The ESX host where 3rd party license was applied.
	Host *HostSystem

	// The asset-id of 3rd party module
	Module string

	// The reason why the assignment failed, if known.
	Reason string
}

type ThirdPartyLicenseAssignmentFailedReason struct {
}

//
// TicketedSessionAuthentication contains the information necessary to
// use previously obtained credentials in the guest.
// The ticketed session is not stateless and stores state inside of the guest.
//
// A TicketedSessionAuthentication object will be returned as the result of a
// successful call to AcquireCredentialsInGuest. You can
// use this object in any guest operations function call.
//
//
// When you no longer need the TicketedSessionAuthentication object, you should
// call ReleaseCredentialsInGuest to free associated resources
// and session data.
//
//
//
type TicketedSessionAuthentication struct {
	*GuestAuthentication

	// This contains a base64 encoded Ticket.
	Ticket string
}

//
// This event indicates that an operation performed on the host timed out. Typically,
// a previous event in the sequence of events contains more
// information about the cause of the operation timing out.
//
//
type TimedOutHostOperationEvent struct {
	*HostEvent
}

//
// Timedout exception is thrown when a server abandons an operation that
// is taking longer than expected.
//
//
type Timedout struct {
	*VimFault
}

//
// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
//
//
type TooManyConcurrentNativeClones struct {
	*FileFault
}

//
// Thrown if there are too many consecutive user overrides of
// server-managed settings. There are some properties which users are
// allowed to set only in certain configurations. The system controls them
// in other configurations, and overrides all user updates. If there are
// such frequent user overrides in the system controlled state that the
// next update arrives before the previous override is complete, the
// system can enter a tight loop and appear unresponsive to the user. This
// would typically happen if the user overrides are generated by a script.
//
// If the number of such user overrides exceeds the supported maximum, we
// conceptually "throw" this fault. In practice, this is converted into a
// host-level ConfigIssue in VC.
//
//
type TooManyConsecutiveOverrides struct {
	*VimFault
}

//
// Thrown when the number of virtual devices exceeds the maximum for
// a given controller.
//
//
type TooManyDevices struct {
	*InvalidVmConfig
}

// Deprecated.
// As of vSphere 4.1, this error condition is no longer possible.
//
//
// The VM has too many disks which can cause the VM to take a long time
// to power-on. This can result in migration taking a long time to complete
// or to fail due to timeout. This is a problem only for migration of
// powered-on virtual machines from or to ESX 2.x hosts.
//
//
type TooManyDisksOnLegacyHost struct {
	*MigrationFault

	// The number disks this VM has.
	DiskCount int32

	// Whether this number of disks will cause a timeout failure.
	TimeoutDanger bool
}

//
// A TooManyGuestLogons exception is thrown when
// there are too many concurrent login sessions active
// in the guest. ReleaseCredentialsInGuest can be called
// on ticketed sessions that are no longer needed. This will decrease
// the number of concurrent sessions active in the guest.
//
//
type TooManyGuestLogons struct {
	*GuestOperationsFault
}

//
// Thrown when a computer resource does not accept any more hosts. Clusters with DRS or
// HA enabled might impose a limit on the size of the cluster.
//
//
type TooManyHosts struct {
	*HostConnectFault
}

//
// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
//
//
type TooManyNativeCloneLevels struct {
	*FileFault
}

//
// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
//
//
type TooManyNativeClonesOnFile struct {
	*FileFault
}

//
// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
//
//
type TooManySnapshotLevels struct {
	*SnapshotFault
}

//
// Thrown when tools upgrade fails because the version of tools
// installed in the guest is already up-to-date.
//
//
type ToolsAlreadyUpgraded struct {
	*VmToolsUpgradeFault
}

//
// Thrown when tools upgrade fails because the virtual machine's
// guest operating system doesn't support tools auto-upgrades.
//
//
type ToolsAutoUpgradeNotSupported struct {
	*VmToolsUpgradeFault
}

//
// ToolsConfigInfo is a data object type containing settings for the VMware Tools
// software running in the guest operating system.
//
//
type ToolsConfigInfo struct {
	*DynamicData

	// Flag to specify whether or not scripts should run
	// after the virtual machine powers on.
	AfterPowerOn bool

	// Flag to specify whether or not scripts should run
	// after the virtual machine resumes.
	AfterResume bool

	// Flag to specify whether or not scripts should run
	// before the virtual machine reboots.
	BeforeGuestReboot bool

	// Flag to specify whether or not scripts should run
	// before the virtual machine powers off.
	BeforeGuestShutdown bool

	// Flag to specify whether or not scripts should run
	// before the virtual machine suspends.
	BeforeGuestStandby bool

	// Information about the last tools upgrade attempt if applicable.
	// This information is maintained by the server and is ignored if set by the client.
	//
	// Since vSphere API 5.0
	LastInstallInfo *ToolsConfigInfoToolsLastInstallInfo

	// When set, this indicates that a customization operation is pending on the VM.
	// The value represents the filename of the customization package on the host.
	//
	// Since VI API 2.5
	PendingCustomization string

	// Indicates whether or not the tools program will sync time with the host time.
	//
	// Since VI API 2.5
	SyncTimeWithHost bool

	// Tools upgrade policy setting for the virtual machine.See UpgradePolicy
	//
	// Since VI API 2.5
	ToolsUpgradePolicy string

	// Version of VMware Tools installed on the guest operating system.
	ToolsVersion int32
}

//
// Describes status of last tools upgrade attempt
//
//
type ToolsConfigInfoToolsLastInstallInfo struct {
	*DynamicData

	// Number of attempts that have been made to upgrade the version of tools
	// installed on this virtual machine.
	Counter int32

	// Error that happened, if any, during last attempt to upgrade tools.
	Fault *LocalizedMethodFault
}

//
// Thrown when the tools image couldn't be copied to the guest
// operating system: disk out of space, file access error, etc.
//
//
type ToolsImageCopyFailed struct {
	*VmToolsUpgradeFault
}

//
// Thrown when tools install or upgrade fails because the required
// tools image is not available.
//
//
type ToolsImageNotAvailable struct {
	*VmToolsUpgradeFault
}

//
// Thrown when tools install or upgrade fails because the
// signature check on the tools image failed.
//
//
type ToolsImageSignatureCheckFailed struct {
	*VmToolsUpgradeFault
}

//
// The virtual machine is currently in the progress of guest tools installation
// that prevents the migration operation.
//
//
type ToolsInstallationInProgress struct {
	*MigrationFault
}

//
// A ToolsUnavailableFault exception is thrown when an
// operation fails to contact VMware Tools
// running inside the virtual machine.
//
//
type ToolsUnavailable struct {
	*VimFault
}

//
// Thrown when tools install or upgrade fails because the
// operation was canclled by the user.
//
//
type ToolsUpgradeCancelled struct {
	*VmToolsUpgradeFault
}

//
// The TraversalSpec data object type specifies
// how to derive a new set of objects to add to the filter.
//
// It specifies a property path whose value is either another managed
// object or an array of managed objects included in the set of objects for
// consideration.  This data object can also be named, using the "name"
// field in the base type.
//
//
//
type TraversalSpec struct {
	*SelectionSpec

	// Name of the property to use in order to select additional objects.
	Path string

	// Optional set of selections to specify additional objects to filter.
	SelectSet []*SelectionSpec

	// Flag to indicate whether or not to filter the object in the "path"
	// field.
	Skip bool

	// Name of the object type containing the property.
	// Allowable values are:
	//
	//
	// "Alarm" - Alarm Managed Object.
	//
	//
	// "AlarmManager" - AlarmManager Managed Object.
	//
	//
	// "AuthorizationManager" - AuthorizationManager Managed Object.
	//
	//
	// "ClusterComputeResource" - ClusterComputeResource Managed Object.
	//
	//
	// "ClusterProfile" - ClusterProfile Managed Object.
	//
	//
	// "ClusterProfileManager" - ClusterProfileManager Managed Object.
	//
	//
	// "ComputeResource" - ComputeResource Managed Object.
	//
	//
	// "ContainerView" - ContainerView Managed Object.
	//
	//
	// "CustomFieldsManager" - CustomFieldsManager Managed Object.
	//
	//
	// "CustomizationSpecManager" - CustomizationSpecManager Managed Object.
	//
	//
	// "Datacenter" - Datacenter Managed Object.
	//
	//
	// "Datastore" - Datastore Managed Object.
	//
	//
	// "DatastoreNamespaceManager" - DatastoreNamespaceManager Managed Object.
	//
	//
	// "DiagnosticManager" - DiagnosticManager Managed Object.
	//
	//
	// "DistributedVirtualPortgroup" - DistributedVirtualPortgroup Managed Object.
	//
	//
	// "DistributedVirtualSwitch" - DistributedVirtualSwitch Managed Object.
	//
	//
	// "DistributedVirtualSwitchManager" - DistributedVirtualSwitchManager Managed Object.
	//
	//
	// "EnvironmentBrowser" - EnvironmentBrowser Managed Object.
	//
	//
	// "EventHistoryCollector" - EventHistoryCollector Managed Object.
	//
	//
	// "EventManager" - EventManager Managed Object.
	//
	//
	// "ExtensibleManagedObject" - ExtensibleManagedObject Managed Object.
	//
	//
	// "ExtensionManager" - ExtensionManager Managed Object.
	//
	//
	// "FileManager" - FileManager Managed Object.
	//
	//
	// "Folder" - Folder Managed Object.
	//
	//
	// "GuestAuthManager" - GuestAuthManager Managed Object.
	//
	//
	// "GuestFileManager" - GuestFileManager Managed Object.
	//
	//
	// "GuestOperationsManager" - GuestOperationsManager Managed Object.
	//
	//
	// "GuestProcessManager" - GuestProcessManager Managed Object.
	//
	//
	// "HistoryCollector" - HistoryCollector Managed Object.
	//
	//
	// "HostActiveDirectoryAuthentication" - HostActiveDirectoryAuthentication Managed Object.
	//
	//
	// "HostAuthenticationManager" - HostAuthenticationManager Managed Object.
	//
	//
	// "HostAuthenticationStore" - HostAuthenticationStore Managed Object.
	//
	//
	// "HostAutoStartManager" - HostAutoStartManager Managed Object.
	//
	//
	// "HostBootDeviceSystem" - HostBootDeviceSystem Managed Object.
	//
	//
	// "HostCacheConfigurationManager" - HostCacheConfigurationManager Managed Object.
	//
	//
	// "HostCpuSchedulerSystem" - HostCpuSchedulerSystem Managed Object.
	//
	//
	// "HostDatastoreBrowser" - HostDatastoreBrowser Managed Object.
	//
	//
	// "HostDatastoreSystem" - HostDatastoreSystem Managed Object.
	//
	//
	// "HostDateTimeSystem" - HostDateTimeSystem Managed Object.
	//
	//
	// "HostDiagnosticSystem" - HostDiagnosticSystem Managed Object.
	//
	//
	// "HostDirectoryStore" - HostDirectoryStore Managed Object.
	//
	//
	// "HostEsxAgentHostManager" - HostEsxAgentHostManager Managed Object.
	//
	//
	// "HostFirewallSystem" - HostFirewallSystem Managed Object.
	//
	//
	// "HostFirmwareSystem" - HostFirmwareSystem Managed Object.
	//
	//
	// "HostGraphicsManager" - HostGraphicsManager Managed Object.
	//
	//
	// "HostHealthStatusSystem" - HostHealthStatusSystem Managed Object.
	//
	//
	// "HostImageConfigManager" - HostImageConfigManager Managed Object.
	//
	//
	// "HostKernelModuleSystem" - HostKernelModuleSystem Managed Object.
	//
	//
	// "HostLocalAccountManager" - HostLocalAccountManager Managed Object.
	//
	//
	// "HostLocalAuthentication" - HostLocalAuthentication Managed Object.
	//
	//
	// "HostMemorySystem" - HostMemorySystem Managed Object.
	//
	//
	// "HostNetworkSystem" - HostNetworkSystem Managed Object.
	//
	//
	// "HostPatchManager" - HostPatchManager Managed Object.
	//
	//
	// "HostPciPassthruSystem" - HostPciPassthruSystem Managed Object.
	//
	//
	// "HostPowerSystem" - HostPowerSystem Managed Object.
	//
	//
	// "HostProfile" - HostProfile Managed Object.
	//
	//
	// "HostProfileManager" - HostProfileManager Managed Object.
	//
	//
	// "HostServiceSystem" - HostServiceSystem Managed Object.
	//
	//
	// "HostSnmpSystem" - HostSnmpSystem Managed Object.
	//
	//
	// "HostStorageSystem" - HostStorageSystem Managed Object.
	//
	//
	// "HostSystem" - HostSystem Managed Object.
	//
	//
	// "HostVFlashManager" - HostVFlashManager Managed Object.
	//
	//
	// "HostVirtualNicManager" - HostVirtualNicManager Managed Object.
	//
	//
	// "HostVMotionSystem" - HostVMotionSystem Managed Object.
	//
	//
	// "HostVsanInternalSystem" - HostVsanInternalSystem Managed Object.
	//
	//
	// "HostVsanSystem" - HostVsanSystem Managed Object.
	//
	//
	// "HttpNfcLease" - HttpNfcLease Managed Object.
	//
	//
	// "InventoryView" - InventoryView Managed Object.
	//
	//
	// "IpPoolManager" - IpPoolManager Managed Object.
	//
	//
	// "IscsiManager" - IscsiManager Managed Object.
	//
	//
	// "LicenseAssignmentManager" - LicenseAssignmentManager Managed Object.
	//
	//
	// "LicenseManager" - LicenseManager Managed Object.
	//
	//
	// "ListView" - ListView Managed Object.
	//
	//
	// "LocalizationManager" - LocalizationManager Managed Object.
	//
	//
	// "ManagedEntity" - ManagedEntity Managed Object.
	//
	//
	// "ManagedObjectView" - ManagedObjectView Managed Object.
	//
	//
	// "Network" - Network Managed Object.
	//
	//
	// "OpaqueNetwork" - OpaqueNetwork Managed Object.
	//
	//
	// "OptionManager" - OptionManager Managed Object.
	//
	//
	// "OvfManager" - OvfManager Managed Object.
	//
	//
	// "PerformanceManager" - PerformanceManager Managed Object.
	//
	//
	// "Profile" - Profile Managed Object.
	//
	//
	// "ProfileComplianceManager" - ProfileComplianceManager Managed Object.
	//
	//
	// "ProfileManager" - ProfileManager Managed Object.
	//
	//
	// "PropertyCollector" - PropertyCollector Managed Object.
	//
	//
	// "PropertyFilter" - PropertyFilter Managed Object.
	//
	//
	// "ResourcePlanningManager" - ResourcePlanningManager Managed Object.
	//
	//
	// "ResourcePool" - ResourcePool Managed Object.
	//
	//
	// "ScheduledTask" - ScheduledTask Managed Object.
	//
	//
	// "ScheduledTaskManager" - ScheduledTaskManager Managed Object.
	//
	//
	// "SearchIndex" - SearchIndex Managed Object.
	//
	//
	// "ServiceInstance" - ServiceInstance Managed Object.
	//
	//
	// "ServiceManager" - ServiceManager Managed Object.
	//
	//
	// "SessionManager" - SessionManager Managed Object.
	//
	//
	// "SimpleCommand" - SimpleCommand Managed Object.
	//
	//
	// "StoragePod" - StoragePod Managed Object.
	//
	//
	// "StorageResourceManager" - StorageResourceManager Managed Object.
	//
	//
	// "Task" - Task Managed Object.
	//
	//
	// "TaskHistoryCollector" - TaskHistoryCollector Managed Object.
	//
	//
	// "TaskManager" - TaskManager Managed Object.
	//
	//
	// "UserDirectory" - UserDirectory Managed Object.
	//
	//
	// "View" - View Managed Object.
	//
	//
	// "ViewManager" - ViewManager Managed Object.
	//
	//
	// "VirtualApp" - VirtualApp Managed Object.
	//
	//
	// "VirtualDiskManager" - VirtualDiskManager Managed Object.
	//
	//
	// "VirtualizationManager" - VirtualizationManager Managed Object.
	//
	//
	// "VirtualMachine" - VirtualMachine Managed Object.
	//
	//
	// "VirtualMachineCompatibilityChecker" - VirtualMachineCompatibilityChecker Managed Object.
	//
	//
	// "VirtualMachineProvisioningChecker" - VirtualMachineProvisioningChecker Managed Object.
	//
	//
	// "VirtualMachineSnapshot" - VirtualMachineSnapshot Managed Object.
	//
	//
	// "VmwareDistributedVirtualSwitch" - VmwareDistributedVirtualSwitch Managed Object.
	Type string
}

//
// Static strings used for describing an object type.
//
//
type TypeDescription struct {
	*Description

	// Type being described
	Key string
}

//
// VFlash is not supported on the datastore.
//
//
type UnSupportedDatastoreForVFlash struct {
	*UnsupportedDatastore

	// The name of the Datastore.
	DatastoreName string

	// Datastore file system volume type.
	// See type
	Type string
}

//
// Fault thrown when an attempt is made to move or clone an undoable disk with an
// uncommitted REDO log.  This is an error.  Undoable disks may be moved but they must
// be committed.
//
//
type UncommittedUndoableDisk struct {
	*MigrationFault
}

//
// The property value has not been configured by the user, so the application
// cannot be started. This is thrown if a property value is the empty string
// and the types does not allow it. For example, for an integer type or
// a string where the minimum length is 1, and so forth.
//
//
type UnconfiguredPropertyValue struct {
	*InvalidPropertyValue
}

//
// The specified guest operating system is not supported by the guest
// customization process.
//
//
type UncustomizableGuest struct {
	*CustomizationFault

	// The guest OS ID for the uncustomizable guest.
	UncustomizableGuestOS string
}

//
// Error received when customization fails, possibly due to a scripting runtime
// error or invalid script parameters.
//
//
type UnexpectedCustomizationFault struct {
	*CustomizationFault
}

//
// An UnexpectedFault may be thrown when a newer version of the server
// reports a error that a cannot be converted to a fault that a client
// that is using an older version of the API would expect.
//
//
type UnexpectedFault struct {
	*RuntimeFault

	// The unexpected fault if the server can send it in a form that the client
	// will be able to deserialize.
	Fault *LocalizedMethodFault

	// Name of the unexpected fault.
	FaultName string
}

//
// This event records that we have unlicensed virtual machines on the
// specified host. This can be both a (@link vim.ManagedEntity.configIssue
// configIssue) and an entry in the event log.
//
//
type UnlicensedVirtualMachinesEvent struct {
	*LicenseEvent

	Available int32

	Unlicensed int32
}

//
// This event records that we discovered unlicensed virtual machines on
// the specified host. After this event is entered into the event log, we
// expect to see a corresponding (@link
// vim.event.Event.UnlicensedVirtualMachinesEvent
// UnlicensedVirtualMachinesEvent) (@link vim.ManagedEntity.configIssue
// configIssue) on the host.
//
//
type UnlicensedVirtualMachinesFoundEvent struct {
	*LicenseEvent

	Available int32
}

//
// A UnrecognizedHost is thrown if the VirtualCenter server fails to
// validate the identity of the host using host-key.
//
// If a reconnect is attempted on a host and if the host-key of the host
// has changed since the last successful connection attempt,
// (might be changed by another instance of VirtualCenter), VirtualCenter
// server will fail to recognize the host.
//
//
type UnrecognizedHost struct {
	*VimFault

	// Host in the VirtualCenter inventory which failed the identity
	// validation.
	HostName string
}

//
// The compute resource and virtual machine configurations for swapfile
// placement would require the virtual machine swapfile to change location for
// this VMotion; however the host does not support this.
//
//
type UnsharedSwapVMotionNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// The virtual machine is not supported on the target datastore. This fault is
// thrown by provisioning operations when an attempt is made to create a virtual
// machine on an unsupported datastore (for example, creating a non-legacy
// virtual machine on a legacy datastore).
//
//
type UnsupportedDatastore struct {
	*VmConfigFault

	// The invalid datastore for this virtual machine.
	Datastore *Datastore
}

//
// The specified guest operating system is not supported on the host
// that is the target of the operation.
//
//
type UnsupportedGuest struct {
	*InvalidVmConfig

	// The guest OS ID for the unsupported guest.
	UnsupportedGuestOS string
}

//
// This exception will be thrown if a client tries to connect with a unsupported version
// of the Vim API.
//
//
type UnsupportedVimApiVersion struct {
	*VimFault

	Version string
}

//
// ESX 3 Server products requires the .vmx file to be stored
// on NAS or VMFS3 storage. If attempting to power on a virtual
// machine with the .vmx file stored on the service console, this
// fault will be thrown.
//
//
type UnsupportedVmxLocation struct {
	*VmConfigFault
}

//
// The unused disk blocks of the specified virtual disk have not been
// scrubbed on the file system.
//
// Typically, this fault is returned as part of a parent fault like
// VmConfigIncompatibleForFaultTolerance, indicating that the
// unused blocks of the virtual disk must be zeroed-out on the file system before
// before fault tolerance can be enabled on the associated virtual machine.
//
//
//
//
type UnusedVirtualDiskBlocksNotScrubbed struct {
	*DeviceBackingNotSupported
}

//
// A set of updates that represent the changes since a prior call to CheckForUpdates, WaitForUpdates, or WaitForUpdatesEx.
//
//
type UpdateSet struct {
	*DynamicData

	// Set of managed object updates detected by specific filters.  Updates
	// are reported in sets. Each set is associated with a reference to a
	// filter that detected the updates in the set.
	FilterSet []*PropertyFilterUpdate

	// If true, this UpdateSet contains results
	// from a suspended change calculation, which places restrictions on the
	// use of version.
	//
	// The PropertyCollector may suspend a calculation due to server
	// policy or if the total number of ObjectUpdate entries summed across every PropertyFilterUpdate reached the maximum specified in
	// maxObjectUpdates.  The client
	// can pass the "truncated data version" to WaitForUpdatesEx to
	// resume the update calculation, which will start on the filter where it
	// left off. A truncated data version cannot be used more than once and
	// may not be passed to CheckForUpdates or WaitForUpdates.  truncated will
	// never be true in an UpdateSet returned from
	// CheckForUpdates or WaitForUpdates.
	//
	// If false, this UpdateSet contains a
	// complete change calculation or the last part of a series of suspended
	// change calculations.  The version may be passed to CheckForUpdates, WaitForUpdates, or WaitForUpdatesEx more than once. Re-using a version allows a client
	// to recover a change sequence after a transient failure on a previous
	// call.
	//
	// Since vSphere API 4.1
	Truncated bool

	// New data version to pass in the next call to CheckForUpdates,
	// WaitForUpdates, or WaitForUpdatesEx.  These versions,
	// although they are opaque, are strongly ordered in the sense that passing
	// a version to WaitForUpdates, CheckForUpdates or
	// WaitForUpdatesEx requests updates that reflect changes in the
	// objects selected by the Filter that happened after the specified version.
	Version string
}

//
// UpdateVirtualMachineFilesResult is the result returned
// to the UpdateVirtualMachineFiles_Task method.
//
//
type UpdateVirtualMachineFilesResult struct {
	*DynamicData

	// The list of virtual machines files the server has attempted
	// to update but failed to update.
	FailedVmFile []*UpdateVirtualMachineFilesResultFailedVmFileInfo
}

type UpdateVirtualMachineFilesResultFailedVmFileInfo struct {
	*DynamicData

	// The reason why the update failed.
	Fault *LocalizedMethodFault

	// The file path
	VmFile string
}

//
// This event records that the agent has been patched and will be
// restarted.
//
//
type UpdatedAgentBeingRestartedEvent struct {
	*HostEvent
}

//
// These event types represent events converted from VirtualCenter 1.x.
// All upgraded events are converted to string values.
//
//
type UpgradeEvent struct {
	*Event

	// The formatted message from the upgrade.
	Message string
}

//
// The policy setting used to determine when tools are auto-upgraded for
// a virtual machine
//
//
type UpgradePolicy struct {
}

//
// Mtu health check status of an uplink port is changed, and in the latest mtu health check,
// not all the vlans' MTU setting on physical switch allows vSphere Distributed Switch
// max MTU size packets passing.
//
//
type UplinkPortMtuNotSupportEvent struct {
	*DvsHealthStatusChangeEvent
}

//
// Mtu health check status of an uplink port is changed, and in the latest mtu health check,
// all the vlans' MTU setting on physical switch allows vSphere Distributed Switch
// max MTU size packets passing.
//
//
type UplinkPortMtuSupportEvent struct {
	*DvsHealthStatusChangeEvent
}

//
// Vlans health check status of an uplink port is changed, and in the latest vlan health check,
// all the vlans are trunked by the physical switch connected to the uplink port.
//
//
type UplinkPortVlanTrunkedEvent struct {
	*DvsHealthStatusChangeEvent
}

//
// Vlans health check status of an uplink port is changed, and in the latest vlan health check,
// not all the vlans are trunked by the physical switch connected to the uplink port.
//
//
type UplinkPortVlanUntrunkedEvent struct {
	*DvsHealthStatusChangeEvent
}

//
// This event records that a user account membership was added to a group.
//
//
type UserAssignedToGroup struct {
	*HostEvent

	Group string

	UserLogin string
}

//
// The UserDirectory managed object provides information about users
// and groups on a vSphere server and ESX hosts. The method
// RetrieveUserGroups returns a list
// of user account data. The method can perform a search operation based on
// specific criteria - user name, group name, sub-string or string matching,
// and, on Windows, domain. Use the results as input
// to the AuthorizationManager methods
// SetEntityPermissions and
// ResetEntityPermissions.
//
// The content of the returned results depends on the server environment:
//
//
//
// •  On a Windows host, RetrieveUserGroups can search
// from the set of trusted domains on the host, including the primary
// domain of the system. A special domain (specified as an
// empty string - "") refers to the users and groups local
// to the host.
//
// •  On an ESX Server or a Linux host, the search operates on the
// users and groups defined in the /etc/passwd file. Always specify
// an empty string ("") for the domain argument.
// If the /etc/passwd file contains Sun NIS or NIS+ users and groups,
// RetrieveUserGroups returns information about these accounts as well.
//
//
//
//
type UserDirectory struct {
	*ManagedObject

	domainList []string
}

// List of Windows domains available for user searches, if the underlying
// system supports windows domain membership.
// Required Privilege: System.View
func (mo *UserDirectory) DomainList() ([]string, error) {
	t, err := mo.currentProperty("domainList")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]string)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []string")
	}
	return v, nil
}

//
// Returns a list of UserSearchResult objects describing the
// users and groups defined for the server.
//
//
// • On Windows, the search for users and groups is restricted to
// the given domain. If you omit the domain argument, then
// the search is performed on local users and groups.
//
// • On ESX Server (or Linux systems), the method returns the list
// of users and groups that are specified in the /etc/passwd file.
// If the password file contains Sun NIS or NIS+ users and groups,
// the returned list includes information about those as well.
//
//
//
//
// You must hold the Authorization.ModifyPermissions privilege to invoke this
// method. If you hold the privilege on any ManagedEntity, you will
// have access to user and group information for the server.
//
//
//
//
//
// As of vSphere API 5.1:
// •  Local user groups on ESXi are not supported and this method will
// not return information about local groups on the ESXi host.
// Information about Active Directory groups is not affected.
//
// •  Some special system users on ESXi like 'nfsnobody' and 'daemon'
// will be filtered out by this method.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *UserDirectory) RetrieveUserGroups(
	_this *ManagedObjectReference, domain string, searchStr string, belongsToGroup string, belongsToUser string, exactMatch bool, findUsers bool, findGroups bool,
) ([]*UserSearchResult, error) {

	return nil, nil

}

//
// The UserGroupProfile data object represents a user group.
// Use the policy list for access to configuration data
// for the user group profile. Use the property list for access
// to subprofile configuration data, if any.
//
//
type UserGroupProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string
}

//
// The UserInputRequiredParameterMetadata data object represents policy option metadata
// information for configuration data. The Profile Engine saves configuration
// data from the user input options in the host AnswerFile.
// See the ExecuteHostProfile and
// ApplyHostConfig_Task methods.
//
//
type UserInputRequiredParameterMetadata struct {
	*ProfilePolicyOptionMetadata

	// Metadata for user input options.
	UserInputParameter []*ProfileParameterMetadata
}

//
// This event records a user logon.
//
//
type UserLoginSessionEvent struct {
	*SessionEvent

	// The IP address of the peer that initiated the connection. This may
	// be the client that originated the session, or it may be an intervening
	// proxy if the binding uses a protocol that supports proxies, such as HTTP.
	IpAddress string

	// The locale of the session.
	Locale string

	// The unique identifier for the session.
	SessionId string

	// The user agent or application
	//
	// Since vSphere API 5.1
	UserAgent string
}

//
// This event records a user logoff, disconnection, or session timeout.
//
//
type UserLogoutSessionEvent struct {
	*SessionEvent

	// Number of API invocations made by the session
	//
	// Since vSphere API 5.1
	CallCount int64

	// The IP address of client
	//
	// Since vSphere API 5.1
	IpAddress string

	// Timestamp when the user logged on for this session.
	//
	// Since vSphere API 5.1
	LoginTime time.Time

	// The unique identifier for the session.
	//
	// Since vSphere API 5.1
	SessionId string

	// The user agent or application
	//
	// Since vSphere API 5.1
	UserAgent string
}

//
// Thrown when the request refers to a user or group name that could not
// be resolved.
//
//
type UserNotFound struct {
	*VimFault

	// Principal value that failed lookup.
	Principal string

	// Flag to indicate whether or not the lookup was unsuccessful.
	// A false value indicates that the user does not exist in the directory. A true
	// value indicates that the directory could not be contacted, possibly due to a
	// network error.
	Unresolved bool
}

//
// This event records that a user password changed.
//
//
type UserPasswordChanged struct {
	*HostEvent

	UserLogin string
}

//
// The UserProfile data object represents a user.
// Use the policy list for access to configuration data
// for the user profile. Use the property list for access
// to subprofile configuration data, if any.
//
//
type UserProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string
}

//
// When searching for users, the search results in
// some additional information. This object describes
// the additional information.
//
//
type UserSearchResult struct {
	*DynamicData

	// Full name of the user found by the search, or the description
	// of a group, if available.
	FullName string

	// If this is true, then the result is a group. If this is false, then the
	// result is a user.
	Group bool

	// Login name of a user or the name of a group. This key is
	// the user within the searched domain.
	Principal string
}

//
// Information about a current user session.
//
//
type UserSession struct {
	*DynamicData

	// Number of API invocations since the session started
	//
	// Since vSphere API 5.1
	CallCount int64

	// Whether or not this session belongs to a VC Extension.
	//
	// Since vSphere API 5.0
	ExtensionSession bool

	// The full name of the user, if available.
	FullName string

	// The client identity. It could be IP address, or pipe name depended
	// on client binding
	//
	// Since vSphere API 5.1
	IpAddress string

	// A unique identifier for this session,
	// also known as the session ID.
	Key string

	// Timestamp when the user last executed a command.
	LastActiveTime time.Time

	// The locale for the session used for data formatting and preferred for messages.
	Locale string

	// Timestamp when the user last logged on to the server.
	LoginTime time.Time

	// The locale used for messages for the session.
	// If there are no localized messages for the user-specified locale, then
	// the server determines this locale.
	MessageLocale string

	// The name of user agent or application
	//
	// Since vSphere API 5.1
	UserAgent string

	// The user name represented by this session.
	UserName string
}

//
// This event records that a user account membership was removed from a group.
//
//
type UserUnassignedFromGroup struct {
	*HostEvent

	Group string

	UserLogin string
}

//
// This event is a general user event from upgrade.
//
//
type UserUpgradeEvent struct {
	*UpgradeEvent
}

type VAppAutoStartAction struct {
}

//
// Specification for a vApp cloning operation.
//
//
type VAppCloneSpec struct {
	*DynamicData

	// The target host for the virtual machines. This is often not a required
	// parameter. If not specified, the behavior is as follows:
	//
	// If the target pool represents a stand-alone host, that host is used.
	// If the target pool represents a DRS-enabled cluster, a host selected
	// by DRS is used.
	// If the target pool represents a cluster without DRS enabled or a
	// DRS-enabled cluster in manual mode, an InvalidArgument exception is
	// thrown.
	// Required Privilege: VApp.Create
	Host *HostSystem

	// Location where the destination vApp must be stored
	// Required Privilege: Datastore.AllocateSpace
	Location *Datastore

	// Network mappings. See NetworkMappingPair.
	NetworkMapping []*VAppCloneSpecNetworkMappingPair

	// A set of property values to override.
	Property []*KeyValue

	// Specify how the VMs in the vApp should be provisioned.
	//
	// Since vSphere API 4.1
	Provisioning string

	// The resource configuration for the cloned vApp.
	//
	// Since vSphere API 4.1
	ResourceMapping []*VAppCloneSpecResourceMap

	// The resource configuration for the vApp.
	ResourceSpec *ResourceConfigSpec

	// The VM Folder to associate the vApp with
	// Required Privilege: VApp.Create
	VmFolder *Folder
}

//
// Maps one network to another as part of the clone process.
//
// Instances of this class are used in the field networkMapping
//
//
//
type VAppCloneSpecNetworkMappingPair struct {
	*DynamicData

	// The destination network
	// Required Privilege: Network.Assign
	Destination *Network

	// The source network
	Source *Network
}

//
// The cloned VMs can either be provisioned the same way as the VMs
// they are a clone of, thin provisioned or thick provisioned, or
// linked clones (i.e., using delta disks).
//
//
type VAppCloneSpecProvisioningType struct {
}

//
// Maps source child entities to destination resource pools
// and resource settings. If a mapping is not specified,
// a child is copied as a direct child of the parent.
//
//
type VAppCloneSpecResourceMap struct {
	*DynamicData

	// A client can optionally specify a datastore in the resource map to
	// override the default datastore location set in location field. This
	// enables cloning to different compute resources that do not have shared
	// datastores.
	// Required Privilege: Datastore.AllocateSpace
	Location *Datastore

	// Resource pool to use for the cloned entity of source. This must specify a
	// resource pool that is not part of the vApp. If this is specified, a linked
	// child (as opposed to a direct child) is created for the vApp.
	// Required Privilege: Resource.AssignVAppToPool
	Parent *ResourcePool

	// An optional resource configuration for the cloned entity of the source. If
	// not specified, the same resource configuration as the source is used.
	ResourceSpec *ResourceConfigSpec

	// Source entity
	Source *ManagedEntity
}

//
// Base for configuration / environment issues that can be thrown when powering on or
// changing the configuration of a vApp.
//
//
type VAppConfigFault struct {
	*VimFault
}

//
// Configuration of a vApp container.
//
//
type VAppConfigInfo struct {
	*VmConfigInfo

	// Description for the vApp.
	Annotation string

	// Configuration of sub-entities (virtual machine or vApp).
	EntityConfig []*VAppEntityConfigInfo

	// vCenter-specific 128-bit UUID of a vApp, represented  as a hexademical
	// string. This identifier is used by vCenter to uniquely identify all
	// vApp instances.
	//
	// Since vSphere API 4.1
	InstanceUuid string

	// Specifies that this vApp is managed by a VC Extension. See the
	// managedBy property in the
	// VAppConfigSpec for more details.
	//
	// Since vSphere API 5.0
	ManagedBy *ManagedByInfo
}

//
// Configuration of a vApp
//
//
type VAppConfigSpec struct {
	*VmConfigSpec

	// Description for the vApp.
	//
	// Reconfigure privilege: VApp.Rename.
	Annotation string

	// Configuration of sub-entities (virtual machine or vApp container).
	//
	// Reconfigure privilege: See EntityConfigInfo
	EntityConfig []*VAppEntityConfigInfo

	// vCenter-specific 128-bit UUID of a vApp, represented as a hexadecimal
	// string. This identifier is used  by vCenter to uniquely identify all
	// vApp instances in the Virtual Infrastructure environment.
	//
	// Normally, this property is not set by a client, allowing the
	// Virtual Infrastructure environment to assign or change it when
	// VirtualCenter detects an identifier conflict between vApps.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	//
	// Since vSphere API 4.1
	InstanceUuid string

	// Specifies that this vApp is managed by a VC Extension.
	//
	// This information is primarily used in the Client to show a custom icon for
	// managed vApps, and a description of the function of the vApp. If no extension
	// can be found with the extension key in the managedBy
	// object, or the type is not found in the
	// managedEntityInfo list of the
	// extension, the default vApp icon is used, and no description is shown.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	//
	// Since vSphere API 5.0
	ManagedBy *ManagedByInfo
}

//
// This object type describes the  behavior of an entity (virtual machine or
// sub-vApp container) in a vApp container.
//
// The auto-start/auto-stop configurations control the behavior of the
// start/stop vApp operations.
//
//
// An virtual machine entity can be configured to wait for a period of time before
// starting or to wait to receive a successful heartbeat from a virtual machine
// before starting the next virtual machine in the sequence.
//
//
//
// • For a power-on operation, if waitForHeartbeat is true, then the power-on
// sequence continues after the the first heartbeat has been received. If
// waitingForGuest is false, the system waits for the specified delay and
// then continues the power-on sequence.
//
// • For a power-off operation, if delay is non-zero, the requested power-off
// action is invoked (powerOff, suspend, guestShutdown) on the virtual
// machine and the system waits until the number of seconds specified in the
// delay have passed.
//
//
//
// If startAction and stopAction for an entity are both set to none, that
// entity does not participate in the sequence.
//
// The start/stop delay and waitingForGuest is not used if the entity is a
// vApp container. For a vApp the only value values for startAction is none
// or powerOn, and the valid values for stopAction is none or powerOff.
//
//
//
type VAppEntityConfigInfo struct {
	*DynamicData

	// Deprecated.
	// As of vSphere API 5.1.
	//
	//
	// Whether the entity should be removed, when this vApp is removed.
	// This is only set for linked children.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	//
	// Since vSphere API 4.1
	DestroyWithParent bool

	// Entity to power on or power off. This can be a virtual machine or a vApp.
	Key *ManagedEntity

	// How to start the entity. Valid settings are none or powerOn.  If set to none, then
	// the entity does not participate in auto-start.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StartAction string

	// Delay in seconds before continuing with the next entity in the order of entities
	// to be started.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StartDelay int32

	// Specifies the start order for this entity. Entities are started from lower
	// numbers to higher-numbers and reverse on shutdown. Multiple entities with the
	// same start-order can be started in parallel and the order is unspecified. This
	// value must be 0 or higher.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StartOrder int32

	// Defines the stop action for the entity. Can be set to none, powerOff,
	// guestShutdown, or suspend. If set to none, then the entity does not participate in
	// auto-stop.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StopAction string

	// Delay in seconds before continuing with the next entity in the order
	// sequence. This is only used if the stopAction is guestShutdown.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StopDelay int32

	// Tag for entity.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Tag string

	// Determines if the virtual machine should start after receiving a heartbeat,
	// from the guest. When a virtual machine is next in the start
	// order, the system either waits a specified period of time for a virtual
	// machine to power on or it waits until it receives a successful heartbeat from a
	// powered on virtual machine. By default, this is set to false.
	//
	// This property has no effect for vApps.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	WaitingForGuest bool
}

//
// The IPAssignmentInfo class specifies how the guest software gets
// configured with IP addresses, including protocol type (IPv4 or IPv6)
// and the life-time of those IP addresses.
//
// A vApp/virtual machine can either use DHCP to acquire an IP
// configuration, or it can acquire its IP configuration through the
// use of the vSphere platform using the OVF environment's properties.
// The latter is a known as OVF-environment-assigned IP configuration.
//
//
// Guest software can be constructed to support DHCP , OVF assigned
// IP configuration, or both. The supportedAssignmentScheme property
// lists the supported schemes. This is typically specified by the author
// of a vApp.
//
//
// The deployer / operator of a vApp, specifies what IP allocation
// policy should be used:
//
//
//
// • Using DHCP, if the vApp and deployed network supports it
//
// • Transient Assignment, if the vApp supports OVF-assigned IP
// configuration and the network has an IP range configured.
//
// • Fixed Assignment, if the vApp supports OVF-assigned IP
// configuration.
//
// • Fixed Allocated, if the vApp supports OVF-assigned IP
// configuration and the network has an IP range configured.
//
//
//
//
// Transient and fixed assignment differs in the life time of the IP
// allocation. For transient, IP addresses are automatically assigned on
// power-on and released on power-off. For fixed, the IP
// addresses are explicitly specified by the deployer and does not change
// between a power-on/power-off.
// Fixed allocated is a hybrid of transient and fixed assignment. IP
// addresses are allocated at first power-on and remain allocated on power-off.
//
//
// The IPAssignment settings are global to a deployment. Thus, if a vApp or
// virtual machine is part of another vApp, then the settings are ignored,
// and the ones for the top-most vApp container is used.
//
//
//
type VAppIPAssignmentInfo struct {
	*DynamicData

	// Specifies how IP allocation should be managed by the VI platform. This is
	// typically specified by the deployer. The set of valid options for the policy
	// is based on the capabilities of the vApp software, as specified by the
	// supportedAllocationSchemes property.
	//
	// Reconfigure privilege: VApp.InstanceConfig
	IpAllocationPolicy string

	// Specifies the chosen IP protocol for this deployment. This must be one of the
	// values in the supportedIpProtocol field.
	//
	// Reconfigure privilege: VApp.InstanceConfig
	IpProtocol string

	// Specifies the IP allocation schemes supported by the guest software.
	//
	// When updating this field, an empty array will be interpreted as no changes.
	// An array of the form [""] will clear all settings. Otherwise, the supplied
	// value will overwrite the current setting.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	SupportedAllocationScheme []string

	// Specifies the IP protocols supported by the guest software.
	//
	// When updating this field, an empty array will be interpreted as no changes.
	// An array of the form [""] will clear all settings. Otherwise, the supplied
	// value will overwrite the current setting.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	SupportedIpProtocol []string
}

//
// IP allocation schemes supported by the guest.
//
//
type VAppIPAssignmentInfoAllocationSchemes struct {
}

//
// IP allocation policy for a deployment.
//
//
type VAppIPAssignmentInfoIpAllocationPolicy struct {
}

//
// IP protocols supported by the guest.
//
//
type VAppIPAssignmentInfoProtocols struct {
}

//
// A virtual machine in a vApp cannot be powered on unless the
// parent vApp is running.
//
//
type VAppNotRunning struct {
	*VmConfigFault
}

//
// This fault is thrown when an operation is attempted on a target where
// a vApp operation is already in progress. E.g. when trying to move a
// virtual machine from a vApp that is being powered on.
//
//
type VAppOperationInProgress struct {
	*RuntimeFault
}

//
// The OvfSection encapsulates uninterpreted meta-data sections in
// an OVF descriptor. When an OVF package is imported, non-required /
// non-interpreted sections will be stored as OvfSection object. During
// the creation of an OVF package, these sections will be placed in the
// OVF descriptor.
//
//
type VAppOvfSectionInfo struct {
	*DynamicData

	// Whether this is a global envelope section
	AtEnvelopeLevel bool

	// The XML fragment including the top-level <Section...> element. The
	// fragment is self-contained will all required namespace definitions.
	Contents string

	// A unique key to identify a section.
	Key int32

	// The namespace for the value in xsi:type attribute.
	Namespace string

	// The value of the xsi:type attribute not including the namespace prefix.
	Type string
}

//
// An incremental update to the OvfSection list.
//
//
type VAppOvfSectionSpec struct {
	*ArrayUpdateSpec

	Info *VAppOvfSectionInfo
}

//
// Information that describes what product a vApp contains, for example,
// the software that is installed in the contained virtual machines.
//
//
type VAppProductInfo struct {
	*DynamicData

	// URL to entry-point for application. This is often specified using
	// a macro, for example, http://${app.ip}/, where app.ip is a defined property
	// on the virtual machine or vApp container.
	AppUrl string

	// Class name for this attribute.
	//
	// Valid values for classId:
	// Any string except any white-space characters.
	ClassId string

	// Full-version of the product, for example, 1.0-build 12323.
	FullVersion string

	// Class name for this attribute.
	//
	// Valid values for instanceId:
	// Any string except any white-space characters.
	InstanceId string

	// A unique key for the product section
	Key int32

	// Name of the product.
	Name string

	// URL to product homepage.
	ProductUrl string

	// Vendor of the product.
	Vendor string

	// URL to vendor homepage.
	VendorUrl string

	// Short version of the product, for example, 1.0.
	Version string
}

//
// An incremental update to the Product information list.
//
//
type VAppProductSpec struct {
	*ArrayUpdateSpec

	Info *VAppProductInfo
}

//
// The base fault for all vApp property configuration issues
//
//
type VAppPropertyFault struct {
	*VmConfigFault

	// The user-readable category
	Category string

	// The fully-qualified id of the property, including instance and class
	// identifiers.
	Id string

	// The user-readable label
	Label string

	// The type specified for the property
	Type string

	// The value of the property
	Value string
}

//
// A vApp Property description, including deployment values
//
//
type VAppPropertyInfo struct {
	*DynamicData

	// A user-visible description the category the property belongs to.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Category string

	// class name for this property
	//
	// Valid values for classId:
	// Any string except any white-space characters
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	ClassId string

	// This either contains the default value of a field (used if value is empty
	// string), or the expression if the type is "expression". See comment for the
	DefaultValue string

	// A description of the field.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Description string

	// Name of property. In the OVF environment, the property is listed as
	// [classId.]id[.instanceId]. The [classId.]name[.instanceId] must be unique.
	//
	// This field cannot be empty for a property. Thus, it must be specified at creation
	// and cannot be set to the empty string.
	//
	// Valid values for id:
	// Any string except any white-space characters
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Id string

	// class name for this property
	//
	// Valid values for instanceId:
	// Any string except any white-space characters
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	InstanceId string

	// A unique integer key for the property.
	Key int32

	// The display name for the property.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Label string

	// Describes the valid format of the property.
	//
	// A type must be one of:
	//
	// string : A generic string. Max length 65535 (64k).
	// string(x..) : A string with minimum character length x.
	// string(..y) : A string with maximum character length y.
	// string(x..y) : A string with minimum character length x and maximum
	// character length y.
	// string["choice1", "choice2", "choice3"] : A set of choices. " inside a choice
	// must be either \" or ' e.g "start\"middle\"end" or "start'middle'end" and
	// a \ inside a string choice must be encoded as \\ e.g. "start\\end".
	// int : An integer value. Is semantically equivalent to
	// int(-2147483648..2147483647) e.g. signed int32.
	// int(x..y): An integer value with a minimum size x and a maximum size y.
	// For example int(0..255) is a number between 0 and 255 both incl. This is
	// also a way to specify that the number must be a uint8. There is always a lower
	// and lower bound. Max number of digits is 100 including any sign. If exported to OVF the
	// value will be truncated to max of uint64 or int64.
	// real : IEEE 8-byte floating-point value.
	// real(x..y) : IEEE 8-byte floating-point value with a minimum size x and a
	// maximum size y. For example real(-1.5..1.5) must be a number between -1.5 and 1.5.
	// Because of the nature of float some conversions can truncate the value.
	// Real must be encoded acording to CIM:
	// RealValue = [ "+" | "-" } *decimalDigit "." 1*decimalDigit
	// [ ("e" | "E" ) [ "+" | "-" ] 1*decimalDigit ] ]
	// boolean : A boolean. The value can be True or False
	// password       : A generic string. Max length 65535 (64k).
	// password(x..)  : A string with minimum character length x.
	// password(..y)  : A string with maximum character length y.
	// password(x..y) : A string with minimum character length x and maximum
	// character length y.
	// ip  : An IPv4 address in dot-decimal notation or an IPv6 address in
	// colon-hexadecimal notation.
	// ip:network  : An IP address in dot-notation (IPv4) and colon-hexadecimal (IPv6)
	// on a particular network. The behavior of this type depends on the
	// ipAllocationPolicy. See below.
	// expression: The default value specifies an expression that is calculated
	// by the system.
	//
	// For properties of type 'password', the value field and default value field will
	// always be returned as an empty string when queried. Thus, it is a write-only property.
	// Typically, a client application will also render these as a text field with hidden
	// text and double prompting.
	//
	// An expression follows the general patterns of either ${arg} or ${cmd:arg}. The
	// list of supported expressions are listed below:
	//
	// ${<name>} : This expression evaluates to the same value as the named
	// property in the parent vApp. A parent vApp is the
	// first vApp in the ancestry chain (resource pools are
	// skipped). If no parent vApp exists or the property is
	// not defined on the parent vApp, the expression
	// evaluates to the empty value.
	// ${subnet:<network>}  : The subnet value of the given network.
	// ${netmask:<network>} : The netmask value of the given network.
	// ${gateway:<network>} : The gateway value of the given network.
	// ${autoIp:<network>}  : An auto-assigned network address on the given
	// network
	// ${net:<network>}     : The name of the network
	// ${domainName:<network>} : The DNS domain name, e.g., vmware.com, of
	// the given network.
	// ${searchPath:<network>} : The DNS search path, e.g.,
	// eng.vmware.com;vmware.com, of the given
	// network.
	// ${hostPrefix:<network>}: The host prefix on a given network,  e.g.,
	// "voe-"
	// ${dns:network}: A comma-separated string of configured network addresses
	// ${httpProxy:network}: The hostname:port for a proxy on the network
	// ${vimIp:} : The IP address of the VIM API provider server. This would
	// typical be an ESX Server or VirtualCenter Server.
	//
	// A vApp will fail to start if any of the properties cannot be computed. For
	// example, if a property reference a gateway on a network, for which is has not
	// been specified. The value of the computed computation is assigned to the 'value'
	// field upon start of the vApp or virtual machine. The value is cleared once
	// the vApp or virtual machine is not-running.
	//
	// The system provides three ways of specifying IP addresses:
	//
	// ip,
	// ip:network type,
	// ${ip:network} expression.
	//
	// The ip types are typically used to specify an IP addressed to an
	// external system. Thus, these are not used by a virtual ethernet adapter
	// within the guest itself. Both the ip:network expression and the ${ip:network}
	// expression are intended as a way to obtain an IP address for a virtual machine
	// in a vApp.
	//
	// The behavior of ip:network type is controlled by the ipAssignPolicy, as
	// described in the following table:
	//
	//
	//
	// Policy
	// ip:<network> type
	//
	//
	// DHCP
	// The user is not prompted to enter a value. The variable is set to the
	// empty string during power-on, and later updated with the IP value reported
	// by the guest software.
	//
	//
	//
	// Transient
	// The user is not prompted to enter a value. An IP address is allocated by
	// the platform and is assigned to the variable which is available to the
	// guest. The IP address is released at power-off.
	//
	//
	// Fixed
	// The user is prompted to enter a value. This value is available to the
	// guest.
	//
	//
	// Fixed Allocated
	// The user is not prompted to enter a value. An IP address is allocated by
	// the platform and is assigned to the variable which is available to the
	// guest. The IP address remains allocated at power-off, and are only
	// released if the property is deleted or the vApp is destroyed.
	//
	//
	//
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Type string

	// Contains extra configuration data depending on the property type. For types that
	// refer to network names the type reference is the managed object reference
	// of the network.
	//
	// Since vSphere API 5.1
	TypeReference string

	// Whether the property is user-configurable or a system property. This is not used
	// if the type is expression.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	UserConfigurable bool

	// The value of the field at deployment time. For expressions, this will contain
	// the value that has been computed.
	//
	// Reconfigure privilege: VApp.InstanceConfig
	Value string
}

//
// An incremental update to the Property list.
//
//
type VAppPropertySpec struct {
	*ArrayUpdateSpec

	Info *VAppPropertyInfo
}

//
// A specialized TaskInProgress when an operation is performed
// on a VM and it is failed due to a vApp-level operation
// is in progress. For example, while the power-on sequence is
// executed on a vApp, individual power-on's of child VMs are
// failed.
//
//
type VAppTaskInProgress struct {
	*TaskInProgress
}

//
// vFlash module is not supported due to its configuration is not
// supported by the host.
//
//
type VFlashModuleNotSupported struct {
	*VmConfigFault

	// Host name
	HostName string

	// The vFlash module name.
	ModuleName string

	// Message of reason.
	Reason string

	// VM name
	VmName string
}

type VFlashModuleNotSupportedReason struct {
}

//
// The vFlash module version of the vFlash cache asscociated with the
// virtual disk of a VM is not compatible with the supported versions of
// the specified vFlash module on the host.
//
//
type VFlashModuleVersionIncompatible struct {
	*VimFault

	// The minimum supported version of the specified module on the host.
	HostMinSupportedVerson string

	// The verson of the specified module on the host.
	HostModuleVersion string

	// The vFlash module name.
	ModuleName string

	// The VM request module version.
	VmRequestModuleVersion string
}

//
// This event records when a VMFS datastore is created.
//
//
type VMFSDatastoreCreatedEvent struct {
	*HostEvent

	// The associated datastore.
	Datastore *DatastoreEventArgument
}

//
// This event records when a datastore is expanded.
//
//
type VMFSDatastoreExpandedEvent struct {
	*HostEvent

	// The associated datastore.
	Datastore *DatastoreEventArgument
}

//
// This event records when a datastore is extended.
//
//
type VMFSDatastoreExtendedEvent struct {
	*HostEvent

	// The associated datastore.
	Datastore *DatastoreEventArgument
}

//
// The virtual machine is configured to use a VMI ROM, which is not
// supported on the host.
//
//
type VMINotSupported struct {
	*DeviceNotSupported
}

//
// The virtual machine is using a conflict DVPort, which is a temporary port created
// to avoid conflict with another port. Conflict DVPort cannot be moved.
//
//
type VMOnConflictDVPort struct {
	*CannotAccessNetwork
}

//
// The virtual machine is using a "virtual intranet", a virtual network
// that exists only within a single host. If returned as part of a migration check, this
// is an error if the virtual machine is currently connected to the network and a
// warning otherwise.
//
//
type VMOnVirtualIntranet struct {
	*CannotAccessNetwork
}

//
// An operation on a powered-on virtual machine requests a change of
// networks, but the host does not have that capability.
//
//
type VMotionAcrossNetworkNotSupported struct {
	*MigrationFeatureNotSupported
}

//
// Types of a host's compatibility with a designated virtual machine
// that is a candidate for VMotion. Used with queryVMotionCompatibility
// both as inputs (to designate which compatibility types to test for)
// and as outputs (to specify which compatibility types apply for
// each host).
//
//
type VMotionCompatibilityType struct {
}

//
// A VMotion interface has a problem. This may be an error or warning depending
// on the specific fault subclass. This is an error or warning only when
// migrating a powered-on virtual machine.
//
//
type VMotionInterfaceIssue struct {
	*MigrationFault

	// Whether this error is for the source host.
	AtSourceHost bool

	// The name of the host with the bad interface.
	FailedHost string

	// The host with the bad interface.
	//
	// Since VI API 2.5
	FailedHostEntity *HostSystem
}

//
// This event records an expired VMotion license.
//
//
type VMotionLicenseExpiredEvent struct {
	*LicenseEvent
}

//
// The VMotion interface does not have the recommended capacity to support
// VMotion. VMotion is supported on links that have a speed of at least 1000
// Mbps and are full duplex. This is a warning for migrating powered-on virtual
// machines.
//
//
type VMotionLinkCapacityLow struct {
	*VMotionInterfaceIssue

	// Name of the network being used for the VMotion interface.
	Network string
}

//
// The VMotion interface does not have any operational physical links
// associated with it. This is an error for migrating powered-on virtual
// machines.
//
//
type VMotionLinkDown struct {
	*VMotionInterfaceIssue

	// Name of the network being used for the VMotion interface.
	Network string
}

//
// A VMotion interface is not configured (or is misconfigured) on
// either the source or destination host.  This is an error only
// when migrating a powered-on virtual machine.
//
//
type VMotionNotConfigured struct {
	*VMotionInterfaceIssue
}

//
// VMotion is not licensed on a source or destination host. It must be licensed on both
// hosts.
//
//
type VMotionNotLicensed struct {
	*VMotionInterfaceIssue
}

//
// The source or the destination host does not support VMotion.  This is an
// error only when migrating a powered-on virtual machine.
//
//
type VMotionNotSupported struct {
	*VMotionInterfaceIssue
}

//
// VMotion protocol version incompatibility prevents VMotion from the
// virtual machine's current host to the requested destination host.
// (VMotion in the other direction may or may not be supported.)
//
//
type VMotionProtocolIncompatible struct {
	*MigrationFault
}

//
// This class defines the VMware specific configuration for
// DistributedVirtualSwitch.
//
//
type VMwareDVSConfigInfo struct {
	*DVSConfigInfo

	// Configuration for ipfix monitoring of the switch traffic. This must be
	// set before ipfix monitoring can be enabled for the switch, or for any
	// portgroup or port of the switch.See ipfixEnabled
	//
	// Since vSphere API 5.0
	IpfixConfig *VMwareIpfixConfig

	// The Link Aggregation Control Protocol group version in the switch.
	// See LacpApiVersion for valid values.
	//
	// Since vSphere API 5.5
	LacpApiVersion string

	// The Link Aggregation Control Protocol groups in the switch.
	//
	// Since vSphere API 5.5
	LacpGroupConfig []*VMwareDvsLacpGroupConfig

	// See LinkDiscoveryProtocolConfig.
	LinkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig

	// The maximum MTU in the switch.
	MaxMtu int32

	// The PVLAN configured in the switch.
	PvlanConfig []*VMwareDVSPvlanMapEntry

	// The Distributed Port Mirroring sessions in the switch.
	//
	// Since vSphere API 5.0
	VspanSession []*VMwareVspanSession
}

//
// This class defines the VMware specific configuration for
// DistributedVirtualSwitch.
//
//
type VMwareDVSConfigSpec struct {
	*DVSConfigSpec

	// Configuration for ipfix monitoring of the switch traffic. This must be
	// set before ipfix monitoring can be enabled for the switch, or for any
	// portgroup or port of the switch.See ipfixEnabled
	//
	// Since vSphere API 5.0
	IpfixConfig *VMwareIpfixConfig

	// The Link Aggregation Control Protocol group version in the switch.
	// See LacpApiVersion for valid values.
	//
	// Since vSphere API 5.5
	LacpApiVersion string

	// See LinkDiscoveryProtocolConfig.
	LinkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig

	// The maximum MTU in the switch.
	MaxMtu int32

	// The PVLAN configuration specification.
	//
	// A VMwareDVSPvlanMapEntry
	// that has the same value for
	// primaryVlanId and
	// secondaryVlanId
	// is referred to as a primary PVLAN entry.
	// Otherwise, the VMwareDVSPvlanMapEntry
	// is referred to as a secondary PVLAN entry.
	//
	// The pvlanType
	// of a primary PVLAN entry must be
	// promiscuous.
	// A secondary PVLAN entry can have a
	// pvlanType
	// of either
	// community or
	// isolated.
	//
	// Primary PVLAN entries must be explicitly added.
	// If there is no primary PVLAN entry corresponding to the
	// primaryVlanId
	// of a secondary PVLAN entry, a fault is thrown.
	//
	// While deleting a primary PVLAN entry, any associated secondary PVLAN
	// entries must be explicitly deleted.
	PvlanConfigSpec []*VMwareDVSPvlanConfigSpec

	// The Distributed Port Mirroring configuration specification. The VSPAN
	// sessions in the array cannot be of the same key.
	//
	// Since vSphere API 5.0
	VspanConfigSpec []*VMwareDVSVspanConfigSpec
}

//
// Indicators of support for version-specific DVS features that are only
// available on a VMware-class switch.
//
//
type VMwareDVSFeatureCapability struct {
	*DVSFeatureCapability

	// Flag to indicate whether IPFIX(NetFlow) is supported on the
	// vSphere Distributed Switch.
	// IPFIX is supported in vSphere Distributed Switch Version 5.0 or later.
	//
	// Since vSphere API 5.0
	IpfixSupported bool

	// The support for version-specific Link Aggregation Control Protocol.
	//
	// Since vSphere API 5.1
	LacpCapability *VMwareDvsLacpCapability

	// Flag to indicate whether LLDP(Link Layer Discovery Protocol) is supported on the
	// vSphere Distributed Switch.
	// LLDP is supported in vSphere Distributed Switch Version 5.0 or later.
	//
	// Since vSphere API 5.0
	LldpSupported bool

	// The support for version-specific Distributed Port Mirroring sessions.
	//
	// Since vSphere API 5.1
	VspanCapability *VMwareDVSVspanCapability

	// Flag to indicate whether vspan(DVMirror) is supported on the
	// vSphere Distributed Switch.
	// Distributed Port Mirroring is supported in vSphere Distributed Switch Version 5.0 or later.
	//
	// Since vSphere API 5.0
	VspanSupported bool
}

//
// The feature capabilities of health check supported by the
// vSphere Distributed Switch
//
//
type VMwareDVSHealthCheckCapability struct {
	*DVSHealthCheckCapability

	// Flag to indicate whether teaming health check is supported on the
	// vSphere Distributed Switch.
	TeamingSupported bool

	// Flag to indicate whether vlan/mtu health check is supported on the
	// vSphere Distributed Switch.
	VlanMtuSupported bool
}

//
// This class defines health check configuration for
// VMware vSphere Distributed Switch.
//
//
type VMwareDVSHealthCheckConfig struct {
	*DVSHealthCheckConfig
}

//
// This class defines MTU health check result of an uplink port
// in the VMware vSphered Distributed Switch.
//
//
type VMwareDVSMtuHealthCheckResult struct {
	*HostMemberUplinkHealthCheckResult

	// True if the MTU configured in the vSphere Distributed Switch is different from
	// the value configured in the Physical NIC, else false. If it is true,
	// MTU health check is stopped. In this case, vlanSupportSwitchMtu and
	// vlanNotSupportSwitchMtu will not have values.
	MtuMismatch bool

	// The vlan's MTU setting on physical switch does not allow
	// vSphere Distributed Switch max MTU size packets passing.
	// If the vlan is not a range, but a single Id,
	// both start and end have the same value with the single vlan Id.
	VlanNotSupportSwitchMtu []*NumericRange

	// The vlan's MTU setting on physical switch allows vSphere Distributed Switch
	// max MTU size packets passing.
	// If the vlan is not a range, but a single Id,
	// both start and end have the same value with the single vlan Id.
	VlanSupportSwitchMtu []*NumericRange
}

//
// This class defines the VMware specific configuration for
// DistributedVirtualPort.
//
//
type VMwareDVSPortSetting struct {
	*DVPortSetting

	// True if ipfix monitoring is enabled. To successfully enable ipfix
	// monitoring, the switch must have an assigned
	// IP address
	// and an appropriately populated
	// ipfix configuration
	// that specifies a collector IP address and port.
	//
	// Since vSphere API 5.0
	IpfixEnabled *BoolPolicy

	// Deprecated.
	// As of vSphere API 5.5, use
	// UpdateDVSLacpGroupConfig_Task and
	// lacpGroupConfig
	// instead.
	//
	//
	// Link Aggregation Control Protocol policy.
	// This policy is ignored on non-uplink portgroups.
	// Setting this policy at port level is not supported.
	//
	// Since vSphere API 5.1
	LacpPolicy *VMwareUplinkLacpPolicy

	// Deprecated.
	// As of vSphere API 5.0
	//
	//
	// deprecated  As of vSphere API 5.0
	QosTag *IntPolicy

	// The security policy.
	SecurityPolicy *DVSSecurityPolicy

	// If true, a copy of packets sent to the switch will always be forwarded to
	// an uplink in addition to the regular packet forwarded done by the switch.
	TxUplink *BoolPolicy

	// The uplink teaming policy. This property is ignored for uplink
	// ports.
	UplinkTeamingPolicy *VmwareUplinkPortTeamingPolicy

	// The VLAN Specification of the port.
	Vlan *VmwareDistributedVirtualSwitchVlanSpec
}

//
// This class defines the VMware specific configuration for
// DistributedVirtualPort.
//
//
type VMwareDVSPortgroupPolicy struct {
	*DVPortgroupPolicy

	// Allow the setting of
	// ipfixEnabled
	// for an individual port to override the setting in
	// defaultPortConfig of
	// a portgroup.
	//
	// Since vSphere API 5.0
	IpfixOverrideAllowed bool

	// Allow the setting of
	// securityPolicy
	// for an individual port to override the setting in
	// defaultPortConfig of
	// a portgroup.
	SecurityPolicyOverrideAllowed bool

	// Allow the setting of
	// uplinkTeamingPolicy
	// for an individual port to override the setting in
	// defaultPortConfig of
	// a portgroup.
	UplinkTeamingOverrideAllowed bool

	// Allow the setting of
	// vlanId, trunk
	// vlanId, or
	// pvlanId
	// for an individual port to override the setting in
	// defaultPortConfig of
	// a portgroup.
	VlanOverrideAllowed bool
}

//
// This class defines the configuration of a PVLAN map entry
//
//
type VMwareDVSPvlanConfigSpec struct {
	*DynamicData

	// Operation type.  See
	// ConfigSpecOperation for valid values,
	// except for the "edit" value, which is not supported.
	Operation string

	// The PVLAN entry to be added or removed.
	PvlanEntry *VMwareDVSPvlanMapEntry
}

//
// The class represents a PVLAN id.
//
//
type VMwareDVSPvlanMapEntry struct {
	*DynamicData

	// The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved
	// and cannot be used in this property.
	PrimaryVlanId int32

	// The type of PVLAN.
	// See VmwareDistributedVirtualSwitchPvlanPortType
	// for valid values.
	PvlanType string

	// The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved
	// and cannot be used in this property.
	SecondaryVlanId int32
}

//
// This class defines the teaming health check configuration.
// Teaming health check is used to check whether the teaming policy configuration
// of the vSphere Distributed Switch matches the physical switch.
//
//
type VMwareDVSTeamingHealthCheckConfig struct {
	*VMwareDVSHealthCheckConfig
}

//
// This class defines teaming health check result of a host that
// joined the VMware vSphered Distributed Switch.
//
//
type VMwareDVSTeamingHealthCheckResult struct {
	*HostMemberHealthCheckResult

	// Teaming check status. See TeamingMatchStatus
	// for valid values.
	TeamingStatus string
}

//
// The teaming health check match status.
//
//
type VMwareDVSTeamingMatchStatus struct {
}

//
// This class defines Vlan health check result of an uplink port
// in the VMware vSphered Distributed Switch.
//
//
type VMwareDVSVlanHealthCheckResult struct {
	*HostMemberUplinkHealthCheckResult

	// The vlans which are trunked by the physical switch connected to the uplink port.
	// If the vlan is not a range, but a single Id,
	// both start and end have the same value with the single vlan Id.
	TrunkedVlan []*NumericRange

	// The vlans which are not trunked by the physical switch connected to the uplink port.
	// If the vlan is not a range, but a single Id,
	// both start and end have the same value with the single vlan Id.
	UntrunkedVlan []*NumericRange
}

//
// This class defines the vlan and mtu health check configuration.
// Vlan health check is used to check whether vlans are trunked by the physical
// switch connected to the uplink ports.
// MTU health check is used to verify current MTU setting workable on all uplink ports of
// the vSphere Distributed Switch.
//
//
type VMwareDVSVlanMtuHealthCheckConfig struct {
	*VMwareDVSHealthCheckConfig
}

//
// Indicators of support for version-specific Distributed Port Mirroring sessions.
//
//
type VMwareDVSVspanCapability struct {
	*DynamicData

	// Flag to indicate whether dvport mirror session is supported on the
	// vSphere Distributed Switch.
	DvportSupported bool

	// Flag to indicate whether encapsulated remote mirror source session is supported on the
	// vSphere Distributed Switch.
	EncapRemoteSourceSupported bool

	// Flag to indicate whether mixed dest mirror session is supported on the
	// vSphere Distributed Switch.
	MixedDestSupported bool

	// Flag to indicate whether remote mirror destination session is supported on the
	// vSphere Distributed Switch.
	RemoteDestSupported bool

	// Flag to indicate whether remote mirror source session is supported on the
	// vSphere Distributed Switch.
	RemoteSourceSupported bool
}

//
// This class defines the configuration of a Distributed Port Mirroring session. A Distributed Port Mirroring session
//
//
type VMwareDVSVspanConfigSpec struct {
	*DynamicData

	// Operation type, see
	// ConfigSpecOperation for valid values.
	Operation string

	// The Distributed Port Mirroring session to be reconfigured.
	VspanSession *VMwareVspanSession
}

//
// Distributed Port Mirroring session types.
//
//
type VMwareDVSVspanSessionType struct {
}

//
// Link Aggregation Control Protocol API versions.
//
//
type VMwareDvsLacpApiVersion struct {
}

//
// The feature capabilities of Link Aggregation Control Protocol supported by the
// vSphere Distributed Switch.
//
//
type VMwareDvsLacpCapability struct {
	*DynamicData

	// Flag to indicate whether Link Aggregation Control Protocol is supported on the
	// vSphere Distributed Switch.
	LacpSupported bool

	// Flag to indicate whether the vSphere Distributed Switch supports more
	// than one Link Aggregation Control Protocol group to be configured.
	// It is suppported in vSphere Distributed Switch Version 5.5 or later.
	//
	// Since vSphere API 5.5
	MultiLacpGroupSupported bool
}

//
// This class defines VMware specific multiple IEEE 802.3ad
// Dynamic Link Aggregation Control Protocol groups.
//
//
type VMwareDvsLacpGroupConfig struct {
	*DynamicData

	// Ipfix configuration of the Link Aggregation
	// Control Protocol group.
	Ipfix *VMwareDvsLagIpfixConfig

	// The generated key as the identifier for the Link Aggregation group.
	Key string

	// Load balance policy.
	// See LacpLoadBalanceAlgorithm for valid values.
	LoadbalanceAlgorithm string

	// The mode of Link Aggregation Control Protocol.
	// See UplinkLacpMode for valid values.
	Mode string

	// The display name.
	Name string

	// Names for the Uplink Ports in the group.
	// This property is ignored in an update operation.
	UplinkName []string

	// The number of uplink ports.
	UplinkNum int32

	// Keys for the Uplink Ports in the group.
	// This property is ignored in an update operation.
	UplinkPortKey []string

	// The VLAN Specification of the Uplink Ports in the Link Aggregation group.
	Vlan *VMwareDvsLagVlanConfig
}

//
// This class defines the configuration of a Link Aggregation
// Control Protocol group.
//
//
type VMwareDvsLacpGroupSpec struct {
	*DynamicData

	// The Link Aggregation Control Protocol group to be configured.
	LacpGroupConfig *VMwareDvsLacpGroupConfig

	// Operation type, see
	// ConfigSpecOperation for valid values.
	Operation string
}

//
// Load balance algorithm in a Link Aggregation Control Protocol group.
//
//
type VMwareDvsLacpLoadBalanceAlgorithm struct {
}

//
// This class defines the ipfix configuration of the Link Aggregation
// Control Protocol group.
//
//
type VMwareDvsLagIpfixConfig struct {
	*DynamicData

	// True if ipfix monitoring is enabled in the Link Aggregation Control Protocol group.
	// If set, this property will override the ipfix configuration of Uplink Ports
	// in the Link Aggregation Control Protocol group.
	// Thus they are no longer inheriting ipfix configuration from their Uplink Port Group.
	// Setting this property would require
	// ipfixOverrideAllowed
	// of all the Uplink Port Groups to be true,
	// otherwise ConflictingConfiguration fault will be raised.
	IpfixEnabled bool
}

//
// This class defines the vlan configuration of the Link Aggregation
// Control Protocol group.
//
//
type VMwareDvsLagVlanConfig struct {
	*DynamicData

	// The VlanId range for the Uplink Ports in the Link Aggregation
	// Control Protocol group.
	// The valid VlanId range is from 0 to 4094. Overlapping ranges are allowed.
	// If set, this property will override the VLAN configuration of Uplink Ports
	// in the Link Aggregation Control Protocol group.
	// Thus they are no longer inheriting VLAN configuration from their Uplink Port Group.
	// Setting this property would require
	// vlanOverrideAllowed
	// of all the Uplink Port Groups to be true,
	// otherwise ConflictingConfiguration fault will be raised.
	VlanId []*NumericRange
}

//
// Configuration for IPFIX monitoring of distributed virtual switch traffic.
// IPFIX monitoring must be enabled to use this capability. See
// VMwareDVSPortSetting.ipfixEnabled.
//
//
type VMwareIpfixConfig struct {
	*DynamicData

	// The number of seconds after which "active" flows are forced to be
	// exported to the collector. Legal value range is 60-3600. Default 60.
	ActiveFlowTimeout int32

	// IP address for the ipfix collector, specified using IPv4 dot notation.
	// This must be set before ipfix monitoring can be enabled for the
	// switch, or for any portgroup or port of the switch.
	CollectorIpAddress string

	// Port for the ipfix collector. This must be set before ipfix monitoring
	// can be enabled for the switch, or for any portgroup or port of the
	// switch. Legal value range is 0-65535.
	CollectorPort int32

	// The number of seconds after which "idle" flows are forced to be
	// exported to the collector. Legal value range is 10-600. Default 15.
	IdleFlowTimeout int32

	// Whether to limit analysis to traffic that has both source and
	// destination served by the same host. Default false.
	InternalFlowsOnly bool

	// The ratio of total number of packets to the number of packets
	// analyzed. Set to 0 to disable sampling. Legal value range is 0-1000.
	// Default 0.
	SamplingRate int32
}

//
// Link Aggregation Control Protocol policy modes.
//
//
type VMwareUplinkLacpMode struct {
}

// Deprecated.
// As of vSphere API 5.5.
//
//
// This class defines VMware specific Link Aggregation Control Protocol
// policy.
//
//
type VMwareUplinkLacpPolicy struct {
	*InheritablePolicy

	// The flag to indicate whether or not
	// Link Aggregation Control Protocol is enabled.
	// It can be set to true if the value of
	// lacpApiVersion
	// is LacpApiVersion#singleLag,
	// else an exception ConflictingConfiguration will be thrown.
	Enable *BoolPolicy

	// The mode of Link Aggregation Control Protocol.
	// See UplinkLacpMode for valid values.
	Mode *StringPolicy
}

//
// This data object type describes uplink port ordering policy for a
// distributed virtual port.  A uplink port can be in the active
// list, the standby list, or neither.  It cannot be in both lists.
//
//
type VMwareUplinkPortOrderPolicy struct {
	*InheritablePolicy

	// List of active uplink ports used for load balancing.
	ActiveUplinkPort []string

	// Standby uplink ports used for failover.
	StandbyUplinkPort []string
}

//
// This class defines the ports, uplink ports name, vlans and IP addresses participating in a
// Distributed Port Mirroring session. See VspanSession.
//
//
type VMwareVspanPort struct {
	*DynamicData

	// IP address for the destination of encapsulated remote mirror source session,
	// IPv4 address is specified using dotted decimal notation.
	// For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as eight fields
	// of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff.
	//
	// Since vSphere API 5.1
	IpAddress []string

	// Individual ports to participate in the Distributed Port Mirroring session.
	PortKey []string

	// Uplink ports used as destination ports to participate in the Distributed Port Mirroring session.
	// A fault will be raised if uplinkPortName is used as source ports
	// in any Distributed Port Mirroring session.
	UplinkPortName []string

	// Vlan Ids for ingress source of Remote Mirror destination
	// session.
	//
	// Since vSphere API 5.1
	Vlans []int32

	// Wild card specification for source ports participating in the Distributed Port Mirroring session.
	// See DistributedVirtualSwitchPortConnecteeConnecteeType for valid values.
	// Any port that has a connectee of the specified type has its receive traffic
	// mirrored. A fault will be raised if wildcards are specified as destination
	// ports or source ports mirroring traffic on the transmit side.
	// It is to be not used.
	WildcardPortConnecteeType []string
}

//
// The VMwareVspanSession data object
// defines the configuration of a VLAN Services and Protocols for Advanced Networks
// (VSPAN) session. You use a VSPAN session for the following operations:
//
//
// • To mirror network traffic (inbound/outbound) from a set of source
// entities to a set of destination entities.
//
// • To assist in troubleshooting.
//
// • As input for security and other network analysis appliances.
//
//
//
//
// The type of entities that you can specify as source or destination is determined
// by the session type. You can use uplink distributed virtual ports only for
// mixed destination mirror VSPAN sessions (mixedDestMirror).
//
// For all sessions except mixedDestMirror sessions, you cannot
// use uplink distributed virtual ports as destination ports.
//
// sessionType is required for vSphere Distributed Switch 5.1 and later,
// ignored for prior version if set.
//
//
//
//
//
// Session Type
// Source
// Destination
//
//
// mixedDestMirror
// Distributed Ports
// Distributed Ports + Uplink Ports Name
//
//
// dvPortMirror
// Distributed Ports
// Distributed Ports
//
//
//
// remoteMirrorSource
// Distributed Ports
// Uplink Ports Name
//
//
//
// remoteMirrorDest
// VLAN
// Distributed Ports
//
//
//
// encapRemoteMirrorSource
// Distributed Ports
// IP address
//
//
//
//
//
type VMwareVspanSession struct {
	*DynamicData

	// The description for the session.
	Description string

	// Destination ports that received the mirrored packets.
	// You cannot use wild card ports as destination ports. If wildcardPortConnecteeType
	// is set in the value, the reconfigure
	// operation will raise a fault. Also any port designated in the value of
	// this property can not match the wild card source port in any of the
	// Distributed Port Mirroring session.
	DestinationPort *VMwareVspanPort

	// Whether the session is enabled.
	Enabled bool

	// VLAN ID used to encapsulate the mirrored traffic.
	EncapsulationVlanId int32

	// The generated key as the identifier for the session.
	Key string

	// An integer that describes how much of each frame to mirror. If unset, all
	// of the frame would be mirrored.  Setting this property to a smaller value
	// is useful when the consumer will look only at the headers.
	// The value cannot be less than 60.
	MirroredPacketLength int32

	// The display name.
	Name string

	// Whether or not destination ports can send and receive "normal" traffic.
	// Setting this to false will make mirror ports be used solely for mirroring
	// and not double as normal access ports.
	NormalTrafficAllowed bool

	// Sampling rate of the session. If its value is n, one of every n
	// packets is mirrored.
	// Valid values are between 1 to 65535, and default value is 1.
	//
	// Since vSphere API 5.1
	SamplingRate int32

	// Type of the session. See
	// VMwareDVSVspanSessionType
	// for valid values.
	// Default value is mixedDestMirror if unspecified in a VSPAN create operation.
	//
	// Since vSphere API 5.1
	SessionType string

	// Source ports for which received packets are mirrored.
	SourcePortReceived *VMwareVspanPort

	// Source ports for which transmitted packets are mirrored.
	SourcePortTransmitted *VMwareVspanPort

	// Whether to strip the original VLAN tag.  if false, the original VLAN tag
	// will be preserved on the mirrored traffic.  If encapsulationVlanId
	// has been set and this property is false, the frames will be double tagged
	// with the original VLAN ID as the inner tag.
	StripOriginalVlan bool
}

// Deprecated.
// As of vSphere API 4.0, use CheckTestType instead.
//
//
// Types of tests available for validateMigration.
//
//
type ValidateMigrationTestType struct {
}

//
// This event records when the VirtualCenter agent on a host failed to uninstall.
//
//
type VcAgentUninstallFailedEvent struct {
	*HostEvent

	// The reason why the uninstall failed, if known.
	// See AgentInstallFailedReason
	Reason string
}

//
// This event records when the VirtualCenter agent on a host is uninstalled.
//
//
type VcAgentUninstalledEvent struct {
	*HostEvent
}

//
// This event records when the VirtualCenter agent on a host failed to upgrade.
//
//
type VcAgentUpgradeFailedEvent struct {
	*HostEvent

	// The reason why the upgrade failed, if known.
	// See AgentInstallFailedReason
	//
	// Since vSphere API 4.0
	Reason string
}

//
// This event records when the VirtualCenter agent on a host upgraded.
//
//
type VcAgentUpgradedEvent struct {
	*HostEvent
}

//
// View is the base class for session-specific view objects.
// A view is a mechanism that supports selection of objects on the server
// and subsequently, access to those objects.
// To create a view, use the ViewManager methods.
// A view exists until you terminate it by calling the DestroyView method,
// or until the end of the session.
// Access to a view is limited to the session in which it is created.
//
// There are three types of views:
//
//
//
// •  ContainerView
//
// •  ListView
//
// •  InventoryView
//
//
//
//
// A view maintains a view list that contains
// managed object references. You can use a view
// with the PropertyCollector to retrieve data and
// obtain notification of changes to the virtual environment.
// For information about using views with the PropertyCollector,
// see the description of ViewManager.
//
//
//
type View struct {
	*ManagedObject
}

//
// Destroy this view.
//
// Required Privileges
// System.View
//
func (mo *View) DestroyView(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// The ViewManager managed object provides methods to create ContainerView,
// InventoryView, and ListView managed objects.
// The ViewManager also maintains a list of managed object references
// to the views that you have created. Use the viewList
// property to access the views.
//
// A View is a mechanism that supports selection of objects on the server
// and subsequently, access to those objects. Views can simplify the task of
// retrieving data from the server. When you use a view, you can use a single
// invocation of a PropertyCollector method
// to retrieve data or receive notification of changes instead of multiple invocations
// involving multiple filter specifications. A view exists until you destroy it
// or until the end of the session.
//
//
// The ViewManager supports the following views:
//
//
//
// •  A ContainerView is based on Folder,
// Datacenter, ComputeResource,
// ResourcePool, or HostSystem managed objects.
// Use a container view to monitor the container contents and optionally,
// its descendants.
//
// •  A ListView managed object is based on an arbitrary but
// specific set of objects. When you create a list view, you provide
// a list of objects to populate the view
// (CreateListView),
// or you provide an existing view from which the new view is created
// (CreateListViewFromView).
//
// •  An InventoryView managed object is based on the entire inventory.
// Use an inventory view as a general mechanism to monitor the inventory
// or portions of the inventory.
//
//
//
//
//
// For example, you might use the following sequence of operations to get the
// names of all the virtual machines on a server:
//
//
// •  Create a ContainerView for the root folder in the server inventory.
// For the ContainerView, use the type property
// to include only virtual machines.
//
// •  Create a filter specification for the PropertyCollector.
//
//
// •  Use the ContainerView as the starting object in the
// ObjectSpec for the filter.
//
// •  Use the TraversalSpec
// to select all objects in the view list (all the virtual machines).
//
// •  Use the PropertySpec
// to retrieve the name property from each virtual machine.
//
//
//
//
// •  Invoke the PropertyCollector
// RetrieveProperties method.
//
//
//
type ViewManager struct {
	*ManagedObject

	viewList []*View
}

// An array of view references. Each array entry is a managed object reference
// to a view created by this ViewManager.
// Required Privilege: System.View
func (mo *ViewManager) ViewList() ([]*View, error) {
	t, err := mo.currentProperty("viewList")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*View)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*View")
	}
	return v, nil
}

//
// Create a ContainerView managed object for this session.  The method returns
// a reference to a ContainerView object that has a list of managed object references.
// The list references objects in the container and may include references to objects from
// additional containers. You can configure the resulting list of objects by specifying
// a type list and recursion. Once you have created the view, the object list always
// represents the current configuration of the virtual environment and reflects any
// subsequent changes that occur.
//
// Required Privileges
// System.View
//
func (mo *ViewManager) CreateContainerView(
	_this *ManagedObjectReference, container *ManagedEntity, type_ []string, recursive bool,
) (*ContainerView, error) {

	return nil, nil

}

//
// Create a new InventoryView managed object for this session.
//
// Required Privileges
// System.View
//
func (mo *ViewManager) CreateInventoryView(
	_this *ManagedObjectReference,
) (*InventoryView, error) {

	return nil, nil

}

//
// Create a ListView object for this session.  The method returns
// a session object that has a list of managed object references. The list
// of references corresponds to the input object list.
// You can modify the resulting list after you have created the object.
//
// Required Privileges
// System.View
//
func (mo *ViewManager) CreateListView(
	_this *ManagedObjectReference, obj []*ManagedObjectReference,
) (*ListView, error) {

	return nil, nil

}

//
// Create a ListView object for this session. This method uses an existing
// view to construct the object list for the new view.
//
// Required Privileges
// System.View
//
func (mo *ViewManager) CreateListViewFromView(
	_this *ManagedObjectReference, view *View,
) (*ListView, error) {

	return nil, nil

}

//
// Password for the Vim account user on the host has been changed.
// This is an account created by VirtualCenter and used to manage the host.
//
//
type VimAccountPasswordChangedEvent struct {
	*HostEvent
}

//
// The common base type for all virtual infrastructure management
// exceptions.
//
//
type VimFault struct {
	*MethodFault
}

//
// The VirtualAHCIController data object type represents
// an AHCI SATA controller in a virtual machine.
//
//
type VirtualAHCIController struct {
	*VirtualSATAController
}

//
// VirtualAHCIControllerOption is the data object that contains
// the options for an AHCI SATA controller.
//
//
type VirtualAHCIControllerOption struct {
	*VirtualSATAControllerOption
}

//
// Represents a multi-tiered software solution. A vApp is a collection of
// virtual machines (and potentially other vApp containers) that are operated and
// monitored as a unit. From a manage perspective, a multi-tiered vApp acts a
// lot like a virtual machine object. It has power operations, networks, datastores,
// and its resource usage can be configured.
//
// From a technical perspective, a vApp container is a specialized resource pool that
// has been extended with the following capabilities:
//
// •
//
// Product information such as product name, vendor, properties,
// and licenses.
//
//
// A power-on/power-off sequence specification
//
//
// Support for import/export vApps as OVF packages
//
//
// An OVF environment that allows for application-level customization
//
//
//
//
// Destroying a vApp
//
//
// When a vApp is destroyed, all of its virtual machines are destroyed,
// as well as any child vApps.
//
//
// The VApp.Delete privilege must be held on the vApp as well as the
// parent folder of the vApp.  Also, the VApp.Delete privilege must
// be held on any child vApps that would be destroyed by the operation.
//
//
//
type VirtualApp struct {
	*ManagedObject
	*ResourcePool

	childLink []*VirtualAppLinkInfo

	datastore []*Datastore

	network []*Network

	parentFolder *Folder

	parentVApp *ManagedEntity

	vAppConfig *VAppConfigInfo
}

// Deprecated.
// As of vSphere API 5.1.
//
//
// List of linked children.
//
// Since vSphere API 4.1
func (mo *VirtualApp) ChildLink() ([]*VirtualAppLinkInfo, error) {
	t, err := mo.currentProperty("childLink")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*VirtualAppLinkInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*VirtualAppLinkInfo")
	}
	return v, nil
}

// A collection of references to the subset of datastore objects used by this
// vApp.
// Required Privilege: System.View
func (mo *VirtualApp) Datastore() ([]*Datastore, error) {
	t, err := mo.currentProperty("datastore")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Datastore)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Datastore")
	}
	return v, nil
}

// A collection of references to the subset of network objects that
// is used by this virtual machine.
// Required Privilege: System.View
func (mo *VirtualApp) Network() ([]*Network, error) {
	t, err := mo.currentProperty("network")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Network)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Network")
	}
	return v, nil
}

// A reference to the parent folder in the VM and Template folder hierarchy. This
// is only set for a root vApp. A root vApp is a vApp that is not a child of
// another vApp.
// Required Privilege: System.View
func (mo *VirtualApp) ParentFolder() (*Folder, error) {
	t, err := mo.currentProperty("parentFolder")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*Folder)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *Folder")
	}
	return v, nil
}

// Reference to the parent vApp.
//
// Since vSphere API 4.1
func (mo *VirtualApp) ParentVApp() (*ManagedEntity, error) {
	t, err := mo.currentProperty("parentVApp")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ManagedEntity)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ManagedEntity")
	}
	return v, nil
}

// Configuration of this package.
// Required Privilege: System.Read
func (mo *VirtualApp) VAppConfig() (*VAppConfigInfo, error) {
	t, err := mo.currentProperty("vAppConfig")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VAppConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VAppConfigInfo")
	}
	return v, nil
}

//
// Creates a clone of this vApp.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// When invoking this method, the following privilege checks occur:
//
//
//
// • The privilege VApp.Clone is required on this vApp.
//
// • If the target is a resource pool, the privilege
// Resource.AssignVAppToPool is required on it.
//
// • If the target is a vApp, the privileges VApp.Clone and
// VApp.AssignVApp are required on it.
//
//
//
// Additional privileges are required by the clone spec provided. See VAppCloneSpec for details.
//
// Required Privileges
// VApp.Clone
//
func (mo *VirtualApp) CloneVApp_Task(
	_this *ManagedObjectReference, name string, target *ResourcePool, spec *VAppCloneSpec,
) (*Task, error) {

	return nil, nil

}

//
// Obtains an export lease on this vApp. The export lease contains a list
// of URLs for the disks of the virtual machines in this vApp, as well as
// a ticket that gives access to these URLs.
//
// See HttpNfcLease for information on how to use the lease.
//
//
// Required Privileges
// VApp.Export
//
func (mo *VirtualApp) ExportVApp(
	_this *ManagedObjectReference,
) (*HttpNfcLease, error) {

	return nil, nil

}

//
// Stops this vApp.
//
// The virtual machines (or child vApps) will be stopped in the order
// specified in the vApp configuration, if force is false. If force is set
// to true, all virtual machines are powered-off (in no specific order and
// possibly in parallel) regardless of the vApp auto-start configuration.
//
//
// While a vApp is stopping, all power operations performed on sub entities are
// disabled through the VIM API. They will throw TaskInProgress.
//
//
// Required Privileges
// VApp.PowerOff
//
func (mo *VirtualApp) PowerOffVApp_Task(
	_this *ManagedObjectReference, force bool,
) (*Task, error) {

	return nil, nil

}

//
// Starts this vApp.
//
// The virtual machines (or sub vApps) will be started in the order
// specified in the vApp configuration. If the vApp is suspended
// (@see vim.VirtualApp.Summary.suspended), all suspended virtual machines
// will be powered-on based on the defined start-up order.
//
//
// While a vApp is starting, all power operations performed on sub entities are
// disabled through the VIM API. They will throw TaskInProgress.
//
//
// In case of a failure to power-on a virtual machine, the exception from the virtual
// machine power on is returned, and the power-on sequence will be terminated. In
// case of a failure, virtual machines that are already started will remain
// powered-on.
//
//
//
//
// Required Privileges
// VApp.PowerOn
//
func (mo *VirtualApp) PowerOnVApp_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Suspends this vApp.
//
// Suspends all powered-on virtual machines in a vApp, including virtual machines
// in child vApps. The virtual machines are suspended in the same order as
// used for a power-off operation (reverse power-on sequence).
//
//
// While a vApp is being suspended, all power operations performed on sub entities
// are disabled through the VIM API. They will throw TaskInProgress.
//
//
// Required Privileges
// VApp.Suspend
// Since
// vSphere API 4.1
//
func (mo *VirtualApp) SuspendVApp_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Removes this vApp from the inventory without removing
// any of the virtual machine's files on disk. All high-level information
// stored with the management server (ESX Server or VirtualCenter) is
// removed, including information such as vApp configuration, statistics,
// permissions, and alarms.
//
//
//
// Required Privileges
// VApp.Unregister
//
func (mo *VirtualApp) UnregisterVApp_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of vSphere API 5.1.
//
//
// Reconfigure the set of linked children.
//
// A VirtualMachine and vApp can be added as a linked child as long as it
// is not a direct child of another vApp. In case it is a linked child, the
// existing link is removed and replaced with the new link specified in this
// call.
//
//
// An InvalidArgument fault is thrown if a link target is a direct child
// of another vApp, or if the addition of the link will result in a vApp
// with a cycle. For example, a vApp cannot be linked to itself.
//
//
// The removeSet must refer to managed entities that are currently linked
// children. Otherwise, an InvalidArgument exception is thrown.
//
//
// For each entity being linked, the operation is subject to the following privilege
// checks:
//
//
//
// • If the object being linked is a vApp, VApp.Move must be held on
// the vApp being linked and its former parent vApp (if any). The privilege
// VApp.AssignVApp must be held on this vApp.
//
//
// • If the object being linked is a VirtualMachine, VApp.AssignVM is required on
// both the target vApp, the VirtualMachine, and its former parent vApp (if any).
//
//
//
//
//
// Privilege checks for each entity in the removeSet are similar to the entities
// in the addChangeSet, except that there is no target vApp.
//
//
// This operation is only transactional with respect to each individual link change.
// The changes are processed sequentially and committed one at a time. The
// addChangeSet is processed first, followed by the removeSet. If a failure is
// detected, then the method terminates with an exception.
//
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 4.1
//
func (mo *VirtualApp) UpdateLinkedChildren(
	_this *ManagedObjectReference, addChangeSet []*VirtualAppLinkInfo, removeSet []*ManagedEntity,
) error {

	return nil

}

//
// Updates the vApp configuration.
//
// Updates in different areas require different privileges. See
// VAppConfigSpec for a full description.
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *VirtualApp) UpdateVAppConfig(
	_this *ManagedObjectReference, spec *VAppConfigSpec,
) error {

	return nil

}

//
// A VAppImportSpec is used by ResourcePool.importVApp when importing vApps (single VM or multi-VM).
//
// It provides all information needed to import a VirtualApp.
//
//
// See also ImportSpec.
//
//
//
type VirtualAppImportSpec struct {
	*ImportSpec

	// Contains a list of children (VirtualMachines and
	// VirtualApps).
	Child []*ImportSpec

	// The name of the vApp
	Name string

	// Resource pool specification.
	//
	// If resourcePoolSpec.entity is specified, that resource pool is used as the parent
	// resource pool and the vApp will be made a linked child to the parent vApp. This
	// field is ignored for the root node in an ImportSpec tree.
	//
	// Use of resourcePoolSpec.entity for creating linked children is deprecated as of
	// vSphere API 5.1.
	ResourcePoolSpec *ResourceConfigSpec

	// vApp configuration
	VAppConfigSpec *VAppConfigSpec
}

// Deprecated.
// As of vSphere API 5.1.
//
//
// Linked child information.
//
//
type VirtualAppLinkInfo struct {
	*DynamicData

	// Whether the entity should be removed, when this vApp is removed
	DestroyWithParent bool

	// The key contains a reference to the entity that is linked to this vApp
	Key *ManagedEntity
}

//
// This data object type encapsulates a typical set of resource
// pool information that is useful for list views and summary pages.
//
//
type VirtualAppSummary struct {
	*ResourcePoolSummary

	// Whether one or more VMs in this vApp require a reboot to finish
	// installation.
	InstallBootRequired bool

	// vCenter-specific UUID of the vApp
	//
	// Since vSphere API 4.1
	InstanceUuid string

	// Product information. References to properties in the URLs are expanded.
	Product *VAppProductInfo

	// Whether a vApp is suspended, in the process of being suspended, or in the
	// process of being resumed. A stopped vApp is marked as suspended
	// under the following conditions:
	//
	// All child virtual machines are either suspended or powered-off.
	// There is at least one suspended virtual machine for which the
	// stop action is not "suspend".
	//
	// If the vAppState property is "stopped", the value is set to true if the vApp is
	// suspended (according the the above definition).
	//
	// If the vAppState property is "stopping" or "starting" and the suspend flag is set to
	// true, then the vApp is either in the process of being suspended or resumed
	// from a suspended state, respectively.
	//
	// If the vAppState property is "started", then the suspend flag is set to false.
	//
	// Since vSphere API 4.1
	Suspended bool

	// Whether the vApp is running
	VAppState *enum.VirtualAppVAppState
}

//
// The VAppState type defines the set of states a vApp can be
// in. The transitory states between started and stopped is modeled explicitly,
// since the starting or stopping of a vApp is typically a time-consuming
// process that might take minutes to complete.
//
//
type VirtualAppVAppState struct {
}

//
// VirtualBusLogicController is the data object that represents
// a BusLogic SCSI controller.
//
//
type VirtualBusLogicController struct {
	*VirtualSCSIController
}

//
// This data object contains
// the options for a BusLogic SCSI controller.
//
//
type VirtualBusLogicControllerOption struct {
	*VirtualSCSIControllerOption
}

//
// The VirtualCdrom data object type describes the configuration of a CD-ROM device
// in a virtual machine.
//
//
type VirtualCdrom struct {
	*VirtualDevice
}

//
// The VirtualCdrom.AtapiBackingInfo data object type
// represents an ATAPI device backing for a virtual CD-ROM.
//
//
type VirtualCdromAtapiBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

//
// The VirtualCdromOption.AtapiBackingOption data object type
// contains the options for the ATAPI CD-ROM device backing.
//
//
type VirtualCdromAtapiBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The VirtualCdrom.IsoBackingInfo data class represents
// an ISO backing for a virtual CD-ROM.
//
//
type VirtualCdromIsoBackingInfo struct {
	*VirtualDeviceFileBackingInfo
}

//
// The VirtualCdromOption.IsoBackingOption data object type contains
// the options for an ISO image backing.
//
//
type VirtualCdromIsoBackingOption struct {
	*VirtualDeviceFileBackingOption
}

//
// The VirtualCdromOption data object type contains the options for the
// virtual CD-ROM class.
//
//
type VirtualCdromOption struct {
	*VirtualDeviceOption
}

//
// The VirtualCdrom.PassthroughBackingInfo data class
// represents a device pass-through backing for a
// virtual CD-ROM.
//
//
type VirtualCdromPassthroughBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	// Flag to indicate whether or not the virtual machine has
	// exclusive CD-ROM device access.
	Exclusive bool
}

//
// The VirtualCdromOption.PassthroughBackingOption data object type
// contains the options for a pass-through CD-ROM device backing.
//
//
type VirtualCdromPassthroughBackingOption struct {
	*VirtualDeviceDeviceBackingOption

	// Flag to indicate whether or not exclusive CD-ROM device access is supported.
	Exclusive *BoolOption
}

//
// The VirtualCdrom.RemoteAtapiBackingInfo data class
// represents a remote ATAPI device backing for a virtual CD-ROM.
//
//
type VirtualCdromRemoteAtapiBackingInfo struct {
	*VirtualDeviceRemoteDeviceBackingInfo
}

//
// The VirtualCdromOption.RemoteAtapiBackingOption data object type
// contains the options for the remote ATAPI CD-ROM device backing.
// Note that the server cannot present a list of valid remote backing devices
// because it is unable to scan remote hosts.
//
//
type VirtualCdromRemoteAtapiBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The VirtualCdrom.RemotePassthroughBackingInfo data object type
// contains the information to specify a remote pass-through device
// backing of a virtual CD-ROM.
//
//
type VirtualCdromRemotePassthroughBackingInfo struct {
	*VirtualDeviceRemoteDeviceBackingInfo

	// Flag to indicate whether or not the virtual machine
	// has exclusive access to the CD-ROM device.
	Exclusive bool
}

//
// The VirtualCdromOption.RemotePassthroughBackingOption data object type
// contains the options for a remote pass-through CD-ROM device backing.
//
// Note that the server cannot present a list of valid remote backing devices
// because it is unable to scan remote hosts.
//
//
//
type VirtualCdromRemotePassthroughBackingOption struct {
	*VirtualDeviceRemoteDeviceBackingOption

	// Flag to indicate whether or not exclusive CD-ROM device access is supported.
	Exclusive *BoolOption
}

//
// VirtualController is the base data object type for a device controller in
// a virtual machine. VirtualController extends
// VirtualDevice to inherit
// general information about a controller (such as name and description), and to allow
// controllers to appear in a generic list of virtual devices.
//
//
type VirtualController struct {
	*VirtualDevice

	// Bus number associated with this controller.
	BusNumber int32

	// List of devices currently controlled by this controller.
	//
	// Each entry contains the key property of the
	// corresponding device object.
	Device []int32
}

//
// The VirtualControllerOption data object type contains information about
// a virtual controller type.
//
//
type VirtualControllerOption struct {
	*VirtualDeviceOption

	// The minimum and maximum number of devices this controller can control
	// at run time.
	Devices *IntOption

	// Array of supported device options for this controller.
	SupportedDevice []string
}

//
// VirtualDevice is the base data object type for devices in a virtual machine.
// This type contains enough information about a virtual device to allow clients
// to display devices they do not recognize. For example, a client with an
// older version than the server to which it connects may see a device
// without knowing what it is.
//
//
type VirtualDevice struct {
	*DynamicData

	// Information about the backing of this virtual device presented
	// in the context of the virtual machine's environment.
	// Not all devices are required to have backing information.See VirtualMachineConfigOption
	Backing *VirtualDeviceBackingInfo

	// Provides information about restrictions on removing this device while
	// a virtual machine is running. If the device is not removable, then
	// this property is null.
	Connectable *VirtualDeviceConnectInfo

	// Object key for the controller object for this device.
	//
	// This property contains the key property value of the controller device
	// object.
	ControllerKey int32

	// Provides a label and summary information for the device.
	DeviceInfo *Description

	// A unique key that distinguishes this device from other
	// devices in the same virtual machine. Keys are immutable but may be
	// recycled; that is, a key does not change as long as the device is
	// associated with a particular virtual machine. However, once a device is
	// removed, its key may be used when another device is added.
	//
	// This property is not read-only, but the client cannot control its value.
	// Persistent device keys are always assigned and managed by the server, which
	// guarantees that all devices will have non-negative key values.
	//
	// When adding new devices, it may be necessary for a client to assign keys
	// temporarily in order to associate controllers with devices in
	// configuring a virtual machine. However, the server does not allow a
	// client to reassign a device key, and the server may assign a different
	// value from the one passed during configuration. Clients should ensure
	// that existing device keys are not reused as temporary key values for the
	// new device to be added (for example, by using unique negative integers as
	// temporary keys).
	//
	// When editing or deleting a device, clients must use the server-provided key
	// to refer to an existing device.
	Key int32

	// Information about the bus slot of a device in a virtual machine.
	//
	// Since vSphere API 5.1
	SlotInfo *VirtualDeviceBusSlotInfo

	// The unit number of this device on its controller. This property is null if
	// the controller property is null (for example, when the device is not
	// attached to a specific controller object).
	//
	// Normally, two devices on the same controller
	// may not be assigned the same unit number. If
	// multiple devices could exist on a controller,
	// then unit number has to be specified to
	// configure respective devices.
	UnitNumber int32
}

//
// VirtualDeviceBackingInfo is a base data object type
// for information about the backing of a device in a virtual machine.
// This base type does not define any properties. It is used as a namespace
// for general-purpose subtypes. Specific devices are represented by subtypes
// which define properties for device-specific backing information.
//
//
type VirtualDeviceBackingInfo struct {
	*DynamicData
}

//
// The VirtualDeviceBackingOption data class
// defines options for device-specific virtual backing objects.
//
//
type VirtualDeviceBackingOption struct {
	*DynamicData

	// The name of the class the client should use to instantiate backing
	// for the virtual device.
	Type string
}

//
// VirtualDeviceBusSlotInfo is a base data object type
// for information about device connection to its bus. This base type does not
// define any properties. It is used as a namespace for general-purpose subtypes.
// Specific devices types are represented by subtypes which define properties for
// device-specific backing information.
//
//
type VirtualDeviceBusSlotInfo struct {
	*DynamicData
}

//
// The VirtualDeviceBusSlotOption data class
// defines options for device-specific bus slot objects.
//
//
type VirtualDeviceBusSlotOption struct {
	*DynamicData

	// The name of the class the client should use to instantiate bus slot
	// object for the virtual device.
	Type string
}

//
// The VirtualDeviceSpec data object type encapsulates change
// specifications for an individual virtual device. The virtual
// device being added or modified must be fully specified.
//
//
type VirtualDeviceConfigSpec struct {
	*DynamicData

	// Device specification, with all necessary properties set.
	Device *VirtualDevice

	// Type of operation being performed on the backing
	// of the specified virtual device.
	// If no file operation is specified in the VirtualDeviceSpec,
	// then any backing filenames in the
	// VirtualDevice
	// must refer to files that already exist.
	// The "replace" and "delete" values for this property are only
	// applicable to virtual disk backing files.
	FileOperation *enum.VirtualDeviceConfigSpecFileOperation

	// Type of operation being performed on the specified virtual device.
	// If no operation is specified, the spec. is ignored.
	Operation *enum.VirtualDeviceConfigSpecOperation

	// Virtual Device Profile requirement.
	//
	// Profiles are solution specifics.
	//
	// Storage Profile Based Management(SPBM) is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with SPBM service.
	//
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	//
	// Since vSphere API 5.5
	Profile []*VirtualMachineProfileSpec
}

//
// The type of operation being performed on the backing of a virtual device.
// Valid values are:
//
//
type VirtualDeviceConfigSpecFileOperation struct {
}

//
// The type of operation being performed on the specified virtual device.
// Valid values are:
//
//
type VirtualDeviceConfigSpecOperation struct {
}

//
// The VirtualDeviceConnectInfo data object type
// contains information about connectable virtual devices.
//
//
type VirtualDeviceConnectInfo struct {
	*DynamicData

	// Enables guest control over whether the connectable device is
	// connected.
	AllowGuestControl bool

	// Indicates whether the device is currently connected.
	// Valid only while the virtual machine is running.
	Connected bool

	// Specifies whether or not to connect the device
	// when the virtual machine starts.
	StartConnected bool

	// Indicates the current status of the connectable device. Valid only while the
	// virtual machine is running. The set of possible values is described in
	// VirtualDeviceConnectInfoStatus
	//
	// Since vSphere API 4.0
	Status string
}

//
// Specifies the connectable virtual device status.
//
//
type VirtualDeviceConnectInfoStatus struct {
}

//
// The ConnectOption data object type contains information about options for
// connectable virtual devices.
//
//
type VirtualDeviceConnectOption struct {
	*DynamicData

	// Flag to indicate whether or not the device can be
	// connected and disconnected from within the guest operating system.
	AllowGuestControl *BoolOption

	// Flag to indicate whether or not the device supports
	// the startConnected feature.
	StartConnected *BoolOption
}

//
// The VirtualDeviceDeviceBackingInfo data object type
// defines information about a host device or resource that backs a device
// in a virtual machine.
//
//
type VirtualDeviceDeviceBackingInfo struct {
	*VirtualDeviceBackingInfo

	// The name of the device on the host system.
	DeviceName string

	// Indicates whether the device should be auto detected
	// instead of directly specified. If this value is set to TRUE,
	// deviceName is ignored.
	//
	// Since VI API 2.5
	UseAutoDetect bool
}

//
// The DeviceBackingOption data class contains device-specific backing options.
//
//
type VirtualDeviceDeviceBackingOption struct {
	*VirtualDeviceBackingOption

	// Flag to indicate whether the specific instance of this device can
	// be auto-detected on the host instead of having to specify a
	// particular physical device.
	//
	// Since VI API 2.5
	AutoDetectAvailable *BoolOption
}

//
// VirtualDeviceFileBackingInfo is a data object type
// for information about file backing for a device in a virtual machine.
//
//
type VirtualDeviceFileBackingInfo struct {
	*VirtualDeviceBackingInfo

	// Backing object's durable and unmutable identifier.
	// Each backing object has a unique identifier which is not settable.
	//
	// Since vSphere API 5.5
	BackingObjectId string

	// Reference to the datastore managed object where this file is stored.
	// If the file is not located on a datastore, then this reference is null.
	// This is not used for configuration.
	Datastore *Datastore

	// Filename for the host file used in this backing.
	FileName string
}

//
// The FileBackingOption data class contains file-specific backing options.
//
//
type VirtualDeviceFileBackingOption struct {
	*VirtualDeviceBackingOption

	// Valid filename extension for the filename.
	// If no extensions are present, any file extension is acceptable.
	FileNameExtensions *ChoiceOption
}

//
// All known file extensions. Valid ones are:
//
//
type VirtualDeviceFileExtension struct {
}

//
// The VirtualDeviceOption data object type contains information about
// a virtual device type, the options for configuring the virtual device,
// and the relationship between this virtual device and other devices.
// The vSphere API groups device configurations that are mutually exclusive
// into different configuration objects; each of these configuration objects
// may define subtypes for virtual device backing options
// that are independent of the virtual device.
// Backing-dependent options should appear in a subtype of
// VirtualDeviceBackingOption.
//
//
type VirtualDeviceOption struct {
	*DynamicData

	// Flag to indicate whether or not this device will be auto-assigned a controller
	// if one is required. If this is true, then a client need not explicitly create
	// the controller that this device will plug into.
	AutoAssignController *BoolOption

	// A list of backing options that can be used to map the virtual
	// device to the host. The list is optional, since some devices exist only within
	// the virtual machine; for example, a VirtualController.
	BackingOption []*VirtualDeviceBackingOption

	// If the device can use a bus slot configuration, then the busSlotOption
	// describes the bus slot options.
	//
	// Since vSphere API 5.1
	BusSlotOption *VirtualDeviceBusSlotOption

	// If the device is connectable, then the connectOption
	// describes the connect options and defaults.
	ConnectOption *VirtualDeviceConnectOption

	// Data object type that denotes the controller option object that is
	// valid for controlling this device.
	ControllerType string

	// Index into the backingOption list, indicating the default backing.
	DefaultBackingOptionIndex int32

	// Indicates whether this device is deprecated. Hence, if set the device
	// cannot be used when creating a new virtual machine or be added to an existing
	// virtual machine. However, the device is still supported by the platform.
	Deprecated bool

	// Indicates if this type of device can be hot-removed from the virtual machine
	// via a reconfigure operation when the virtual machine is powered on.
	//
	// Since vSphere API 4.0
	HotRemoveSupported bool

	// List of property names enforced by a licensing restriction
	// of the underlying product. For example, a limit that is not
	// derived based on the product or hardware features; the
	// property name "numCPU".
	LicensingLimit []string

	// Indicates if this type of device can be hot-added to the virtual machine
	// via a reconfigure operation when the virtual machine is powered on.
	PlugAndPlay bool

	// The name of the run-time class the client should instantiate
	// to create a run-time instance of this device.
	Type string
}

//
// The VirtualDevicePciBusSlotInfo data object type
// defines information about a pci bus slot of pci device in a virtual machine.
//
//
type VirtualDevicePciBusSlotInfo struct {
	*VirtualDeviceBusSlotInfo

	// The pci slot number of the virtual device.
	//
	// The pci slot number assignment should generally be left to the system.
	// If assigned  a value, and the value is invalid or duplicated, it will
	// automatically be reassigned. This will not cause an error.
	//
	// Generally, the PCI slot numbers should never be specified in an
	// Reconfigure operation, and only in a CreateVM operation if i) they
	// are specified for all devices, and ii) the  numbers have been
	// determined by looking at an existing VM configuration of similar
	// hardware version. In other words, when the virtual hardware configuration
	// is duplicated.
	PciSlotNumber int32
}

//
// The VirtualDevicePipeBackingInfo data object type
// defines information for using a named pipe as backing for a device
// in a virtual machine.
//
//
type VirtualDevicePipeBackingInfo struct {
	*VirtualDeviceBackingInfo

	// Pipe name for the host pipe associated with this backing.
	PipeName string
}

//
// The PipeBackingOption data object type contains options
// specific to pipe backings.
//
//
type VirtualDevicePipeBackingOption struct {
	*VirtualDeviceBackingOption
}

//
// VirtualDeviceRemoteDeviceBackingInfo is a data object type
// for information
// about a remote device backing used by a device in a virtual machine.
// The primary difference between a remote device backing and a
// local device backing is that the VirtualCenter server cannot provide a list
// of remote host devices available for this virtual device backing.
//
//
type VirtualDeviceRemoteDeviceBackingInfo struct {
	*VirtualDeviceBackingInfo

	// The name of the device on the remote system.
	DeviceName string

	// Indicates whether the device should be auto detected
	// instead of directly specified. If this value is set to TRUE,
	// deviceName is ignored.
	//
	// Since VI API 2.5
	UseAutoDetect bool
}

//
// VirtualDeviceOption.RemoteDeviceBackingOption describes the options
// for a remote device backing. The primary difference
// between a remote device backing and a local device backing is that
// the VirtualCenter server cannot provide a list of remote host devices
// available for this virtual device backing.
//
//
type VirtualDeviceRemoteDeviceBackingOption struct {
	*VirtualDeviceBackingOption

	// Flag to indicate whether the specific instance of this device can
	// be auto-detected on the host instead of having to specify a
	// particular physical device.
	//
	// Since VI API 2.5
	AutoDetectAvailable *BoolOption
}

//
// The VirtualDeviceURIBackingInfo data object type
// defines information for using a network socket as backing for a virtual device.
//
//
type VirtualDeviceURIBackingInfo struct {
	*VirtualDeviceBackingInfo

	// The direction of the connection.  For possible values see
	// VirtualDeviceURIBackingOptionDirection
	Direction string

	// Identifies a proxy service that provides network access to the
	// serviceURI.
	// If you specify a proxy URI, the virtual machine initiates
	// a connection with the proxy service and forwards the
	// serviceURI and direction to the proxy.
	ProxyURI string

	// Identifies the local host or a system on the network,
	// depending on the value of direction.
	//
	// If you use the virtual machine as a server, the URI identifies
	// the host on which the virtual machine runs. In this case,
	// the host name part of the URI should be empty, or it should
	// specify the address of the local host.
	// If you use the virtual machine as a client, the URI identifies
	// the remote system on the network.
	ServiceURI string
}

//
// The URIBackingOption data object type describes network communication
// options for virtual devices.
// When establishing a connection with a remote system on the network,
// the virtual machine can act as a server or a client.
// When the virtual machine acts as a server, it accepts a connection.
// When the virtual machine acts as a client, it initiates the connection.
//
//
type VirtualDeviceURIBackingOption struct {
	*VirtualDeviceBackingOption

	// List of possible directions. Valid directions are:
	//
	// server
	// client
	Directions *ChoiceOption
}

//
// The VirtualDeviceURIBackingOptionDirection enum type
// provides values for the direction of a network connection.
//
//
type VirtualDeviceURIBackingOptionDirection struct {
}

//
// This data object type contains information about a disk in a virtual machine.
//
// The virtual disk backing object types describe the different virtual disk backings
// available.
// The disk format version in each case describes
// the version of the format that is used.
//
//
// Supported virtual disk backings:
// Sparse disk format, version 1 and 2The virtual disk backing grows when needed.
// Supported only for VMware Server.Flat disk format, version 1 and 2The virtual disk backing is preallocated.
// Version 1 is supported only for VMware Server.Space efficient sparse disk formatThe virtual disk backing grows on demand and
// incorporates additional space optimizations.Raw disk format, version 2The virtual disk backing uses a full physical disk drive
// to back the virtual disk. Supported only for VMware Server.Partitioned raw disk format, version 2The virtual disk backing uses one or more partitions on a
// physical disk drive to back a virtual disk. Supported only for VMware Server.Raw disk mapping, version 1The virtual disk backing uses a raw device mapping to back the virtual disk.
// Supported for ESX Server 2.5 and 3.x.
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
type VirtualDisk struct {
	*VirtualDevice

	// Capacity of this virtual disk in bytes.
	// Server will always populate this property. Clients must initialize it when
	// creating a new non -RDM disk or in case they want to change the current
	// capacity of an existing virtual disk, but can omit it otherwise.
	//
	// Since vSphere API 5.5
	CapacityInBytes int64

	// Deprecated.
	// As of vSphere API 5.5, use capacityInBytes.
	//
	//
	// Capacity of this virtual disk in kilobytes.
	// Information might be lost when actual disk size is rounded off to kilobytes.
	CapacityInKB int64

	// Virtual disk durable and unmutable identifier.
	//
	// Virtual disk has a UUID field but that can be set through
	// VirtualDiskManager APIs.
	//
	// This identifier is a universally unique identifier which is not settable.
	// VirtualDisk can remain in existence even if it is not associated with VM.
	//
	// Since vSphere API 5.5
	DiskObjectId string

	// Deprecated.
	// As of vSphere API 4.1, use
	// shares.
	//
	//
	// Disk shares, used for resource scheduling.
	Shares *SharesInfo

	// Resource allocation for storage I/O.
	//
	// Since vSphere API 4.1
	StorageIOAllocation *StorageIOAllocationInfo

	// vFlash cache configuration supported on this virtual disk
	//
	// Since vSphere API 5.5
	VFlashCacheConfigInfo *VirtualDiskVFlashCacheConfigInfo
}

//
// The types of virtual disk adapters used by virtual disks
//
//
type VirtualDiskAdapterType struct {
}

//
// Pod-wide anit-affinity rule for virtual disks. The set of virtual disks should
// be placed on different datastores.
//
//
//
//
type VirtualDiskAntiAffinityRuleSpec struct {
	*ClusterRuleInfo

	// The list of virtual disks.
	DiskId []int32
}

//
// The disk blocks of the specified virtual disk have not been fully
// provisioned on the file system.
//
// Typically, this fault is returned as part of a parent fault like
// VmConfigIncompatibleForFaultTolerance, indicating that the
// disk blocks of the virtual disk must be fully provisioned on the file system
// before fault tolerance can be enabled on the associated virtual machine.
//
//
//
//
type VirtualDiskBlocksNotFullyProvisioned struct {
	*DeviceBackingNotSupported
}

//
// All known compatibility modes for raw disk mappings. Valid compatibility
// modes are:
//
//
// • virtualMode
//
// • physicalMode
//
//
//
//
//
type VirtualDiskCompatibilityMode struct {
}

//
// The VirtualDiskSpec data object type encapsulates change
// specifications for an individual virtual disk device. The virtual
// disk being added or modified must be fully specified.
//
//
type VirtualDiskConfigSpec struct {
	*VirtualDeviceConfigSpec

	// Manner in which to transfer the cache associated with the virtual disk to the
	// target host.
	// If left unset then migrate is used when the backing vFlash module version is
	// compatible with the specific vFalsh module on the target host; otherwise flush is
	// used for write back cache, or a no-op for write through cache. This setting can
	// avoid VM migration failure due to incompatibility.
	// If true then migrate is always used. VM migration may fail if the backing vFlash module
	// version is incompatible with the module on the target host.
	// If false then flush is used for write back cache. It is a no-op for write through
	// cache. This setting can avoid VM migration failure due to incompatibility, but cache
	// files have to be rebuilt on the target host.
	// Default is unset.
	// See HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption
	MigrateCache bool
}

//
// The delta disk format constants
//
//
type VirtualDiskDeltaDiskFormat struct {
}

//
// Delta disk format supported for each datastore type.
//
//
type VirtualDiskDeltaDiskFormatsSupported struct {
	*DynamicData

	// Datastore type name
	DatastoreType string

	// Delta disk formats supported. Valid values are:
	//
	// redoLogFormat
	// nativeFormat
	DeltaDiskFormat *ChoiceOption
}

//
// This data object type contains information about backing a virtual disk by
// using a virtual disk file on the host, in the flat file format used by
// GSX Server 2.x.
//
// Flat disks are allocated when created, unlike sparse disks, which
// grow as needed.
//
//
//
type VirtualDiskFlatVer1BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	//
	// Since vSphere API 4.0
	ContentId string

	// The disk persistence mode. Valid modes are:
	//
	// persistent
	// nonpersistent
	// undoable
	// See VirtualDiskMode
	DiskMode string

	// The parent of this virtual disk file, if this is a delta disk backing.
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time.  A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent).  After a delta
	// disk backing is added, all writes go to the delta disk backing.  All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine creation and
	// reconfiguration this property is
	// only checked if the VirtualDeviceConfigSpec specifies
	// an add operation with a
	// create file operation.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing.  Only the fileName
	// property is important; all other properties will be ignored.  The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// deltaDiskBackingsSupported
	// is true.
	//
	// Since vSphere API 4.0
	Parent *VirtualDiskFlatVer1BackingInfo

	// Flag to indicate the type of virtual disk file: split or monolithic.
	// If true, the virtual disk is stored in multiple files, each 2GB.
	Split bool

	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough bool
}

//
// This data object type contains the available options when backing a virtual disk
// using a host file with the flat file format from GSX Server 2.x.
// Flat disks are pre-allocated, whereas sparse disks are grown as needed.
//
//
type VirtualDiskFlatVer1BackingOption struct {
	*VirtualDeviceFileBackingOption

	// The disk mode. Valid disk modes are:
	//
	// persistent
	// nonpersistent
	// undoable
	// independent_persistent
	// independent_nonpersistent
	// append
	// See VirtualDiskMode
	DiskMode *ChoiceOption

	// Flag to indicate whether this backing can have its size changed.
	Growable bool

	// Flag to indicate whether or not the host supports
	// allowing the client to select whether or not a disk
	// should be split.
	Split *BoolOption

	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks. Typically, this is available only for GSX Server Linux hosts.
	WriteThrough *BoolOption
}

//
// This data object type contains information about backing a virtual disk using a
// virtual disk file on the host, in the flat file format used by VMware Server,
// ESX Server 2.x, and ESX Server 3.x.
// Flat disks are allocated when created, unlike sparse disks, which
// grow as needed.
//
//
type VirtualDiskFlatVer2BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine. This can be used to track
	// incremental changes to a virtual disk. See
	// QueryChangedDiskAreas.
	//
	// Since vSphere API 4.0
	ChangeId string

	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	//
	// Since vSphere API 4.0
	ContentId string

	// The format of the delta disk.
	//
	// This field is valid only for a delta disk.
	//
	// See DeltaDiskFormat for the
	// supported formats. If not specified, the default value used is
	// redoLogFormat.
	//
	// If nativeFormat
	// is specified and the datastore does not support this format or the parent is
	// on a different datastore,
	// DeltaDiskFormatNotSupported is
	// thrown.
	//
	// vSphere server does not support relocation of virtual machines with
	// nativeFormat.
	// An exception is thrown for such requests.
	//
	// Since vSphere API 5.0
	DeltaDiskFormat string

	// Grain size in kB for a delta disk of format type seSparseFormat.  The default
	// size is 1024 kB.
	//
	// This setting is used to specify the grain size of
	// Flex-SE delta disks
	// when the base disk is of type FlatVer2BackingInfo.
	// The DeltaDiskFormat must also
	// be set to seSparseFormat.
	//
	// Since vSphere API 5.1
	DeltaGrainSize int32

	// Indicates whether the disk backing has digest file enabled.
	//
	// Since vSphere API 5.0
	DigestEnabled bool

	// The disk persistence mode. Valid modes are:
	//
	// persistent
	// independent_persistent
	// independent_nonpersistent
	// nonpersistent
	// undoable
	// append
	// See VirtualDiskMode
	DiskMode string

	// Flag to indicate to the underlying filesystem whether the
	// virtual disk backing file should be scrubbed completely at
	// this time.
	//
	// Virtual disks on some filesystems like VMFS3 are zeroed-out
	// lazily so that disk creation time doesn't take too long.
	// However, clustering applications and features like
	// Fault Tolerance require that the virtual disk be
	// completely scrubbed. This setting allows controlling the
	// scrubbing policy on a per-disk basis.
	//
	// If this flag is unset or set to false when creating a new disk,
	// the disk scrubbing policy will be decided by the filesystem. If
	// this flag is unset or set to false when editing an existing disk,
	// it is ignored.
	//
	// When returned as part of a VirtualMachineConfigInfo, this
	// property may be unset if its value is unknown.
	//
	// Since vSphere API 4.0
	EagerlyScrub bool

	// The parent of this virtual disk file, if this is a delta disk backing.
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time.  A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent).  After a delta
	// disk backing is added, all writes go to the delta disk backing.  All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine creation and
	// reconfiguration this property is
	// only checked if the VirtualDeviceConfigSpec specifies
	// an add operation with a
	// create file operation.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing.  Only the fileName
	// property is important; all other properties will be ignored.  The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// deltaDiskBackingsSupported
	// is true.
	//
	// Since vSphere API 4.0
	Parent *VirtualDiskFlatVer2BackingInfo

	// Flag to indicate the type of virtual disk file: split or monolithic.
	// If true, the virtual disk is stored in multiple files, each 2GB.
	//
	// On ESX this property is ignored when creating new disks or
	// editing existing disks. This property is always false for disks
	// created on ESX.
	//
	// When an existing split disk such as those created by VMware
	// Server is added to a virtual machine on ESX, the property will
	// be set to true when retrieved from VirtualMachineConfigInfo.
	Split bool

	// Flag to indicate to the underlying filesystem, whether the
	// virtual disk backing file should be allocated lazily (using
	// thin provisioning). This flag is only used for file systems
	// that support configuring the provisioning policy on a per file
	// basis, such as VMFS3.See perFileThinProvisioningSupported
	ThinProvisioned bool

	// Disk UUID for the virtual disk, if available.
	//
	// Since VI API 2.5
	Uuid string

	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough bool
}

//
// This data object type contains the available options when backing a virtual
// disk using a host file with the flat file format used in VMware Server and
// in ESX Server 2.x and greater.
// Flat disks are pre-allocated, whereas sparse disks are grown as needed.
//
//
type VirtualDiskFlatVer2BackingOption struct {
	*VirtualDeviceFileBackingOption

	// Deprecated.
	// As of vSphere API 5.1, please use
	// deltaDiskFormatsSupported.
	//
	//
	// Delta disk formats supported. Valid values are:
	//
	// redoLogFormat
	// nativeFormat
	//
	//
	//
	// Since vSphere API 5.0
	DeltaDiskFormat *ChoiceOption

	// Delta disk formats supported for each datastore type.
	//
	// Since vSphere API 5.1
	DeltaDiskFormatsSupported []*VirtualDiskDeltaDiskFormatsSupported

	// The disk mode. Valid disk modes are:
	//
	// persistent
	// independent_persistent
	// independent_nonpersistent
	// See VirtualDiskMode
	DiskMode *ChoiceOption

	// Flag to indicate if this backing supports eager scrubbing.
	//
	// Since vSphere API 4.0
	EagerlyScrub *BoolOption

	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation.
	//
	// If set to true, reconfiguring this virtual disk
	// with a capacityInKB value greater
	// than its current value will grow the disk to the newly specified size.
	Growable bool

	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation while
	// the virtual machine is powered on.
	//
	// If set to true, reconfiguring this virtual disk
	// with a capacityInKB value greater
	// than its current value will grow the disk to the newly specified size
	// while the virtual machine is powered on.
	//
	// Since VI API 2.5
	HotGrowable bool

	// Flag to indicate whether or not the host supports
	// allowing the client to select whether or not a disk
	// should be split.
	Split *BoolOption

	// Flag to indicate if this backing supports thin-provisioned disks.
	//
	// When creating a thin-provisioned disk (or converting an existing disk to
	// to a thin-provisioned one), both the target datastore and the
	// host accessing it must support thin-provisioning. This flag indicates only
	// the host capability. See perFileThinProvisioningSupported
	// for datastore capability.
	//
	// Since vSphere API 4.0
	ThinProvisioned *BoolOption

	// Flag to indicate whether this backing supports disk UUID property.
	//
	// Since VI API 2.5
	Uuid bool

	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks. Typically, this is available only for VMware Server Linux hosts.
	WriteThrough *BoolOption
}

//
// Identifier for a virtual disk.
//
//
//
//
type VirtualDiskId struct {
	*DynamicData

	// Device ID key of the virtual disk.
	DiskId int32

	// Virtual machine reference.
	Vm *VirtualMachine
}

//
// This managed object type provides a way to manage and manipulate virtual disks
// on datastores. The source and the destination names are in the form of
// a URL or a datastore path.
//
// A URL has the form
//
// scheme://authority/folder/path?dcPath=dcPath&amp;dsName=dsName
// where
// • scheme is http or https.
//
// • authority specifies the hostname or IP address of the VirtualCenter or
// ESX server and optionally the port.
//
// • dcPath is the inventory path to the Datacenter containing the
// Datastore.
//
// • dsName is the name of the Datastore.
//
// • path is a slash-delimited path from the root of the datastore.
//
//
// A datastore path has the form
// [datastore] path
// where
// • datastore is the datastore name.
//
// • path is a slash-delimited path from the root of the datastore.
//
// An example datastore path is "[storage] path/to/file.extension".
// A listing of all the files, disks and folders on
// a datastore can be obtained from the datastore browser.See HostDatastoreBrowser
//
type VirtualDiskManager struct {
	*ManagedObject
}

//
// Copy a virtual disk, performing conversions as specified in the spec.
//
// If source (or destination) name is specified as a URL, then the
// corresponding datacenter parameter may be omitted.
//
//
// If source and destination resolve to the same file system location,
// the call has no effect, regardless of destSpec content.
//
//
// Requires Datastore.FileManagement privilege on both source and destination
// datastores.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) CopyVirtualDisk_Task(
	_this *ManagedObjectReference, sourceName string, sourceDatacenter *Datacenter, destName string, destDatacenter *Datacenter, destSpec *VirtualDiskSpec, force bool,
) (*Task, error) {

	return nil, nil

}

//
// Create a virtual disk.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk is created.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) CreateVirtualDisk_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter, spec *VirtualDiskSpec,
) (*Task, error) {

	return nil, nil

}

//
// Defragment a sparse virtual disk.
// This is defragmentation of the virtual disk file(s) in the host operating
// system, not defragmentation of the guest operating system filesystem inside
// the virtual disk.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) DefragmentVirtualDisk_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (*Task, error) {

	return nil, nil

}

//
// Delete a virtual disk.  All files relating to the disk
// will be deleted.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk is removed.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) DeleteVirtualDisk_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (*Task, error) {

	return nil, nil

}

//
// Explicitly zero out unaccessed parts zeroedthick disk.
// Effectively a no-op if the disk is already eagerZeroedThick.
// Unlike zeroFillVirtualDisk, which wipes the entire disk, this
// operation only affects previously unaccessed parts of the disk.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
// Since
// vSphere API 4.0
//
func (mo *VirtualDiskManager) EagerZeroVirtualDisk_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (*Task, error) {

	return nil, nil

}

//
// Expand the capacity of a virtual disk to the new capacity.
//
// If the eagerZero flag is not specified,
// - the extended disk region of a zerothick disk will be zeroedthick
// - the extended disk region of a eagerzerothick disk will be eagerzeroedthick
// - a thin-provisioned disk will always be extended as a thin-provisioned disk.
//
// If the eagerZero flag TRUE, the extended region of the disk will
// always be eagerly zeroed.
//
// If the eagerZero flag FALSE, the extended region of a zeroedthick or
// eagerzeroedthick the disk will not be eagerly zeroed. This condition has
// no effect on a thin source disk.
//
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) ExtendVirtualDisk_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter, newCapacityKb int64, eagerZero bool,
) (*Task, error) {

	return nil, nil

}

//
// Inflate a sparse or thin-provisioned virtual disk up to the full size.
// Additional space allocated to the disk as a result of this operation
// will be filled with zeroes.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) InflateVirtualDisk_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (*Task, error) {

	return nil, nil

}

//
// Move a virtual disk and all related files from the source location specified
// by sourceName and sourceDatacenter to the destination
// location specified by destName and destDatacenter.
//
// If source (or destination) name is specified as a URL, then the
// corresponding datacenter parameter may be omitted.
//
//
// If source and destination resolve to the same file system location,
// the call has no effect.
//
//
// Requires Datastore.FileManagement privilege on both source and destination
// datastores.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) MoveVirtualDisk_Task(
	_this *ManagedObjectReference, sourceName string, sourceDatacenter *Datacenter, destName string, destDatacenter *Datacenter, force bool, profile []*VirtualMachineProfileSpec,
) (*Task, error) {

	return nil, nil

}

//
// Return the percentage of fragmentation of the sparse virtual disk.
// This is the fragmentation of virtual disk file(s) in the host operating
// system, not the fragmentation of the guest operating systemS filesystem
// inside the virtual disk.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) QueryVirtualDiskFragmentation(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (int32, error) {

	return int32(0), nil

}

//
// Get the disk geometry information for the virtual disk.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) QueryVirtualDiskGeometry(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (*HostDiskDimensionsChs, error) {

	return nil, nil

}

//
// Get the virtual disk SCSI inquiry page 0x83 data.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) QueryVirtualDiskUuid(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (string, error) {

	return "", nil

}

//
// Set the virtual disk SCSI inquiry page 0x83 data.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) SetVirtualDiskUuid(
	_this *ManagedObjectReference, name string, datacenter *Datacenter, uuid string,
) error {

	return nil

}

//
// Shrink a sparse virtual disk.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// The optional parameter copy specifies whether to shrink the
// disk in copy-shrink mode or in-place mode. In copy-shrink mode,
// additional space is required, but will result in a shrunk disk that is
// also defragmented. In-place shrink does not require additional space,
// but will increase fragmentation. The default behavior is to perform
// copy-shrink if the parameter is not specified.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) ShrinkVirtualDisk_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter, copy bool,
) (*Task, error) {

	return nil, nil

}

//
// Overwrite all blocks of the virtual disk with zeros.
// All data will be lost.
//
// The datacenter parameter may be omitted if a URL is used to name the disk.
//
//
// Requires Datastore.FileManagement privilege on the datastore where the
// virtual disk resides.
//
//
//
//
// Required Privileges
// System.View
//
func (mo *VirtualDiskManager) ZeroFillVirtualDisk_Task(
	_this *ManagedObjectReference, name string, datacenter *Datacenter,
) (*Task, error) {

	return nil, nil

}

//
// The list of known disk modes.
//
// The list of supported disk modes varies by the backing type. The "persistent"
// mode is supported by every backing type.
//
//
//
type VirtualDiskMode struct {
}

//
// The disk mode of the specified virtual disk is not supported.
//
// Typically, this fault is returned as part of a parent fault like
// VmConfigIncompatibleForFaultTolerance, indicating that the
// virtual disk's mode needs to be changed before fault tolerance can be
// enabled on the associated virtual machine.
//
//
//
//
type VirtualDiskModeNotSupported struct {
	*DeviceNotSupported

	// Disk mode that is not supported
	Mode string
}

//
// The VirtualDiskOption data class contains the options for the
// virtual disk data object type.
//
//
type VirtualDiskOption struct {
	*VirtualDeviceOption

	// Minimum, maximum, and default capacity of the disk.
	CapacityInKB *LongOption

	// Minumum, maximum, and default values for Storage I/O allocation.See StorageIOAllocationInfo
	//
	// Since vSphere API 4.1
	IoAllocationOption *StorageIOAllocationOption

	// vFlash cache configuration on the disk
	//
	// Since vSphere API 5.5
	VFlashCacheConfigOption *VirtualDiskOptionVFlashCacheConfigOption
}

//
// Options for vFlash cache configuration.
//
//
type VirtualDiskOptionVFlashCacheConfigOption struct {
	*DynamicData

	// Cache block size
	BlockSizeInKB *LongOption

	// Cache data consistency type.
	// See VirtualDiskVFlashCacheConfigInfoCacheConsistencyType
	CacheConsistencyType *ChoiceOption

	// Cache mode
	// See VirtualDiskVFlashCacheConfigInfoCacheMode
	CacheMode *ChoiceOption

	// Cache reservation
	ReservationInMB *LongOption
}

//
// This data object type contains information about backing a virtual disk
// using one or more partitions on a physical disk device. This type of
// backing is supported for VMware Server.
//
//
type VirtualDiskPartitionedRawDiskVer2BackingInfo struct {
	*VirtualDiskRawDiskVer2BackingInfo

	// Array of partition indexes. This array identifies the
	// partitions that are used on the physical disk drive.
	Partition []int32
}

//
// The VirtualDiskOption.PartitionedRawDiskVer2BackingOption object
// type contains the available options when backing a virtual disk
// using one or more partitions on a physical disk device. This
// backing is supported in VMware Server.
//
//
type VirtualDiskPartitionedRawDiskVer2BackingOption struct {
	*VirtualDiskRawDiskVer2BackingOption
}

//
// This data object type contains information about backing a virtual disk using a
// raw device mapping. Supported for ESX Server 2.5 and 3.x.
//
//
type VirtualDiskRawDiskMappingVer1BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine. This can be used to track
	// incremental changes to a virtual disk. See
	// QueryChangedDiskAreas.
	//
	// Since vSphere API 4.0
	ChangeId string

	// The compatibility mode of the raw disk mapping (RDM). This must be specified
	// when a new virtual disk with an RDM backing is created. On subsequent virtual
	// machine reconfigurations, this property should be handled as follows,
	// depending on the version of the host:
	//
	// On ESX Server 2.5, the compatibility mode of an RDM backing is a
	// characteristic of the virtual machine's configuration. When reconfiguring
	// a virtual machine that currently uses a virtual disk backed by an RDM,
	// the compatibility mode of that backing may be modified. When reconfiguring a
	// virtual machine to add an existing virtual disk backed by an RDM, the
	// compatibility mode of that backing may be specified. If left unspecified it
	// defaults to "physicalMode".
	//
	// On ESX Server 3.x, the compatibility mode of an RDM backing is a
	// characteristic of the RDM itself. Once the RDM is created, its compatibility
	// mode cannot be changed by reconfiguring the virtual machine. When
	// reconfiguring a virtual machine to add an existing virtual disk backed by an
	// RDM, the compatibility mode of that backing must be left unspecified.
	// See VirtualDiskCompatibilityMode
	CompatibilityMode string

	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	//
	// Since vSphere API 4.0
	ContentId string

	// The host-specific device the LUN is being accessed through. If the
	// target LUN is not available on the host then it is empty. For example, this
	// could happen if it has accidentally been masked out.
	DeviceName string

	// The disk mode. Valid values are:
	//
	// persistent
	// independent_persistent
	// independent_nonpersistent
	// nonpersistent
	// undoable
	// append
	//
	//
	// Disk modes are only supported when the raw disk mapping is using virtual
	// compatibility mode.See VirtualDiskMode
	DiskMode string

	// Unique identifier of the LUN accessed by the raw disk mapping.
	LunUuid string

	// The parent of this virtual disk file, if this is a delta disk backing.
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time.  A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent).  After a delta
	// disk backing is added, all writes go to the delta disk backing.  All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine creation and
	// reconfiguration this property is
	// only checked if the VirtualDeviceConfigSpec specifies
	// an add operation with a
	// create file operation.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing.  Only the fileName
	// property is important; all other properties will be ignored.  The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// Only raw disk mappings in virtual compatibility mode can have parents.
	//
	// This property may only be set if
	// deltaDiskBackingsSupported
	// is true.
	//
	// Since vSphere API 4.0
	Parent *VirtualDiskRawDiskMappingVer1BackingInfo

	// Disk UUID for the virtual disk, if available. Disk UUID is not available if
	// the raw disk mapping is in physical compatibility mode.
	//
	// Since VI API 2.5
	Uuid string
}

//
// The VirtualDiskOption.RawDiskMappingVer1BackingOption object type
// contains the available options when backing a virtual disk using
// a raw device mapping on ESX Server 2.5 or 3.x.
//
//
type VirtualDiskRawDiskMappingVer1BackingOption struct {
	*VirtualDeviceDeviceBackingOption

	// The supported raw disk mapping compatibility modes.See VirtualDiskCompatibilityMode
	CompatibilityMode *ChoiceOption

	// Valid extensions for the filename of the optional
	// raw disk mapping descriptor file.
	// This is present only for ESX Server 3.x and greater hosts.
	DescriptorFileNameExtensions *ChoiceOption

	// The disk mode. Valid values are:
	//
	// persistent
	// independent_persistent
	// independent_nonpersistent
	// See VirtualDiskMode
	DiskMode *ChoiceOption

	// Flag to indicate whether this backing supports disk UUID property.
	//
	// Since VI API 2.5
	Uuid bool
}

//
// This data object type contains information about backing a virtual disk by
// using a host device, as used by VMware Server.
//
//
type VirtualDiskRawDiskVer2BackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine. This can be used to track
	// incremental changes to a virtual disk. See
	// QueryChangedDiskAreas.
	//
	// Since vSphere API 4.0
	ChangeId string

	// The name of the raw disk descriptor file.
	DescriptorFileName string

	// Disk UUID for the virtual disk, if available.
	//
	// Since VI API 2.5
	Uuid string
}

//
// The VirtualDiskOption.RawDiskVer2BackingOption object type
// contains the available options when backing a virtual disk
// using a host device on VMware Server.
//
//
type VirtualDiskRawDiskVer2BackingOption struct {
	*VirtualDeviceDeviceBackingOption

	// Valid extensions for the filename of the raw disk descriptor
	// file.
	DescriptorFileNameExtensions *ChoiceOption

	// Flag to indicate whether this backing supports disk UUID property.
	//
	// Since VI API 2.5
	Uuid bool
}

//
// Backing type for virtual disks that use the space efficient
// sparse format.
//
// Space for space efficient sparse disks is allocated on
// demand and optimizations are applied to achieve additional
// space savings. The effective space usage of such a disk can
// be obtained from VirtualMachineFileLayoutEx.
//
//
//
type VirtualDiskSeSparseBackingInfo struct {
	*VirtualDeviceFileBackingInfo

	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine. This can be used to track
	// incremental changes to a virtual disk. See QueryChangedDiskAreas.
	ChangeId string

	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	ContentId string

	// The format of the delta disk.
	//
	// This field is valid only for a delta disk.
	//
	// See DeltaDiskFormat for the
	// supported formats. If not specified, the default value used is
	// redoLogFormat.
	DeltaDiskFormat string

	// Indicates whether the disk backing has digest file enabled.
	DigestEnabled bool

	// The disk persistence mode. Valid modes are:
	//
	// persistent
	// independent_persistent
	// independent_nonpersistent
	// nonpersistent
	// undoable
	// append
	// See VirtualDiskMode
	DiskMode string

	// Specify the grain size in kB.  The default size is 1024 kB.
	GrainSize int32

	// The parent of this virtual disk file, if this is a delta disk backing.
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time.  A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent).  After a delta
	// disk backing is added, all writes go to the delta disk backing.  All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine creation and
	// reconfiguration this property is
	// only checked if the VirtualDeviceConfigSpec specifies
	// an add operation with a
	// create file operation.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing.  Only the fileName
	// property is important; all other properties will be ignored.  The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// deltaDiskBackingsSupported
	// is true.
	Parent *VirtualDiskSeSparseBackingInfo

	// Disk UUID for the virtual disk, if available.
	Uuid string

	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough bool
}

//
// Backing options for virtual disks that use the space
// efficient sparse format.
//
// Space for Flex-SE disks is allocated on demand and
// optimizations are applied to achieve additional
// space savings.
//
//
//
type VirtualDiskSeSparseBackingOption struct {
	*VirtualDeviceFileBackingOption

	// Delta disk formats supported for each datastore type.
	DeltaDiskFormatsSupported []*VirtualDiskDeltaDiskFormatsSupported

	// The disk mode. Valid disk modes are:
	//
	// persistent
	// independent_persistent
	// independent_nonpersistent
	// See VirtualDiskMode
	DiskMode *ChoiceOption

	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation.
	//
	// If set to true, reconfiguring this virtual disk
	// with a capacityInKB value greater
	// than its current value will grow the disk to the newly specified size.
	Growable bool

	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation while
	// the virtual machine is powered on.
	//
	// If set to true, reconfiguring this virtual disk
	// with a capacityInKB value greater
	// than its current value will grow the disk to the newly specified size
	// while the virtual machine is powered on.
	HotGrowable bool

	// Flag to indicate whether this backing supports disk UUID property.
	Uuid bool

	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks. Typically, this is available only for VMware Server Linux hosts.
	WriteThrough *BoolOption
}

//
// This data object type contains information about backing a virtual disk by
// using a virtual disk file on the host, in the sparse disk format used by
// GSX Server 2.x.
//
//
type VirtualDiskSparseVer1BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	//
	// Since vSphere API 4.0
	ContentId string

	// The disk persistence mode. Valid values are:
	//
	// persistent
	// nonpersistent
	// undoable
	// independent_persistent
	// independent_nonpersistent
	// append
	// See VirtualDiskMode
	DiskMode string

	// The parent of this virtual disk file, if this is a delta disk backing.
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time.  A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent).  After a delta
	// disk backing is added, all writes go to the delta disk backing.  All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine creation and
	// reconfiguration this property is
	// only checked if the VirtualDeviceConfigSpec specifies
	// an add operation with a
	// create file operation.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing.  Only the fileName
	// property is important; all other properties will be ignored.  The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// deltaDiskBackingsSupported
	// is true.
	//
	// Since vSphere API 4.0
	Parent *VirtualDiskSparseVer1BackingInfo

	// The space in use for this sparse disk. This information is provided
	// when retrieving configuration information for an existing virtual
	// machine. The client cannot modify this information using reconfigure
	// on a virtual machine.
	SpaceUsedInKB int64

	// Flag to indicate the type of virtual disk file: split or monolithic.
	// If true, the virtual disk is stored in multiple files, each 2GB.
	Split bool

	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough bool
}

//
// This data object type contains the available options when backing a virtual
// disk using a host file with the sparse file format from GSX Server 2.x.
//
//
type VirtualDiskSparseVer1BackingOption struct {
	*VirtualDeviceFileBackingOption

	// The disk mode. Valid disk modes are:
	//
	// persistent
	// nonpersistent
	// undoable
	// independent_persistent
	// independent_nonpersistent
	// append
	// See VirtualDiskMode
	DiskModes *ChoiceOption

	// Flag to indicate whether this backing can have its size changed.
	Growable bool

	// Flag to indicate whether or not the host supports
	// allowing the client to select whether or not a sparse disk
	// should be split.
	Split *BoolOption

	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks. Typically, this is available only for VMware Server Linux hosts.
	WriteThrough *BoolOption
}

//
// This data object type contains information about backing a virtual disk by
// using a virtual disk file on the host, in the sparse disk format used by
// VMware Server.
//
//
type VirtualDiskSparseVer2BackingInfo struct {
	*VirtualDeviceFileBackingInfo

	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine. This can be used to track
	// incremental changes to a virtual disk. See
	// QueryChangedDiskAreas.
	//
	// Since vSphere API 4.0
	ChangeId string

	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	//
	// Since vSphere API 4.0
	ContentId string

	// The disk persistence mode. Valid modes are:
	//
	// persistent
	// independent_persistent
	// independent_nonpersistent
	// See VirtualDiskMode
	DiskMode string

	// The parent of this virtual disk file, if this is a delta disk backing.
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time.  A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent).  After a delta
	// disk backing is added, all writes go to the delta disk backing.  All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine creation and
	// reconfiguration this property is
	// only checked if the VirtualDeviceConfigSpec specifies
	// an add operation with a
	// create file operation.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing.  Only the fileName
	// property is important; all other properties will be ignored.  The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// deltaDiskBackingsSupported
	// is true.
	//
	// Since vSphere API 4.0
	Parent *VirtualDiskSparseVer2BackingInfo

	// The space in use for this sparse disk. This information is provided
	// when retrieving configuration information for an exisiting virtual
	// machine. The client cannot modify this information using reconfigure
	// on a virtual machine.
	SpaceUsedInKB int64

	// Flag to indicate the type of virtual disk file: split or monolithic.
	// If true, the virtual disk is stored in multiple files, each 2GB.
	Split bool

	// Disk UUID for the virtual disk, if available.
	//
	// Since VI API 2.5
	Uuid string

	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough bool
}

//
// This data object type contains the options available when backing a virtual
// disk using a host file with the sparse file format from VMware Server.
//
//
type VirtualDiskSparseVer2BackingOption struct {
	*VirtualDeviceFileBackingOption

	// The disk mode. Valid disk modes are:
	//
	// persistent
	// nonpersistent
	// undoable
	// independent_persistent
	// independent_nonpersistent
	// append
	// See VirtualDiskMode
	DiskMode *ChoiceOption

	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation.
	//
	// If set to true, reconfiguring this virtual disk
	// with a capacityInKB value greater
	// than its current value will grow the disk to the newly specified size.
	Growable bool

	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation while
	// the virtual machine is powered on.
	//
	// If set to true, reconfiguring this virtual disk
	// with a capacityInKB value greater
	// than its current value will grow the disk to the newly specified size
	// while the virtual machine is powered on.
	//
	// Since VI API 2.5
	HotGrowable bool

	// Flag to indicate whether or not the host supports
	// allowing the client to select whether or not a sparse disk
	// should be split.
	Split *BoolOption

	// Flag to indicate whether this backing supports disk UUID property.
	//
	// Since VI API 2.5
	Uuid bool

	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks. Typically, this is available only for VMware Server Linux hosts.
	WriteThrough *BoolOption
}

//
// Specification used to create or clone a virtual disk
//
//
type VirtualDiskSpec struct {
	*DynamicData

	// The type of the virtual disk adapter for the new virtual disk.See VirtualDiskAdapterType
	AdapterType string

	// The type of the new virtual disk.See VirtualDiskType
	DiskType string
}

//
// The types of virtual disks that can be created or cloned.
//
//
type VirtualDiskType struct {
}

//
// Data object describes the vFlash cache configuration on this virtual disk.
//
//
type VirtualDiskVFlashCacheConfigInfo struct {
	*DynamicData

	// Cache block size. This parameter allows the user to control how much
	// data gets cached on a single access to the VMDK. Max block size is 1MB.
	// Default is 4KB.
	BlockSizeInKB int64

	// Cache data consistency types after a crash.
	// See VirtualDiskVFlashCacheConfigInfoCacheConsistencyType
	// for supported types. If not specified, the default value used is
	// strong
	CacheConsistencyType string

	// Cache modes.
	// See VirtualDiskVFlashCacheConfigInfoCacheMode
	// for supported modes. If not specified, the default value used is
	// write_thru.
	CacheMode string

	// Amount of vFlash resource that is guaranteed available to the cache. If not specified,
	// default reservation will be used.
	ReservationInMB int64

	// Name of vFlash module which manages the cache. If not specified, default setting
	// defaultVFlashModule
	// will be used.
	VFlashModule string
}

//
// Pre-defined constants for cache consistency types
//
//
type VirtualDiskVFlashCacheConfigInfoCacheConsistencyType struct {
}

//
// Pre-defined constants for cache modes.
//
//
type VirtualDiskVFlashCacheConfigInfoCacheMode struct {
}

//
// The VirtualE1000 data object type represents an instance
// of the E1000 virtual Ethernet adapter attached to a virtual machine.
//
//
type VirtualE1000 struct {
	*VirtualEthernetCard
}

//
// The VirtualE1000 option data object type contains the options for the
// VirtualE1000 data object type.
//
//
type VirtualE1000Option struct {
	*VirtualEthernetCardOption
}

//
// The VirtualE1000e data object type represents an instance
// of the E1000e virtual Ethernet adapter attached to a virtual machine.
//
//
type VirtualE1000e struct {
	*VirtualEthernetCard
}

//
// The VirtualE1000e option data object type contains the options for the
// VirtualE1000e data object type.
//
//
type VirtualE1000eOption struct {
	*VirtualEthernetCardOption
}

//
// The VirtualEnsoniq1371 data object type represents an Ensoniq 1371
// sound card in a virtual machine.
//
//
type VirtualEnsoniq1371 struct {
	*VirtualSoundCard
}

//
// The VirtualEnsoniq1371Option data object type contains the options for the
// virtual Ensoniq 1371 sound card.
//
//
type VirtualEnsoniq1371Option struct {
	*VirtualSoundCardOption
}

//
// The VirtualEthernetCard data object contains the properties
// of an Ethernet adapter attached to a virtual machine.
//
//
type VirtualEthernetCard struct {
	*VirtualDevice

	// MAC address type.
	//
	// Valid values for address type are:
	// ManualStatically assigned MAC address.GeneratedAutomatically generated MAC address.AssignedMAC address assigned by VirtualCenter.
	AddressType string

	// MAC address assigned to the virtual network adapter. Clients can
	// set this property to any of the allowed address types. The server might
	// override the specified value for "Generated" or "Assigned" if it does not
	// fall in the right ranges or is determined to be a duplicate.
	MacAddress string

	// Indicates whether wake-on-LAN is enabled on this virtual network adapter. Clients
	// can set this property to selectively enable or disable wake-on-LAN.
	WakeOnLanEnabled bool
}

//
// This data object type contains the options for using a distributed
// virtual port virtual network card backing data object type.
//
//
type VirtualEthernetCardDVPortBackingOption struct {
	*VirtualDeviceBackingOption
}

//
// The VirtualEthernetCardDistributedVirtualPortBackingInfo
// data object defines backing for a virtual Ethernet card that connects
// to a distributed virtual switch port or portgroup.
//
//
type VirtualEthernetCardDistributedVirtualPortBackingInfo struct {
	*VirtualDeviceBackingInfo

	// DistributedVirtualPort or DistributedVirtualPortgroup
	// connection. To specify a port connection, set the
	// portKey property.
	// To specify a portgroup connection, set the
	// portgroupKey property.
	//
	// This property will be unset during Virtual Machine or template cloning
	// operation unless it's set to a DistributedVirtualSwitchPortConnection
	// object and the portgroup is a late binding portgroup.
	Port *DistributedVirtualSwitchPortConnection
}

//
// The VirtualEthernetCardLegacyNetworkBackingInfo data object
// provides legacy backing for a virtual Ethernet card.
//
//
type VirtualEthernetCardLegacyNetworkBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

//
// This data object type contains the options
// for using a legacy virtual network card backing data object type.
//
//
type VirtualEthernetCardLegacyNetworkBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// Possible device names for legacy network backing option are listed below.
// Note: This is not an exhaustive list. It is possible to specify
// a specific device as well.
// For example, on ESX hosts, the device name could be specified as "vmnic[0-9]"
// or vmnet_[0-9].
// For VMware Server Windows hosts, the device name could be specified as "vmnet[0-9]"
// and for VMware Server Linux hosts, the device name could be specified as "/dev/vmnet[0-9]"
// depending on what devices are available on that particular host.
//
//
type VirtualEthernetCardLegacyNetworkDeviceName struct {
}

//
// The enumeration of all known valid MAC address types.
//
//
type VirtualEthernetCardMacType struct {
}

//
// The VirtualEthernetCardNetworkBackingInfo data object
// defines network backing for a virtual Ethernet card.
//
//
type VirtualEthernetCardNetworkBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	// Deprecated.
	// As of vSphere API 4.0, this property is not supported.
	//
	//
	//
	//
	//
	// Since vSphere API 4.0
	InPassthroughMode bool

	// Reference to the network managed object to which this backing applies.
	// This is not used during configuration.
	Network *Network
}

//
// This data object type contains the options for
// the virtual network card backing data object type.
//
//
type VirtualEthernetCardNetworkBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The virtual machine's virtual ethernet card is not supported.
//
//
type VirtualEthernetCardNotSupported struct {
	*DeviceNotSupported
}

//
// This class defines backing for a virtual Ethernet card that connects
// to an opaque network.
//
//
type VirtualEthernetCardOpaqueNetworkBackingInfo struct {
	*VirtualDeviceBackingInfo

	// The opaque network ID
	OpaqueNetworkId string

	// The opaque network type
	OpaqueNetworkType string
}

//
// This data object type contains the options for
// the virtual network card backing data object type.
//
//
type VirtualEthernetCardOpaqueNetworkBackingOption struct {
	*VirtualDeviceBackingOption
}

//
// This data object type contains the options for the
// virtual ethernet card data object type.
//
//
type VirtualEthernetCardOption struct {
	*VirtualDeviceOption

	// The supported MAC address types.
	MacType *ChoiceOption

	// The valid Organizational Unique Identifiers (OUIs)
	// supported by this virtual Ethernet card.
	// Supported OUIs for statically assigned MAC addresses:"00:50:56"
	SupportedOUI *ChoiceOption

	// Flag to indicate whether VMDirectPath Gen 2 is available on this device.
	//
	// Since vSphere API 4.1
	VmDirectPathGen2Supported bool

	// Flag to indicate whether or not wake-on-LAN is settable on this device.
	WakeOnLanEnabled *BoolOption
}

//
// The VirtualFloppy data object type contains information about a floppy drive
// in a virtual machine.
//
//
type VirtualFloppy struct {
	*VirtualDevice
}

//
// The data object type for device backing of a virtual floppy drive.
//
//
type VirtualFloppyDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

//
// The DeviceBackingOption data object type contains the options
// for the floppy device backing type.
//
//
type VirtualFloppyDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The data object type for file image backing of a virtual floppy drive.
//
//
type VirtualFloppyImageBackingInfo struct {
	*VirtualDeviceFileBackingInfo
}

//
// The ImageBackingOption data object type contains the options
// for the floppy image backing type.
//
//
type VirtualFloppyImageBackingOption struct {
	*VirtualDeviceFileBackingOption
}

//
// The VirtualFloppyOption data class contains the options for the
// virtual floppy data object type.
//
//
type VirtualFloppyOption struct {
	*VirtualDeviceOption
}

//
// The data object type for remote device backing of a virtual floppy drive.
//
//
type VirtualFloppyRemoteDeviceBackingInfo struct {
	*VirtualDeviceRemoteDeviceBackingInfo
}

//
// The RemoteDeviceBackingOption data object type contains the options
// for the floppy remote device backing type.
//
//
type VirtualFloppyRemoteDeviceBackingOption struct {
	*VirtualDeviceRemoteDeviceBackingOption
}

//
// The VirtualHardware data object type contains the complete configuration
// of the hardware in a virtual machine.
//
//
type VirtualHardware struct {
	*DynamicData

	// The set of virtual devices belonging to the virtual machine.
	// This list is unordered.
	Device []*VirtualDevice

	// Memory size, in MB.
	MemoryMB int32

	// Number of cores used to distribute virtual CPUs among sockets
	// in this virtual machine.
	// If the value is unset it implies to numCoresPerSocket = 1.
	//
	// Since vSphere API 5.0
	NumCoresPerSocket int32

	// Number of virtual CPUs present in this virtual machine.
	NumCPU int32

	// Does this virtual machine have Virtual Intel I/O Controller Hub 7
	//
	// Since vSphere API 5.0
	VirtualICH7MPresent bool

	// Does this virtual machine have System Management Controller
	//
	// Since vSphere API 5.0
	VirtualSMCPresent bool
}

//
// There is a problem with the compatibility between the intended execution host
// and the virtual machine. This may be an error or warning depending on
// the specific fault subclass.
//
//
type VirtualHardwareCompatibilityIssue struct {
	*VmConfigFault
}

//
// The VirtualHardwareOption data object contains the options available
// for all virtual devices.
//
//
type VirtualHardwareOption struct {
	*DynamicData

	// Whether the set of virtual devices can be changed, e.g., can devices
	// be added or removed. This does not preclude changing devices.
	DeviceListReadonly bool

	// The virtual hardware version.
	HwVersion int32

	// List of propery names which limits are given be a licensing
	// restriction of the underlying product, e.g., a limit that is
	// not derived based on the product or hardware features.
	// For example, the property name "numCPU"
	LicensingLimit []string

	// The minimum, maximum, and default memory options, in MB, per virtual machine,
	// for this VirtualHardwareOption. These
	// values are typically overruled by the supported and recommended
	// values specified in the GuestOsDescriptor class.
	MemoryMB *LongOption

	// The minimum, maximum and default number of cores per socket that
	// can be used when distributing virtual CPUs.
	//
	// Since vSphere API 5.0
	NumCoresPerSocket *IntOption

	// List of acceptable values for the number of CPUs supported by this
	// ConfigOption.
	// This is usually superceded by the information available in the
	// guest operating system descriptors.
	// The guest operating system descriptor describes a maximum CPU
	// count, but the acceptable values are still constrained to the
	// set specified here. The default value is stored at index 0 in the list.
	NumCPU []int32

	// Can the number of virtual CPUs be changed
	NumCpuReadonly bool

	// The minimum, maximum, and default number of IDE controllers for
	// this virtual machine configuration. Note: SCSI controllers sit
	// on the PCI controller so their options (minimum, maximum, and default values)
	// are contained inside the
	// VirtualPCIControllerOption
	// class.
	NumIDEControllers *IntOption

	// The minimum, maximum, and default number of PCI controllers for
	// this virtual machine configuration.
	NumPCIControllers *IntOption

	// The minimum, maximum, and default number of PS2 controllers for
	// this virtual machine configuration.
	NumPS2Controllers *IntOption

	// The minimum, maximum, and default number of SIO controllers for
	// this virtual machine configuration.
	NumSIOControllers *IntOption

	// The minimum, maximum and default number of NPIV WorldWidePort names
	// supported for this virtual machine configuration.
	//
	// Since vSphere API 4.0
	NumSupportedWwnNodes *IntOption

	// The minimum, maximum and default number of NPIV WorldWideNode names
	// supported for this virtual machine configuration.
	//
	// Since vSphere API 4.0
	NumSupportedWwnPorts *IntOption

	// The minimum, maximum, and default number of USB controllers for
	// this virtual machine configuration.
	NumUSBControllers *IntOption

	// The minimum, maximum, and default number of XHCI (USB 3.0) controllers for
	// this virtual machine configuration.
	//
	// Since vSphere API 5.0
	NumUSBXHCIControllers *IntOption

	// Default value and value range for ResourceConfigOption
	//
	// Since vSphere API 4.1
	ResourceConfigOption *ResourceConfigOption

	// Array of virtual device options valid for this virtual
	// machine configuration. The list is unordered.
	VirtualDeviceOption []*VirtualDeviceOption
}

//
// The virtual machine's virtual hardware version is not supported on the host.
//
//
type VirtualHardwareVersionNotSupported struct {
	*VirtualHardwareCompatibilityIssue

	// The host.
	//
	// Since VI API 2.5
	Host *HostSystem

	// Since VI API 2.5
	HostName string
}

//
// The VirtualHdAudioCard data object type represents a HD Audio
// sound card in a virtual machine.
//
//
type VirtualHdAudioCard struct {
	*VirtualSoundCard
}

//
// The VirtualHdAudioCardOption data object type contains the options for a
// virtual HD Audio sound card.
//
//
type VirtualHdAudioCardOption struct {
	*VirtualSoundCardOption
}

//
// The VirtualIDEController data object type specifies a virtual IDE controller.
//
//
type VirtualIDEController struct {
	*VirtualController
}

//
// The VirtualIDEControllerOption data object type contains the options
// for a virtual IDE controller.
//
//
type VirtualIDEControllerOption struct {
	*VirtualControllerOption

	// The minimum, maximum, and default number of IDE VirtualCdrom instances you can
	// have, at any given time, in the IDE controller. The number is further constrained
	// by the number of available slots in the virtual IDE controller.
	NumIDECdroms *IntOption

	// The minimum, maximum, and default number of IDE VirtualDisk instances you can
	// have, at any given time, in the IDE controller. The number is further constrained
	// by the number of available slots in the virtual IDE controller.
	NumIDEDisks *IntOption
}

//
// This data object type contains information about
// the keyboard on a virtual machine.
//
//
type VirtualKeyboard struct {
	*VirtualDevice
}

//
// The VirtualKeyboardOption data object type contains the options for the
// virtual keyboard class.
//
//
type VirtualKeyboardOption struct {
	*VirtualDeviceOption
}

//
// VirtualLsiLogicController is the data object that represents
// a LSI Logic SCSI controller.
//
//
type VirtualLsiLogicController struct {
	*VirtualSCSIController
}

//
// VirtualLsiLogicControllerOption is the data object that contains
// the options for a LSI Logic SCSI controller.
//
//
type VirtualLsiLogicControllerOption struct {
	*VirtualSCSIControllerOption
}

//
// VirtualLsiLogicSASController is the data object that represents
// a LSI Logic SAS SCSI controller.
//
//
type VirtualLsiLogicSASController struct {
	*VirtualSCSIController
}

//
// VirtualLsiLogicSASControllerOption is the data object that contains
// the options for a LSI Logic SAS SCSI controller.
//
//
type VirtualLsiLogicSASControllerOption struct {
	*VirtualSCSIControllerOption
}

//
// VirtualMachine is the managed object type for manipulating virtual machines,
// including templates that can be deployed (repeatedly) as new virtual machines.
// This type provides methods for configuring and controlling a virtual machine.
//
// VirtualMachine extends the ManagedEntity type because virtual machines are
// part of a virtual infrastructure inventory. The parent of a virtual machine
// must be a folder, and a virtual machine has no children.
//
//
// Destroying a virtual machine disposes of all associated storage, including
// the virtual disks. To remove a virtual machine while retaining its
// virtual disk storage, a client must remove the virtual disks
// from the virtual machine before destroying it.
//
//
//
type VirtualMachine struct {
	*ManagedEntity

	capability *VirtualMachineCapability

	config *VirtualMachineConfigInfo

	datastore []*Datastore

	environmentBrowser *EnvironmentBrowser

	guest *GuestInfo

	guestHeartbeatStatus *enum.ManagedEntityStatus

	layout *VirtualMachineFileLayout

	layoutEx *VirtualMachineFileLayoutEx

	network []*Network

	parentVApp *ManagedEntity

	resourceConfig *ResourceConfigSpec

	resourcePool *ResourcePool

	rootSnapshot []*VirtualMachineSnapshot

	runtime *VirtualMachineRuntimeInfo

	snapshot *VirtualMachineSnapshotInfo

	storage *VirtualMachineStorageInfo

	summary *VirtualMachineSummary
}

// Information about the runtime capabilities of this virtual machine.
func (mo *VirtualMachine) Capability() (*VirtualMachineCapability, error) {
	t, err := mo.currentProperty("capability")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineCapability)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineCapability")
	}
	return v, nil
}

// Configuration of this virtual machine, including the name and UUID.
//
// This property is set when a virtual machine is created or when
// the reconfigVM method is called.
//
// The virtual machine configuration is not guaranteed to be available.
// For example, the configuration information would be unavailable
// if the server is unable to access the virtual machine files on disk,
// and is often also unavailable during the initial phases of
// virtual machine creation.
func (mo *VirtualMachine) Config() (*VirtualMachineConfigInfo, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineConfigInfo")
	}
	return v, nil
}

// A collection of references to the subset of datastore objects in the datacenter
// that is used by this virtual machine.
// Required Privilege: System.View
func (mo *VirtualMachine) Datastore() ([]*Datastore, error) {
	t, err := mo.currentProperty("datastore")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Datastore)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Datastore")
	}
	return v, nil
}

// The current virtual machine's environment browser object. This contains
// information on all the configurations that can be used on the
// virtual machine. This is identical to the environment browser on
// the ComputeResource to which this virtual machine belongs.
func (mo *VirtualMachine) EnvironmentBrowser() (*EnvironmentBrowser, error) {
	t, err := mo.currentProperty("environmentBrowser")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*EnvironmentBrowser)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *EnvironmentBrowser")
	}
	return v, nil
}

// Information about VMware Tools and about the virtual machine
// from the perspective of VMware Tools.
// Information about the guest operating system is available in VirtualCenter. Guest
// operating system information reflects the last known state of the virtual machine.
// For powered on machines, this is current information. For powered off machines,
// this is the last recorded state before the virtual machine was powered off.
func (mo *VirtualMachine) Guest() (*GuestInfo, error) {
	t, err := mo.currentProperty("guest")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*GuestInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *GuestInfo")
	}
	return v, nil
}

// The guest heartbeat.
// The heartbeat status is classified as:
//
// gray - VMware Tools are not installed or not running.
// red - No heartbeat. Guest operating system may have stopped responding.
// yellow - Intermittent heartbeat. May be due to guest load.
// green - Guest operating system is responding normally.
//
// The guest heartbeat is a statistics metric. Alarms can be configured on
// this metric to trigger emails or other actions.
func (mo *VirtualMachine) GuestHeartbeatStatus() (*ManagedEntityStatus, error) {
	t, err := mo.currentProperty("guestHeartbeatStatus")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ManagedEntityStatus)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ManagedEntityStatus")
	}
	return v, nil
}

// Deprecated.
// As of vSphere API 4.0, use layoutEx instead.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
//
//
// Detailed information about the files that comprise this virtual machine.
func (mo *VirtualMachine) Layout() (*VirtualMachineFileLayout, error) {
	t, err := mo.currentProperty("layout")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineFileLayout)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineFileLayout")
	}
	return v, nil
}

// Detailed information about the files that comprise this virtual machine.
//
// Can be explicitly refreshed by the RefreshStorageInfo operation.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
//
// Since vSphere API 4.0
func (mo *VirtualMachine) LayoutEx() (*VirtualMachineFileLayoutEx, error) {
	t, err := mo.currentProperty("layoutEx")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineFileLayoutEx)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineFileLayoutEx")
	}
	return v, nil
}

// A collection of references to the subset of network objects in the datacenter that
// is used by this virtual machine.
// Required Privilege: System.View
func (mo *VirtualMachine) Network() ([]*Network, error) {
	t, err := mo.currentProperty("network")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*Network)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*Network")
	}
	return v, nil
}

// Reference to the parent vApp.
//
// Since vSphere API 4.1
func (mo *VirtualMachine) ParentVApp() (*ManagedEntity, error) {
	t, err := mo.currentProperty("parentVApp")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ManagedEntity)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ManagedEntity")
	}
	return v, nil
}

// The resource configuration for a virtual machine. The shares
// in this specification are evaluated relative to the resource pool
// to which it is assigned. This will return null if the product
// the virtual machine is registered on does not support resource
// configuration.
//
// To retrieve the configuration, you typically use
// childConfiguration.
//
// To change the configuration, use
// UpdateChildResourceConfiguration.
func (mo *VirtualMachine) ResourceConfig() (*ResourceConfigSpec, error) {
	t, err := mo.currentProperty("resourceConfig")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ResourceConfigSpec)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ResourceConfigSpec")
	}
	return v, nil
}

// The current resource pool that specifies resource allocation
// for this virtual machine.
//
// This property is set when a virtual machine is created or associated with
// a different resource pool.
//
// Returns null if the virtual machine is a template or the session has no access
// to the resource pool.
func (mo *VirtualMachine) ResourcePool() (*ResourcePool, error) {
	t, err := mo.currentProperty("resourcePool")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*ResourcePool)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *ResourcePool")
	}
	return v, nil
}

// The roots of all snapshot trees for the virtual machine.
//
// Since vSphere API 4.1
func (mo *VirtualMachine) RootSnapshot() ([]*VirtualMachineSnapshot, error) {
	t, err := mo.currentProperty("rootSnapshot")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*VirtualMachineSnapshot)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*VirtualMachineSnapshot")
	}
	return v, nil
}

// Execution state and history for this virtual machine.
//
// The contents of this property change when:
//
// the virtual machine's power state changes.
// an execution message is pending.
// an event occurs.
func (mo *VirtualMachine) Runtime() (*VirtualMachineRuntimeInfo, error) {
	t, err := mo.currentProperty("runtime")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineRuntimeInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineRuntimeInfo")
	}
	return v, nil
}

// Current snapshot and tree.
// The property is valid if snapshots have been created
// for this virtual machine.
//
// The contents of this property change in response to the methods:
//
// CreateSnapshot_Task
// RevertToCurrentSnapshot_Task
// RemoveSnapshot_Task
// RevertToSnapshot_Task
// RemoveAllSnapshots_Task
func (mo *VirtualMachine) Snapshot() (*VirtualMachineSnapshotInfo, error) {
	t, err := mo.currentProperty("snapshot")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineSnapshotInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineSnapshotInfo")
	}
	return v, nil
}

// Storage space used by the virtual machine, split by datastore.
// Can be explicitly refreshed by the RefreshStorageInfo operation.
//
// In releases after vSphere API 5.0, vSphere Servers might not
// generate property collector update notifications for this property.
// To obtain the latest value of the property, you can use
// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
// If you use the PropertyCollector.WaitForUpdatesEx method, specify
// an empty string for the version parameter. Any other version value will not
// produce any property values as no updates are generated.
//
// Since vSphere API 4.0
func (mo *VirtualMachine) Storage() (*VirtualMachineStorageInfo, error) {
	t, err := mo.currentProperty("storage")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineStorageInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineStorageInfo")
	}
	return v, nil
}

// Basic information about this virtual machine. This includes:
//
// runtimeInfo
// guest
// basic configuration
// alarms
// performance information
func (mo *VirtualMachine) Summary() (*VirtualMachineSummary, error) {
	t, err := mo.currentProperty("summary")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineSummary)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineSummary")
	}
	return v, nil
}

// Deprecated.
// As of vSphere API 4.1, use AcquireTicket instead.
//
//
// Creates and returns a one-time credential used in establishing a
// remote mouse-keyboard-screen connection to this virtual
// machine.
//
// The correct function of this method depends on being able to
// retrieve TCP binding information about the server end of the
// client connection that is requesting the ticket. If such
// information is not available, the NotSupported fault is thrown.
// This method is appropriate for SOAP and authenticated connections,
// which are both TCP-based connections.
//
// Required Privileges
// VirtualMachine.Interact.ConsoleInteract
//
func (mo *VirtualMachine) AcquireMksTicket(
	_this *ManagedObjectReference,
) (*VirtualMachineMksTicket, error) {

	return nil, nil

}

//
// Creates and returns a one-time credential used in establishing a
// specific connection to this virtual machine, for example, a ticket
// type of mks can be used to establish a remote mouse-keyboard-screen
// connection.
//
// A client using this ticketing mechanism must have network
// connectivity to the ESX server where the virtual machine is running,
// and the ESX server must be reachable to the management client from
// the address made available to the client via the ticket.
//
//
// Acquiring a virtual machine ticket requires different privileges
// depending on the types of ticket:
//
//
//
// • VirtualMachine.Interact.DeviceConnection if requesting a device
// ticket.
//
// • VirtualMachine.Interact.GuestControl if requesting a guestControl
// ticket.
//
// • VirtualMachine.Interact.ConsoleInteract if requesting an mks
// ticket.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
// Since
// vSphere API 4.1
//
func (mo *VirtualMachine) AcquireTicket(
	_this *ManagedObjectReference, ticketType string,
) (*VirtualMachineTicket, error) {

	return nil, nil

}

//
// Responds to a question that is blocking this virtual machine.
//
// Required Privileges
// VirtualMachine.Interact.AnswerQuestion
//
func (mo *VirtualMachine) AnswerVM(
	_this *ManagedObjectReference, questionId string, answerChoice string,
) error {

	return nil

}

//
// Checks the customization specification against the virtual machine configuration.
// For example, this is used on a source virtual machine before a clone operation to
// catch customization failure before the disk copy. This checks the specification's
// internal consistency as well as for compatibility with this virtual machine's
// configuration.
//
// Required Privileges
// VirtualMachine.Provisioning.Customize
//
func (mo *VirtualMachine) CheckCustomizationSpec(
	_this *ManagedObjectReference, spec *CustomizationSpec,
) error {

	return nil

}

//
// Creates a clone of this virtual machine. If the virtual machine
// is used as a template, this method corresponds to the deploy command.
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
// The privilege required on the source virtual machine depends on the source
// and destination types:
//
//
//
// •  source is virtual machine, destination is virtual machine -
// VirtualMachine.Provisioning.Clone
//
// •  source is virtual machine, destination is template -
// VirtualMachine.Provisioning.CreateTemplateFromVM
//
// •  source is template, destination is virtual machine -
// VirtualMachine.Provisioning.DeployTemplate
//
// •  source is template, destination is template -
// VirtualMachine.Provisioning.CloneTemplate
//
//
//
// If customization is requested in the CloneSpec, then the
// VirtualMachine.Provisioning.Customize privilege must also be
// held on the source virtual machine.
//
// The Resource.AssignVMToPool privilege is also required for the
// resource pool specified in the CloneSpec, if the destination is not a
// template.
// The Datastore.AllocateSpace privilege is required on all datastores
// where the clone is created.
//
//
// Required Privileges
// None
//
func (mo *VirtualMachine) CloneVM_Task(
	_this *ManagedObjectReference, folder *Folder, name string, spec *VirtualMachineCloneSpec,
) (*Task, error) {

	return nil, nil

}

//
// Consolidate the virtual disk files of the virtual machine by finding hierarchies
// of redo logs that can be combined without violating data dependency. The
// redundant redo logs after merging are then deleted.
//
// Consolidation improves I/O performance since less number of virtual disk
// files need to be traversed; it also reduces the storage usage. However
// additional space is temporarily required to perform the operation. Use EstimateStorageForConsolidateSnapshots_Task to estimate the
// temporary space required.
//
// Consolidation can be I/O intensive, it is advisable to invoke this operation
// when guest is not under heavy I/O usage.
//
// Required Privileges
// VirtualMachine.State.RemoveSnapshot
// Since
// vSphere API 5.0
//
func (mo *VirtualMachine) ConsolidateVMDisks_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Create a screen shot of a virtual machine.
//
// Required Privileges
// VirtualMachine.Interact.CreateScreenshot
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) CreateScreenshot_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Creates a secondary virtual machine to be part of this fault tolerant group.
//
// If a host is specified, the secondary virtual machine will be created on it.
// Otherwise, a host will be selected by the system.
//
//
// If a FaultToleranceConfigSpec is specified, the virtual machine's
// configuration files and disks will be created in the specified datastores.
//
//
// If the primary virtual machine (i.e., this virtual machine) is powered on when
// the secondary is created, an attempt will be made to power on the secondary on
// a system selected host. If the cluster is a DRS cluster, DRS will be
// invoked to obtain a placement for the new secondary virtual machine. If the DRS
// recommendation (see ClusterRecommendation)
// is automatic, it will be automatically executed. Otherwise, the recommendation will
// be returned to the caller of this method and the secondary will remain powered off
// until the recommendation is approved using ApplyRecommendation.
// Failure to power on the secondary virtual machine will not fail the creation of the secondary.
//
//
// Required Privileges
// VirtualMachine.Interact.CreateSecondary
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) CreateSecondaryVM_Task(
	_this *ManagedObjectReference, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Creates a new snapshot of this virtual machine. As a side effect,
// this updates the current snapshot.
//
// Snapshots are not supported for Fault Tolerance primary and secondary
// virtual machines.
//
//
// Any % (percent) character used in this name parameter must be escaped, unless it
// is used to start an escape sequence. Clients may also escape any other characters
// in this name parameter.
//
//
//
//
// Required Privileges
// VirtualMachine.State.CreateSnapshot
//
func (mo *VirtualMachine) CreateSnapshot_Task(
	_this *ManagedObjectReference, name string, description string, memory bool, quiesce bool,
) (*Task, error) {

	return nil, nil

}

//
// Customizes a virtual machine's guest operating system.
//
// Required Privileges
// VirtualMachine.Provisioning.Customize
//
func (mo *VirtualMachine) CustomizeVM_Task(
	_this *ManagedObjectReference, spec *CustomizationSpec,
) (*Task, error) {

	return nil, nil

}

//
// Defragment all virtual disks attached to this virtual machine.
//
// Required Privileges
// VirtualMachine.Interact.DefragmentAllDisks
// Since
// VI API 2.5
//
func (mo *VirtualMachine) DefragmentAllDisks(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Disables the specified secondary virtual machine in this fault tolerant group.
// The specified secondary will not be automatically started on a subsequent
// power-on of the primary virtual machine.
//
// This operation could leave the primary virtual machine in a non-fault
// tolerant state.
//
// Required Privileges
// VirtualMachine.Interact.DisableSecondary
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) DisableSecondaryVM_Task(
	_this *ManagedObjectReference, vm *VirtualMachine,
) (*Task, error) {

	return nil, nil

}

//
// Enables the specified secondary virtual machine in this fault tolerant group.
//
// This operation is used to enable a secondary virtual machine that was
// previously disabled by the DisableSecondaryVM_Task
// call. The specified secondary will be automatically started whenever the
// primary is powered on.
//
//
// If the primary virtual machine (i.e., this virtual machine) is powered on when
// the secondary is enabled, an attempt will be made to power on the secondary. If
// a host was specified in the method call, this host will be used. If a host is
// not specified, one will be selected by the system. In the latter case, if the cluster
// is a DRS cluster, DRS will be invoked to obtain a placement for the new secondary
// virtual machine. If the DRS recommendation (see ClusterRecommendation)
// is automatic, it will be executed. Otherwise, the recommendation will be
// returned to the caller of this method and the secondary will remain powered off
// until the recommendation is approved using ApplyRecommendation.
//
//
// Required Privileges
// VirtualMachine.Interact.EnableSecondary
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) EnableSecondaryVM_Task(
	_this *ManagedObjectReference, vm *VirtualMachine, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Estimate the temporary space required to consolidation disk
// files. The estimation is a lower bound if the childmost writable disk
// file will be consolidated for an online virtual machine, it is
// accurate for all other situations. This is because the space
// requirement depending on the size of the childmost disk file and how
// write intensive the guest is.
//
// This method can be used prior to invoke consolidation via
// ConsolidateVMDisks_Task.
//
//
// Required Privileges
// VirtualMachine.State.RemoveSnapshot
// Since
// vSphere API 5.0
//
func (mo *VirtualMachine) EstimateStorageForConsolidateSnapshots_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Obtains an export lease on this virtual machine. The export lease contains
// a list of URLs for the virtual disks for this virtual machine, as well as
// a ticket giving access to the URLs.
//
// See HttpNfcLease for information on how to use the lease.
//
//
// Required Privileges
// VApp.Export
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) ExportVm(
	_this *ManagedObjectReference,
) (*HttpNfcLease, error) {

	return nil, nil

}

//
// Returns the OVF environment for a virtual machine. If the virtual machine has no
// vApp configuration, an empty string is returned. Also, sensitive information
// is omitted, so this method is not guaranteed to return the complete OVF
// environment.
//
// Required Privileges
// VApp.ExtractOvfEnvironment
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) ExtractOvfEnvironment(
	_this *ManagedObjectReference,
) (string, error) {

	return "", nil

}

//
// Makes the specified secondary virtual machine from this fault tolerant group as
// the primary virtual machine.
//
// Required Privileges
// VirtualMachine.Interact.MakePrimary
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) MakePrimaryVM_Task(
	_this *ManagedObjectReference, vm *VirtualMachine,
) (*Task, error) {

	return nil, nil

}

//
// Marks a VirtualMachine object as being used as a template.
// Note: A VirtualMachine marked as a template cannot be powered on.
//
// Required Privileges
// VirtualMachine.Provisioning.MarkAsTemplate
//
func (mo *VirtualMachine) MarkAsTemplate(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Clears the 'isTemplate' flag and reassociates the virtual machine with
// a resource pool and host.
//
// Required Privileges
// VirtualMachine.Provisioning.MarkAsVM
//
func (mo *VirtualMachine) MarkAsVirtualMachine(
	_this *ManagedObjectReference, pool *ResourcePool, host *HostSystem,
) error {

	return nil

}

//
// Migrates a virtual machine's execution to a specific resource pool or host.
//
// Requires Resource.HotMigrate privilege if the virtual machine is powered on or
// Resource.ColdMigrate privilege if the virtual machine is powered off or
// suspended.
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *VirtualMachine) MigrateVM_Task(
	_this *ManagedObjectReference, pool *ResourcePool, host *HostSystem, priority *enum.VirtualMachineMovePriority, state *enum.VirtualMachinePowerState,
) (*Task, error) {

	return nil, nil

}

//
// Mounts the VMware Tools CD installer as a CD-ROM for the guest operating system.
// To monitor the status of the tools install, clients should check the tools status,
// toolsVersionStatus and
// toolsRunningStatus
//
// Required Privileges
// VirtualMachine.Interact.ToolsInstall
//
func (mo *VirtualMachine) MountToolsInstaller(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Powers off this virtual machine.
//
//
// If this virtual machine is a fault tolerant primary virtual machine, this
// will result in the secondary virtual machine(s) getting powered off as well.
//
// Required Privileges
// VirtualMachine.Interact.PowerOff
//
func (mo *VirtualMachine) PowerOffVM_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Powers on this virtual machine. If the virtual machine is suspended,
// this method resumes execution from the suspend point.
//
// When powering on a virtual machine in a cluster, the system might implicitly
// or due to the host argument, do an implicit relocation of the virtual machine
// to another host. Hence, errors related to this relocation can be thrown. If the
// cluster is a DRS cluster, DRS will be invoked if the virtual machine can be
// automatically placed by DRS (see DrsBehavior).
// Because this method does not return a DRS ClusterRecommendation, no
// vmotion nor host power operations will be done as part of a DRS-facilitated power
// on. To have DRS consider such operations use PowerOnMultiVM_Task.
// As of vSphere API 5.1, use of this method with vCenter Server is deprecated;
// use PowerOnMultiVM_Task instead.
//
//
// If this virtual machine is a fault tolerant primary virtual machine, its
// secondary virtual machines will be started on system-selected
// hosts. If the virtual machines are in a VMware DRS enabled cluster,
// then DRS will be invoked to obtain placements for the secondaries but
// no vmotion nor host power operations will be considered for these power ons.
//
//
// Required Privileges
// VirtualMachine.Interact.PowerOn
//
func (mo *VirtualMachine) PowerOnVM_Task(
	_this *ManagedObjectReference, host *HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// Promotes disks on this virtual machine that have delta disk backings.
//
// A delta disk backing is a way to preserve a virtual disk backing
// at some point in time.  A delta disk backing is a file backing which in
// turn points to the original virtual disk backing (the parent).  After a delta
// disk backing is added, all writes go to the delta disk backing.  All reads
// first try the delta disk backing and then try the parent backing if needed.
//
//
// Promoting does two things
//
//
// •
// If the unlink parameter is true, any disk backing which is shared
// shared by multiple virtual machines is copied so that this virtual machine
// has its own unshared version.  Copied files always end up in the virtual
// machine's home directory.
//
//
// •
// Any disk backing which is not shared between multiple virtual
// machines and is not associated with a snapshot is consolidated
// with its child backing.
//
//
//
//
// If the unlink parameter is true, the net effect of this operation is improved
// read performance, at the cost of disk space.  If the unlink parameter is
// false the net effect is improved read performance at the cost of inhibiting
// future sharing.
//
//
// This operation is only supported if
// deltaDiskBackingsSupported is true.
//
//
// This operation is only supported on VirtualCenter.
//
//
// Required Privileges
// VirtualMachine.Provisioning.PromoteDisks
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) PromoteDisks_Task(
	_this *ManagedObjectReference, unlink bool, disks []*VirtualDisk,
) (*Task, error) {

	return nil, nil

}

//
// Get a list of areas of a virtual disk belonging to this VM that have
// been modified since a well-defined point in the past. The beginning of
// the change interval is identified by "changeId", while the end of the
// change interval is implied by the snapshot ID passed in.
//
// Note that the result of this function may contain "false positives"
// (i.e: flag areas of the disk as modified that are not). However, it is
// guaranteed that no changes will be missed.
//
//
// Required Privileges
// VirtualMachine.Provisioning.DiskRandomRead
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) QueryChangedDiskAreas(
	_this *ManagedObjectReference, snapshot *VirtualMachineSnapshot, deviceKey int32, startOffset int64, changeId string,
) (*DiskChangeInfo, error) {

	return nil, nil

}

//
// This API can be invoked to determine whether a virtual machine is
// compatible for Fault Tolerance. The API only checks for VM-specific
// factors that impact compatibility for Fault Tolerance. Other
// requirements for Fault Tolerance such as host processor compatibility,
// logging nic configuration and licensing are not covered by this API.
//
// The query returns a list of faults, each fault corresponding to a
// specific incompatibility. If a given virtual machine is
// compatible for Fault Tolerance, then the fault list returned will be
// empty.
//
// Required Privileges
// VirtualMachine.Config.QueryFTCompatibility
// Since
// vSphere API 4.1
//
func (mo *VirtualMachine) QueryFaultToleranceCompatibility(
	_this *ManagedObjectReference,
) ([]*MethodFault, error) {

	return nil, nil

}

//
// For all files that belong to the vm, check that the file owner
// is set to the current datastore principal user, as set by
// HostDatastoreSystem.ConfigureDatastorePrincipal
//
// Required Privileges
// VirtualMachine.Config.QueryUnownedFiles
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) QueryUnownedFiles(
	_this *ManagedObjectReference,
) ([]string, error) {

	return nil, nil

}

//
// Issues a command to the guest operating system asking it to perform
// a reboot.
// Returns immediately and does not wait for the guest operating system
// to complete the operation.
//
// Required Privileges
// VirtualMachine.Interact.Reset
//
func (mo *VirtualMachine) RebootGuest(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Reconfigures this virtual machine. All the changes in the given configuration
// are applied to the virtual machine as an atomic operation.
//
// Reconfiguring the virtual machine may require any of the following privileges
// depending on what is being changed:
//
//
//
// • VirtualMachine.Interact.DeviceConnection if changing the runtime connection
// state of a device as embodied by the Connectable property.
//
// • VirtualMachine.Interact.SetCDMedia if changing the backing of a CD-ROM
// device
//
// • VirtualMachine.Interact.SetFloppyMedia if changing the backing of a
// floppy device
//
// • VirtualMachine.Config.Rename if renaming the virtual machine
//
// • VirtualMachine.Config.Annotation if setting annotation a value
//
// • VirtualMachine.Config.AddExistingDisk if adding a virtual disk device
// that is backed by an existing virtual disk file
//
// • VirtualMachine.Config.AddNewDisk if adding a virtual disk device for which
// the backing virtual disk file is to be created
//
// • VirtualMachine.Config.RemoveDisk if removing a virtual disk device that
// refers to a virtual disk file
//
// • VirtualMachine.Config.CPUCount if changing the number of CPUs
//
// • VirtualMachine.Config.Memory if changing the amount of memory
//
// • VirtualMachine.Config.RawDevice if adding, removing or editing a raw
// device mapping (RDM) or SCSI passthrough device
//
// • VirtualMachine.Config.AddRemoveDevice if adding or removing any
// device other than disk, raw, or USB device
//
// • VirtualMachine.Config.EditDevice if changing the settings of any
// device
//
// • VirtualMachine.Config.Settings if changing any basic settings such as
// those in ToolsConfigInfo, FlagInfo, or DefaultPowerOpInfo
//
// • VirtualMachine.Config.Resource if changing resource allocations,
// affinities, or setting network traffic shaping or virtual disk shares
//
// • VirtualMachine.Config.AdvancedConfig if changing values in
// extraConfig
//
// • VirtualMachine.Config.SwapPlacement if changing swapPlacement
//
// • VirtualMachine.Config.HostUSBDevice if adding, removing or editing a
// VirtualUSB device backed by the host USB device.
//
// • VirtualMachine.Config.DiskExtend if extending an existing VirtualDisk
// device.
//
// • VirtualMachine.Config.ChangeTracking if enabling/disabling changed
// block tracking for the virtual machine's disks.
//
// • VirtualMachine.Config.MksControl if toggling display connection
// limits or the guest auto-lock feature.
//
// • DVSwitch.CanUse if connecting a VirtualEthernetAdapter to a port
// in a DistributedVirtualSwitch.
//
// • DVPortgroup.CanUse if connecting a VirtualEthernetAdapter to a
// DistributedVirtualPortgroup.
//
//
//
// Creating a virtual machine may require the following privileges:
//
//
// • VirtualMachine.Config.RawDevice if adding a raw device
//
// • VirtualMachine.Config.AddExistingDisk if adding a VirtualDisk and
// the fileOperation is unset
//
// • VirtualMachine.Config.AddNewDisk if adding a VirtualDisk and
// the fileOperation is set
//
// • VirtualMachine.Config.HostUSBDevice if adding a VirtualUSB device
// backed by the host USB device.
//
//
//
// In addition, this operation may require the following privileges:
//
//
// • Datastore.AllocateSpace on any datastore where virtual disks will
// be created or extended.
//
// • Network.Assign on any network the virtual machine will be
// connected to.
//
//
//
//
// Required Privileges
// Dynamic - See discussion above
//
func (mo *VirtualMachine) ReconfigVM_Task(
	_this *ManagedObjectReference, spec *VirtualMachineConfigSpec,
) (*Task, error) {

	return nil, nil

}

//
// Explicitly refreshes the storage information of this virtual machine,
// updating properties storage, layoutEx
// and storage.
//
// Required Privileges
// System.Read
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) RefreshStorageInfo(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Reloads the configuration for this virtual machine from a given
// datastore path. This is equivalent to unregistering and registering the
// virtual machine from a different path. The virtual machine's hardware
// configuration, snapshots, guestinfo variables etc. will be
// replaced based on the new configuration file. Other information
// associated with the virtual machine object, such as events and
// permissions, will be preserved.
//
// This method is only supported on vCenter Server. It can be invoked on
// inaccessible or orphaned virtual machines, but it cannot be invoked on
// powered on, connected virtual machines. Both the source virtual machine
// object and the destination path should be of the same type i.e. virtual
// machine or template. Reloading a virtual machine with a template or
// vice-versa is not supported.
//
//
// Note: Since the API replaces the source configuration with that
// of the destination, if the destination configuration does not refer to a
// valid virtual machine, it will create an invalid virtual machine object.
// This API should not be invoked on fault tolerant virtual machines since
// doing so will leave the original virtual machine's configuration in an
// invalid state. It is recommended that you turn off fault tolerance before
// invoking this API.
//
//
//
//
// Required Privileges
// VirtualMachine.Config.ReloadFromPath
// Since
// vSphere API 4.1
//
func (mo *VirtualMachine) ReloadVirtualMachineFromPath_Task(
	_this *ManagedObjectReference, configurationPath string,
) (*Task, error) {

	return nil, nil

}

//
// Relocates a virtual machine's virtual disks to a specific location; optionally
// moves the virtual machine to a different host as well.
// Starting from VCenter 5.1, this API also supports relocating a template
// to a new host should the current host becomes inactive.
// If spec.host is specified, this API attempts to relocate the template
// to the specified host; otherwise, this API will select a suitable host.
//
// Additionally requires the Resource.HotMigrate privilege if the virtual machine
// is powered on (for Storage VMotion), and Datastore.AllocateSpace on any
// datastore the virtual machine or its disks are relocated to.
//
//
// If the "pool" field of the RelocateSpec is set, additionally requires the
// Resource.AssignVMToPool privilege held on the specified pool.
//
//
// Required Privileges
// Resource.ColdMigrate
//
func (mo *VirtualMachine) RelocateVM_Task(
	_this *ManagedObjectReference, spec *VirtualMachineRelocateSpec, priority *enum.VirtualMachineMovePriority,
) (*Task, error) {

	return nil, nil

}

//
// Remove all the snapshots associated with this virtual machine. If the virtual
// machine
// does not have any snapshots, then this operation simply returns successfully.
//
// Required Privileges
// VirtualMachine.State.RemoveSnapshot
//
func (mo *VirtualMachine) RemoveAllSnapshots_Task(
	_this *ManagedObjectReference, consolidate bool,
) (*Task, error) {

	return nil, nil

}

//
// Clears cached guest information. Guest information can be cleared
// only if the virtual machine is powered off.
//
// This method can be useful if stale information is cached,
// preventing an IP address or MAC address from being reused.
//
//
// Required Privileges
// VirtualMachine.Config.ResetGuestInfo
//
func (mo *VirtualMachine) ResetGuestInformation(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Resets power on this virtual machine. If the current state is poweredOn,
// then this method first performs powerOff(hard). Once the power state
// is poweredOff, then this method performs powerOn(option).
//
// Although this method functions as a powerOff followed by a powerOn, the
// two operations are atomic with respect to other clients, meaning that
// other power operations cannot be performed until the reset method completes.
//
//
// Required Privileges
// VirtualMachine.Interact.Reset
//
func (mo *VirtualMachine) ResetVM_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Reverts the virtual machine to the current snapshot. This is equivalent to
// doing snapshot.currentSnapshot.revert.
//
// If no snapshot exists, then the operation does nothing,
// and the virtual machine state remains unchanged.
//
//
// Required Privileges
// VirtualMachine.State.RevertToSnapshot
//
func (mo *VirtualMachine) RevertToCurrentSnapshot_Task(
	_this *ManagedObjectReference, host *HostSystem, suppressPowerOn bool,
) (*Task, error) {

	return nil, nil

}

//
// Sets the console window's display topology as specified.
//
// Required Privileges
// VirtualMachine.Interact.ConsoleInteract
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) SetDisplayTopology(
	_this *ManagedObjectReference, displays []*VirtualMachineDisplayTopology,
) error {

	return nil

}

//
// Sets the console window's resolution as specified.
//
// Required Privileges
// VirtualMachine.Interact.ConsoleInteract
//
func (mo *VirtualMachine) SetScreenResolution(
	_this *ManagedObjectReference, width int32, height int32,
) error {

	return nil

}

//
// Issues a command to the guest operating system asking it to perform
// a clean shutdown of all services.
// Returns immediately and does not wait for the guest operating system
// to complete the operation.
//
// Required Privileges
// VirtualMachine.Interact.PowerOff
//
func (mo *VirtualMachine) ShutdownGuest(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Issues a command to the guest operating system asking it to prepare for
// a suspend operation.
// Returns immediately and does not wait for the guest operating system
// to complete the operation.
//
// Required Privileges
// VirtualMachine.Interact.Suspend
//
func (mo *VirtualMachine) StandbyGuest(
	_this *ManagedObjectReference,
) error {

	return nil

}

// Deprecated.
// As of vsphere API 5.1
//
//
// Initiates a recording session on this virtual machine. As a side effect,
// this operation creates a snapshot on the virtual machine, which in turn
// becomes the current snapshot.
//
// This is an experimental interface that is not intended for use in production code.
//
//
//
//
// Required Privileges
// VirtualMachine.Interact.Record
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) StartRecording_Task(
	_this *ManagedObjectReference, name string, description string,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of vsphere API 5.1
//
//
// Starts a replay session on this virtual machine. As a side effect,
// this operation updates the current snapshot of the virtual machine.
//
// This is an experimental interface that is not intended for use in production code.
//
//
//
//
// Required Privileges
// VirtualMachine.Interact.Replay
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) StartReplaying_Task(
	_this *ManagedObjectReference, replaySnapshot *VirtualMachineSnapshot,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of vsphere API 5.1
//
//
// Stops a currently active recording session on this virtual machine.
//
// This is an experimental interface that is not intended for use in production code.
//
//
//
//
// Required Privileges
// VirtualMachine.Interact.Record
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) StopRecording_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

// Deprecated.
// As of vsphere API 5.1
//
//
// Stops a replay session on this virtual machine.
//
// This is an experimental interface that is not intended for use in production code.
//
//
//
//
// Required Privileges
// VirtualMachine.Interact.Replay
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) StopReplaying_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Suspends execution in this virtual machine.
//
// Required Privileges
// VirtualMachine.Interact.Suspend
//
func (mo *VirtualMachine) SuspendVM_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Terminates the specified secondary virtual machine in a fault tolerant group. This
// can be used to test fault tolerance on a given virtual machine, and should
// be used with care.
//
// Required Privileges
// VirtualMachine.Interact.TerminateFaultTolerantVM
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) TerminateFaultTolerantVM_Task(
	_this *ManagedObjectReference, vm *VirtualMachine,
) (*Task, error) {

	return nil, nil

}

//
// Do an immediate power off of a VM.
//
// This API issues a SIGKILL to the vmx process of the VM.
// Pending synchronous I/Os may not be written out before the vmx
// process dies depending on accessibility of the datastore.
//
//
//
//
// Required Privileges
// VirtualMachine.Interact.PowerOff
// Since
// vSphere API 5.1
//
func (mo *VirtualMachine) TerminateVM(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Removes all secondary virtual machines associated with the fault tolerant
// group and turns off protection for this virtual machine.
//
// This operation can only be invoked from the primary virtual machine in
// the group.
//
// Required Privileges
// VirtualMachine.Interact.TurnOffFaultTolerance
// Since
// vSphere API 4.0
//
func (mo *VirtualMachine) TurnOffFaultToleranceForVM_Task(
	_this *ManagedObjectReference,
) (*Task, error) {

	return nil, nil

}

//
// Unmounts VMware Tools installer CD.
//
// Required Privileges
// VirtualMachine.Interact.ToolsInstall
//
func (mo *VirtualMachine) UnmountToolsInstaller(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Removes this virtual machine from the inventory without removing
// any of the virtual machine's files on disk. All high-level information
// stored with the management server (ESX Server or VirtualCenter) is
// removed, including information such as statistics, resource pool association,
// permissions, and alarms.
//
// Use the Folder.RegisterVM method to recreate a
// VirtualMachine object from the set of virtual machine files by passing in
// the path to the configuration file. However, the VirtualMachine managed object
// that results typically has different objects ID and may inherit a different
// set of permissions.
//
//
// Required Privileges
// VirtualMachine.Inventory.Unregister
//
func (mo *VirtualMachine) UnregisterVM(
	_this *ManagedObjectReference,
) error {

	return nil

}

//
// Begins the tools upgrade process.
// To monitor the status of the tools install, clients should check the tools status,
// toolsVersionStatus and
// toolsRunningStatus.
//
// Required Privileges
// VirtualMachine.Interact.ToolsInstall
//
func (mo *VirtualMachine) UpgradeTools_Task(
	_this *ManagedObjectReference, installerOptions string,
) (*Task, error) {

	return nil, nil

}

//
// Upgrades this virtual machine's virtual hardware to the latest revision
// that is supported by the virtual machine's current host.
//
// Required Privileges
// VirtualMachine.Config.UpgradeVirtualHardware
//
func (mo *VirtualMachine) UpgradeVM_Task(
	_this *ManagedObjectReference, version string,
) (*Task, error) {

	return nil, nil

}

//
// Specification of scheduling affinity.
//
// Scheduling affinity is used for explicitly specifying which
// processors or NUMA nodes may be used by a virtual machine.
//
//
//
type VirtualMachineAffinityInfo struct {
	*DynamicData

	// List of nodes (processors for CPU, NUMA nodes for memory) that
	// may be used by the virtual machine.  If the array is empty when
	// modifying the affinity setting, then any existing affinity is removed.
	AffinitySet []int32
}

//
// Application heartbeat status type.
//
//
type VirtualMachineAppHeartbeatStatusType struct {
}

//
// The VirtualMachineBootOptions data object defines the boot-time
// behavior of a virtual machine.
//
// You can use the delay options to specify a time interval
// during which you can enter the virtual machine BIOS setup.
// These options provide a solution for the situation that occurs
// when the console attaches to the virtual machine after
// the boot sequence has passed the BIOS setup entry point.
//
//
//
type VirtualMachineBootOptions struct {
	*DynamicData

	// Delay in milliseconds before starting the boot sequence.
	// The boot delay specifies a time interval between virtual machine
	// power on or restart and the beginning of the boot sequence.
	BootDelay int64

	// Boot order.  Listed devices are used for booting.  After list
	// is exhausted, default BIOS boot device algorithm is used for
	// booting.
	//
	// Note that order of the entries in the list is important:
	// device listed first is used for boot first, if that one
	// fails second entry is used, and so on.
	//
	// Platform may have some internal limit on the number of devices
	// it supports.  If bootable device is not reached before platform's
	// limit is hit, boot will fail.  At least single entry is supported
	// by all products supporting boot order settings.
	//
	// Since vSphere API 5.0
	BootOrder []*VirtualMachineBootOptionsBootableDevice

	// Delay in milliseconds before a boot retry. The boot retry delay
	// specifies a time interval between virtual machine boot failure
	// and the subsequent attempt to boot again. The virtual machine
	// uses this value only if bootRetryEnabled is true.
	//
	// Since vSphere API 4.1
	BootRetryDelay int64

	// If set to true, a virtual machine that fails
	// to boot will try again after the bootRetryDelay
	// time period has expired. When false,
	// the virtual machine waits indefinitely for you to initiate
	// boot retry.
	//
	// Since vSphere API 4.1
	BootRetryEnabled bool

	// If set to true, the virtual machine
	// automatically enters BIOS setup the next time it boots.
	// The virtual machine resets this flag to false
	// so that subsequent boots proceed normally.
	EnterBIOSSetup bool
}

//
// Bootable CDROM.  First CDROM with bootable media found is used.
//
//
type VirtualMachineBootOptionsBootableCdromDevice struct {
	*VirtualMachineBootOptionsBootableDevice
}

//
// Bootable device.
//
//
type VirtualMachineBootOptionsBootableDevice struct {
	*DynamicData
}

//
// Bootable disk.
//
//
type VirtualMachineBootOptionsBootableDiskDevice struct {
	*VirtualMachineBootOptionsBootableDevice

	// Key
	// property of the bootable harddisk.
	DeviceKey int32
}

//
// Bootable ethernet adapter.  PXE boot is attempted from the device.
//
//
type VirtualMachineBootOptionsBootableEthernetDevice struct {
	*VirtualMachineBootOptionsBootableDevice

	// Key
	// property of the bootable ethernet adapter.
	DeviceKey int32
}

//
// Bootable floppy disk.
//
//
type VirtualMachineBootOptionsBootableFloppyDevice struct {
	*VirtualMachineBootOptionsBootableDevice
}

//
// This data object type contains information about the
// operation/capabilities of a virtual machine
//
//
type VirtualMachineCapability struct {
	*DynamicData

	// Indicates whether boot options can be configured
	// for this virtual machine.
	//
	// Since VI API 2.5
	BootOptionsSupported bool

	// Indicates whether automatic boot retry can be
	// configured for this virtual machine.
	//
	// Since vSphere API 4.1
	BootRetryOptionsSupported bool

	// Indicates that change tracking is supported for virtual disks of this
	// virtual machine. However, even if change tracking is supported, it might
	// not be available for all disks of the virtual machine. For example,
	// passthru raw disk mappings or disks backed by any Ver1BackingInfo cannot
	// be tracked.
	//
	// Since vSphere API 4.0
	ChangeTrackingSupported bool

	// Indicates whether console preferences can be set for this virtual machine.
	ConsolePreferencesSupported bool

	// Indicates whether CPU feature requirements masks can be set for this
	// virtual machine.
	CpuFeatureMaskSupported bool

	// Deprecated.
	// As of vSphere API 4.0. The value returned from the server is
	// always false.
	//
	//
	// Indicates whether or not snapshots can be disabled.
	//
	// Since VI API 2.5
	DisableSnapshotsSupported bool

	// Indicates whether resource settings for disks can be
	// applied to this virtual machine.
	//
	// Since VI API 2.5
	DiskSharesSupported bool

	// Indicates whether featureRequirement feature is supported.
	//
	// Since vSphere API 5.1
	FeatureRequirementSupported bool

	// Since vSphere API 5.0
	GuestAutoLockSupported bool

	// Indicates that host based replication is supported on this virtual
	// machine. However, even if host based replication is supported,
	// it might not be available for all disk types. For example, passthru
	// raw disk mappings can not be replicated.
	//
	// Since vSphere API 5.0
	HostBasedReplicationSupported bool

	// Indicates whether or not the snapshot tree can be locked.
	//
	// Since VI API 2.5
	LockSnapshotsSupported bool

	// Indicates whether
	// memoryReservationLockedToMax
	// may be set to true for this virtual machine.
	//
	// Since vSphere API 5.0
	MemoryReservationLockSupported bool

	// Indicates whether or not a virtual machine supports memory snapshots.
	MemorySnapshotsSupported bool

	// Indicates whether multiple virtual cores per socket is supported on this VM.
	//
	// Since vSphere API 5.0
	MultipleCoresPerSocketSupported bool

	// Indicates whether or not a virtual machine supports multiple snapshots.
	// This value is not set when the virtual machine is unavailable, for instance,
	// when it is being created or deleted.
	MultipleSnapshotsSupported bool

	// Indicates whether this virtual machine supports nested hardware-assisted
	// virtualization.
	//
	// Since vSphere API 5.1
	NestedHVSupported bool

	// Supports assigning NPIV WWN to virtual machines that don't have RDM disks.
	//
	// Since VI API 2.5
	NpivWwnOnNonRdmVmSupported bool

	// Indicates whether or not a virtual machine supports snapshot operations in
	// poweredOff state. This flag doesn't affect vim.VirtualMachine.GetSnapshot,
	// which is always supported.
	PoweredOffSnapshotsSupported bool

	// Indicates whether a monitor type change is supported while this virtual
	// machine is in the poweredOn state.
	//
	// Since vSphere API 5.1
	PoweredOnMonitorTypeChangeSupported bool

	// Indicates whether or not a virtual machine supports quiesced snapshots.
	QuiescedSnapshotsSupported bool

	// Indicates whether record and replay functionality is supported on this
	// virtual machine.
	//
	// Since vSphere API 4.0
	RecordReplaySupported bool

	// Indicates whether or not a virtual machine supports reverting to a snapshot.
	RevertToSnapshotSupported bool

	// Indicates whether or not a virtual machine supports ACPI S1 settings management.
	S1AcpiManagementSupported bool

	// Indicates whether this virtual machine supports the Flex-SE
	// (space-efficent, sparse) format for virtual disks.
	//
	// Since vSphere API 5.1
	SeSparseDiskSupported bool

	// Indicates whether of not this virtual machine supports
	// setting the display topology of the console window.
	// This capability depends on the guest operating system
	// configured for this virtual machine.
	//
	// Since vSphere API 4.0
	SettingDisplayTopologySupported bool

	// Indicates whether of not this virtual machine supports
	// setting the screen resolution of the console window.
	// This capability depends on the guest operating system
	// configured for this virtual machine.
	SettingScreenResolutionSupported bool

	// Flag indicating whether the video ram size of this virtual machine
	// can be configured.
	//
	// Since VI API 2.5
	SettingVideoRamSizeSupported bool

	// Indicates whether or not a virtual machine supports snapshot config.
	SnapshotConfigSupported bool

	// Indicates whether or not a virtual machine supports snapshot operations.
	SnapshotOperationsSupported bool

	// Flag indicating whether the virtual machine has a configurable
	// swapfile placement policy.
	//
	// Since VI API 2.5
	SwapPlacementSupported bool

	// Supports tools auto-update.
	ToolsAutoUpdateSupported bool

	// Indicates whether asking tools to sync time with the host is supported.
	//
	// Since VI API 2.5
	ToolsSyncTimeSupported bool

	// Indicates whether or not the use of nested page table hardware support
	// can be explicitly set.
	//
	// Since VI API 2.5
	VirtualMmuUsageSupported bool

	// Indicates whether the NPIV disabling operation is supported the virtual machine.
	//
	// Since vSphere API 4.0
	VmNpivWwnDisableSupported bool

	// Supports virtual machine NPIV WWN.
	//
	// Since VI API 2.5
	VmNpivWwnSupported bool

	// Indicates whether the update of NPIV WWNs are supported on the virtual machine.
	//
	// Since vSphere API 4.0
	VmNpivWwnUpdateSupported bool

	// Indicates whether this virtual machine supports virtualized CPU performance
	// counters.
	//
	// Since vSphere API 5.1
	VPMCSupported bool
}

//
// CdromInfo class contains information about a physical CD-ROM drive on the host.
//
//
type VirtualMachineCdromInfo struct {
	*VirtualMachineTargetInfo
}

//
// Specification for a virtual machine cloning operation.
//
//
type VirtualMachineCloneSpec struct {
	*DynamicData

	// An optional specification of changes to the virtual hardware. For example,
	// this can be used to, (but not limited to) reconfigure the networks the virtual
	// switches are hooked up to in the cloned virtual machine.
	Config *VirtualMachineConfigSpec

	// An optional guest operating system customization specification. This value
	// is ignored if a template is being created.
	Customization *CustomizationSpec

	// A type of RelocateSpec that specifies the location of resources the newly cloned
	// virtual machine will use. The location specifies:
	//
	// A datastore where the virtual machine will be located on physical storage.
	// This is always provided because it indicates where the newly created clone
	// will be copied.
	// a resource pool and optionally a host. The resource pool determines what
	// compute resources will be available to the clone and the host indicates
	// which machine will host the clone.
	Location *VirtualMachineRelocateSpec

	// Flag indicating whether to retain a copy of the source virtual machine's
	// memory state in the clone. Retaining the memory state during
	// clone results in a clone in suspended state with all network adapters
	// removed to avoid network conflicts, except those with a
	// VirtualEthernetCard.addressType of "manual".
	// Users of this flag should take special care so that, when adding a network
	// adapter back to the clone, the VM is not resumed on the same VM network
	// as the source VM, or else MAC address conflicts could occur.
	// When cloning between two hosts with different CPUs outside an EVC cluster,
	// users of this flag should be aware that vCenter does not verify
	// CPU compatibility between the clone's memory state and the target host
	// prior to the clone operation, so the clone may fail to resume
	// until it is migrated to a host with a compatible CPU.
	//
	// This flag is ignored if the snapshot parameter is unset. This flag
	// only applies for a snapshot taken on a running or suspended
	// virtual machine with the 'memory' parameter set to true, because otherwise
	// the snapshot has no memory state. This flag defaults to false.
	//
	// Since vSphere API 5.5
	Memory bool

	// Specifies whether or not the new VirtualMachine should be powered on after
	// creation. As part of a customization, this flag is normally set to true,
	// since the first power-on operation completes the customization process.
	// This flag is ignored if a template is being created.
	PowerOn bool

	// Snapshot reference from which to base the clone.
	//
	// If this parameter is set, the clone is based off of the snapshot
	// point.  This means that the newly created virtual machine will
	// have the same configuration as the virtual machine at the time
	// the snapshot was taken.
	//
	// If this property is not set then the clone is based off of the
	// virtual machine's current configuration.
	//
	// Setting this is only supported if the host this virtual machine
	// is currently residing on supports cloning from a snapshot point.  Such support does not need to exist
	// on the destination host for the clone.
	//
	// Setting this is only supported if the virtual machine supports
	// reporting snapshot configuration information.  See snapshotConfigSupported.  Such support does not need to
	// exist on the destination host for the clone.
	//
	// Since vSphere API 4.0
	Snapshot *VirtualMachineSnapshot

	// Specifies whether or not the new virtual machine should be marked as a template.
	Template bool
}

//
// A singleton managed object that can answer questions about compatibility
// of a virtual machine with a host.
//
type VirtualMachineCompatibilityChecker struct {
	*ManagedObject
}

//
// Tests whether or not a virtual machine could be placed on
// the given host in the given resource pool.
//
// Required Privileges
// System.View
//
func (mo *VirtualMachineCompatibilityChecker) CheckCompatibility_Task(
	_this *ManagedObjectReference, vm *VirtualMachine, host *HostSystem, pool *ResourcePool, testType []string,
) (*Task, error) {

	return nil, nil

}

//
// The ConfigInfo data object type encapsulates the configuration settings and
// virtual hardware for a virtual machine. This type holds all the information
// that is present in the .vmx configuration file for the virtual machine.
//
//
type VirtualMachineConfigInfo struct {
	*DynamicData

	// Used as display name for the operating system if guestId is other
	// or other-64.
	// See guestFullName
	//
	// Since VI API 2.5
	AlternateGuestName string

	// Description for the virtual machine.
	Annotation string

	// Configuration options for the boot behavior of the virtual machine.
	//
	// Since VI API 2.5
	BootOptions *VirtualMachineBootOptions

	// Indicates whether changed block tracking for this VM's disks
	// is active.
	//
	// Since vSphere API 4.0
	ChangeTrackingEnabled bool

	// The changeVersion is a unique identifier for a given version
	// of the configuration. Each change to the configuration
	// updates this value. This is typically implemented as an ever
	// increasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	ChangeVersion string

	// Legacy console viewer preferences when doing power operations.
	ConsolePreferences *VirtualMachineConsolePreferences

	// Affinity settings for CPU.
	CpuAffinity *VirtualMachineAffinityInfo

	// Resource limits for CPU.
	CpuAllocation *ResourceAllocationInfo

	// Specifies CPU feature compatibility masks that override the
	// defaults from the GuestOsDescriptor
	// of the virtual machine's guest OS.
	CpuFeatureMask []*HostCpuIdInfo

	// Whether virtual processors can be added while this
	// virtual machine is running.
	//
	// Since vSphere API 4.0
	CpuHotAddEnabled bool

	// Whether virtual processors can be removed while this
	// virtual machine is running.
	//
	// Since vSphere API 4.0
	CpuHotRemoveEnabled bool

	// Enumerates the set of datastores that this virtual machine is
	// stored on, as well as the URL identification for each of these.
	//
	// Changes to datastores do not generate property updates on this
	// property. However, when this property is retrieved it returns the
	// current datastore information.
	DatastoreUrl []*VirtualMachineConfigInfoDatastoreUrlPair

	// Configuration of default power operations.
	DefaultPowerOps *VirtualMachineDefaultPowerOpInfo

	// Additional configuration information for the virtual machine.
	ExtraConfig []*OptionValue

	// Information about the files associated with a virtual machine.
	// This information does not include files for specific virtual disks or
	// snapshots.
	Files *VirtualMachineFileInfo

	// Information about firmware type for this Virtual Machine.
	//
	// Possible values are described in
	// GuestOsDescriptorFirmwareType
	//
	// Since vSphere API 5.0
	Firmware string

	// Additional flags for a virtual machine.
	Flags *VirtualMachineFlagInfo

	// Fault Tolerance settings for this virtual machine.
	//
	// Since vSphere API 4.0
	FtInfo *FaultToleranceConfigInfo

	// Indicates whether the guest operating system will logout any active
	// sessions whenever there are no remote display connections open to
	// the virtual machine.
	//
	// Since vSphere API 5.0
	GuestAutoLockEnabled bool

	// This is the full name of the guest operating system for the virtual machine.
	// For example: Windows 2000 Professional.
	// See alternateGuestName
	GuestFullName string

	// Guest operating system configured on a virtual machine.
	// This is a guest identifier that can be used to access the
	// GuestOsDescriptor
	// list for information about default configuration.
	// For more information on possible values, see
	// VirtualMachineGuestOsIdentifier.
	GuestId string

	// Processor, memory, and virtual devices for a virtual machine.
	Hardware *VirtualHardware

	// Memory, in MB that can be added to a running virtual machine
	// must be in increments of this value and needs be a
	// multiple of this value.
	//
	// This value is determined by the virtual machine and is specified
	// only if memoryHotAddEnabled
	// has been set to true.
	//
	// Since vSphere API 4.0
	HotPlugMemoryIncrementSize int64

	// The maximum amount of memory, in MB, than can be added to a
	// running virtual machine. This value is determined by the
	// virtual machine and is specified only if
	// memoryHotAddEnabled
	// is set to true.
	//
	// Since vSphere API 4.0
	HotPlugMemoryLimit int64

	// Set of values to be used only to perform admission control when
	// determining if a host has sufficient resources for the virtual
	// machine to power on.
	//
	// Since vSphere API 5.0
	InitialOverhead *VirtualMachineConfigInfoOverheadInfo

	// VirtualCenter-specific 128-bit UUID of a virtual machine, represented
	// as a hexademical string. This identifier is used by VirtualCenter to
	// uniquely identify all virtual machine instances, including those that
	// may share the same SMBIOS UUID.
	//
	// Since vSphere API 4.0
	InstanceUuid string

	// The latency-sensitivity of the virtual machine.
	//
	// Since vSphere API 5.1
	LatencySensitivity *LatencySensitivity

	// Hash incorporating the virtual machine's config file location
	// and the UUID of the host assigned to run the virtual machine.
	LocationId string

	// Specifies that this VM is managed by a VC Extension. See the
	// managedBy property in the ConfigSpec
	// for more details.
	//
	// Since vSphere API 5.0
	ManagedBy *ManagedByInfo

	// Indicates the maximum number of active remote display connections
	// that the virtual machine will support.
	//
	// Since vSphere API 5.0
	MaxMksConnections int32

	// Affinity settings for memory.
	MemoryAffinity *VirtualMachineAffinityInfo

	// Resource limits for memory.
	MemoryAllocation *ResourceAllocationInfo

	// Whether memory can be added while this virtual machine is running.
	//
	// Since vSphere API 4.0
	MemoryHotAddEnabled bool

	// If set true, memory resource reservation for this virtual machine will always be
	// equal to the virtual machine's memory size; increases in memory size will be
	// rejected when a corresponding reservation increase is not possible.
	//
	// Since vSphere API 5.0
	MemoryReservationLockedToMax bool

	// Last time a virtual machine's configuration was modified.
	Modified time.Time

	// Display name of the virtual machine.
	//
	// Any / (slash), \ (backslash), character used in this
	// name element is escaped. Similarly, any % (percent) character used in
	// this name element is escaped, unless it is used to start an escape
	// sequence. A slash is escaped as %2F or %2f. A backslash is escaped as %5C or
	// %5c, and a percent is escaped as %25.
	Name string

	// Indicates whether this VM is configured to use nested
	// hardware-assisted virtualization.
	//
	// Since vSphere API 5.1
	NestedHVEnabled bool

	// Deprecated.
	// from vSphere 5.5, shaping policy on VM is not supported.
	//
	//
	// Resource limits for network.
	NetworkShaper *VirtualMachineNetworkShaperInfo

	// The NPIV node WWNs to be extended from the original list of WWN nummbers. This
	// property should be set to desired number which is an aggregate of existing
	// plus new numbers. Desired Node WWNs should always be greater than the existing
	// number of node WWNs
	//
	// Since vSphere API 4.0
	NpivDesiredNodeWwns int16

	// The NPIV port WWNs to be extended from the original list of WWN nummbers. This
	// property should be set to desired number which is an aggregate of existing
	// plus new numbers. Desired Node WWNs should always be greater than the existing
	// number of port WWNs
	//
	// Since vSphere API 4.0
	NpivDesiredPortWwns int16

	// A 64-bit node WWN (World Wide Name). These WWNs are paired with the
	// npivPortWorldWideName to be used by the NPIV VPORTs instantiated for the
	// virtual machine on the physical HBAs of the host. A pair of node and port WWNs
	// serves as a unique identifier in accessing a LUN, so that it can be monitored or
	// controlled by the storage administrator.
	//
	// If this property contains a single node WWN, the same node WWN is used to pair
	// with all port WWNs listed in npivPortWorldWideName. If this property or
	// npivPortWorldWideName is empty or unset, NPIV WWN is disabled for the
	// virtual machine.
	//
	// Since VI API 2.5
	NpivNodeWorldWideName []int64

	// This property is used to check whether the NPIV can be enabled on the Virtual
	// machine with non-rdm disks in the configuration, so this is potentially not
	// enabling npiv on vmfs disks. Also this property is used to check whether RDM
	// is required to generate WWNs for a virtual machine.
	//
	// Since vSphere API 4.0
	NpivOnNonRdmDisks bool

	// A 64-bit port WWN (World Wide Name). For detail description on WWN, see
	// npivNodeWorldWideName.
	//
	// Since VI API 2.5
	NpivPortWorldWideName []int64

	// This property is used to enable or disable the NPIV capability on a desired
	// virtual machine on a temporary basis. When this property is set NPIV Vport
	// will not be instantiated by the VMX process of the Virtual Machine. When this
	// property is set port WWNs and node WWNs in the VM configuration are preserved.
	//
	// Since vSphere API 4.0
	NpivTemporaryDisabled bool

	// The source that provides/generates the assigned WWNs.
	// See VirtualMachineConfigInfoNpivWwnType
	//
	// Since VI API 2.5
	NpivWorldWideNameType string

	// Configuration of scheduled hardware upgrades and result from last
	// attempt to run scheduled hardware upgrade.See ScheduledHardwareUpgradeInfo
	//
	// Since vSphere API 5.1
	ScheduledHardwareUpgradeInfo *ScheduledHardwareUpgradeInfo

	// Virtual machine swapfile placement policy. This will be unset if the
	// virtual machine's
	// swapPlacementSupported
	// capability is false. If swapPlacementSupported is true, the default
	// policy is "inherit".
	// See VirtualMachineConfigInfoSwapPlacementType
	//
	// Since VI API 2.5
	SwapPlacement string

	// Flag indicating whether or not a virtual machine is a template.
	Template bool

	// Configuration of VMware Tools running in the guest operating system.
	Tools *ToolsConfigInfo

	// 128-bit SMBIOS UUID of a virtual machine represented as a hexadecimal string
	// in "12345678-abcd-1234-cdef-123456789abc" format.
	Uuid string

	// vApp meta-data for the virtual machine
	//
	// Since vSphere API 4.0
	VAppConfig *VmConfigInfo

	// Indicates whether user-configured virtual asserts will be
	// triggered during virtual machine replay.
	//
	// Since vSphere API 4.0
	VAssertsEnabled bool

	// The version string for this virtual machine.
	Version string

	// Specifies the total vFlash resource reservation for the vFlash caches associated
	// with this VM's virtual disks, in bytes. This reservation must be allocated to power on the VM.
	// See vFlashCacheAllocation for allocated
	// reservation when VM is powered on.
	//
	// Since vSphere API 5.5
	VFlashCacheReservation int64

	// Indicates whether this VM have vurtual CPU performance counters
	// enabled.
	//
	// Since vSphere API 5.1
	VPMCEnabled bool
}

//
// Contains the name of a datastore, and its local file path on the host
// currently affiliated with this virtual machine.
//
//
type VirtualMachineConfigInfoDatastoreUrlPair struct {
	*DynamicData

	Name string

	Url string
}

//
// The NPIV WWN source type.
//
//
type VirtualMachineConfigInfoNpivWwnType struct {
}

//
// Information about virtualization overhead required to power on the
// virtual machine on the registered host.
//
//
type VirtualMachineConfigInfoOverheadInfo struct {
	*DynamicData

	// Memory overhead required for virtual machine to be powered on (in bytes).
	InitialMemoryReservation int64

	// Disk space required for virtual machine to be powered on (in bytes).
	// This space is used by virtualization infrastructure to swap out
	// virtual machine process memory. Location of the file is specified by
	// sched.swap.vmxSwapDir virtual machinge advanced config option or
	// in case it is not specified - current virtual machine home directory
	// is being used.
	InitialSwapReservation int64
}

//
// Available choices for virtual machine swapfile placement policy. This is
// the set of legal values for the virtual machine configuration's
// swapPlacement property. All
// values except for "inherit" and "vmConfigured" are also valid values for
// a compute resource configuration's
// vmSwapPlacement
// property.
//
//
type VirtualMachineConfigInfoSwapPlacementType struct {
}

//
// This configuration data object type contains information about the execution
// environment for a virtual machine. This includes information about which features are
// supported, such as:
//
//
// •  Which guest operating systems are supported.
//
// •  How devices are emulated. For example, that a CD-ROM drive can be emulated
// with a file or that a serial port can be emulated with a pipe.
//
//
//
// VirtualCenter can provide a broader environment than any single physical host. This
// is a departure from traditional virtualization approaches, which rely on the host
// system to define the environment for virtual machines. This data object describes
// environment capabilities and is used by VirtualCenter to choose hosts on which to run
// virtual machines.
//
//
type VirtualMachineConfigOption struct {
	*DynamicData

	// Capabilities supported by a virtual machine.
	Capabilities *VirtualMachineCapability

	// The datastore options for this virtual machine.
	Datastore *DatastoreOption

	// The list of virtual devices that are created on a virtual machine by default.
	// Clients should not create these devices.
	DefaultDevice []*VirtualDevice

	// A description string for this configOption.
	Description string

	// Index into guestOsDescriptor array denoting the default guest
	// operating system.
	GuestOSDefaultIndex int32

	// List of supported guest operating systems.
	// The choice of guest operating system may limit the set of valid devices.
	// For example, you cannot select Vmxnet with all guest operating systems.
	GuestOSDescriptor []*GuestOsDescriptor

	// Processor, memory, and virtual device options for a virtual machine.
	HardwareOptions *VirtualHardwareOption

	// The monitor types supported by a host. The acceptable monitor types
	// are enumerated by VirtualMachineFlagInfoMonitorType.
	//
	// Since VI API 2.5
	SupportedMonitorType []string

	// Specifies the supported property transports that are
	// available for the OVF environment
	//
	// Since vSphere API 4.0
	SupportedOvfEnvironmentTransport []string

	// Specifies the supported transports for the OVF
	// installation phase.
	//
	// Since vSphere API 4.0
	SupportedOvfInstallTransport []string

	// The version corresponding to this configOption.
	Version string
}

//
// Contains the definition of a unique key that can be used to
// retrieve a configOption object.
//
//
type VirtualMachineConfigOptionDescriptor struct {
	*DynamicData

	// Indicates whether the associated set of configuration options
	// can be used for virtual machine creation on a given host or
	// cluster.
	//
	// Since vSphere API 4.0
	CreateSupported bool

	// Indicates whether the associated set of virtual machine
	// configuration options is the default one for a given host or
	// cluster.  Latest version is marked as default unless
	// other version is specified via
	// defaultHardwareVersionKey
	// or defaultHardwareVersionKey.
	//
	// If this setting is TRUE, virtual machine creates will use the
	// associated set of configuration options, unless a config version is
	// explicitly specified in the ConfigSpec.
	//
	// Since vSphere API 4.0
	DefaultConfigOption bool

	// A description of the configOption object.
	Description string

	// List of hosts to which this descriptor applies.
	// List of hosts is not set when descriptor is returned
	// from queryDatacenterConfigOptionDescriptor.
	Host []*HostSystem

	// A unique key used to identify a configOption object in this
	// EnvironmentBrowser.
	Key string

	// Indicates whether the associated set of configuration options
	// can be used to power on a virtual machine on a given host or
	// cluster.
	//
	// Since vSphere API 5.1
	RunSupported bool

	// Indicates whether the associated set of configuration options
	// can be used as a virtual hardware upgrade target.
	//
	// Since vSphere API 5.1
	UpgradeSupported bool
}

//
// This data object type encapsulates configuration settings
// when creating or reconfiguring a virtual machine. To support incremental changes,
// these properties are all optional. If an optional property is unset,
// or any nested optional property is unset, the property will not
// be changed unless 'unset' is a valid value for the property. To determine
// whether 'unset' is a valid value for a particular property, refer to
// the documentation for that property.
//
//
type VirtualMachineConfigSpec struct {
	*DynamicData

	// Full name for guest, if guestId is specified as other
	// or other-64.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	//
	// Since VI API 2.5
	AlternateGuestName string

	// User-provided description of the virtual machine. Because this property
	// is optional in the virtual machine configuration, it is necessary
	// to pass an explicit empty string in a ConfigSpec object to remove an annotation
	// that is already present in the VirtualMachineConfigInfo
	// for a virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Rename
	Annotation string

	// Settings that control the boot behavior of the virtual
	// machine. These settings take effect during the next power-on
	// of the virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	//
	// Since VI API 2.5
	BootOptions *VirtualMachineBootOptions

	// Setting to control enabling/disabling changed block tracking for
	// the virtual disks of this VM. This may only be set if the
	// changeTrackingSupported
	// capability is true for this virtual machine. Any change to this property
	// will take effect the next time the virtual machine powers on, resumes
	// from a suspended state, performs a snapshot create/delete/revert operation
	// or migrates while powered on.
	//
	// Reconfigure privilege: VirtualMachine.Config.ChangeTracking
	// (also required when setting this property while creating a virtual machine)
	//
	// Since vSphere API 4.0
	ChangeTrackingEnabled bool

	// If specified, the changes are only applied if the current changeVersion matches
	// the specified changeVersion. This field can be used to guard against updates that
	// have happened between when configInfo is read and when it is applied.
	//
	// For more information about how configurations are uniquely identified, see
	// changeVersion.
	ChangeVersion string

	// Legacy console viewer preferences that are used with power operations. For
	// example, power on.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	ConsolePreferences *VirtualMachineConsolePreferences

	// Affinity settings for CPU.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	CpuAffinity *VirtualMachineAffinityInfo

	// Resource limits for CPU.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	CpuAllocation *ResourceAllocationInfo

	// Specifies the CPU feature compatibility masks.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	CpuFeatureMask []*VirtualMachineCpuIdInfoSpec

	// Indicates whether or not virtual processors can be added to
	// the virtual machine while it is running.
	//
	// This attribute can only be set when the virtual machine is
	// powered-off.
	//
	// Reconfigure privilege: VirtualMachine.Config.CpuCount
	//
	// Since vSphere API 4.0
	CpuHotAddEnabled bool

	// Indicates whether or not virtual processors can be removed
	// from the virtual machine while it is running.
	//
	// This attribute can only be set when the virtual machine is
	// powered-off.
	//
	// Reconfigure privilege: VirtualMachine.Config.CpuCount
	//
	// Since vSphere API 4.0
	CpuHotRemoveEnabled bool

	// Set of virtual devices being modified by the configuration operation.
	//
	// Reconfigure privileges:
	//
	// VirtualMachine.Config.Resource if setting the "shares" property of
	// a new or existing VirtualDisk device
	// VirtualMachine.Config.RawDevice if adding, removing, or modifying a
	// raw device (also required when creating a virtual machine)
	// VirtualMachine.Config.HostUSBDevice if adding, removing, or
	// modifying a VirtualUSB device backed by a host USB device (also
	// required when creating a virtual machine).
	// VirtualMachine.Interact.DeviceConnection if setting the "connectable"
	// property of a connectable device
	// VirtualMachine.Interact.SetCDMedia if setting the "backing" property
	// of a VirtualCdrom device
	// VirtualMachine.Interact.SetFloppyMedia if setting the "backing" property
	// of a VirtualFloppy device
	// VirtualMachine.Config.EditDevice if setting any property of a
	// non-CDROM non-Floppy device
	// VirtualMachine.Config.AddExistingDisk if adding a VirtualDisk, and
	// the fileOperation is unset (also required when creating a virtual machine)
	// VirtualMachine.Config.AddNewDisk if adding a VirtualDisk and the
	// fileOperation is set (also required when creating a virtual machine)
	// VirtualMachine.Config.RemoveDisk if removing a VirtualDisk device
	// VirtualMachine.Config.AddRemoveDevice if adding or removing any
	// device other than disk, raw, or USB device.
	// Network.Assign if if setting the "backing" property of a
	// VirtualEthernetCard device.
	DeviceChange []*VirtualDeviceConfigSpec

	// Additional configuration information for the virtual machine.
	// This describes a set of modifications to the additional options. If the key is
	// already present, it will be reset with the new value provided. Otherwise, a new
	// option is added. Keys with empty values will be removed.
	//
	// Configuration keys that would conflict with parameters that are explicitly
	// configurable through other fields in the ConfigSpec object are silently ignored.
	//
	// Reconfigure privilege: VirtualMachine.Config.AdvancedConfig
	// (also required when setting this property while creating a virtual machine)
	ExtraConfig []*OptionValue

	// Information about virtual machine files.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	Files *VirtualMachineFileInfo

	// Set the desired firmware type for this Virtual Machine.
	//
	// Possible values are described in
	// GuestOsDescriptorFirmwareType
	//
	// Since vSphere API 5.0
	Firmware string

	// Additional flags for a virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	Flags *VirtualMachineFlagInfo

	// Fault Tolerance settings for this virtual machine.
	//
	// Since vSphere API 4.0
	FtInfo *FaultToleranceConfigInfo

	// If set to True, this causes the guest operating system to automatically
	// logout any active sessions whenever there are no remote display
	// connections open to the virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.MksControl
	//
	// Since vSphere API 5.0
	GuestAutoLockEnabled bool

	// Short guest operating system identifier.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	GuestId string

	// VirtualCenter-specific 128-bit UUID of a virtual machine, represented
	// as a hexadecimal string. This identifier is used  by VirtalCenter
	// to uniquely identify all virtual machine instances in the Virtual
	// Infrastructure environment, including those that may share the same
	// SMBIOS UUID.
	//
	// Normally, this property is not set by a client, allowing the
	// Virtual Infrastructure environment to assign or change it when
	// VirtualCenter detects an identifier conflict between virtual
	// machines. This identifier can be modified even when a virtual
	// machine is powered on. Clients can specify that vCenter Server
	// reassign a new identifier by a providing an empty string. Reassigning
	// the identifer is not allowed for Fault Tolerance virtual machines.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	//
	// Since vSphere API 4.0
	InstanceUuid string

	// The latency-sensitivity setting of the virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	//
	// Since vSphere API 5.1
	LatencySensitivity *LatencySensitivity

	// 128-bit hash based on the virtual machine's configuration file location
	// and the UUID of the host assigned to run the virtual machine.
	//
	// Normally, this property is not set by a client, allowing the
	// Virtual Infrastructure environment to assign a location ID when
	// the virtual machine is created. However, if the virtual machine's
	// configuration file has been manually moved, it may be desirable to clear this
	// property, setting it to an empty string, so the property is regenerated.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	LocationId string

	// Specifies that this VM is managed by a VC Extension.
	//
	// This information is primarily used in the Client to show a custom icon for
	// managed virtual machines, and a description of the function of the virtual
	// machine. If no extension can be found with the extension key in the
	// managedBy object, or the type is not found
	// in the managedEntityInfo list of the
	// extension, the default virtual machine icon is used, and no description is
	// shown.
	//
	// Reconfigure privilege: VirtualMachine.Config.ManagedBy
	//
	// Since vSphere API 5.0
	ManagedBy *ManagedByInfo

	// If set, this setting limits the maximum number of active remote
	// display connections that the virtual machine will support to
	// the specified value.
	//
	// Reconfigure privilege: VirtualMachine.Config.MksControl
	//
	// Since vSphere API 5.0
	MaxMksConnections int32

	// Affinity settings for memory.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	MemoryAffinity *VirtualMachineAffinityInfo

	// Resource limits for memory.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	MemoryAllocation *ResourceAllocationInfo

	// Indicates whether or not memory can be added to the virtual
	// machine while it is running.
	//
	// This attribute can only be set when the virtual machine is
	// powered-off.
	//
	// Reconfigure privilege: VirtualMachine.Config.Memory
	//
	// Since vSphere API 4.0
	MemoryHotAddEnabled bool

	// Size of a virtual machine's memory, in MB.
	//
	// Reconfigure privilege: VirtualMachine.Config.Memory
	MemoryMB int64

	// If set true, memory resource reservation for this virtual machine will always be
	// equal to the virtual machine's memory size; increases in memory size will be
	// rejected when a corresponding reservation increase is not possible. This feature
	// may only be enabled if it is currently possible to reserve all of the virtual machine's memory.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	//
	// Since vSphere API 5.0
	MemoryReservationLockedToMax bool

	// Display name of the virtual machine.
	//
	// Any % (percent) character used in this name parameter must be escaped, unless it
	// is used to start an escape sequence. Clients may also escape any other characters
	// in this name parameter. Snapshots of virtual machines that have spaces in their
	// names and are associated with ESX 2.x servers are not supported. Therefore, if you
	// want the option to take snapshots of this virtual machine and you are associating
	// it with an ESX 2.x server, do not use spaces in the name.
	//
	// Reconfigure privilege: VirtualMachine.Config.Rename
	Name string

	// Specifies that this VM will use nested hardware-assisted virtualization.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	//
	// Since vSphere API 5.1
	NestedHVEnabled bool

	// Deprecated.
	// from vSphere 5.5, shaping policy on VM is not supported.
	//
	//
	// Resource limits for network.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	NetworkShaper *VirtualMachineNetworkShaperInfo

	// The NPIV node WWNs to be extended from the original list of WWN nummbers. This
	// property should be set to desired number which is an aggregate of existing
	// plus new numbers. Desired Node WWNs should always be greater than the existing
	// number of node WWNs
	//
	// Since vSphere API 4.0
	NpivDesiredNodeWwns int16

	// The NPIV port WWNs to be extended from the original list of WWN nummbers. This
	// property should be set to desired number which is an aggregate of existing
	// plus new numbers. Desired Node WWNs should always be greater than the existing
	// number of port WWNs
	//
	// Since vSphere API 4.0
	NpivDesiredPortWwns int16

	// The NPIV node WWN to be assigned to a virtual machine.  This property should only
	// be used or set when the value of npivWorldWideNameOp property is "set".
	// Otherwise, an InvalidVmConfig fault will be thrown. If the
	// specified node WWN is currently being used by another virtual machine, a
	// VmWwnConflict fault will be thrown.
	//
	// For detail description on WWN, see npivNodeWorldWideName.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	//
	// Since VI API 2.5
	NpivNodeWorldWideName []int64

	// This property is used to check whether the NPIV can be enabled on the Virtual
	// machine with non-rdm disks in the configuration, so this is potentially not
	// enabling npiv on vmfs disks. Also this property is used to check whether RDM
	// is required to generate WWNs for a virtual machine.
	//
	// Since vSphere API 4.0
	NpivOnNonRdmDisks bool

	// The NPIV port WWN to be assigned to a virtual machine.  This property should only
	// be used or set when the value of npivWorldWideNameOp property is "set".
	// Otherwise, an InvalidVmConfig fault will be thrown. If the
	// specified port WWN is currently being used by another virtual machine, a
	// VmWwnConflict fault will be thrown.
	//
	// For detail description on WWN, see npivPortWorldWideName.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	//
	// Since VI API 2.5
	NpivPortWorldWideName []int64

	// This property is used to enable or disable the NPIV capability on a desired
	// virtual machine on a temporary basis. When this property is set NPIV Vport
	// will not be instantiated by the VMX process of the Virtual Machine. When this
	// property is set port WWNs and node WWNs in the VM configuration are preserved.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	//
	// Since vSphere API 4.0
	NpivTemporaryDisabled bool

	// The flag to indicate what type of NPIV WWN operation is going to be performed
	// on the virtual machine.  If unset, it indicates no change to existing NPIV WWN
	// assignment (or not assigned) in the virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.See NpivWwnOp
	//
	// Since VI API 2.5
	NpivWorldWideNameOp string

	// This property is used internally in the communication between the
	// VirtualCenter server and ESX Server to indicate the source for
	// npivNodeWorldWideName and
	// npivPortWorldWideName when npivWorldWideNameOp is "set".
	// This property should only be set by the VirtualCenter server.
	//
	// If this property is set in a call to a VirtualCenter server,
	// an InvalidVmConfig fault will always be thrown.  In a
	// call to an ESX Server host, an InvalidVmConfig
	// fault will be thrown if the value of npivWorldWideNameOp is not set to
	// "set".
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	//
	// Since VI API 2.5
	NpivWorldWideNameType string

	// Number of cores among which to distribute
	// CPUs in this virtual machine.
	//
	// Since vSphere API 5.0
	NumCoresPerSocket int32

	// Number of virtual processors in a virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.CpuCount
	NumCPUs int32

	// Configuration for default power operations.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	PowerOpInfo *VirtualMachineDefaultPowerOpInfo

	// Configuration of scheduled hardware upgrades.See ScheduledHardwareUpgradeInfo
	//
	// Since vSphere API 5.1
	ScheduledHardwareUpgradeInfo *ScheduledHardwareUpgradeInfo

	// Virtual machine swapfile placement policy. This may only be set if the
	// swapPlacementSupported
	// capability is true for this virtual machine. Any change to this policy
	// will take effect the next time the virtual machine powers on, resumes
	// from a suspended state, or migrates while powered on.
	//
	// Reconfigure privilege: VirtualMachine.Config.SwapPlacement
	// (also required when setting this property while creating a virtual machine)
	// See VirtualMachineConfigInfoSwapPlacementType
	//
	// Since VI API 2.5
	SwapPlacement string

	// Configuration of VMware Tools running in the guest operating system.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	Tools *ToolsConfigInfo

	// 128-bit SMBIOS UUID of a virtual machine represented as a hexadecimal string
	// in "12345678-abcd-1234-cdef-123456789abc" format.
	//
	// Normally, this property is not set by a client, allowing the
	// Virtual Infrastructure environment to assign a UUID when
	// the virtual machine is created. However, in some rare cases,
	// such as a manual copy of a virtual machine, it may be necessary
	// to set this property.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	Uuid string

	// Configuration of vApp meta-data for a virtual machine
	//
	// Since vSphere API 4.0
	VAppConfig *VmConfigSpec

	// Set to true, if the vApp configuration should be removed
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	//
	// Since vSphere API 4.0
	VAppConfigRemoved bool

	// Indicates whether user-configured virtual asserts will be
	// triggered during virtual machine replay. This setting takes
	// effect during the next replay of the virtual machine.
	//
	// Enabling this functionality can potentially cause some
	// performance overhead during virtual machine execution.
	//
	// Since vSphere API 4.0
	VAssertsEnabled bool

	// The version string for this virtual machine. This is used only while
	// creating a new virtual machine, and can be updated by invoking
	// UpgradeVM_Task for this virtual
	// machine.
	Version string

	// Does this virtual machine have Virtual Intel I/O Controller Hub 7
	//
	// Since vSphere API 5.0
	VirtualICH7MPresent bool

	// Does this virtual machine have System Management Controller
	//
	// Since vSphere API 5.0
	VirtualSMCPresent bool

	// Virtual Machine Profile requirement.
	//
	// Profiles are solution specific.
	//
	// Profile Based Storage Management is a vSphere server extension.
	// API users who want to provision VMs using Storage Profiles, need to
	// interact with it.
	//
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	//
	// Since vSphere API 5.5
	VmProfile []*VirtualMachineProfileSpec

	// Specifies that this VM will have vurtual CPU performance counters
	// enabled.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	//
	// Since vSphere API 5.1
	VPMCEnabled bool
}

//
// The root WWN operation mode.
//
//
type VirtualMachineConfigSpecNpivWwnOp struct {
}

//
// A subset of virtual machine configuration.
//
//
type VirtualMachineConfigSummary struct {
	*DynamicData

	// Description for the virtual machine.
	Annotation string

	// Configured CPU reservation in MHz
	CpuReservation int32

	// Fault Tolerance settings for this virtual machine.
	// This property will be populated only for fault tolerance virtual
	// machines and will be left unset for all other virtual machines.
	// See FaultToleranceConfigInfo for a description.
	//
	// Since vSphere API 4.0
	FtInfo *FaultToleranceConfigInfo

	// Guest operating system name configured on the virtual machine.
	GuestFullName string

	// Guest operating system identifier (short name).
	GuestId string

	// Whether the VM requires a reboot to finish installation. False if no vApp
	// meta-data is configured.
	//
	// Since vSphere API 4.0
	InstallBootRequired bool

	// VC-specific identifier of the virtual machine
	//
	// Since vSphere API 4.0
	InstanceUuid string

	// Specifies that this VM is managed by a VC Extension. See the
	// managedBy property in the ConfigSpec
	// for more details.
	//
	// Since vSphere API 5.0
	ManagedBy *ManagedByInfo

	// Configured Memory reservation in MB
	MemoryReservation int32

	// Memory size of the virtual machine, in megabytes.
	MemorySizeMB int32

	// Name of the virtual machine.
	Name string

	// Number of processors in the virtual machine.
	NumCpu int32

	// Number of virtual network adapters.
	NumEthernetCards int32

	// Number of virtual disks attached to the virtual machine.
	NumVirtualDisks int32

	// Product information. References to properties in the URLs are expanded.
	//
	// Since vSphere API 4.0
	Product *VAppProductInfo

	// Flag to determine whether or not this virtual machine is a template.
	Template bool

	// Virtual machine BIOS identification.
	Uuid string

	// Path name to the configuration file for the virtual machine
	VmPathName string
}

//
// The connectivity state of a virtual machine. When the API is provided directly by
// a server product, such as ESX Server, then the disconnected state is not
// possible. However, when accessed through VirtualCenter, the state of a virtual
// machine is set to disconnected if the hosts that manage the virtual
// machine becomes unavailable.
//
//
type VirtualMachineConnectionState struct {
}

//
// Preferences for the legacy console application that affect the way it behaves during power
// operations on the virtual machine.
//
//
type VirtualMachineConsolePreferences struct {
	*DynamicData

	// Close the console application when the virtual machine is powered off
	// or suspended.
	CloseOnPowerOffOrSuspend bool

	// Enter full screen mode when this virtual machine is powered on.
	EnterFullScreenOnPowerOn bool

	// Power on the virtual machine when it is opened in the console.
	PowerOnWhenOpened bool
}

//
// Wrapper class to support incremental updates of the cpuFeatureMask.
//
//
type VirtualMachineCpuIdInfoSpec struct {
	*ArrayUpdateSpec

	Info *HostCpuIdInfo
}

//
// DatastoreInfo describes a datastore that a virtual disk can be
// stored on.
//
//
type VirtualMachineDatastoreInfo struct {
	*VirtualMachineTargetInfo

	// Information about the datastore capabilities
	Capability *DatastoreCapability

	// Information about the datastore
	Datastore *DatastoreSummary

	// The maximum size of a file that can reside on this datastore.
	MaxFileSize int64

	// The maximum capacity of a virtual disk which can be created on this volume
	//
	// Since vSphere API 5.5
	MaxVirtualDiskCapacity int64

	// Access mode for this datastore. This is either
	// readOnly or readWrite. A virtual disk needs to be
	// stored on readWrite datastore. ISOs can be read
	// from a readOnly datastore.See HostMountMode
	Mode string

	// Indicate the states of vStorage hardware acceleration
	// support for this datastore.
	// See FileSystemMountInfoVStorageSupportStatus
	//
	// Since vSphere API 5.0
	VStorageSupport string
}

//
// This data object type describes a file system volume option for this
// virtual machine.
//
//
type VirtualMachineDatastoreVolumeOption struct {
	*DynamicData

	// The type name of the file system volume information object for this
	// option.See HostFileSystemVolumeInfo
	FileSystemType string

	// The major version of the file system volume information for this
	// option. If not specified, all versions of this file system are included
	// in this option. Currently, this value is set only for VMFS volumes.
	MajorVersion int32
}

//
// The DefaultPowerOpInfo data object type holds the configured defaults for the power
// operations on a virtual machine. The properties indicated whether to do a "soft"
// or guest initiated operation, or a "hard" operation.
//
//
type VirtualMachineDefaultPowerOpInfo struct {
	*DynamicData

	// Default operation for power off: soft or hard
	DefaultPowerOffType string

	// Default operation for reset: soft or hard
	DefaultResetType string

	// Default operation for suspend: soft or hard
	DefaultSuspendType string

	// Describes the default power off type for this virtual machine.
	// The possible values are specified by the PowerOpType.
	//
	// hard - Perform power off by using the PowerOff method.
	// soft - Perform power off by using the ShutdownGuest method.
	// preset - The preset value is specified in the defaultPowerOffType
	// section.
	//
	// This setting is advisory and clients can choose to ignore it.
	PowerOffType string

	// Describes the default reset type for this virtual machine.
	// The possible values are specified by the PowerOpType.
	//
	// hard - Perform reset by using the Reset method.
	// soft - Perform reset by using the RebootGuest method.
	// preset - The preset value is specified in the defaultResetType
	// section.
	//
	// This setting is advisory and clients can choose to ignore it.
	ResetType string

	// Behavior of virtual machine when it receives the S1 ACPI call.
	StandbyAction string

	// Describes the default suspend type for this virtual machine.
	// The possible values are specified by the PowerOpType.
	//
	// hard - Perform suspend by using the Suspend method.
	// soft - Perform suspend by using the StandbyGuest method.
	// preset - The preset value is specified in the defaultSuspendType
	// section.
	//
	// This setting is advisory and clients can choose to ignore it.
	SuspendType string
}

//
// Policy specification that carries a pre-defined Storage Policy to be associated
// with a Virtual Machine Home or a Virtual Disk object. Such a pre-defined
// policy can be either be vSphere Storage Administrator defined or may come
// from a set of pre-defined policies from Storage Vendor.
//
//
// Neither the association nor the policy data is persisted in Virtual Machine
// configuration. This data is managed by the an extension of Virtual Center
// (Storage Policy Based Management).
//
//
//
//
//
type VirtualMachineDefinedProfileSpec struct {
	*VirtualMachineProfileSpec

	// Profile data sent to the Storage Backend by vSphere.
	//
	// This data is provided by the SPBM component of the vSphere platform.
	// This field should not be set by Virtual Center users.
	ProfileData *VirtualMachineProfileRawData

	// Storage Policy Profile identification - Should be
	// pbm.profileId but for implementation reasons, could not be.
	ProfileId string
}

//
// The DeviceRuntimeInfo data object type provides information about
// the execution state of a single virtual device.
//
//
type VirtualMachineDeviceRuntimeInfo struct {
	*DynamicData

	// The device key.
	Key int32

	// The device runtime state.
	RuntimeState *VirtualMachineDeviceRuntimeInfoDeviceRuntimeState
}

//
// Runtime state of a device.  Subclassed for information that is specific
// to certain device types.
//
//
type VirtualMachineDeviceRuntimeInfoDeviceRuntimeState struct {
	*DynamicData
}

//
// Runtime state of a virtual ethernet card device.
//
//
type VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState struct {
	*VirtualMachineDeviceRuntimeInfoDeviceRuntimeState

	// The status indicating whether network reservation requirement is violated
	// or not on the virtual network adapter. See ManagedEntityStatus
	// for possible values.
	//
	// red indicates that reservation specified on the virtual
	// network adapter is not being fulfilled. This can happen if the reservation requested is
	// greater than the available capacity reserved for virtual machine traffic on the host.
	//
	// green indicates that the reservation specified on the
	// virtual network adapter is being fulfilled.
	//
	// Since vSphere API 5.5
	ReservationStatus string

	// Flag to indicate whether VMDirectPath Gen 2 is active on this device.
	// If false, the reason(s) for inactivity will be provided in one or
	// more of vmDirectPathGen2InactiveReasonVm,
	// vmDirectPathGen2InactiveReasonOther,
	// and vmDirectPathGen2InactiveReasonExtended.
	VmDirectPathGen2Active bool

	// If vmDirectPathGen2Active is false, this property may
	// contain an explanation provided by the platform, beyond the reasons
	// (if any) enumerated in vmDirectPathGen2InactiveReasonVm
	// and/or vmDirectPathGen2InactiveReasonOther.
	VmDirectPathGen2InactiveReasonExtended string

	// If vmDirectPathGen2Active is false, this array will be
	// populated with reasons for the inactivity that are not related to
	// virtual machine state or configuration (chosen from
	// VmDirectPathGen2InactiveReasonOther). Virtual machine
	// related reasons for inactivity will be provided in
	// vmDirectPathGen2InactiveReasonVm. If there is a reason
	// for inactivity that cannot be described by the available constants,
	// vmDirectPathGen2InactiveReasonExtended will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.See vmDirectPathGen2Supported
	VmDirectPathGen2InactiveReasonOther []string

	// If vmDirectPathGen2Active is false, this array will be
	// populated with reasons for the inactivity that are related to virtual
	// machine state or configuration (chosen from
	// VmDirectPathGen2InactiveReasonVm). Other reasons for
	// inactivity will be provided in
	// vmDirectPathGen2InactiveReasonOther. If there is a reason
	// for inactivity that cannot be described by the available constants,
	// vmDirectPathGen2InactiveReasonExtended will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.
	VmDirectPathGen2InactiveReasonVm []string
}

type VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther struct {
}

type VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm struct {
}

//
// The DiskDeviceInfo class contains basic information about a specific disk hardware
// device.
//
//
type VirtualMachineDiskDeviceInfo struct {
	*VirtualMachineTargetInfo

	// Size of disk
	Capacity int64

	// List of known virtual machines using this physical disk as a backing
	Vm []*VirtualMachine
}

//
// This data object defines a two-dimensional, rectangular
// display area.
//
//
type VirtualMachineDisplayTopology struct {
	*DynamicData

	// The height of the display rectangle.
	Height int32

	// The width of the display rectangle.
	Width int32

	// The x co-ordinate defining the start of the display rectangle.
	X int32

	// The y co-ordinate defining the start of the display rectangle.
	Y int32
}

//
// Specifies an empty Storage Policy for a Virtual Machine Home or a
// Virtual Disk object.
//
// The object is left without any profile association, and hence has no
// explicit policy driven requirements.
// This implies that object's policy driven SLAs are always met trivially.
//
//
//
type VirtualMachineEmptyProfileSpec struct {
	*VirtualMachineProfileSpec
}

//
// The FaultToleranceState type defines a simple set of states for a
// fault tolerant virtual machine:
// disabled, starting, and enabled.
//
//
//
//
type VirtualMachineFaultToleranceState struct {
}

//
// Feature requirement contains a key, featureName and an opaque value
//
//
type VirtualMachineFeatureRequirement struct {
	*DynamicData

	// Name of the feature. Identical to the key.
	FeatureName string

	// Accessor name to the feature requirement test
	Key string

	// Opaque value for the feature operation. Operation is contained
	// in the value.
	Value string
}

//
// The FileInfo data object type contains the locations of virtual machine
// files other than the virtual disk files. The configurable parameters
// are all in the FileInfo object.
//
// The object also contains a FileLayout object that returns a complete
// list of additional files that makes up the virtual machine
// configuration. This is a read-only structure and is returned when
// the configuration is read. This is ignored during configuration and
// can be left out.
//
//
//
type VirtualMachineFileInfo struct {
	*DynamicData

	// Directory to store the log files for the virtual machine. If not specified,
	// this defaults to the same directory as the configuration file,
	LogDirectory string

	// Path name of the directory that holds suspend and snapshot files
	// belonging to the virtual machine. Prior to vSphere 5.0, this
	// directory also holds snapshot redo files. Starting with vSphere 5.0,
	// the redo files will stay in the same directory as the snapshotted
	// disk, thus this directory will no longer hold the snapshot redo
	// files.
	//
	// This path name defaults to the same directory as the configuration
	// file.
	//
	// ESX Server requires this to indicate a VMFS volume or NAS volume
	// (for ESX Server 3).
	// In case the configuration file is not stored on VMFS or NAS, this
	// property must be set explicitly.
	SnapshotDirectory string

	// Some products allow the suspend directory to be different than the
	// snapshot directory. On products where this is not possible, setting
	// of this property is ignored.
	SuspendDirectory string

	// Path name to the configuration file for the virtual machine, e.g., the
	// .vmx file. This also implicitly defines the configuration directory.
	VmPathName string
}

// Deprecated.
// As of vSphere API 4.0, use VirtualMachineFileLayoutEx instead.
//
//
// Describes the set of files that makes up a virtual machine on disk. The
// file layout is broken into 4 major sections:
//
//
// • Configuration: Files stored in the configuration directory
//
// • Log: Files stored in the log directory
//
// • Disk: Files stored relative to a disk configuration file
//
// • Snapshot: Stored in the snapshot directory
//
//
//
// Often the same directory is used for configuration, log, disk and
// snapshots.
//
//
//
//
type VirtualMachineFileLayout struct {
	*DynamicData

	// A list of files that makes up the configuration of the virtual machine
	// (excluding the .vmx file, since that file is represented in the
	// FileInfo). These are relative paths from the configuration directory. A
	// slash is always used as a separator. This list will typically include the
	// NVRAM file, but could also include other meta-data files.
	ConfigFile []string

	// Files making up each virtual disk.
	Disk []*VirtualMachineFileLayoutDiskLayout

	// A list of files stored in the virtual machine's log directory. These are
	// relative paths from the logDirectory. A slash is always used as a
	// separator.
	LogFile []string

	// Files of each snapshot.
	Snapshot []*VirtualMachineFileLayoutSnapshotLayout

	// The swapfile specific to this virtual machine, if any. This is a
	// complete datastore path, not a relative path.
	SwapFile string
}

//
// Enumerats the set of files for each virtual disk.
//
//
type VirtualMachineFileLayoutDiskLayout struct {
	*DynamicData

	// List of files that makes up the virtual disk. At least one entry
	// always exists in this array. The first entry is the main
	// descriptor of the virtual disk (the one used when adding the
	// disk to a virtual machine). These are complete datastore paths, not
	// relative paths.
	DiskFile []string

	// Identification of the disk in config.
	Key int32
}

//
// Detailed description of files that make up a virtual machine on disk. The
// file layout is broken into 4 major sections:
//
//
// • Configuration: Files stored in the configuration directory
//
// • Log: Files stored in the log directory
//
// • Disk: Files stored relative to a disk configuration file
//
// • Snapshot: Stored in the snapshot directory
//
//
//
// Often the same directory is used for configuration, log, disk and
// snapshots.
//
//
type VirtualMachineFileLayoutEx struct {
	*DynamicData

	// Layout of each virtual disk attached to the virtual machine.
	//
	// For a virtual machine with snaphots, this property gives only those disks
	// that are attached to it at the current point of running.
	Disk []*VirtualMachineFileLayoutExDiskLayout

	// Information about all the files that constitute the virtual machine
	// including configuration files, disks, swap file, suspend file, log files,
	// core files, memory file etc. VirtualMachineFileLayoutExFileType lists the
	// different file-types that make a virtual machine.
	File []*VirtualMachineFileLayoutExFileInfo

	// Layout of each snapshot of the virtual machine.
	Snapshot []*VirtualMachineFileLayoutExSnapshotLayout

	// Time when values in this structure were last updated.
	Timestamp time.Time
}

//
// Layout of a virtual disk, including the base- and delta- disks.
//
// A virtual disk typically is made up of a chain of disk-units.
//
//
//
type VirtualMachineFileLayoutExDiskLayout struct {
	*DynamicData

	// The disk-unit chain that makes up this virtual disk.
	Chain []*VirtualMachineFileLayoutExDiskUnit

	// Identifier for the virtual disk in device.
	Key int32
}

//
// Information about a single unit of a virtual disk, such as
// the base-disk or a delta-disk.
//
// A disk-unit consists of at least one descriptor
// file, and zero or more extent files.
//
//
// Sometimes, a disk-unit is also referred to as a backing.
//
//
//
type VirtualMachineFileLayoutExDiskUnit struct {
	*DynamicData

	// Array of keys of the files that make up the disk unit. Values here
	// correspond to property key in
	// file.
	//
	// At least one entry always exists in this array. Property
	// type of the referenced file
	// can be used to distinguish the disk descriptor (type diskDescriptor) from the extents.
	FileKey []int32
}

//
// Basic information about a file.
//
//
type VirtualMachineFileLayoutExFileInfo struct {
	*DynamicData

	// Key to reference this file.
	Key int32

	// Name of the file, including the complete datastore path.
	Name string

	// Size of the file in bytes.
	Size int64

	// Type of the file. VirtualMachineFileLayoutExFileType lists
	// all valid values.
	Type string

	// Size of the file in bytes corresponding to the file blocks
	// that were allocated uniquely. In other words, if the underlying
	// storage supports sharing of file blocks across disk files, the
	// property corresponds to the size of the file blocks that were
	// allocated only in context of this file, i.e. it does not include
	// shared blocks that were allocated in other files.
	//
	// This property will be unset if the underlying implementation
	// is unable to compute this information. One example of this
	// is when the file resides on a NAS datastore whose underlying
	// storage doesn't support this metric. In some cases the field
	// might be set but the value could be over-estimated due to
	// the inability of the NAS based storage to provide an
	// accurate value.
	//
	// Since vSphere API 5.1
	UniqueSize int64
}

//
// File-type constants.
//
//
type VirtualMachineFileLayoutExFileType struct {
}

//
// Layout of a snapshot.
//
//
type VirtualMachineFileLayoutExSnapshotLayout struct {
	*DynamicData

	// Key to the snapshot data file in file.
	DataKey int32

	// Layout of each virtual disk of the virtual machine when the
	// snapshot was taken.
	Disk []*VirtualMachineFileLayoutExDiskLayout

	// Reference to the snapshot.
	Key *VirtualMachineSnapshot
}

//
// Enumerates the set of files that make up a snapshot or redo-point
//
//
type VirtualMachineFileLayoutSnapshotLayout struct {
	*DynamicData

	// Identification of the snapshot
	Key *VirtualMachineSnapshot

	// A list of files that make up the snapshot state. These are relative
	// paths from the snapshotDirectory. A slash is always used as a
	// separator.
	SnapshotFile []string
}

//
// The FlagInfo data object type encapsulates the flag settings
// for a virtual machine.
// These properties are optional since the same structure
// is used to change the values during an edit or create operation.
//
//
type VirtualMachineFlagInfo struct {
	*DynamicData

	// Flag to turn off video acceleration for a virtual machine console window.
	DisableAcceleration bool

	// Indicates whether disk UUIDs are being used by this virtual machine.
	// If this flag is set to false, disk UUIDs are not exposed to the guest.
	//
	// Since products before ESX 3.1 do not support disk UUIDs, moving virtual
	// machines from a platform that supports UUID to a platform that does
	// not support UUIDs could result in unspecified guest behavior. For
	// virtual machines where the ability to move to older platforms is
	// important, this flag should be set to false. If the value is unset,
	// the behavior 'false' will be used.
	//
	// Since VI API 2.5
	DiskUuidEnabled bool

	// Flag to enable logging for a virtual machine.
	EnableLogging bool

	// Specifies how the VCPUs of a virtual machine are allowed to
	// share physical cores on a hyperthreaded system. Two VCPUs are
	// "sharing" a core if they are both running on logical CPUs of
	// the core at the same time.See VirtualMachineHtSharing
	HtSharing string

	// vmx process type. See VirtualMachineFlagInfoMonitorType
	// for possible values for this property.
	//
	// Since VI API 2.5
	MonitorType string

	// Flag to specify whether record and replay operations are
	// allowed for this virtual machine.
	//
	// If this flag is set to 'true', instruction virtualization
	// will use hardware virtualization (HV) support. I.e.,
	// virtualExecUsage will be set to 'hvOn'.
	//
	// If this flag is set to 'false' for a virtual machine that
	// already has a recording, replay will be disallowed, though
	// the recording will be preserved.
	//
	// If the value is unset, the behavior 'false' will be used.
	//
	// Since vSphere API 4.0
	RecordReplayEnabled bool

	// Deprecated.
	// As of VI API 2.5, use monitorType.
	//
	//
	// Flag to specify whether or not to run in debug mode.
	RunWithDebugInfo bool

	// Deprecated.
	// As of vSphere API 4.0. The flag is ignored by the server.
	//
	//
	// Flag to specify whether snapshots are disabled for this virtual
	// machine.
	//
	// Since VI API 2.5
	SnapshotDisabled bool

	// Flag to specify whether the snapshot tree is locked for this virtual machine.
	//
	// Since VI API 2.5
	SnapshotLocked bool

	// Specifies the power-off behavior for a virtual machine that has
	// a snapshot.  If the value is unset, the behavior 'powerOff' will
	// be used.See VirtualMachinePowerOffBehavior
	//
	// Since VI API 2.5
	SnapshotPowerOffBehavior string

	// Flag to specify whether or not to use TOE (TCP/IP Offloading).
	UseToe bool

	// Indicates whether or not the system will try to use Hardware
	// Virtualization (HV) support for instruction virtualization,
	// if available.
	//
	// By default, VMware software will determine whether or not
	// to use hardware virtualization support based on various factors such
	// as the guest operating system type and the physical hardware.
	// Certain workloads can benefit from explicitly turning
	// hardware virtualization support on or off.
	// If the value is unset, the value will default to hvAuto.
	//
	// VirtualMachineFlagInfoVirtualExecUsage represents the set of
	// possible values.
	//
	// New processors can enable two hardware acceleration technologies
	// for virtualization, one for instruction virtualization and the
	// other for MMU virtualization. Intel names its hardware-assisted
	// instruction virtualization as VT, and its hardware-assisted
	// MMU virtualization as EPT. AMD calls them as AMD-V and RVI,
	// respectively. For details on these technologies, please refer
	// to documents from the processor vendors.
	//
	// virtualExecUsage controls instruction
	// virtualization; while virtualMmuUsage
	// controls MMU virtualization. "On" allows hardware acceleration,
	// while "off" only allows software solution.
	//
	// There are four meaningful combinations.
	//
	// (hvAuto, automatic) - The host chooses which feature to use.
	// (hvOn, on)          - Use both VT/AMD-V and EPT/RVI.
	// (hvOn, off)         - Use VT/AMD-V but do not use EPT/RVI.
	// (hvOff, off)        - Do not use any of these hardware acceleration technologies.
	//
	// Since vSphere API 4.0
	VirtualExecUsage string

	// Indicates whether or not the system will try to use nested page
	// table hardware support, if available.
	//
	// By default, VMware software will determine whether or not
	// to use nested page table hardware support based on various factors such
	// as the guest operating system type and the physical hardware.
	// Certain workloads can benefit from explicitly turning
	// nested page table hardware support on or off; this can be set using
	// nptUsage flag.
	// If the value is unset, the value will default to automatic.
	//
	// VirtualMachineFlagInfoVirtualMmuUsage represents the set of
	// possible values.
	//
	// Since VI API 2.5
	VirtualMmuUsage string
}

//
// Set of possible values for monitorType.
//
//
type VirtualMachineFlagInfoMonitorType struct {
}

//
// Set of possible values for virtualExecUsage.
//
//
type VirtualMachineFlagInfoVirtualExecUsage struct {
}

//
// Set of possible values for virtualMmuUsage.
//
//
type VirtualMachineFlagInfoVirtualMmuUsage struct {
}

//
// FloppyInfo class contains information about a physical floppy
// drive on the host.
//
//
type VirtualMachineFloppyInfo struct {
	*VirtualMachineTargetInfo
}

//
// Guest operating system family constants.
//
//
type VirtualMachineGuestOsFamily struct {
}

//
// Guest operating system identifier.
//
//
type VirtualMachineGuestOsIdentifier struct {
}

//
// The possible hints that the guest could display about current tasks
// inside the guest.
//
//
type VirtualMachineGuestState struct {
}

//
// A subset of virtual machine guest information.
//
//
type VirtualMachineGuestSummary struct {
	*DynamicData

	// Guest operating system name configured on the virtual machine.
	GuestFullName string

	// Guest operating system identifier (short name), if known.
	GuestId string

	// Hostname of the guest operating system, if known.
	HostName string

	// Primary IP address assigned to the guest operating system, if known.
	IpAddress string

	// Current running status of VMware Tools in the guest operating system,
	// if known.
	//
	// Since vSphere API 4.0
	ToolsRunningStatus string

	// Deprecated.
	// As of vSphere API 5.0 use toolsVersionStatus2 and
	// toolsRunningStatus.
	//
	//
	// Current status of VMware Tools in the guest operating system, if known.
	ToolsStatus *enum.VirtualMachineToolsStatus

	// Deprecated.
	// As of vSphere API 5.0 use toolsVersionStatus2.
	//
	//
	// Current version status of VMware Tools in the guest operating system,
	// if known.
	//
	// Since vSphere API 4.0
	ToolsVersionStatus string

	// Current version status of VMware Tools in the guest operating system,
	// if known.
	//
	// Since vSphere API 5.0
	ToolsVersionStatus2 string
}

//
// Set of possible values for htSharing.
//
//
type VirtualMachineHtSharing struct {
}

//
// The IdeDiskDeviceInfo class contains detailed information about a specific
// IDE disk hardware device. These devices are for the
// vim.vm.device.VirtualDisk.RawDiskVer2BackingInfo and
// vim.vm.device.VirtualDisk.PartitionedRawDiskVer2BackingInfo backings.
//
//
type VirtualMachineIdeDiskDeviceInfo struct {
	*VirtualMachineDiskDeviceInfo

	PartitionTable []*VirtualMachineIdeDiskDevicePartitionInfo
}

//
// Describes the partition sizes
//
//
type VirtualMachineIdeDiskDevicePartitionInfo struct {
	*DynamicData

	// Size of partition
	Capacity int32

	// Identification of the partition
	Id int32
}

//
// A VmImportSpec is used by ResourcePool.importVApp when importing entities.
//
// It provides all information needed to import a VirtualMachine. So far,
// this coincides with VirtualMachineConfigSpec.
//
//
// A VmImportSpec can be contained in a VirtualAppImportSpec as part of
// the ImportSpec for an entity.
//
//
// See also ImportSpec.
//
//
//
type VirtualMachineImportSpec struct {
	*ImportSpec

	// Configuration for the virtual machine.
	ConfigSpec *VirtualMachineConfigSpec

	// Deprecated.
	// As of vSphere API 5.1.
	//
	//
	// If specified, this resource pool will be used as the parent resource pool and the
	// virtual machine will be made a linked child to the parent vApp. This field is ignored
	// for the root node in an ImportSpec tree.
	//
	// Since vSphere API 4.1
	ResPoolEntity *ResourcePool
}

//
// The LegacyNetworkSwitchInfo data object type contains information about
// the legacy network switches available on the host.
//
//
// •  VMware Server - Options available for the "custom" NetworkBackingType.
//
// •  ESX Server - The "esxnet" NetworkBackingType.
//
//
//
//
//
type VirtualMachineLegacyNetworkSwitchInfo struct {
	*DynamicData

	// The name of the network switch.
	Name string
}

//
// Means for allocating additional memory for virtual machines.
//
//
type VirtualMachineMemoryAllocationPolicy struct {
}

//
// The VirtualMachineReservationInfo data object type describes the
// amount of memory that is being reserved for virtual machines on
// the host, and how additional memory may be acquired.
//
//
type VirtualMachineMemoryReservationInfo struct {
	*DynamicData

	// Policy for allocating additional memory for virtual machines.See AllocationPolicy
	AllocationPolicy string

	// The maximum amount of memory reserved for all running virtual machines,
	// in bytes.
	VirtualMachineMax int64

	// The minimum amount of memory reserved for all running virtual machines,
	// in bytes.
	VirtualMachineMin int64

	// The amount of memory reserved for all running virtual machines,
	// in bytes.
	VirtualMachineReserved int64
}

//
// The VirtualMachineReservationSpec data object specifies
// configurable parameters for virtual machine memory reservation.
//
//
type VirtualMachineMemoryReservationSpec struct {
	*DynamicData

	// Policy for allocating additional memory for virtual machines.See VirtualMachineReservationInfo.AllocationPolicy
	AllocationPolicy string

	// The amount of memory reserved for all running virtual machines, in
	// bytes.
	VirtualMachineReserved int64
}

//
// Message data which is intended to be displayed according
// to the locale of a client.
//
// A VirtualMachineMessage contains both a formatted, localized version of the
// text and the data needed to perform localization in conjunction
// with localization catalogs.
//
//
// Clients of the VIM API may use
// SessionManager.SetLocale
// to cause the server to emit localized text, or may perform
// client-side localization based on message catalogs provided by the
// LocalizationManager.
//
//
// Message variables are always integers, e.g. {1} and {2}, which are
// 1-based indexes into argument.
//
//
//
//
// • The corresponding argument may be a recursive lookup:
//
//
// • argument = ["button.cancel", "msg.revert"]
//
// • CATALOG(locmsg, id) = "Select '{1}' to {2}"
//
// • CATALOG(locmsg, button.cancel) = "Cancel"
//
// • CATALOG(locmsg, msg.revert) = "revert"
//
// • ==&gt; text = "Select 'Cancel' to revert"
//
//
//
//
//
// • If the recursive lookup fails, the argument is a plain string.
//
//
// • argument = ["127.0.0.1"]
//
// • CATALOG(locmsg, id) = "IP address is {1}"
//
// • ==&gt; text "IP address is 127.0.0.1"
//
//
//
//
//
//
// See LocalizationManager
//
//
type VirtualMachineMessage struct {
	*DynamicData

	// Substitution arguments for variables in the localized message.
	//
	// Substitution variables in the format string identified by id
	// are 1-based indexes into this array. Substitution variable {1}
	// corresponds to argument[0], etc.
	Argument []interface{}

	// A unique identifier for this particular message.
	//
	// This field is a key for looking up format strings in the locmsg
	// catalog.
	Id string

	// Text in session locale.
	// Use SessionManager.SetLocale to
	// change the session locale.
	//
	// Since vSphere API 4.0
	Text string
}

//
// VmMetadata is a pair of VM ID and opaque metadata.
//
//
type VirtualMachineMetadataManagerVmMetadata struct {
	*DynamicData

	// Opaque metadata for the VM identified by vmId. If no
	// value is supplied, the entry for this VM is removed.
	Metadata string

	// Datastore URL-based ID for VM, for example,
	// "[datastore1] SomeVM/SomeVM.vmx".
	VmId string
}

//
// VmMetadataInput specifies the operation and metadata for a
// specific VM.
//
//
type VirtualMachineMetadataManagerVmMetadataInput struct {
	*DynamicData

	// The input operation type.  The values come from VmMetadataOp
	Operation string

	// the VM and optional metadata
	VmMetadata *VirtualMachineMetadataManagerVmMetadata
}

//
// This enum represents the set of legal operations
//
//
type VirtualMachineMetadataManagerVmMetadataOp struct {
}

//
// VmMetadataOwner defines the namespace for an owner
//
//
type VirtualMachineMetadataManagerVmMetadataOwner struct {
	*DynamicData

	// A string representing the owner. Valid values come
	// from Owner for vSAN datastores.  Otherwise, the
	// owner field is interpreted by the implementation based on
	// the datastore type.
	Name string
}

//
// This enum contains a list of valid owner values for
// the name field
//
//
type VirtualMachineMetadataManagerVmMetadataOwnerOwner struct {
}

//
// A list of VmMetadataResults are returned for successful and
// non-successful results of an update or retrieve operation.See MetadataManager#updateMetadata(VmMetadataOwner,See MetadataManager#retrieveMetadata(VmMetadataOwner,See MetadataManager#retrieveAllMetadata(VmMetadataOwner,See MetadataManager#clearMetadata(VmMetadataOwner,
//
//
type VirtualMachineMetadataManagerVmMetadataResult struct {
	*DynamicData

	// MethodFault set for errors in getting or setting
	// the VmMetadata.
	Error *LocalizedMethodFault

	// The VM-specific metadata
	VmMetadata *VirtualMachineMetadataManagerVmMetadata
}

// Deprecated.
// As of vSphere API 4.1, use VirtualMachineTicket
// instead.
//
//
// This data object contains the information needed to establish an MKS
// (mouse-keyboard-screen) connection to a running virtual machine.
//
//
type VirtualMachineMksTicket struct {
	*DynamicData

	// The name of the configuration file for the virtual machine.
	CfgFile string

	// The host with which to establish a connection. If the host is not specified,
	// it is assumed that the requesting entity knows the appropriate host with which
	// to connect.
	Host string

	// The port number to use. If the port is not specified,
	// it is assumed that the requesting entity knows the appropriate port to
	// use when making a new connection.
	Port int32

	// The expected thumbprint of the SSL cert of the host to which
	// we are connecting.
	//
	// Since VI API 2.5
	SslThumbprint string

	// The ticket name. This is used as the username and password for the MKS
	// connection.
	Ticket string
}

//
// MovePriority is an enumeration of values that indicate the priority of the task
// that moves a virtual machine from one host to another or one storage location
// to another. Note this priority can affect both the source and target hosts.
//
//
type VirtualMachineMovePriority struct {
}

//
// The NeedSecondaryReason type defines all reasons a virtual machine is
// in the needSecondary Fault Tolerance state following a failure.
//
//
type VirtualMachineNeedSecondaryReason struct {
}

//
// NetworkInfo describes a network that a device backing
// can attached to.
//
//
type VirtualMachineNetworkInfo struct {
	*VirtualMachineTargetInfo

	// Information about the network
	Network *NetworkSummary
}

//
// Network traffic shaping specification.
//
// Traffic shaping is used to configure the network utilization
// characteristics of a virtual machine.
//
//
//
type VirtualMachineNetworkShaperInfo struct {
	*DynamicData

	// Average bandwidth, in bits per second.
	AverageBps int64

	// Burst size, in bytes.
	BurstSize int64

	// Is the shaper enabled?
	Enabled bool

	// Peak bandwidth, in bits per second.
	PeakBps int64
}

//
// ParallelInfo class contains information about a physical parallel
// drive on the host.
//
//
type VirtualMachineParallelInfo struct {
	*VirtualMachineTargetInfo
}

//
// Description of a generic PCI device that can be attached to a virtual machine.
//
//
type VirtualMachinePciPassthroughInfo struct {
	*VirtualMachineTargetInfo

	// Details of the PCI device, including vendor, class and
	// device identification information.
	PciDevice *HostPciDevice

	// The ID of the system the PCI device is attached to.
	SystemId string
}

//
// Set of possible values for snapshotPowerOffBehavior.
//
//
type VirtualMachinePowerOffBehavior struct {
}

//
// The list of possible default power operations available for the virtual machine
//
//
type VirtualMachinePowerOpType struct {
}

//
// The PowerState type defines a simple set of states for a virtual machine:
// poweredOn, poweredOff, and suspended. This type does not model substates,
// such as when a task is running to change the virtual machine state.
// If the virtual machine is in a state with a task in progress, it
// transitions to a new state when the task completes. For example, a virtual
// machine continues to be in the poweredOn state while a suspend task
// is running, and changes to the suspended state once the task finishes.
//
// As a consequence of this approach, clients interested in monitoring
// the status of a virtual machine should typically track the
// activeTask data object in addition to the
// powerState object.
//
//
//
type VirtualMachinePowerState struct {
}

//
// The extensible data object type encapsulates additional data specific
// to Virtual Machine and its devices.
//
// This data is provided by vSphere Extensions which are integral part
// of vSphere.
//
//
// The data is not persisted in Virtual Machine configuration file but is
// stored and managed by extensions.
//
//
// Storage Profile Based Management (SPBM) will be one of the consumers of
// this data structure. SPBM will provide detailed information about
// Virtual Machine storage requirements.
//
//
//
//
//
type VirtualMachineProfileRawData struct {
	*DynamicData

	// vSphere Extension Identifier
	ExtensionKey string

	// Extension-specific additional data to be associated
	// with Virtual machine and its devices.
	ObjectData string
}

//
// The ProfileSpec data object is used to specify the Storage Policy to be
// associated with a Virtual Machine Home or a Virtual Disk.
//
//
type VirtualMachineProfileSpec struct {
	*DynamicData
}

//
// A singleton managed object that can answer questions about
// the feasibility of certain provisioning operations.
//
type VirtualMachineProvisioningChecker struct {
	*ManagedObject
}

//
// Tests the feasibility of a proposed
// MigrateVM_Task operation.
//
// Required Privileges
// System.View
//
func (mo *VirtualMachineProvisioningChecker) CheckMigrate_Task(
	_this *ManagedObjectReference, vm *VirtualMachine, host *HostSystem, pool *ResourcePool, state *enum.VirtualMachinePowerState, testType []string,
) (*Task, error) {

	return nil, nil

}

//
// Tests the feasibility of a proposed
// RelocateVM_Task operation.
//
// Required Privileges
// System.View
//
func (mo *VirtualMachineProvisioningChecker) CheckRelocate_Task(
	_this *ManagedObjectReference, vm *VirtualMachine, spec *VirtualMachineRelocateSpec, testType []string,
) (*Task, error) {

	return nil, nil

}

//
// Investigates the general VMotion compatibility of a set of virtual machines
// with a set of hosts. The virtual machine may be in any power state. Hosts
// may be in any connection state and also may be in maintenance mode.
//
// Required Privileges
// System.View
//
func (mo *VirtualMachineProvisioningChecker) QueryVMotionCompatibilityEx_Task(
	_this *ManagedObjectReference, vm []*VirtualMachine, host []*HostSystem,
) (*Task, error) {

	return nil, nil

}

//
// This data object type describes the question that is currently
// blocking a virtual machine.
//
//
type VirtualMachineQuestionInfo struct {
	*DynamicData

	// List of key-value pairs that specify possible answers.
	Choice *ChoiceOption

	// Identifier with an opaque value that specifies the pending question.
	Id string

	// The message data for the individual messages that comprise the question.
	// Only available on servers that support localization.
	//
	// Since VI API 2.5
	Message []*VirtualMachineMessage

	// Text that describes the pending question.
	Text string
}

//
// A set of statistics that are typically updated with near real-time regularity.
// This data object type does not support notification, for scalability reasons.
// Therefore, changes in QuickStats do not generate property collector updates. To
// monitor statistics values, use the statistics and alarms modules instead.
//
//
type VirtualMachineQuickStats struct {
	*DynamicData

	// The size of the balloon driver in the VM, in MB. The host will inflate the
	// balloon driver to reclaim physical memory from the VM.  This is a sign that
	// there is memory pressure on the host.
	//
	// Since vSphere API 4.0
	BalloonedMemory int32

	// The amount of compressed memory currently consumed by VM, in Kb.
	//
	// Since vSphere API 4.1
	CompressedMemory int64

	// The amount of consumed overhead memory, in MB, for this VM.
	//
	// Since vSphere API 4.0
	ConsumedOverheadMemory int32

	// This is the amount of CPU resource, in MHz, that this VM is entitled to, as
	// calculated by DRS. Valid only for a VM managed by DRS.
	DistributedCpuEntitlement int32

	// This is the amount of memory, in MB, that this VM is entitled to, as
	// calculated by DRS. Valid only for a VM managed by DRS.
	DistributedMemoryEntitlement int32

	// The latency status of the fault tolerance VM.
	// ftLatencyStatus is determined by the value of ftSecondaryLatency.
	// ftLatencyStatus is:
	// green,  if ftSecondaryLatency is less than or equal to 2 seconds;
	// yellow, if ftSecondaryLatency is greater than 2 seconds,
	// and less than or equal to 6 seconds;
	// red,    if ftSecondaryLatency is greater than 6 seconds;
	// gray,   if ftSecondaryLatency is unknown.
	//
	// Since vSphere API 4.0
	FtLatencyStatus *enum.ManagedEntityStatus

	// The network bandwidth used for logging between the
	// primary and secondary fault tolerance VMs.
	// The unit is kilobytes per second.
	//
	// Since vSphere API 4.0
	FtLogBandwidth int32

	// The amount of time in wallclock that the VCPU of the secondary fault
	// tolerance VM is behind the VCPU of the primary VM.
	// The unit is millisecond.
	//
	// Since vSphere API 4.0
	FtSecondaryLatency int32

	// Guest operating system heartbeat metric.
	// See guestHeartbeatStatus for a description.
	GuestHeartbeatStatus *enum.ManagedEntityStatus

	// Guest memory utilization statistics, in MB. This
	// is also known as active guest memory. The number
	// can be between 0 and the configured memory size of
	// the virtual machine. Valid while the virtual machine is
	// running.
	GuestMemoryUsage int32

	// Host memory utilization statistics, in MB. This
	// is also known as consumed host memory. This is between 0 and
	// the configured resource limit. Valid while the virtual machine is
	// running. This includes the overhead memory of the VM.
	HostMemoryUsage int32

	// Basic CPU performance statistics, in MHz.
	// Valid while the virtual machine is running.
	//
	// Since vSphere API 4.0
	OverallCpuDemand int32

	// Basic CPU performance statistics, in MHz.
	// Valid while the virtual machine is running.
	OverallCpuUsage int32

	// The portion of memory, in MB, that is granted to this VM from non-shared
	// host memory.
	//
	// Since vSphere API 4.0
	PrivateMemory int32

	// The portion of memory, in MB, that is granted to this VM from host memory
	// that is shared between VMs.
	//
	// Since vSphere API 4.0
	SharedMemory int32

	// The amount of memory swapped to fast disk device such as
	// SSD, in KB.
	//
	// Since vSphere API 5.0
	SsdSwappedMemory int64

	// The static CPU resource entitlement for a virtual machine. This value is
	// calculated based on this virtual machine's resource reservations, shares
	// and limit, and doesn't take into account current usage. This is the worst
	// case CPU allocation for this virtual machine, that is, the amount of CPU
	// resource this virtual machine would receive if all virtual machines running
	// in the cluster went to maximum consumption. Units are MHz.
	//
	// Since vSphere API 4.0
	StaticCpuEntitlement int32

	// The static memory resource entitlement for a virtual machine. This value is
	// calculated based on this virtual machine's resource reservations, shares
	// and limit, and doesn't take into account current usage. This is the worst
	// case memory allocation for this virtual machine, that is, the amount of
	// memory this virtual machine would receive if all virtual machines running
	// in the cluster went to maximum consumption. Units are MB.
	//
	// Since vSphere API 4.0
	StaticMemoryEntitlement int32

	// The portion of memory, in MB, that is granted to this VM from the host's swap
	// space. This is a sign that there is memory pressure on the host.
	//
	// Since vSphere API 4.0
	SwappedMemory int32

	// The system uptime of the VM in seconds.
	//
	// Since vSphere API 4.1
	UptimeSeconds int32
}

//
// The RecordReplayState type defines a simple set of record and replay
// states for a virtual machine.
//
//
type VirtualMachineRecordReplayState struct {
}

//
// Specifies how a virtual disk is moved or copied to a
// datastore.
//
// In all cases after the move or copy the virtual machine's current running point
// will be placed on the target datastore.  The current running point is defined
// as the disk backing which the virtual machine is currently
// writing to.  This end state can be achieved in multiple
// ways, and the supported options are described in this
// enumeration.
//
//
// These options are only relevant when the backing of the
// specified disk is a file backing.
//
//
// Since disk backings may become shared as the result of
// either a clone operation or
// a relocate operation,
// PromoteDisks_Task has been provided as
// a way to unshare such disk backings.
//
// See parentSee parentSee parentSee parentSee parentSee diskMoveTypeSee diskMoveType
//
//
//
type VirtualMachineRelocateDiskMoveOptions struct {
}

//
// Specification for moving or copying a virtual machine to a different datastore
// or host.
//
//
type VirtualMachineRelocateSpec struct {
	*DynamicData

	// The datastore where the virtual machine should be located. If
	// not specified, the current datastore is used.
	Datastore *Datastore

	// An optional list of virtual device specs that allow specifying the
	// migrate options for the relocate operation. The supported device type
	// is VirtualDisk
	//
	// For VirtualDisk device, VirtualDiskConfigSpec has to be
	// used to specify migrateCache option for disk with vFlash cache.
	//
	// Since vSphere API 5.5
	DeviceChange []*VirtualDeviceConfigSpec

	// An optional list that allows specifying the datastore location
	// for each virtual disk.
	Disk []*VirtualMachineRelocateSpecDiskLocator

	// Manner in which to move the virtual disk to the target datastore.  The set of possible values is described in
	// VirtualMachineRelocateDiskMoveOptions.
	//
	// This property applies to all the disks which the virtual machine has,
	// but can be overridden on a per-disk basis using
	// diskMoveType.
	//
	// This property can only be set if
	// deltaDiskBackingsSupported is true.
	//
	// If left unset then
	// moveAllDiskBackingsAndDisallowSharing
	// is assumed.
	//
	// Since vSphere API 4.0
	DiskMoveType string

	// The target host for the virtual machine. If not specified,
	//
	// if resource pool is not specified, current host is used.
	// if resource pool is specified, and the target pool represents
	// a stand-alone host, the host is used.
	// if resource pool is specified, and the target pool represents
	// a DRS-enabled cluster, a host selected by DRS is used.
	// if resource pool is specified and the target pool represents
	// a cluster without DRS enabled, an InvalidArgument exception
	// be thrown.
	Host *HostSystem

	// The resource pool to which this virtual machine should be attached.
	// For a relocate or clone operation to a virtual machine, if the argument
	// is not supplied, the current resource pool of virtual machine is used.
	// For a clone operation to a template, this argument is ignored.
	// For a clone operation from a template to a virtual machine,
	// this argument is required.
	Pool *ResourcePool

	// Storage profile requirement for Virtual Machine's home directory.
	//
	// Profiles are solution specific.
	//
	// Storage Profile Based Management(SPBM) is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with SPBM.
	//
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	//
	// Since vSphere API 5.5
	Profile []*VirtualMachineProfileSpec

	// Deprecated.
	// as of vSphere API 5.0. Use
	// diskBackingInfo instead for
	// disk format conversions. This setting will be ignored for
	// disks with the above property set.
	//
	//
	// Transformation to perform on the disks. The backend is free to ignore
	// this hint if it is not valid for the current operation.  This can be
	// used by clients, for example, to create sparse disks for templates.See VirtualMachineRelocateTransformation
	Transform *enum.VirtualMachineRelocateTransformation
}

//
// The DiskLocator data object type specifies a virtual disk device (by ID) and
// a datastore locator for the disk's storage.
//
//
type VirtualMachineRelocateSpecDiskLocator struct {
	*DynamicData

	// Target datastore.
	Datastore *Datastore

	// Backing information for the virtual disk at the destination.
	// This can be used, for instance, to change the format of the
	// virtual disk. If the specified backing is invalid or not
	// supported at the destination, InvalidDeviceBacking is thrown. Specific property
	// changes may be ignored if they are not supported.
	//
	// Supported BackingInfo types and properties:
	//
	// VirtualDiskFlatVer2BackingInfo
	//
	// thinProvisioned
	// eagerlyScrub
	//
	//
	// VirtualDiskSeSparseBackingInfo
	// (ESX 5.1 or later)
	//
	//
	//
	// Since vSphere API 5.0
	DiskBackingInfo *VirtualDeviceBackingInfo

	// Device ID of the virtual disk.
	DiskId int32

	// Manner in which to move the virtual disk to the target datastore.  The set of possible values is described
	// in VirtualMachineRelocateDiskMoveOptions.
	//
	// This property can only be set if deltaDiskBackingsSupported is true.
	//
	// If left unset then moveAllDiskBackingsAndDisallowSharing
	// is assumed.
	//
	// Since vSphere API 4.0
	DiskMoveType string

	// Virtual Disk Profile requirement.
	//
	// Profiles are solution specific.
	//
	// Profile Based Storage Management is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with it.
	//
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	//
	// Since vSphere API 5.5
	Profile []*VirtualMachineProfileSpec
}

// Deprecated.
// as of vSphere API 5.0.
//
//
// The set of tranformations that can be performed on the virtual disks
// as part of the copy.
//
//
type VirtualMachineRelocateTransformation struct {
}

//
// The RuntimeInfo data object type provides information about
// the execution state and history of a virtual machine.
//
//
type VirtualMachineRuntimeInfo struct {
	*DynamicData

	// The timestamp when the virtual machine was most recently powered on.
	//
	// This property is updated when the virtual machine is powered on
	// from the poweredOff state, and is cleared when the virtual machine is
	// powered off. This property is not updated when a virtual machine is resumed
	// from a suspended state.
	BootTime time.Time

	// For a powered off virtual machine, indicates whether the virtual
	// machine's last shutdown was an orderly power off or not. Unset if
	// the virtual machine is running or suspended.
	//
	// Since vSphere API 4.0
	CleanPowerOff bool

	// Indicates whether or not the virtual machine is available for management.
	ConnectionState *enum.VirtualMachineConnectionState

	// Whether any disk of the virtual machine requires consolidation.
	// This can happen for example when a snapshot is deleted but its
	// associated disk is not committed back to the base disk.
	//
	// Use ConsolidateVMDisks_Task to consolidate if
	// needed.
	//
	// Since vSphere API 5.0
	ConsolidationNeeded bool

	// The vSphere HA protection state for a virtual machine. Property
	// is unset if vSphere HA is not enabled.
	//
	// Since vSphere API 5.0
	DasVmProtection *VirtualMachineRuntimeInfoDasProtectionState

	// Per-device runtime info. This array will be empty if the host
	// software does not provide runtime info for any of the device
	// types currently in use by the virtual machine.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	//
	// Since vSphere API 4.1
	Device []*VirtualMachineDeviceRuntimeInfo

	// The fault tolerance state of the virtual machine.
	//
	// Since vSphere API 4.0
	FaultToleranceState *enum.VirtualMachineFaultToleranceState

	// The masks applied to an individual virtual machine as a result of its
	// configuration.
	//
	// Since vSphere API 5.1
	FeatureMask []*HostFeatureMask

	// These requirements must have equivalent host capabilities
	// featureCapability in order to power on,
	// resume, or migrate to the host.
	//
	// Since vSphere API 5.1
	FeatureRequirement []*VirtualMachineFeatureRequirement

	// The host that is responsible for running a virtual machine.
	// This property is null if the virtual machine is not running and is
	// not assigned to run on a particular host.
	Host *HostSystem

	// Current upper-bound on CPU usage. The upper-bound is based on the host
	// the virtual machine is current running on, as well as limits configured
	// on the virtual machine itself or any parent resource pool.
	// Valid while the virtual machine is running.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	MaxCpuUsage int32

	// Current upper-bound on memory usage. The upper-bound is based on memory
	// configuration of the virtual machine, as well as limits configured
	// on the virtual machine itself or any parent resource pool.
	// Valid while the virtual machine is running.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	MaxMemoryUsage int32

	// Deprecated.
	// As of vSphere API 4.1, use the PerformanceManager
	// memory overhead counter to get this value.
	//
	//
	// The amount of memory resource (in bytes) that will be used by
	// the virtual machine above its guest memory requirements.
	// This value is set if and only if the virtual machine is registered
	// on a host that supports memory resource allocation features.
	//
	// For powered off VMs, this is the minimum overhead required to
	// power on the VM on the registered host.
	//
	// For powered on VMs, this is the current overhead reservation, a
	// value which is almost always larger than the minimum overhead, and
	// which grows with time.
	// See QueryMemoryOverheadEx
	MemoryOverhead int64

	// For a powered-on or suspended virtual machine in a cluster with Enhanced
	// VMotion Compatibility (EVC) enabled, this identifies the least-featured
	// EVC mode (among those for the appropriate CPU vendor) that could admit
	// the virtual machine. See EVCMode. This property will
	// be unset if the virtual machine is powered off or is not in an EVC
	// cluster.
	//
	// This property may be used as a general indicator of the CPU feature
	// baseline currently in use by the virtual machine. However, the virtual
	// machine may be suppressing some of the features present in the CPU
	// feature baseline of the indicated mode, either explicitly (in the
	// virtual machine's configured
	// cpuFeatureMask) or implicitly
	// (in the default masks for the
	// GuestOsDescriptor appropriate for the
	// virtual machine's configured guest OS).
	//
	// Since vSphere API 4.1
	MinRequiredEVCModeKey string

	// If set, indicates the reason the virtual machine needs a secondary.
	//
	// Since vSphere API 4.0
	NeedSecondaryReason string

	// Number of active MKS connections to this virtual machine.
	NumMksConnections int32

	// These requirements must have equivalent host capabilities
	// featureCapability in order to power on.
	//
	// Since vSphere API 5.1
	OfflineFeatureRequirement []*VirtualMachineFeatureRequirement

	// This property indicates whether the guest has gone into one of the
	// s1, s2 or s3 standby modes, false indicates the guest is awake.
	//
	// Since vSphere API 5.1
	OnlineStandby bool

	// The current power state of the virtual machine.
	PowerState *enum.VirtualMachinePowerState

	// The current question, if any, that is blocking the virtual machine's execution.
	Question *VirtualMachineQuestionInfo

	// Record / replay state of this virtual machine.
	//
	// Since vSphere API 4.0
	RecordReplayState *enum.VirtualMachineRecordReplayState

	// The total time the virtual machine has been suspended
	// since it was initially powered on. This time excludes the current period,
	// if the virtual machine is currently suspended.  This property is updated
	// when the virtual machine resumes, and is reset to zero when the virtual machine
	// is powered off.
	SuspendInterval int64

	// The timestamp when the virtual machine was most recently suspended.
	//
	// This property is updated every time the virtual machine is suspended.
	SuspendTime time.Time

	// Flag to indicate whether or not the VMware Tools installer
	// is mounted as a CD-ROM.
	ToolsInstallerMounted bool

	// Specifies the total allocated vFlash resource for the vFlash caches associated with VM's
	// VMDKs when VM is powered on, in bytes.
	//
	// Since vSphere API 5.5
	VFlashCacheAllocation int64
}

//
// The DasProtectionState object describes the
// vSphere HA protection state of a virtual machine (VM).
//
//
type VirtualMachineRuntimeInfoDasProtectionState struct {
	*DynamicData

	// Whether vSphere HA is protecting a virtual machine (VM). If a
	// VM is protected, vSphere HA will enforce any availability
	// features that have been enabled for this VM. For
	// example, if the VM is running on a host
	// that fails and the VM is configured to be restarted on a failure,
	// then vSphere HA will attempt to restart the VM on another host.
	// Similarly, if you enable VM/Application Health Monitoring
	// for this VM, vSphere HA will monitor the heartbeats of the
	// VM and reset the VM when needed, as dictated by the configured
	// policy settings.
	DasProtected bool
}

//
// The ScsiDiskDeviceInfo class contains detailed information about a specific
// scsi disk hardware device. These devices are for the
// vim.vm.device.VirtualDisk.RawDiskMappingVer1BackingInfo.
//
//
type VirtualMachineScsiDiskDeviceInfo struct {
	*VirtualMachineDiskDeviceInfo

	// Detailed information about the disk.
	Disk *HostScsiDisk

	// LUN number hint used to identify the SCSI device.  To definitively
	// correlate this device with a host physical disk, use the disk property.
	// This identifier is intended as a hint to end users to identify the
	// disk device.
	//
	// Since vSphere API 4.0
	LunNumber int32

	// Transport identifier hint used to identify the device.  To definitively
	// correlate this device with a host physical disk, use the disk property.
	// This identifier is intended as a hint to end users to identify the
	// disk device.
	//
	// Since vSphere API 4.0
	TransportHint string
}

//
// Description of a generic SCSI device, including information about
// the device ID.
//
//
type VirtualMachineScsiPassthroughInfo struct {
	*VirtualMachineTargetInfo

	// Unit number of the generic device on the physical host.
	PhysicalUnitNumber int32

	// The class of the generic SCSI device.
	ScsiClass string

	// The vendor name.
	Vendor string
}

//
// Possible SCSI classes.
//
//
type VirtualMachineScsiPassthroughType struct {
}

//
// SerialInfo class contains information about a physical serial
// drive on the host.
//
//
type VirtualMachineSerialInfo struct {
	*VirtualMachineTargetInfo
}

//
// The Snapshot managed object type specifies the interface to individual snapshots
// of a virtual machine. Although these are managed objects, they are subordinate to
// their virtual machine.
//
type VirtualMachineSnapshot struct {
	*ExtensibleManagedObject

	childSnapshot []*VirtualMachineSnapshot

	config *VirtualMachineConfigInfo
}

// All snapshots for which this snapshot is the parent.
//
// Since vSphere API 4.1
func (mo *VirtualMachineSnapshot) ChildSnapshot() ([]*VirtualMachineSnapshot, error) {
	t, err := mo.currentProperty("childSnapshot")
	if err != nil {
		return nil, err
	}

	v, ok := t.([]*VirtualMachineSnapshot)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: []*VirtualMachineSnapshot")
	}
	return v, nil
}

// Information about the configuration of this virtual machine when this snapshot was
// taken.
//
// The datastore paths for the virtual machine disks point to the head of the disk
// chain that represents the disk at this given snapshot. The fileInfo.fileLayout
// field is not set.
func (mo *VirtualMachineSnapshot) Config() (*VirtualMachineConfigInfo, error) {
	t, err := mo.currentProperty("config")
	if err != nil {
		return nil, err
	}

	v, ok := t.(*VirtualMachineConfigInfo)
	if !ok {
		return nil, errors.New("Unable to make type assertion to: *VirtualMachineConfigInfo")
	}
	return v, nil
}

//
// Obtains an export lease on this snapshot. The export lease contains
// a list of URLs for the virtual disks for this snapshot, as well as
// a ticket giving access to the URLs.
//
// See HttpNfcLease for information on how to use the lease.
//
//
// Required Privileges
// VApp.Export
// Since
// vSphere API 5.5
//
func (mo *VirtualMachineSnapshot) ExportSnapshot(
	_this *ManagedObjectReference,
) (*HttpNfcLease, error) {

	return nil, nil

}

//
// Removes this snapshot and deletes any associated storage.
//
// Required Privileges
// VirtualMachine.State.RemoveSnapshot
//
func (mo *VirtualMachineSnapshot) RemoveSnapshot_Task(
	_this *ManagedObjectReference, removeChildren bool, consolidate bool,
) (*Task, error) {

	return nil, nil

}

//
// Rename this snapshot with either a new name or a new description or both.
// At least one of these must be specified when calling the rename method.
//
//
//
// Required Privileges
// VirtualMachine.State.RenameSnapshot
//
func (mo *VirtualMachineSnapshot) RenameSnapshot(
	_this *ManagedObjectReference, name string, description string,
) error {

	return nil

}

//
// Change the execution state of the virtual machine to the state of this snapshot.
//
// Required Privileges
// VirtualMachine.State.RevertToSnapshot
//
func (mo *VirtualMachineSnapshot) RevertToSnapshot_Task(
	_this *ManagedObjectReference, host *HostSystem, suppressPowerOn bool,
) (*Task, error) {

	return nil, nil

}

//
// The SnapshotInfo data object type provides all the information about the
// hierarchy of snapshots in a virtual machine.
//
//
type VirtualMachineSnapshotInfo struct {
	*DynamicData

	// Current snapshot of the virtual machine
	//
	// This property is set by calling
	// Snapshot.revert or
	// VirtualMachine.createSnapshot.
	// This property will be empty when the working snapshot is at the root
	// of the snapshot tree.
	CurrentSnapshot *VirtualMachineSnapshot

	// Data for the entire set of snapshots for one virtual machine.
	RootSnapshotList []*VirtualMachineSnapshotTree
}

//
// SnapshotTree encapsulates all the read-only data produced by the snapshot.
//
//
type VirtualMachineSnapshotTree struct {
	*DynamicData

	// The relative path from the snapshotDirectory pointing to the backup
	// manifest. Available for certain quiesced snapshots only.
	//
	// Since vSphere API 4.0
	BackupManifest string

	// The snapshot data for all snapshots for which this snapshot is the parent.
	ChildSnapshotList []*VirtualMachineSnapshotTree

	// The date and time the snapshot was taken.
	CreateTime time.Time

	// Description of the snapshot.
	Description string

	// The unique identifier that distinguishes this snapshot from
	// other snapshots of the virtual machine.
	//
	// Since vSphere API 4.0
	Id int32

	// Name of the snapshot.
	Name string

	// Flag to indicate whether or not the snapshot was created with
	// the "quiesce" option, ensuring a consistent state of the file system.
	Quiesced bool

	// Flag to indicate whether this snapshot is associated with a recording
	// session on the virtual machine that can be replayed.
	//
	// Since vSphere API 4.0
	ReplaySupported bool

	// The managed object for this snapshot.
	Snapshot *VirtualMachineSnapshot

	// The power state of the virtual machine when this snapshot was taken.
	State *enum.VirtualMachinePowerState

	// The virtual machine for which the snapshot was taken.
	Vm *VirtualMachine
}

//
// SoundInfo class contains information about a physical sound
// card on the host.
//
//
type VirtualMachineSoundInfo struct {
	*VirtualMachineTargetInfo
}

//
// Description of a SRIOV device that can be attached to a virtual machine.
//
//
type VirtualMachineSriovInfo struct {
	*VirtualMachinePciPassthroughInfo

	// The name of the physical nic that is represented by a SR-IOV
	// capable physical function.
	Pnic string

	// Indicates whether corresponding PCI device is a virtual function
	// instantiated by a SR-IOV capable device.
	VirtualFunction bool
}

//
// The list of possible standby actions that the virtual machine can take
// for S1 ACPI.
//
//
type VirtualMachineStandbyActionType struct {
}

//
// Information about the amount of storage used by a virtual machine across
// datastores that it is located on.
//
//
type VirtualMachineStorageInfo struct {
	*DynamicData

	// Storage space used by this virtual machine on all datastores that it
	// is located on.
	//
	// Total storage space committed to this virtual machine across all datastores is
	// simply an aggregate of the property
	// committed.See committed
	PerDatastoreUsage []*VirtualMachineUsageOnDatastore

	// Time when values in this structure were last updated.
	Timestamp time.Time
}

//
// A subset of the storage information of this virtual machine.
//
// See VirtualMachineStorageInfo for a detailed storage break-up.
//
//
//
type VirtualMachineStorageSummary struct {
	*DynamicData

	// Total storage space, in bytes, committed to this virtual machine across
	// all datastores.
	//
	// Essentially an aggregate of the property
	// committed across all
	// datastores that this virtual machine is located on.
	Committed int64

	// Time when values in this structure were last updated.
	Timestamp time.Time

	// Additional storage space, in bytes, potentially used by this virtual machine
	// on all datastores.
	//
	// Essentially an aggregate of the property
	// uncommitted across all
	// datastores that this virtual machine is located on.
	Uncommitted int64

	// Total storage space, in bytes, occupied by the virtual machine across
	// all datastores, that is not shared with any other virtual machine.
	Unshared int64
}

//
// The summary data object type encapsulates a typical set of virtual machine
// information that is useful for list views and summary pages.
//
// VirtualCenter can retrieve this information very efficiently,
// even for large sets of virtual machines.
//
//
//
type VirtualMachineSummary struct {
	*DynamicData

	// Basic configuration information about the virtual machine. This information
	// is not available when the virtual machine is unavailable, for instance, when
	// it is being created or deleted.
	Config *VirtualMachineConfigSummary

	// Custom field values.
	CustomValue []*CustomFieldValue

	// Guest operating system and VMware Tools information. See guest for more information.
	Guest *VirtualMachineGuestSummary

	// Overall alarm status on this node.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	OverallStatus *enum.ManagedEntityStatus

	// A set of statistics that are typically updated with near real-time regularity.
	// This data object type does not support notification, for scalability reasons.
	// Therefore, changes in QuickStats do not generate property collector updates. To
	// monitor statistics values, use the statistics and alarms modules instead.
	QuickStats *VirtualMachineQuickStats

	// Runtime and state information of a running virtual machine.
	// Most of this information is also available when a virtual machine is powered off.
	// In that case, it contains information from the last run, if available.
	Runtime *VirtualMachineRuntimeInfo

	// Storage information of the virtual machine. It can be explicitly refreshed
	// with the RefreshStorageInfo operation.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	//
	// Since vSphere API 4.0
	Storage *VirtualMachineStorageSummary

	// Reference to the virtual machine managed object.
	Vm *VirtualMachine
}

//
// The TargetInfo specified a  value that can be used in the device backings to
// connect the virtual machine to a physical (or logical) host device.
//
//
type VirtualMachineTargetInfo struct {
	*DynamicData

	// List of configurations that this device is available for. This is only filled
	// out if more than one configuration is requested.
	ConfigurationTag []string

	// The identification of the endpoint on the host. The format of this depends
	// on the kind of virtual device this endpoints is used for. For example,
	// for a VirtualEthernetCard this would be a networkname, and for a VirtualCDROM
	// it would be a device name.
	Name string
}

//
// Describes how widely the endpoint is availabe in a cluster. Note that these
// fields are not neccessarily mutual-exclusive.
//
//
type VirtualMachineTargetInfoConfigurationTag struct {
}

//
// This data object contains the information needed to establish a
// connection to a running virtual machine.
//
//
type VirtualMachineTicket struct {
	*DynamicData

	// The name of the configuration file for the virtual machine.
	CfgFile string

	// The host with which to establish a connection. If the host is not specified,
	// it is assumed that the requesting entity knows the appropriate host with which
	// to connect.
	Host string

	// The port number to use. If the port is not specified,
	// it is assumed that the requesting entity knows the appropriate port to
	// use when making a new connection.
	Port int32

	// The expected thumbprint of the SSL cert of the host to which
	// we are connecting.
	SslThumbprint string

	// The ticket name. This is used as the username and password for the MKS
	// connection.
	Ticket string
}

//
// The virtual machine ticket type.
//
//
type VirtualMachineTicketType struct {
}

//
// Current running status of VMware Tools running in the guest
// operating system.
//
//
type VirtualMachineToolsRunningStatus struct {
}

// Deprecated.
// As of vSphere API 4.0 use VirtualMachineToolsVersionStatus
// and VirtualMachineToolsRunningStatus.
//
//
// Current status of VMware Tools running in the guest operating system.
//
//
type VirtualMachineToolsStatus struct {
}

//
// Current version status of VMware Tools installed in the guest operating
// system.
//
//
type VirtualMachineToolsVersionStatus struct {
}

//
// Storage space used by this virtual machine on a particular datastore.
//
//
type VirtualMachineUsageOnDatastore struct {
	*DynamicData

	// Storage space, in bytes, on this datastore that is actually being used by
	// the virtual machine.
	//
	// It includes space actually occupied by disks, logs, snapshots,
	// configuration files etc. Files of the virtual machine which are present
	// on a different datastore (e.g. a virtual disk on another datastore) are not
	// included here. VirtualMachineFileLayoutEx provides a detailed
	// break-up of the committed space.
	Committed int64

	// Reference to datastore for which information is being provided.
	Datastore *Datastore

	// Additional storage space, in bytes, potentially used by the virtual machine
	// on this datastore.
	//
	// Additional space may be needed for example when lazily allocated disks grow,
	// or storage for swap is allocated when powering on the virtual machine.
	//
	// If the virtual machine is running off delta disks (for example because
	// a snapshot was taken), then only the potential growth of the currently
	// used delta-disks is considered.
	Uncommitted int64

	// Storage space, in bytes, occupied by the virtual machine on this datastore
	// that is not shared with any other virtual machine.
	Unshared int64
}

//
// This data object contains information about a physical USB device
// on the host.
//
//
type VirtualMachineUsbInfo struct {
	*VirtualMachineTargetInfo

	// A user visible name of the USB device.
	Description string

	// The device class families.
	// For possible values see
	// VirtualMachineUsbInfoFamily
	Family []string

	// An autoconnect pattern which describes the device's physical
	// path. This is the path to the specific port on the host where the
	// USB device is attached.
	PhysicalPath string

	// The product ID of the USB device.
	Product int32

	// The possible device speeds detected by server.
	// For possible values see
	// VirtualMachineUsbInfoSpeed
	Speed []string

	// Summary information about the virtual machine that is currently
	// using this device, if any.
	Summary *VirtualMachineSummary

	// The vendor ID of the USB device.
	Vendor int32
}

//
// Device class family.
//
//
type VirtualMachineUsbInfoFamily struct {
}

//
// Device speed.
//
//
type VirtualMachineUsbInfoSpeed struct {
}

//
// VFlashModuleInfo class contains information about a vFlash module
// on the host.
//
//
type VirtualMachineVFlashModuleInfo struct {
	*VirtualMachineTargetInfo

	// Information about the vFlash module
	VFlashModule *HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption
}

//
// The VirtualMachineVMCIDevice data object represents
// a virtual communication device that supports the VMCI
// (Virtual Machine Communication Interface).
// Each virtual machine has a VMCI device that handles
// interprocess socket-based communication.
// VMCI device information is available in the virtual machine
// hardware device list
// (VirtualMachine.config.hardware.device[]).
//
// An application running on a virtual machine uses the VMCI Sockets API
// for communication with other virtual machines on the same host
// (communication between virtual machines is not supported on vSphere
// 5.1 and later platforms as described for
// VirtualVMCIDevice.allowUnrestrictedCommunication),
// or for communication with the host.
// For information about using the vSphere VMCI Sockets API,
// see the VMCI Sockets Programming Guide.
//
//
//
type VirtualMachineVMCIDevice struct {
	*VirtualDevice

	// Deprecated.
	// As of vSphere API 5.1. On vSphere 5.1 and later
	// platforms, the VMCI device does not support communication with
	// other virtual machines. Therefore, this property has no effect
	// on these platforms.
	//
	//
	// Determines the extent of VMCI communication with this virtual
	// machine. Set this property to true to allow VMCI communication
	// with all virtual machines on the host and with trusted services.
	// Set this property to false to allow VMCI communication only
	// with trusted services such as the hypervisor on the host.
	//
	// If unset, communication is restricted to trusted services only.
	AllowUnrestrictedCommunication bool

	// Unique identifier for VMCI socket access to this virtual machine.
	// Use this value to identify this virtual machine in calls to the
	// VMCI Sockets API. Applications running on other virtual machines on this
	// host will use this value to connect to this virtual machine.
	// You can cast this value to a 32-bit unsigned integer.
	//
	// The vSphere Server sets this value when a virtual machine
	// powers on. The Server may change this value after power
	// operations such as vMotion or restoring a virtual machine
	// from a snapshot. If you have saved a VMCI device identifier,
	// check to see if the value is still valid after power
	// operations.
	Id int64
}

//
// The VirtualMachineVMCIDeviceOption data object contains the options
// for the virtual VMCI device (VirtualMachineVMCIDevice).
//
//
type VirtualMachineVMCIDeviceOption struct {
	*VirtualDeviceOption

	// Indicates support for VMCI communication and specifies the default
	// operation. If defaultValue is set to true,
	// the virtual machine can participate in VMCI communication with all other
	// virtual machines on the host. Otherwise, VMCI communication will be
	// restricted to trusted services such as the hypervisor on the host.
	AllowUnrestrictedCommunication *BoolOption
}

// Deprecated.
// As of vSphere API 5.5. On vSphere 5.5 and later
// platforms, the VMIROM device does not provide any functionality.
//
//
// The VirtualVMIROM data object type represents the ROM on the
// virtual machine's PCI bus that provides support for VMI.
//
//
type VirtualMachineVMIROM struct {
	*VirtualDevice
}

//
// The VirtualVideoCard data object type represents a video card in
// a virtual machine.
//
//
type VirtualMachineVideoCard struct {
	*VirtualDevice

	// Flag to indicate whether the virtual video card supports 3D functions.
	//
	// This property can only be updated when the virtual machine is powered
	// off.
	//
	// Since vSphere API 4.0
	Enable3DSupport bool

	// Indicates the number of supported monitors.
	//
	// The number of displays X the maximum resolution of each display is
	// bounded by the video RAM size of the virtual video card.
	//
	// This property can only be updated when the virtual machine is
	// powered off.
	//
	// Since vSphere API 4.0
	NumDisplays int32

	// Indicate how the virtual video device renders 3D graphics.
	//
	// The virtual video device can use hardware acceleration and software
	// rendering.  By default, VMware products determine whether or not to
	// use hardware acceleration based on the availability of physical graphics
	// devices.  Certain workloads can benefit from explicitly specifying if
	// hardware acceleration is required.  For example, 3D intensive workloads
	// may indicate to run on systems with graphics hardware.
	//
	// There are three settings.
	//
	// (automatic) - The virtual device chooses how to render 3D graphics (default).
	// (software)  - The virtual device will use software rendering and
	// will not attempt to use hardware acceleration.
	// (hardware)  - The virtual device will use hardware acceleration and
	// will not activate without it.
	//
	// Since vSphere API 5.1
	Use3dRenderer string

	// Flag to indicate whether the display settings of the host on which the
	// virtual machine is running should be used to automatically determine
	// the display settings of the virtual machine's video card.
	//
	// This setting takes effect at virtual machine power-on time. If this
	// value is set to TRUE, numDisplays will be ignored.
	//
	// Since vSphere API 4.0
	UseAutoDetect bool

	// The size of the framebuffer for a virtual machine.
	VideoRamSizeInKB int64
}

//
// Set of possible values for use3dRenderer.
//
//
type VirtualMachineVideoCardUse3dRenderer struct {
}

//
// Data structure used by wipeDisk to return the amount of disk space that
// can be saved on an Flex-SE disk if a subsequent shrinkDisk API is invoked
// on that disk.
//
//
type VirtualMachineWipeResult struct {
	*DynamicData

	// The disk id for the disk that was wiped.
	DiskId int32

	// The amount of shrinkable disk space in kB.
	ShrinkableDiskSpace int64
}

//
// The NetConfig data object type contains the networking
// configuration.
//
//
type VirtualNicManagerNetConfig struct {
	*DynamicData

	// List of VirtualNic objects that may be used.
	// This will be a subset of the list of VirtualNics in
	// vnic.
	CandidateVnic []*HostVirtualNic

	// Whether multiple nics can be selected for this nicType.
	MultiSelectAllowed bool

	// The NicType of this NetConfig.
	NicType string

	// List of VirtualNic objects that are selected for use.
	SelectedVnic []string
}

//
// The VirtualPCIController data object type defines a virtual PCI
// controller.
//
//
type VirtualPCIController struct {
	*VirtualController
}

//
// This data object type contains the options
// for a virtual PCI Controller.
//
//
type VirtualPCIControllerOption struct {
	*VirtualControllerOption

	// Defines the minimum, maximum, and
	// default number of VirtualEthernetCard instances available,
	// at any given time, in the PCI controller. The number of
	// VirtualEthernetCard instances is also limited by the number of
	// available slots in the PCI controller.
	NumEthernetCards *IntOption

	// Defines the minimum, maximum, and default
	// number of ParaVirtualScsiController instances available,
	// at any given time, in the PCI controller.  This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported SCSI controllers.
	//
	// Since vSphere API 4.0
	NumParaVirtualSCSIControllers *IntOption

	// Defines the minimum, maximum, and default
	// number of VirtualPCIPassthrough instances available,
	// at any given time, in the PCI controller. This is also limited
	// by the number of available PCI Express slots in the PCI controller.
	//
	// Since vSphere API 4.0
	NumPCIPassthroughDevices *IntOption

	// Defines the minimum, maximum, and default
	// number of VirtualLsiLogicSASController instances available,
	// at any given time, in the PCI controller.  This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported SCSI controllers.
	//
	// Since vSphere API 4.0
	NumSasSCSIControllers *IntOption

	// Defines the minimum, maximum, and default
	// number of VirtualSATAController instances available,
	// at any given time, in the PCI controller.  This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported SATA controllers.
	//
	// Since vSphere API 5.5
	NumSATAControllers *IntOption

	// Defines the minimum, maximum, and
	// default number of VirtualSCSIController instances available
	// at any given time in the PCI controller. The number of
	// VirtualSCSIController instances is also limited by the number of
	// available slots in the PCI controller.
	NumSCSIControllers *IntOption

	// Defines the minimum, maximum, and default
	// number of VirtualSoundCard instances available,
	// at any given time, in the PCI controller. The number of
	// VirtualSoundCard instances is also limited by the number of
	// available slots in the PCI controller.
	NumSoundCards *IntOption

	// Defines the minimum, maximum, and default
	// number of VirtualVideoCard instances available,
	// at any given time, in the PCI controller. The number of
	// VirtualVideoCard instances is also limited by the number of
	// available slots in the PCI controller.
	NumVideoCards *IntOption

	// Defines the minimum, maximum, and default
	// number of VirtualVMCIDevice instances available,
	// at any given time, in the PCI controller. This is also limited
	// by the number of available slots in the PCI controller.
	//
	// Since vSphere API 4.0
	NumVmciDevices *IntOption

	// Defines the minimum, maximum, and default
	// number of VirtualVMIROM instances available,
	// at any given time, in the PCI controller. This is also limited
	// by the number of available slots in the PCI controller.
	//
	// Since VI API 2.5
	NumVmiRoms *IntOption

	// Defines the minimum, maximum, and default
	// number of VirtualVmxnet3 ethernet card instances available,
	// at any given time, in the PCI controller. This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported ethernet cards.
	//
	// Since vSphere API 4.0
	NumVmxnet3EthernetCards *IntOption
}

//
// The VirtualPCIPassthrough data object type contains information about a
// PCI device on the virtual machine that is being backed by
// a generic PCI device on the host via passthrough.
//
//
type VirtualPCIPassthrough struct {
	*VirtualDevice
}

//
// The VirtualPCIPassthrough.DeviceBackingInfo data object type
// contains information about the backing that maps the
// virtual device onto a physical device.
//
//
type VirtualPCIPassthroughDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	// The device ID of this PCI. You must use the device ID retrieved
	// from the vSphere host (HostPciDevice.deviceId), converted
	// as is to a string.
	DeviceId string

	// The name ID of this PCI, composed of "bus:slot.function".
	Id string

	// The ID of the system the PCI device is attached to.
	SystemId string

	// The vendor ID for this PCI device. You must use the vendor ID retrieved
	// from the vSphere host (HostPciDevice.vendorId).
	VendorId int16
}

//
// This data object type describes the options for the
// VirtualPCIPassthroughDeviceBackingInfo data object type.
//
//
type VirtualPCIPassthroughDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The VirtualPCIPassthroughOption data object type describes the options
// for the
// VirtualPCIPassthrough
// data object type.
//
//
type VirtualPCIPassthroughOption struct {
	*VirtualDeviceOption
}

//
// This data object type defines the properties
// of an AMD Lance PCNet32 Ethernet card attached to a virtual machine.
//
//
type VirtualPCNet32 struct {
	*VirtualEthernetCard
}

//
// The VirtualPCNet32Option data object type defines the options for the
// VirtualPCNet32 data object type.  Except for the boolean
// supportsMorphing option, the options are inherited from the
// VirtualEthernetCardOption data
// object type.
//
//
type VirtualPCNet32Option struct {
	*VirtualEthernetCardOption

	// Indicates that this Ethernet card supports morphing into vmxnet when
	// appropriate.  This means that, if supportsMorphing="true", the virtual
	// AMD Lance PCNet32 Ethernet card becomes a vmxnet Ethernet card
	// with its added performance capabilities when appropriate.
	SupportsMorphing bool
}

//
// The VirtualPS2Controller data object type represents a controller
// for keyboards and mice.
//
//
type VirtualPS2Controller struct {
	*VirtualController
}

//
// The VirtualPS2ControllerOption data object type contains the options
// for a virtual PS/2 controller for keyboards and mice. In addition to
// the options defined in the VirtualControllerOption data object type, these options include the
// number of keyboards and mice.
//
//
type VirtualPS2ControllerOption struct {
	*VirtualControllerOption

	// The minimum, maximum, and default number of keyboards you can
	// have at any given time. This is further constrained  by the number
	// of available slots in the PS/2 controller. The minimum, maximum,
	// and default are integers defined by three properties:
	//
	//
	// numKeyBoards.min:  the minimum.
	// numKeyBoards.max:  the maximum.
	// numKeyBoards.defaultValue: the default number.
	NumKeyboards *IntOption

	// The minimum, maximum, and default number of mice you can
	// have at any given time. The number of mice is also limited by the number
	// of available slots in the PS/2 controller. The minimum, maximum, and
	// default are integers defined by three properties:
	//
	//
	// numPointingDevices.min: the minimum.
	// numPointingDevices.max: the maximum.
	// numPointingDevices.defaultValue: the default number.
	NumPointingDevices *IntOption
}

//
// This data object type represents a parallel port
// in a virtual machine.
//
//
type VirtualParallelPort struct {
	*VirtualDevice
}

//
// The data object type for a device backing of a virtual parallel port.
//
//
type VirtualParallelPortDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

//
// Data object type that represents the options for a device backing
// of a virtual parallel port.
//
//
type VirtualParallelPortDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The data object type for a file backing of a virtual parallel port.
//
//
type VirtualParallelPortFileBackingInfo struct {
	*VirtualDeviceFileBackingInfo
}

//
// Data object type that represents the options for a file backing
// of a virtual parallel port.
//
//
type VirtualParallelPortFileBackingOption struct {
	*VirtualDeviceFileBackingOption
}

//
// This data object type contains the options for the
// virtual parallel port class.
//
//
type VirtualParallelPortOption struct {
	*VirtualDeviceOption
}

//
// The VirtualPointingDevice data object type contains information about
// the mouse type on a virtual machine.
//
//
type VirtualPointingDevice struct {
	*VirtualDevice
}

//
// The DeviceBackingOption data object type represents
// the options for a pointing device backing a
// VirtualPointingDevice data object type.
//
//
type VirtualPointingDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption

	// This object defines the supported mouse types, including the default
	// supported mouse type, with the following properties:
	//
	//
	// hostPointingDevices.value:  This array defines the
	// supported mouse types.
	// hostPointingDevices.choiceDescription: This array
	// provides the descriptions for the supported mouse types defined by
	// hostPointingDevices.value.
	// hostPointingDevices.defaultIndex: This integer points
	// to an index in the hostPointingDevices.value array.  This is the
	// mouse type supported by default.
	HostPointingDevice *ChoiceOption
}

//
// The VirtualPointingDevice.DeviceBackingInfo provides information about
// the physical mouse backing the VirtualPointingDevice data object
// type.
//
//
type VirtualPointingDeviceDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	// This optional property defines the mouse type (two-button,
	// three-button, and so on).  The mouse type
	// determines how the user interacts with the host mouse.
	// The valid values are specified in the
	// VirtualPointingDeviceHostChoice list.
	//
	// Note:  The value specified by this property must be
	// one of the supported types listed in the hostPointingDevices.value
	// array in the VirtualPointingDeviceOption data object type.  If this property is
	// not set, then the property defaults to the
	// hostPointingDevices.defaultIndex property in the same data
	// object type.
	HostPointingDevice string
}

//
// The valid choices for host pointing devices are:
//
//
//
//
//
type VirtualPointingDeviceHostChoice struct {
}

//
// The VirtualPointingDeviceOption data object type contains the options
// for the host mouse type defined in the
// VirtualPointingDevice data object type.
// These options include the valid selections for the mouse type, the supported
// mouse types, and the default mouse type.
//
//
type VirtualPointingDeviceOption struct {
	*VirtualDeviceOption
}

//
// The VirtualSATAController data object type represents
// a SATA controller in a virtual machine.
//
//
type VirtualSATAController struct {
	*VirtualController
}

//
// The VirtualSATAControllerOption data object type contains the options
// for a virtual SATA controller defined by the
// VirtualSATAController
// data object type.
//
//
type VirtualSATAControllerOption struct {
	*VirtualControllerOption

	// Three properties (numSATACdroms.min, numSATACdroms.max, and
	// numSATACdroms.defaultValue) define the minimum, maximum, and default
	// number of SATA VirtualCdrom instances available
	// in the SATA controller. The number of SATA VirtualCdrom instances is
	// also limited by the number of available slots in the SATA controller.
	NumSATACdroms *IntOption

	// Three properties (numSATADisks.min, numSATADisks.max, and
	// numSATADisks.defaultValue) define the minimum, maximum, and default
	// number of SATA VirtualDisk instances available at any given time in the
	// SATA controller. The number of SATA VirtualDisk instances is
	// also limited by the number of available slots in the SATA controller.
	NumSATADisks *IntOption
}

//
// The VirtualSCSIController data object type represents
// a SCSI controller in a virtual machine.
//
//
type VirtualSCSIController struct {
	*VirtualController

	// All SCSI controllers support hot adding and removing of devices. This
	// support can't be toggled in the current implementation. Therefore, this
	// option is ignored when reconfiguring a SCSI controller and is always set
	// to "true" when reading an existing configuration.
	HotAddRemove bool

	// The unit number of the SCSI controller. The SCSI controller sits on its
	// own bus, so this field defines which slot the controller is using.
	ScsiCtlrUnitNumber int32

	// Mode for sharing the SCSI bus. The modes are physicalSharing,
	// virtualSharing, and noSharing. See the
	// Sharing
	// data object type for an explanation of these modes.
	SharedBus *enum.VirtualSCSISharing
}

//
// The VirtualSCSIControllerOption data object type contains the options
// for a virtual SCSI controller defined by the
// VirtualSCSIController
// data object type.
//
//
type VirtualSCSIControllerOption struct {
	*VirtualControllerOption

	// Index into sharing array specifying the default value.
	DefaultSharedIndex int32

	// All SCSI controllers support hot adding and removing of devices. This
	// support can't be toggled in the current implementation. Therefore, this
	// option is ignored when reconfiguring a SCSI controller and is always set
	// to "true" when reading an existing configuration.
	HotAddRemove *BoolOption

	// Three properties (numSCSICdroms.min, numSCSICdroms.max, and
	// numSCSICdroms.defaultValue) define the minimum, maximum, and default
	// number of SCSI VirtualCdrom instances available
	// in the SCSI controller. The number of SCSI VirtualCdrom instances is
	// also limited by the number of available slots in the SCSI controller.
	NumSCSICdroms *IntOption

	// Three properties (numSCSIDisks.min, numSCSIDisks.max, and
	// numSCSIDisks.defaultValue) define the minimum, maximum, and default
	// number of SCSI VirtualDisk instances available at any given time in the
	// SCSI controller. The number of SCSI VirtualDisk instances is
	// also limited by the number of available slots in the SCSI controller.
	NumSCSIDisks *IntOption

	// Three properties (numSCSIPassthrough.min, numSCSIPassthrough.max, and
	// numSCSIPassthrough.defaultValue) define the minimum, maximum, and
	// default number of VirtualSCSIPassthrough instances available
	// have at any given time in the SCSI controller. The number of
	// VirtualSCSIPassthrough instances is also limited by the number of
	// available slots in the SCSI controller.
	NumSCSIPassthrough *IntOption

	// The unit number of the SCSI controller. The SCSI controller sits on its
	// own bus, so that this field defines which slot the controller will use.
	ScsiCtlrUnitNumber int32

	// Supported shared bus modes.
	Sharing []*enum.VirtualSCSISharing
}

//
// The VirtualSCSIPassthrough data object type contains information about a
// SCSI device on the virtual machine that is being backed by
// a generic SCSI device on the host via passthrough.
//
//
type VirtualSCSIPassthrough struct {
	*VirtualDevice
}

//
// The VirtualSCSIPassthrough.DeviceBackingInfo data object type
// contains information about the backing that maps the
// virtual device onto a physical device.
//
//
type VirtualSCSIPassthroughDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

//
// This data object type describes
// the options for the
// VirtualSCSIPassthroughDeviceBackingInfo data object type.
//
//
type VirtualSCSIPassthroughDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The VirtualSCSIPassthroughOption data object type describes the options
// for the
// VirtualSCSIPassthrough
// data object type.
//
//
type VirtualSCSIPassthroughOption struct {
	*VirtualDeviceOption
}

//
// Sharing describes three possible ways of sharing the SCSI bus:
//
// One of these values is assigned to the sharedBus object to determine
// if or how the SCSI bus is shared.
//
//
type VirtualSCSISharing struct {
}

//
// This data object type defines a
// Super IO Controller for floppy drives, parallel ports,
// and serial ports.
//
//
type VirtualSIOController struct {
	*VirtualController
}

//
// The VirtualSIOControllerOption data object type contains the options
// for a virtual Super IO Controller.
//
//
type VirtualSIOControllerOption struct {
	*VirtualControllerOption

	// Three properties (numFloppyDrives.min, numFloppyDrives.max, and
	// numFloppyDrives.defaultValue) define the minimum, maximum, and default
	// number of floppy drives you can have at any given time in the Super IO
	// Controller. This is further constrained by the number of available
	// slots in the Super IO Controller.
	NumFloppyDrives *IntOption

	// Three properties (numParallelPorts.min, numParallelPorts.max, and
	// numParallelPorts.defaultValue) define the minimum, maximum, and default
	// number of parallel ports you can
	// have at any given time in the Super IO controller. This is further
	// constrained by the number of available slots in the Super IO
	// Controller.
	NumParallelPorts *IntOption

	// Three properties (numSerialPorts.min, numSerialPorts.max, and
	// numSerialPorts.defaultValue) define the minimum, maximum, and default
	// number of serial ports you can
	// have at any given time in the Super IO Controller. This is further
	// constrained by the number of available slots in the Super IO
	// Controller.
	NumSerialPorts *IntOption
}

//
// The VirtualSerialPort data object represents a serial port
// on a virtual machine.
// A virtual serial port uses one of the following backing types to specify
// how the virtual machine performs serial port operations.
//
//
// • Network backing (VirtualSerialPortURIBackingInfo)
// supports a connection between the virtual machine and a resource
// on the network. The virtual machine can initiate a connection with
// the network resource, or it can listen for connections originating
// from the network.
//
// • Pipe backing (VirtualSerialPortPipeBackingInfo)
// supports I/O through a named pipe. The pipe connects the virtual machine
// to a host application or a virtual machine on the same host.
//
// • File backing (VirtualSerialPortFileBackingInfo)
// supports output through the virtual serial port to a file on the same host.
//
// • Physical serial port backing
// (VirtualSerialPortDeviceBackingInfo)
// supports a connection between the virtual machine and a
// device that is connected to a physical serial port on the host.
//
// • ThinPrint backing (VirtualSerialPortThinPrintBackingInfo)
// provides driver-free printing.
//
//
//
//
// When you use network backing, you can also configure a virtual serial port
// to use a virtual serial port concentrator. The virtual machine initiates
// a telnet connection with the concentrator, and the concentrator acts
// as a proxy between the virtual machine and a system on the network.
// By using a virtual serial port concentrator, you can maintain the connection
// between the virtual machine and the network resource
// when a vMotion event moves the virtual machine from one host to another.
// Without a virtual serial port concentrator, the connection would be lost.
// For information about using a serial port concentrator,
// see Using a Proxy with vSphere Virtual Serial Ports.
//
//
// You can configure a virtual serial port when you create or reconfigure
// a virtual machine. For example, to create a virtual serial port
// with network backing, use the following sequence of operations.
// In this procedure, the virtual serial port uses a proxy and will accept
// a network connection.
//
//
// • Use the QueryConfigOption method
// to determine the backing options that are available on a host.
// The method returns a VirtualMachineConfigOption data object.
// The virtual machine configuration data includes a list of backing options
// (backingOption).
// The following pseudocode shows the path to the backing options.
//
// VirtualMachineConfigOption.hardwareOptions.VirtualDeviceOption[].backingOption[]
//
// The array of virtual device options can include a virtual serial port
// (VirtualSerialPortOption). The array of serial port
// backing options can include URI, file, pipe, or device backing options.
//
//
//
// • Use the CreateVM_Task method
// (or the CreateChildVM_Task method)
// to create the virtual machine and configure the virtual serial port backing.
// Create a VirtualMachineConfigSpec data object and nested
// data objects for the method's config parameter.
// The following pseudocode shows the resulting path to the backing
// information.
//
// VirtualMachineConfigSpec.deviceChange[].device.backing
//
// Set the direction property to "server" to direct the virtual machine to accept
// a connection. Set the serviceURI property to the URI for the host on which
// the virtual machine runs.
//
//
// If you use physical device backing
// (VirtualSerialPortDeviceBackingOption),
// you should also use the QueryConfigTarget
// method to determine if a serial device is available before configuring device backing.
//
//
type VirtualSerialPort struct {
	*VirtualDevice

	// Enables CPU yield behavior. If you set yieldOnPoll to true,
	// the virtual machine will periodically relinquish the processor if its sole task
	// is polling the virtual serial port. The amount of time it takes to regain
	// the processor will depend on the degree of other virtual machine activity on the host.
	//
	// To use this property, the CPU yield option must be supported. (See the
	// yieldOnPoll property for
	// the virtual serial port option object.)
	YieldOnPoll bool
}

//
// The VirtualSerialPortDeviceBackingInfo data object
// defines information for using a host serial port device as backing for a
// VirtualSerialPort. On a host, the first virtual machine
// to configure physical device backing for a virtual serial port will obtain
// the mapping. As long as that machine maintains the backing, any additional attempts
// to configure backing using that device will fail (a recoverable error, see
// the connection info status).
//
//
type VirtualSerialPortDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

//
// The VirtualSerialPortDeviceBackingOption data object type
// contains the options for backing a serial port with a host serial port device.
//
//
type VirtualSerialPortDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The VirtualSerialPortEndPoint enum defines
// endpoint values for virtual serial port pipe backing.
// When you use serial port pipe backing to connect a virtual machine
// to another process, you must define the endpoints.
// See the endpoint
// property for the virtual serial port pipe backing information data object.
//
// The possible endpoint values are:
//
//
//
// • client
//
// • server
//
//
//
//
// For the supported choices, see the
// endpoint
// property for the virtual serial port pipe backing option data object.
//
//
//
type VirtualSerialPortEndPoint struct {
}

//
// The VirtualSerialPortFileBackingInfo data object provides
// information for backing a virtual serial port with a host file.
//
//
type VirtualSerialPortFileBackingInfo struct {
	*VirtualDeviceFileBackingInfo
}

//
// The VirtualSerialPortFileBackingOption data object type
// contains the options for backing a serial port with a host file.
//
//
type VirtualSerialPortFileBackingOption struct {
	*VirtualDeviceFileBackingOption
}

//
// The VirtualSerialPortOption data object contains the options
// for configuring the virtual serial port device defined by the
// VirtualSerialPort data object.
// These options include information about how the device is backed
// physically on the host:  by a network socket, a host file, a host serial port device,
// or a pipe to another process.
//
//
type VirtualSerialPortOption struct {
	*VirtualDeviceOption

	// Indicates whether the virtual machine supports the CPU yield option during
	// virtual serial port polling. When this feature is supported and enabled,
	// the virtual machine will periodically relinquish the processor if its
	// sole task is polling the virtual serial port.
	//
	// If yieldOnPoll.supported is false, the virtual
	// machine ignores the virtual serial port object setting for
	// yieldOnPoll.
	YieldOnPoll *BoolOption
}

//
// The VirtualSerialPortPipeBackingInfo data object defines information
// for backing a VirtualSerialPort with a named pipe.
// You can use a pipe to connect a virtual serial port to a host
// application or to another virtual machine on the host computer.
// This is useful for capturing debugging information sent through
// the virtual serial port.
//
//
type VirtualSerialPortPipeBackingInfo struct {
	*VirtualDevicePipeBackingInfo

	// Indicates the role the virtual machine assumes as an endpoint
	// for the pipe. The valid values are "client" or "server".
	Endpoint string

	// Enables optimized data transfer over the pipe. When you use this feature,
	// the ESX server buffers data to prevent data overrun.
	// This allows the virtual machine to read
	// all of the data transferred over the pipe with no data loss.
	// To use optimized data transfer, set noRxLoss to true.
	// To disable this feature, set the property to false.
	//
	// This property is optional. If this property is not set, the ESX server
	// uses the default value specified in the pipe backing options
	// (noRxLoss.defaultValue - see
	// noRxLoss
	// in the pipe backing option object).
	//
	// To use this property, optimized data transfer must be supported on the host.
	// (See noRxLoss
	// in the pipe backing option object.)
	// If the ESX server does not support the option, it ignores the
	// noRxLoss setting in the pipe backing information object.
	//
	// Note: You can use this feature even if the other end of the pipe
	// is not an application, but this is more likely to fail.
	NoRxLoss bool
}

//
// The VirtualSerialPortPipeBackingOption data object contains
// the options for backing a serial port device with a pipe to another process.
//
//
type VirtualSerialPortPipeBackingOption struct {
	*VirtualDevicePipeBackingOption

	// Indicates the choices available and the default setting
	// for the pipe endpoint. As an endpoint, the virtual machine can act
	// as a client or a server.
	Endpoint *ChoiceOption

	// Indicates whether the server supports optimized data transfer
	// over the pipe and also specifies default behavior.
	//
	// When this feature is supported and enabled, the server buffers data
	// to prevent data overrun. This allows the virtual machine to read all
	// of the data transferred over the pipe with no data loss.
	//
	// If optimized data transfer is supported (noRxLoss.supported
	// is true):
	//
	// You can enable (or disable) the feature explicitly by setting the
	// noRxLoss
	// property on the pipe backing information object.
	// If you do not set the
	// noRxLoss
	// property on the
	// the pipe backing information object, the server enables
	// optimized data transfer if the noRxLoss.defaultValue
	// property on the pipe backing options object is true.
	//
	//
	// If noRxLoss.supported is false, the server
	// ignores the optimization settings.
	//
	// Note: You can use this feature even if the other end of the pipe
	// is not an application, but it is more likely to fail.
	NoRxLoss *BoolOption
}

//
// The VirtualSerialPortThinPrintBackingInfo data object defines
// information required for backing a VirtualSerialPort with a
// ThinPrint device.
//
//
type VirtualSerialPortThinPrintBackingInfo struct {
	*VirtualDeviceBackingInfo
}

//
// The VirtualSerialPortThinPrintBackingOption data
// object type contains the options for backing a serial port with a ThinPrint device.
//
//
type VirtualSerialPortThinPrintBackingOption struct {
	*VirtualDeviceBackingOption
}

//
// The VirtualSerialPortURIBackingInfo data object
// specifies network backing for a VirtualSerialPort.
// You can use URI backing to create a network serial port on the virtual machine,
// supporting connections between the virtual machine and remote systems.
//
// When a virtual machine  establishes a connection with a remote system on the network,
// the virtual machine can act as a server or a client. When the virtual machine
// acts as a server, it accepts a connection. When the virtual machine acts as a client,
// it initiates the connection.
//
//
// You can configure the virtual serial port for communication through a
// virtual serial port concentrator that acts as a proxy between the virtual
// machine and the network. When you specify a
// proxyURI,
// the virtual machine initiates the connection with the concentrator
// and forwards the direction
// and serviceURI
// to the concentrator.
// For information about using a virtual serial port concentrator,
// see Using a Proxy with vSphere Virtual Serial Ports.
//
//
// ESX hosts support different protocols depending on your virtual serial port configuration.
//
//
//
// • If the virtual machine is handling the network connection
// directly (no proxyURI specified),
// you can use telnet, TCP, and SSL protocols.
// The serviceURI
// must use one of the following URI schemes:
//
// • &lt;host&gt;:&lt;port&gt; - this is the equivalent of
// tcp://&lt;host&gt;:&lt;port&gt;.
//
// • tcp://&lt;host&gt;:&lt;port&gt; - unencrypted TCP connection
// (IPv4 or IPv6).
//
// • tcp4://&lt;host&gt;:&lt;port&gt; - unencrypted TCP connection
// (IPv4 only).
//
// • tcp6://&lt;host&gt;:&lt;port&gt; - unencrypted TCP connection
// (IPv6 only).
//
// • ssl://&lt;host&gt;:&lt;port&gt; - this is the equivalent of
// tcp+ssl://&lt;host&gt;:&lt;port&gt;.
//
// • tcp+ssl://&lt;host&gt;:&lt;port&gt; - encrypted SSL over TCP.
//
// • tcp4+ssl://&lt;host&gt;:&lt;port&gt; - SSL over TCP over IPv4.
//
// • tcp6+ssl://&lt;host&gt;:&lt;port&gt; - SSL over TCP over IPv6.
//
// • telnet://&lt;host&gt;:&lt;port&gt; - telnet over TCP.
// The virtual machine and remote system can negotiate and use SSL if the remote
// system supports the telnet authentication option; if not, the connection
// uses unencrypted text (plaintext).
//
// • telnets://&lt;host&gt;:&lt;port&gt; - telnet over SSL over TCP.
// In this case, SSL negotiation begins immediately and you cannot use
// the telnet authentication option.
//
//
//
//
// As of vSphere 5.1 you can specify authentication parameters to support an encrypted
// connection with a remote system using SSL over telnet or telnets.
// The connection will fail if the peer does not support the protocols.
// You cannot use certificate verification when you specify
// tcp, tcp4, or tcp6 schemas. For information
// about parameter specification, see Authentication Parameters
// below.
//
//
// • If you are using a proxyURI
// to connect to a virtual serial port concentrator, the URI scheme for
// the communication between the remote system on the network and the concentrator
// depends on the concentrator implementation. The connection between
// the concentrator and the virtual serial port must use telnet or secure telnet
// (telnets). The proxy URI must use one of the following URI schemes. You cannot
// specify a username and password in the proxy URI.
//
// • telnet://&lt;host&gt;:&lt;port&gt;- telnet over TCP.
// The virtual machine and remote system can negotiate and use SSL if the remote
// system supports the telnet authentication option; if not, the connection
// uses unencrypted text (plaintext).
//
// • telnets://&lt;host&gt;:&lt;port&gt; - telnet over SSL over TCP.
// In this case, SSL negotiation starts immediately and you cannot use
// the telnet authentication option.
//
//
//
// As of vSphere 5.1 you can specify authentication parameters to support an encrypted
// connection with a concentrator using SSL over telnet or telnets.
// The connection will fail if the concentrator does not support the protocols.
// For information about parameter specification,
// see Authentication Parameters below.
//
//
//
//
//
//
// Authentication Parameters
// For an encrypted connection, the URI includes a set of authentication
// parameters. The parameters are specified as key words or key/value pairs.
// The following syntax description uses telnet; you can also
// specify authentication parameters for secure telnet (telnets).
//
// telnet://&lt;host&gt;:&lt;port&gt;#key[=value][&amp;key[=value] ...]
//
//
// The first parameter must have a number sign (#) prefix. Additional parameters
// must have an ampersand (&amp;) prefix. The following list shows the valid parameters.
//
//
//
// • thumbprint=value - Specifies a certificate thumbprint against
// which the peer certificate thumbprint is compared. When you specify a thumbprint,
// certificate verification is automatically enabled. See the description of the
// verify parameter below.
//
// • peerName=value - Specifies the peer name that will be used
// to validate the peer certificate. When you specify a peer name,
// certificate verification is automatically enabled. See the description of the
// verify parameter below.
//
// • verify - Forces certificate verification. The virtual machine
// will verify that the peer certificate subject matches the specified
// peerName and that it was signed by a certificate authority
// known to the ESXi host. Verification is automatically enabled if you specify a
// thumbprint or peerName.
//
// • cipherList=value - Specifies a list of SSL ciphers.
// See OpenSSL ciphers.
// The ciphers are specified as a list separated by colons, spaces, or commas.
//
//
//
//
// For information about URI format, see
// RFC 2396.
//
//
//
type VirtualSerialPortURIBackingInfo struct {
	*VirtualDeviceURIBackingInfo
}

//
// The VirtualSerialPortURIBackingOption data object type
// contains the options for using a network socket as backing for a virtual serial port.
//
//
type VirtualSerialPortURIBackingOption struct {
	*VirtualDeviceURIBackingOption
}

//
// The VirtualSoundBlaster16 data object type represents a Sound
// Blaster 16 sound card in a virtual machine.
//
//
type VirtualSoundBlaster16 struct {
	*VirtualSoundCard
}

//
// The VirtualSoundBlaster16Option data object type contains the options for a
// virtual SoundBlaster 16 sound card.
//
//
type VirtualSoundBlaster16Option struct {
	*VirtualSoundCardOption
}

//
// This data object type represents a sound card in
// a virtual machine.
//
//
type VirtualSoundCard struct {
	*VirtualDevice
}

//
// The sound card device backing data class.
//
//
type VirtualSoundCardDeviceBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

//
// The VirtualSoundCardBackingOption class contains the options
// for the virtual sound card backing class.
//
//
type VirtualSoundCardDeviceBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The VirtualSoundCardOption data class contains the options for the
// virtual sound card class.
//
//
type VirtualSoundCardOption struct {
	*VirtualDeviceOption
}

//
// The VirtualSriovEthernetCard data object defines the properties
// of a SR-IOV enabled Ethernet card attached to a virtual machine.
//
//
type VirtualSriovEthernetCard struct {
	*VirtualEthernetCard

	// Indicates whether MTU can be changed from guest OS.
	AllowGuestOSMtuChange bool

	// Information about SR-IOV passthrough backing of this VirtualSriovEthernetCard.
	SriovBacking *VirtualSriovEthernetCardSriovBackingInfo
}

//
// The VirtualSriovEthernetCardOption data object contains the options for the
// VirtualSriovEthernetCard data object type.
//
//
type VirtualSriovEthernetCardOption struct {
	*VirtualEthernetCardOption
}

//
// The VirtualSriovEthernetCardSriovBackingInfo
// data object contains information about the SR-IOV physical function and
// virtual function backing for a passthrough NIC.
//
//
type VirtualSriovEthernetCardSriovBackingInfo struct {
	*VirtualDeviceBackingInfo

	PhysicalFunctionBacking *VirtualPCIPassthroughDeviceBackingInfo

	VirtualFunctionBacking *VirtualPCIPassthroughDeviceBackingInfo

	VirtualFunctionIndex int32
}

//
// This data object contains the option for SriovBackingInfo data
// of the virtual network SR-IOV card object type.
//
//
type VirtualSriovEthernetCardSriovBackingOption struct {
	*VirtualDeviceBackingOption
}

//
// The VirtualSwitchProfile data object represents a subprofile
// for a virtual switch. If a profile plug-in defines policies or subprofiles, use the
// policy or property
// list to access the additional configuration data.
//
//
type VirtualSwitchProfile struct {
	*ApplyProfile

	// Linkable identifier.
	Key string

	// Links that are connected to the virtual switch.
	Link *LinkProfile

	// Name of the virtual switch.
	Name string

	// Network policy for the virtual switch.
	NetworkPolicy *NetworkPolicyProfile

	// Number of ports on the virtual switch.
	NumPorts *NumPortsProfile
}

//
// The VirtualSwitchSelectionProfile data object represents
// the virtual switch that is connected to a port group.
// The policy property contains
// the configuration data values for the virtual switch.
//
//
type VirtualSwitchSelectionProfile struct {
	*ApplyProfile
}

//
// The VirtualUSB data object describes the USB device configuration
// for a virtual machine. You can attach a USB device to an ESX host.
// The device is available to only one virtual machine at a time. When you remove
// the device from the virtual machine, it becomes available to other virtual machines
// located on the host. You can add up to 20 USB devices to a virtual machine.
// Virtual USB support requires virtual machine hardware version 7 or later.
//
// The VirtualUSB object represents either a configuration to be applied to
// the virtual machine or the current device configuration on the virtual machine.
//
//
//
// • To configure a USB connection for the virtual machine, add a VirtualUSB
// object to the VirtualDeviceConfigSpec.
// Use USB backing (VirtualUSBUSBBackingInfo) to establish
// a connection with a virtual machine that will remain on the host to which
// the USB device is attached.
// The vSphere Server does not support vMotion for standard USB backing.
// To configure vMotion support for a virtual machine with a USB connection,
// use remote host backing for the USB connection
// (VirtualUSBRemoteHostBackingInfo).
//
// To configure a USB device for a virtual machine, the virtual machine
// must have a USB controller. To add a controller, include a
// VirtualUSBController object in the virtual device
// specification for your virtual machine configuration. You can add only one
// USB controller to a virtual machine.
//
//
// • To determine USB device configuration status for the virtual machine,
// check the virtual hardware device list
// (VirtualHardware.device).
// The presence of the VirtualUSB object in the hardware device list
// indicates that the virtual machine is configured to use a USB device.
// The connected property indicates
// whether the virtual machine is connected to the device.
//
//
//
//
// To determine the USB options available on the host, use the
// QueryConfigOption method to retrieve the virtual
// machine configuration. The presence of the VirtualUSBOption
// object in the retrieved configuration
// (VirtualMachineConfigOption.hardwareOptions.virtualDeviceOption)
// indicates that the host supports USB connections.
//
//
// The following operations will disconnect a USB device, losing data if data transfer
// is in progress over the USB connection.
//
//
//
// • Hot add of memory, CPU, or PCI devices. A hot add operation disconnects only
// USB devices for virtual machines that use a local connection to the device
// (VirtualUSBUSBBackingInfo).
//
// • Suspend and resume on a virtual machine.
//
// • vMotion of a virtual machine with a USB connection,
// if you are not using remote host USB backing.
//
//
//
//
// The following services do not support USB connections.
//
//
//
// • Fault Tolerance virtual machines cannot use USB devices.
//
// • DPM (Distributed Power Management) will put a host into standby,
// regardless of any connections to USB devices on the host.
//
// • DRS (Distributed Resource Scheduling) may power-off hosts that have
// USB connections to virtual machines.
//
//
//
//
//
type VirtualUSB struct {
	*VirtualDevice

	// Flag indicating whether the device is currently connected.
	// The virtual machine is not connected to the device if the autoconnect pattern
	// specified in the USB device backing
	// (VirtualDeviceDeviceBackingInfo.deviceName)
	// can not be satisfied, either
	// because there is no such device, or the matching device is not
	// available. Valid only while the virtual machine is running.
	//
	// Since VI API 2.5
	Connected bool

	// Device class families.
	// For possible values see
	// VirtualMachineUsbInfoFamily.
	//
	// Since vSphere API 4.1
	Family []string

	// Product ID of the USB device.
	//
	// Since vSphere API 4.1
	Product int32

	// Device speeds detected by server.
	// For possible values see
	// VirtualMachineUsbInfoSpeed.
	//
	// Since vSphere API 4.1
	Speed []string

	// Vendor ID of the USB device.
	//
	// Since vSphere API 4.1
	Vendor int32
}

//
// The VirtualUSBController data object describes a virtual USB controller
// and contains a list of the devices connected to the controller.
// A virtual machine must have a virtual USB controller before you can add
// a USB device to the virtual machine configuration. To add a controller,
// include a VirtualUSBController object in the
// VirtualDeviceConfigSpec for your virtual machine configuration.
// You can add only one controller to a virtual machine.
// A virtual USB controller supports up to 20 USB device connections on the
// virtual machine.
//
// The ESX Server host must have the USB controller hardware and modules
// that support USB 2.0 and USB1.1.
// You can use a maximum of 15 USB controllers on a host. If your system
// includes an additional number of controllers with connected devices,
// the additional devices will not be available to virtual machines on the host.
//
//
// You must remove all USB devices from a virtual machine before you can
// remove the USB controller.
//
//
//
type VirtualUSBController struct {
	*VirtualController

	// Flag to indicate whether or not the ability to hot plug devices
	// is enabled on this controller.
	AutoConnectDevices bool

	// Flag to indicate whether or not enhanced host controller
	// interface (USB 2.0) is enabled on this controller.
	//
	// Since VI API 2.5
	EhciEnabled bool
}

//
// The VirtualUSBControllerOption data object type contains the options
// for a virtual USB Host Controller Interface.
//
//
type VirtualUSBControllerOption struct {
	*VirtualControllerOption

	// Flag to indicate whether or not the ability to autoconnect devices
	// is enabled for this virtual USB controller.
	AutoConnectDevices *BoolOption

	// Flag to indicate whether or not enhanced host controller
	// interface (USB 2.0) is available on this virtual USB controller.
	//
	// Since VI API 2.5
	EhciSupported *BoolOption

	// Range of USB device speeds supported by this USB controller type.
	// Acceptable values are specified at VirtualMachineUsbInfoSpeed.
	//
	// Since vSphere API 5.0
	SupportedSpeeds []string
}

//
// The PciBusSlotInfo data object type
// defines information about the pci bus slots of usb controller device
// in a virtual machine.
//
//
type VirtualUSBControllerPciBusSlotInfo struct {
	*VirtualDevicePciBusSlotInfo

	// The pci slot number of eHCI controller.
	//
	// This property should be used only when the ehciEnabled property
	// is set to true.
	EhciPciSlotNumber int32
}

//
// The VirtualUSBOption data object type contains options for
// USB device configuration on a virtual machine. The vSphere API supports
// the following options:
//
//
// • Local host USB connection
// (VirtualUSBUSBBackingOption)
//
// • Remote host USB connection
// (VirtualUSBRemoteHostBackingOption)
//
//
//
//
// For information about USB device configuration, see VirtualUSB.
//
//
//
type VirtualUSBOption struct {
	*VirtualDeviceOption
}

//
// The virtual remote client USB device backing class.
//
//
type VirtualUSBRemoteClientBackingInfo struct {
	*VirtualDeviceRemoteDeviceBackingInfo

	// Hostname of the remote client where the physical USB device resides.
	Hostname string
}

//
// This data object type contains the options for
// the virtual remote USB client backing data object type.
//
//
type VirtualUSBRemoteClientBackingOption struct {
	*VirtualDeviceRemoteDeviceBackingOption
}

//
// The VirtualUSBRemoteHostBackingInfo data object
// identifies a host and a USB device that is attached to the host.
// Use this object to configure support for persistent access to the USB device
// when vMotion operations migrate a virtual machine to a different host.
// The vCenter Server will not migrate the virtual machine to a host
// that does not support the USB remote host backing capability.
//
// Specify remote host backing as part of the USB device configuration
// when you create or reconfigure a virtual machine
// (VirtualMachineConfigSpec.deviceChange.device.backing).
//
//
// To identify the USB device, you specify an autoconnect pattern
// for the deviceName.
// The virtual machine can connect to the USB device if the ESX server
// can find a USB device described by the autoconnect pattern.
// The autoconnect pattern consists of name:value pairs. You can
// use any combination of the following fields.
//
//
//
// • path - USB connection path on the host
//
// • pid - idProduct field in the USB device descriptor
//
// • vid - idVendor field in the USB device descriptor
//
// • hostId - unique ID for the host
//
// • speed - device speed (low, full, or high)
//
//
//
//
// For example, the following pattern identifies a USB device:
//
//
// "path:1/3/0 hostId:44\ 45\ 4c\ 43\ 00\ 10\ 54-80\ 35\ ca\ c0\ 4f\ 4d\ 37\ 31"
//
//
// This pattern identifies the USB device connected to port 1/3/0 on the
// host with the unique id 0x44454c4c430010548035cac04f4d3731.
//
//
// Special characters for autoconnect pattern values:
//
//
//
// • The name and value are separated by a colon (:).
//
// • Name:value pairs are separated by spaces.
//
// • The escape character is a backslash (\). Use a single backslash to embed
// a space in a value. Use a double blackslash to embed a single backslash
// in the value.
//
//
//
//
//
type VirtualUSBRemoteHostBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo

	// Name of the ESX host to which the physical USB device is attached
	// (HostSystem.name).
	// When you configure remote host backing, hostname must identify
	// the local host on which the virtual machine is running.
	Hostname string
}

//
// The VirtualUSBRemoteHostBackingOption data object
// contains options for remote host USB configuration. This backing option
// indicates support for persistent USB connections when vMotion operations
// migrate virtual machines to different hosts.
//
//
type VirtualUSBRemoteHostBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The VirtualUSBUSBBackingInfo data object
// identifies a USB device on the host where the virtual machine
// is located. This type of backing supports only a local connection
// where the virtual machine will remain on the host to which the
// USB device is attached.
//
// To identify the USB device, you specify an autoconnect pattern
// for the deviceName.
// The virtual machine can connect to the USB device if the ESX server
// can find a USB device described by the autoconnect pattern.
// The autoconnect pattern consists of name:value pairs. You can
// use any combination of the following fields.
//
//
//
// • path - USB connection path on the host
//
// • pid - idProduct field in the USB device descriptor
//
// • vid - idVendor field in the USB device descriptor
//
// • hostId - unique ID for the host
//
// • speed - device speed (low, full, or high)
//
//
//
//
// For example, the following pattern identifies a USB device:
//
//
// "path:1/3/0 hostId:44\ 45\ 4c\ 43\ 00\ 10\ 54-80\ 35\ ca\ c0\ 4f\ 4d\ 37\ 31"
//
//
// This pattern identifies the USB device connected to port 1/3/0 on the
// host with the unique id 0x44454c4c430010548035cac04f4d3731.
//
//
// Special characters for autoconnect pattern values:
//
//
//
// • The name and value are separated by a colon (:).
//
// • Name:value pairs are separated by spaces.
//
// • The escape character is a backslash (\). Use a single backslash to embed
// a space in a value. Use a double blackslash to embed a single backslash
// in the value.
//
//
//
//
//
type VirtualUSBUSBBackingInfo struct {
	*VirtualDeviceDeviceBackingInfo
}

//
// The VirtualUSBUSBBackingOption data object
// contains the options for virtual backing for a USB device.
// This backing option indicates support for a local connection where
// the virtual machine will remain on the host to which the USB device
// is attached.
//
//
type VirtualUSBUSBBackingOption struct {
	*VirtualDeviceDeviceBackingOption
}

//
// The VirtualUSBXHCIController data object describes a virtual
// USB Extensible Host Controller Interface (USB 3.0).
// For more informatino see VirtualUSBController.
//
//
type VirtualUSBXHCIController struct {
	*VirtualController

	// Flag to indicate whether or not the ability to hot plug devices
	// is enabled on this controller.
	AutoConnectDevices bool
}

//
// The VirtualUSBXHCIControllerOption data object type contains the options
// for a virtual USB Extensible Host Controller Interface (USB 3.0).
//
//
type VirtualUSBXHCIControllerOption struct {
	*VirtualControllerOption

	// Flag to indicate whether or not the ability to autoconnect devices
	// is enabled for this virtual USB controller.
	AutoConnectDevices *BoolOption

	// Range of USB device speeds supported by this USB controller type.
	// Acceptable values are specified at VirtualMachineUsbInfoSpeed.
	SupportedSpeeds []string
}

//
// This data object type contains the options for the
// VirtualVMIROM data object type.
//
//
type VirtualVMIROMOption struct {
	*VirtualDeviceOption
}

//
// This data object type contains the options for the
// VirtualVideoCard data object type.
//
//
type VirtualVideoCardOption struct {
	*VirtualDeviceOption

	// Minimum, maximum and default value for the number of displays.
	//
	// Since vSphere API 4.0
	NumDisplays *IntOption

	// Flag to indicate whether the virtual video card supports 3D functions.
	//
	// Since vSphere API 4.0
	Support3D *BoolOption

	// Flag to indicate whether the virtual video card can specify how to render 3D graphics.
	//
	// Since vSphere API 5.1
	Use3dRendererSupported *BoolOption

	// Flag to indicate whether the display settings of the host should
	// be used to automatically determine the display settings of the
	// virtual machine's video card.
	//
	// Since vSphere API 4.0
	UseAutoDetect *BoolOption

	// Minimum, maximum and default size of the video frame buffer.
	VideoRamSizeInKB *LongOption
}

//
// The VirtualVmxnet data object type represents an instance
// of the Vmxnet virtual Ethernet adapter attached to a virtual machine.
//
//
type VirtualVmxnet struct {
	*VirtualEthernetCard
}

//
// The VirtualVmxnet2 data object type represents an instance
// of the Vmxnet2 virtual Ethernet adapter attached to a virtual machine.
//
//
type VirtualVmxnet2 struct {
	*VirtualVmxnet
}

//
// The VirtualVmxnet2Option data object type contains the options for the
// VirtualVmxnet2 data object type.
//
//
type VirtualVmxnet2Option struct {
	*VirtualVmxnetOption
}

//
// The VirtualVmxnet3 data object type represents an instance
// of the Vmxnet3 virtual Ethernet adapter attached to a virtual machine.
//
//
type VirtualVmxnet3 struct {
	*VirtualVmxnet
}

//
// The VirtualVmxnet3Option data object type contains the options for the
// VirtualVmxnet3 data object type.
//
//
type VirtualVmxnet3Option struct {
	*VirtualVmxnetOption
}

//
// The VirtualVmxnetOption data object type contains the options for the
// VirtualVmxnet data object type.
//
//
type VirtualVmxnetOption struct {
	*VirtualEthernetCardOption
}

// Deprecated.
// As of VI API 2.5, use the VMware vCenter Converter,
// an optional software plug-in for vCenter Server for
// migrating physical and virtual machines to VMware vSphere.
//
//
// The VirtualizationManager is the interface for discover and consolidate
// host and services from physical environment to virtualization environment.
//
type VirtualizationManager struct {
	*ManagedObject
}

//
// The VlanProfile data object represents
// the VLAN identifier subprofile. The policy
// property contains the configuration data values for the VLAN identifier.
//
//
type VlanProfile struct {
	*ApplyProfile
}

//
// This event records a user successfully acquiring an MKS ticket
//
//
type VmAcquiredMksTicketEvent struct {
	*VmEvent
}

//
// This event records a user successfully acquiring a ticket
//
//
type VmAcquiredTicketEvent struct {
	*VmEvent

	// The type of the ticketSee VirtualMachine.TicketType
	TicketType string
}

//
// Fault thrown when moving a standalone host between datacenters, and
// one or more of the virtual machines registered on the host are already
// registered to hosts in the target datacenter.
//
//
type VmAlreadyExistsInDatacenter struct {
	*InvalidFolder

	// The target host.
	Host *HostSystem

	// Name of the target host.
	Hostname string

	// Virtual machines in the target datacenter which have the same
	// registration information as those belonging to the target host.
	Vm []*VirtualMachine
}

//
// This event records that a virtual machine was automatically renamed
// because of a name conflict.
//
//
type VmAutoRenameEvent struct {
	*VmEvent

	// The name of the virtual machine after renaming.
	NewName string

	// The name of the virtual machine before renaming.
	OldName string
}

//
// This event records a virtual machine being cloned.
//
//
type VmBeingClonedEvent struct {
	*VmCloneEvent

	// The destination folder to which the virtual machine is being cloned.
	DestFolder *FolderEventArgument

	// The destination host to which the virtual machine is being cloned.
	DestHost *HostEventArgument

	// The name of the destination virtual machine.
	DestName string
}

//
// This event records a virtual machine being cloned.
//
//
type VmBeingClonedNoFolderEvent struct {
	*VmCloneEvent

	// The destination host to which the virtual machine is being cloned.
	DestHost *HostEventArgument

	// The name of the destination virtual machine.
	DestName string
}

//
// This event records a virtual machine being created.
//
//
type VmBeingCreatedEvent struct {
	*VmEvent

	// The configuration specification that was used to create this virtual machine.
	ConfigSpec *VirtualMachineConfigSpec
}

//
// This event records a virtual machine being deployed from a template.
//
//
type VmBeingDeployedEvent struct {
	*VmEvent

	// The template object from which the virtual machine is being deployed.
	SrcTemplate *VmEventArgument
}

//
// This event records that a virtual machine is being hot-migrated.
//
//
type VmBeingHotMigratedEvent struct {
	*VmEvent

	// The destination datacenter to which the virtual machine is being migrated
	//
	// Since vSphere API 5.0
	DestDatacenter *DatacenterEventArgument

	// The destination primary datastore to which the virtual machine is being migrated
	//
	// Since vSphere API 5.0
	DestDatastore *DatastoreEventArgument

	// The destination host to which the virtual machine is to be migrated.
	DestHost *HostEventArgument
}

//
// This event records that a virtual machine is being migrated.
//
//
type VmBeingMigratedEvent struct {
	*VmEvent

	// The destination datacenter
	//
	// Since vSphere API 5.0
	DestDatacenter *DatacenterEventArgument

	// The destination primary datastore
	//
	// Since vSphere API 5.0
	DestDatastore *DatastoreEventArgument

	// The destination host.
	DestHost *HostEventArgument
}

//
// This event records that a virtual machine is being relocated.
//
//
type VmBeingRelocatedEvent struct {
	*VmRelocateSpecEvent

	// The destination datacenter to which the virtual machine is being relocated
	//
	// Since vSphere API 5.0
	DestDatacenter *DatacenterEventArgument

	// The destination primary datastore to which the virtual machine is being relocated
	//
	// Since vSphere API 5.0
	DestDatastore *DatastoreEventArgument

	// The destination host to which the virtual machine is being relocated.
	DestHost *HostEventArgument
}

//
// The is the base event for all clone operations.
//
//
type VmCloneEvent struct {
	*VmEvent
}

//
// This event records a failure to clone a virtual machine.
//
//
type VmCloneFailedEvent struct {
	*VmCloneEvent

	// The destination folder to which the virtual machine is being cloned.
	DestFolder *FolderEventArgument

	// The destination host to which the virtual machine was being cloned.
	DestHost *HostEventArgument

	// The name of the destination virtual machine.
	DestName string

	// The reason why this clone operation failed.
	Reason *LocalizedMethodFault
}

//
// This event records the completion of a virtual machine cloning operation.
//
//
type VmClonedEvent struct {
	*VmCloneEvent

	// The source virtual machine for the clone operation.
	SourceVm *VmEventArgument
}

//
// Base for configuration / environment issues that can be thrown when powering on or
// changing the configuration of a virtual machine. Subclasses of this fault is also
// used as recent why a migration can fail.
//
//
type VmConfigFault struct {
	*VimFault
}

//
// This data object type describes a virtual machine configuration file.
//
//
type VmConfigFileInfo struct {
	*FileInfo

	ConfigVersion int32
}

//
// This data object type describes query specification for the virtual machine
// configuration file.
//
//
type VmConfigFileQuery struct {
	*FileQuery

	// The details specification for the virtual machine configuration file query.
	Details *VmConfigFileQueryFlags

	// The filter specification for the virtual machine configuration file query.
	Filter *VmConfigFileQueryFilter
}

//
// The filter for the virtual machine configuration file.
//
//
type VmConfigFileQueryFilter struct {
	*DynamicData

	// If this property is set, only the virtual machine configuration files that
	// match one of the specified configuration versions are selected. If no
	// versions are specified, this search criteria is ignored.
	MatchConfigVersion []int32
}

type VmConfigFileQueryFlags struct {
	*DynamicData

	// The flag to indicate whether or not the configuration file version number is
	// returned.
	ConfigVersion bool
}

//
// Thrown when a virtual machine's existing or requested configuration is
// incompatible for fault tolerance.
//
//
type VmConfigIncompatibleForFaultTolerance struct {
	*VmConfigFault

	// Fault indicating the specific configuration issue. This is typically
	// a subclass of VirtualHardwareCompatibilityIssue.
	Fault *LocalizedMethodFault
}

//
// Thrown when a virtual machine's existing or requested configuration is
// incompatible for record and replay.
//
//
type VmConfigIncompatibleForRecordReplay struct {
	*VmConfigFault

	// Fault indicating the specific configuration issue. This is typically
	// a subclass of VirtualHardwareCompatibilityIssue.
	Fault *LocalizedMethodFault
}

//
// VM Configuration.
//
//
type VmConfigInfo struct {
	*DynamicData

	// End User Liceses Agreements.
	Eula []string

	// Specifies whether the VM needs an initial boot before the deployment is complete.
	//
	// Not relevant for vApps. This means that the value is always false when reading the
	// configuration and is ignored when setting the configuration.
	//
	// If a vApp requires an install boot (because one of its VMs does), this is visible
	// on the installBootRequired field of the vApp.
	InstallBootRequired bool

	// Specifies the delay in seconds to wait for the VM to power off after the initial
	// boot (used only if installBootRequired is true). A value of 0 means wait forever.
	//
	// Not relevant for vApps. This means that the value is always false when reading the
	// configuration and is ignored when setting the configuration.
	InstallBootStopDelay int32

	// IP assignment policy and DHCP support configuration.
	IpAssignment *VAppIPAssignmentInfo

	// List the transports to use for properties. Supported values are: iso and
	// com.vmware.guestInfo.
	OvfEnvironmentTransport []string

	// List of uninterpreted OVF meta-data sections.
	OvfSection []*VAppOvfSectionInfo

	// Information about the package content.
	Product []*VAppProductInfo

	// List of properties
	Property []*VAppPropertyInfo
}

//
// This event records if the configuration file can not be found.
//
//
type VmConfigMissingEvent struct {
	*VmEvent
}

//
// vApp related configuration of a VM.
//
//
type VmConfigSpec struct {
	*DynamicData

	// End User Liceses Agreements.
	//
	// If this list is set, it replaces all exiting  licenses. An empty list will not
	// make any changes to installed licenses. A list with a single element {""} will
	// remove all licenses and leave an empty list.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Eula []string

	// If this is on a VirtualMachine object, it specifies whether the VM needs an
	// initial boot before the deployment is complete. If this is on a vApp object,
	// it indicates than one or more VMs needs an initial reboot. This flag is
	// automatically reset once the reboot has happened.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	InstallBootRequired bool

	// Specifies the delay in seconds to wait for the VM to power off after the initial
	// boot (used only if installBootRequired is true). A value of 0 means wait forever.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	InstallBootStopDelay int32

	// IP assignment policy and DHCP support configuration.
	//
	// Reconfigure privilege: See VAppIPAssignmentInfo
	IpAssignment *VAppIPAssignmentInfo

	// List the transports to use for properties. Supported values are: iso and
	// com.vmware.guestInfo.
	//
	// If this list is set, it replaces all exiting entries. An empty list will not make
	// any changes. A list with a single element {""} will clear the list of transports.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	OvfEnvironmentTransport []string

	// List of uninterpreted OVF meta-data sections.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	OvfSection []*VAppOvfSectionSpec

	// Information about the product.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Product []*VAppProductSpec

	// List of properties.
	//
	// Adding and editing properties requires various privileges depending on which fields
	// are affected. See VAppPropertyInfo for details.
	//
	// Deleting properties requires the privilege VApp.ApplicationConfig.
	Property []*VAppPropertySpec
}

//
// This event records that a virtual machine is connected.
//
//
type VmConnectedEvent struct {
	*VmEvent
}

//
// This event records that a virtual machine was successfully created.
//
//
type VmCreatedEvent struct {
	*VmEvent
}

//
// This event records when a virtual machine is reset by
// HA VM Health Monitoring on hosts that do not support the
// create screenshot api or if the createscreenshot api fails.
//
//
type VmDasBeingResetEvent struct {
	*VmEvent

	// The reason why this vm is being reset
	//
	// Since vSphere API 4.1
	Reason string
}

type VmDasBeingResetEventReasonCode struct {
}

//
// This event records when a virtual machine is reset by
// HA VM Health Monitoring on hosts that support the create screenshot api
//
//
type VmDasBeingResetWithScreenshotEvent struct {
	*VmDasBeingResetEvent

	// The datastore path of the screenshot taken before resetting.
	ScreenshotFilePath string
}

//
// This event records when HA VM Health Monitoring fails to reset
// a virtual machine after failure
//
//
type VmDasResetFailedEvent struct {
	*VmEvent
}

//
// The event records that an error occured when updating the HA agents
// with the current state of the virtual machine. If this occurs during a
// powerOn operation, the virtual machine will not be failed over in the
// event of a host failure. If it occurs during a powerOff, the virtual
// machine will be automatically powered on if the host it was last running
// on crashes.
//
//
type VmDasUpdateErrorEvent struct {
	*VmEvent
}

//
// This event records that HA agents have been updated with the current
// state of the virtual machine.
//
//
type VmDasUpdateOkEvent struct {
	*VmEvent
}

//
// This event records when the VirtualCenter server date rolled back.
//
//
type VmDateRolledBackEvent struct {
	*VmEvent
}

//
// This event records a failure to deploy from a template.
//
//
type VmDeployFailedEvent struct {
	*VmEvent

	// The destination datastore the template is being deployed to.
	DestDatastore *EntityEventArgument

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records the completion of a virtual machine deployment operation.
//
//
type VmDeployedEvent struct {
	*VmEvent

	// The template object from which the virtual machine has been deployed.
	SrcTemplate *VmEventArgument
}

//
// This event records that a virtual machine disconnected.
//
//
type VmDisconnectedEvent struct {
	*VmEvent
}

//
// This event records a virtual machine discovery.
//
//
type VmDiscoveredEvent struct {
	*VmEvent
}

//
// This event records a failure to create a virtual disk in a virtual machine.
//
//
type VmDiskFailedEvent struct {
	*VmEvent

	// The name of the virtual disk.
	Disk string

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This data object type describes a virtual disk primary file.
//
//
type VmDiskFileInfo struct {
	*FileInfo

	// The capacity of a virtual disk from the point of view of a virtual machine.
	CapacityKb int64

	// Deprecated.
	// As of vSphere API 5.0, this property is no longer
	// relevant and should not be used.
	// With the current state of emulation, we don't care about the
	// adapter type a disk is connected to, as disks may be shuffled
	// around. For example, a disk may be unplugged from a buslogic
	// controller and plugged into an lsilogic controller.
	//
	//
	// The controller type suitable for this virtual disk.
	//
	// Since VI API 2.5
	ControllerType string

	// The extents of this virtual disk specified in absolute DS paths
	//
	// Since VI API 2.5
	DiskExtents []string

	// Disk type of the virtual disk.
	//
	// The specified disk type is one of the backing information types for a virtual
	// disk.See VirtualDisk
	DiskType string

	// The hardware version of the virtual disk file.
	HardwareVersion int32

	// Indicates if the disk is thin-provisioned
	//
	// Since vSphere API 4.0
	Thin bool
}

//
// This data object type describes the query specification for the virtual disk
// primary file.
//
//
type VmDiskFileQuery struct {
	*FileQuery

	// Details specification for the virtual disk primary file query.
	Details *VmDiskFileQueryFlags

	// The filter specification for the virtual disk primary file query.
	Filter *VmDiskFileQueryFilter
}

//
// The filter for the virtual disk primary file.
//
//
type VmDiskFileQueryFilter struct {
	*DynamicData

	// Deprecated.
	// As of vSphere API 5.0, this property is no longer
	// relevant and should not be used.
	// With the current state of emulation, we don't care about the
	// adapter type a disk is connected to, as disks may be shuffled
	// around. For example, a disk may be unplugged from a buslogic
	// controller and plugged into an lsilogic controller.
	//
	//
	// If this optional property is set, only virtual disk files that have a
	// controller type that matches one of the controller types specified
	// are returned. If no controller types are specified, this search criteria
	// is ignored.
	//
	// The specified controller type is one of the controller types for a
	// virtual disk.See VirtualIDEControllerSee VirtualSCSIController
	//
	// Since VI API 2.5
	ControllerType []string

	// If this optional property is set, only the virtual disk primary files that
	// match one of the specified disk types are selected. If no disk types are
	// specified, this search criteria is ignored.
	//
	// The specified disk type is one of the backing information types for a
	// virtual disk.See VirtualDisk
	DiskType []string

	// If this optional property is set, only virtual disk primary files that match
	// one of the specified hardware versions are selected.  If no versions are
	// specified, this search criteria is ignored.
	MatchHardwareVersion []int32

	// This optional property can be used to filter disks based on whether
	// they are thin-provsioned or not: if set to true, only thin-provisioned
	// disks are returned, and vice-versa.
	//
	// Since vSphere API 4.0
	Thin bool
}

//
// Details for the virtual disk primary file.
//
//
type VmDiskFileQueryFlags struct {
	*DynamicData

	// The flag to indicate whether the capacity of the virtual disk from
	// the point of view of a virtual machine is returned.
	CapacityKb bool

	// Deprecated.
	// As of vSphere API 5.0, this property is no longer
	// relevant and should not be used.
	// With the current state of emulation, we don't care about the
	// adapter type a disk is connected to, as disks may be shuffled
	// around. For example, a disk may be unplugged from a buslogic
	// controller and plugged into an lsilogic controller.
	//
	//
	// The flag to indicate whether or not the controller type of the virtual disk
	// file is returned.
	//
	// Since VI API 2.5
	ControllerType bool

	// The flag to indicate whether or not the disk extents of the virtual disk
	// are returned.
	//
	// Since VI API 2.5
	DiskExtents bool

	// The flag to indicate whether the type of the physical disk backing
	// the virtual disk is returned.
	DiskType bool

	// The flag to indicate whether the hardware version of the virtual disk
	// file is returned.
	HardwareVersion bool

	// The flag to indicate whether the thin-ness of the disk is returned.
	//
	// Since vSphere API 4.0
	Thin bool
}

//
// This event records a virtual machine emigration.
//
//
type VmEmigratingEvent struct {
	*VmEvent
}

//
// This event indicates the end of a recording session on a virtual machine.
//
//
type VmEndRecordingEvent struct {
	*VmEvent
}

//
// This event indicates the end of a replay session on a virtual machine.
//
//
type VmEndReplayingEvent struct {
	*VmEvent
}

//
// These are virtual machine events.
//
//
type VmEvent struct {
	*Event

	// Indicates whether or not the virtual machine is marked as a template.
	Template bool
}

//
// The event argument is a VirtualMachine object.
//
//
type VmEventArgument struct {
	*EntityEventArgument

	// The VirtualMachine object.
	Vm *VirtualMachine
}

//
// This event records a failure to migrate a virtual machine.
//
//
type VmFailedMigrateEvent struct {
	*VmEvent

	// The destination datacenter
	//
	// Since vSphere API 5.0
	DestDatacenter *DatacenterEventArgument

	// The destination primary datastore
	//
	// Since vSphere API 5.0
	DestDatastore *DatastoreEventArgument

	// The destination host.
	DestHost *HostEventArgument

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records a specific failure to relay out a virtual machine,
// such as a failure to access the disk.
//
//
type VmFailedRelayoutEvent struct {
	*VmEvent

	Reason *LocalizedMethodFault
}

//
// This event records a failure to relay out a virtual machine
// when the virtual machine still has disks on a VMFS2 volume.
//
//
type VmFailedRelayoutOnVmfs2DatastoreEvent struct {
	*VmEvent
}

//
// This event records vmotion failure when starting a secondary VM.
//
//
type VmFailedStartingSecondaryEvent struct {
	*VmEvent

	// The reason for the failure.
	// See VmFailedStartingSecondaryEventFailureReason
	Reason string
}

//
// The reason for the failure.
//
//
type VmFailedStartingSecondaryEventFailureReason struct {
}

//
// This event records a failure to power off a virtual machine.
//
//
type VmFailedToPowerOffEvent struct {
	*VmEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records a failure to power on a virtual machine.
//
//
type VmFailedToPowerOnEvent struct {
	*VmEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records a failure to reboot the guest on a virtual machine.
//
//
type VmFailedToRebootGuestEvent struct {
	*VmEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records a failure to reset a virtual machine.
//
//
type VmFailedToResetEvent struct {
	*VmEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records a failure to shut down the guest on a virtual machine.
//
//
type VmFailedToShutdownGuestEvent struct {
	*VmEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records a failure to set the guest on a virtual machine to a standby
// state.
//
//
type VmFailedToStandbyGuestEvent struct {
	*VmEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records a failure to suspend a virtual machine.
//
//
type VmFailedToSuspendEvent struct {
	*VmEvent

	// The reason for the failure.
	Reason *LocalizedMethodFault
}

//
// This event records after a failover the new new primary failed to
// update the config of the secondary vm.
//
//
type VmFailedUpdatingSecondaryConfig struct {
	*VmEvent
}

//
// This event records when a virtual machine failover was unsuccessful.
//
//
type VmFailoverFailed struct {
	*VmEvent

	// The reason for the failure
	//
	// Since vSphere API 4.1
	Reason *LocalizedMethodFault
}

//
// Configuration issues that can occur during operations
// related to fault tolerance protection for virtual machines.
//
//
type VmFaultToleranceConfigIssue struct {
	*VmFaultToleranceIssue

	// The entity
	Entity *ManagedEntity

	// The entity name. Depending on the issue, it could
	// be virtual machine or host.
	EntityName string

	// The reason for the failure.
	Reason string
}

type VmFaultToleranceConfigIssueReasonForIssue struct {
}

//
// Configuration issues that can occur during operations
// related to fault tolerance protection for virtual machines.
//
//
type VmFaultToleranceConfigIssueWrapper struct {
	*VmFaultToleranceIssue

	// The entity
	Entity *ManagedEntity

	// The entity name. Depending on the issue, it could
	// be virtual machine or host.
	EntityName string

	// The nested error when the reason field is other
	Error *LocalizedMethodFault
}

//
// Indicates the file backing for some device prevents fault tolerance
// protection
//
//
type VmFaultToleranceInvalidFileBacking struct {
	*VmFaultToleranceIssue

	BackingFilename string

	// The device type of the file backing
	BackingType string
}

type VmFaultToleranceInvalidFileBackingDeviceType struct {
}

//
// Base object type for issues that can occur during operations
// related to fault tolerance protection for virtual machines.
//
//
type VmFaultToleranceIssue struct {
	*VimFault
}

//
// Container for a list of configuration issues that can occur during
// operations related to fault tolerance protection for virtual machines.
//
//
type VmFaultToleranceOpIssuesList struct {
	*VmFaultToleranceIssue

	// A list of faults representing errors
	Errors []*LocalizedMethodFault

	Warnings []*LocalizedMethodFault
}

//
// This event records a fault tolerance state change.
// A default alarm will be triggered upon this event, which would
// change the vm state:
// the vm state is red if the newState is needSecondary;
// the vm state is yellow if the newState is disabled;
// the vm state is green if the newState is notConfigured, starting,
// enabled or running
//
//
type VmFaultToleranceStateChangedEvent struct {
	*VmEvent

	// The new fault tolerance state.
	NewState *enum.VirtualMachineFaultToleranceState

	// The old fault toleeance state.
	OldState *enum.VirtualMachineFaultToleranceState
}

//
// This fault is returned when a host has more than the recommended number of
// Fault Tolerance VMs running on it.
//
//
type VmFaultToleranceTooManyVMsOnHost struct {
	*InsufficientResourcesFault

	HostName string

	// The recommended number of Fault Tolerance VMs running on the host.
	MaxNumFtVms int32
}

//
// This event records that all secondary virtual machines have
// been removed and fault tolerance protection turned off for
// this virtual machine.
//
//
type VmFaultToleranceTurnedOffEvent struct {
	*VmEvent
}

//
// This event records a secondary or primary VM is terminated.
// The reason could be : divergence, lost connection to secondary, partial
// hardware failure of secondary, or by user.
//
//
type VmFaultToleranceVmTerminatedEvent struct {
	*VmEvent

	Reason string
}

//
// This is a virtual machine guest reboot request event.
//
//
type VmGuestRebootEvent struct {
	*VmEvent
}

//
// This is a virtual machine guest shutdown request event.
//
//
type VmGuestShutdownEvent struct {
	*VmEvent
}

//
// This is a virtual machine guest standby request event.
//
//
type VmGuestStandbyEvent struct {
	*VmEvent
}

//
// This event records when host monitoring state has changed.
//
//
type VmHealthMonitoringStateChangedEvent struct {
	*ClusterEvent

	// The service state in
	// ClusterDasConfigInfoVmMonitoringState
	State string
}

//
// The virtual machine if powered on or VMotioned, would violate a VM-Host affinity rule.
//
//
type VmHostAffinityRuleViolation struct {
	*VmConfigFault

	// The host that the virtual machine can not be powered on without violating a rule.
	HostName string

	// The vm that can not be powered on or VMotioned without violating a rule.
	VmName string
}

//
// This event records the assignment of a new instance UUID
// to a virtual machine.
//
//
type VmInstanceUuidAssignedEvent struct {
	*VmEvent

	// The new instance UUID.
	InstanceUuid string
}

//
// This event records a change in a virtual machine's instance UUID.
//
//
type VmInstanceUuidChangedEvent struct {
	*VmEvent

	// The new instance UUID.
	NewInstanceUuid string

	// The old instance UUID.
	OldInstanceUuid string
}

//
// This event records a conflict of virtual machine instance UUIDs.
//
//
type VmInstanceUuidConflictEvent struct {
	*VmEvent

	// The virtual machine whose instance UUID conflicts with the
	// current virtual machine's instance UUID.
	ConflictedVm *VmEventArgument

	// The instance UUID in conflict.
	InstanceUuid string
}

//
// A VmLimitLicense fault is thrown if powering on the virtual
// machine would exceed the maximum number of running virtual
// machines allowed.
//
//
type VmLimitLicense struct {
	*NotEnoughLicenses

	// The maximum number of running virtual machines
	// limit.
	Limit int32
}

//
// This data object type describes a file that is logging output for a virtual
// machine.
//
//
type VmLogFileInfo struct {
	*FileInfo
}

//
// This data object type describes the query specification for a virtual machine log
// file file.
//
//
type VmLogFileQuery struct {
	*FileQuery
}

//
// This event records the assignment of a new MAC address
// to a virtual network adapter.
//
//
type VmMacAssignedEvent struct {
	*VmEvent

	// The name of the virtual adapter.
	Adapter string

	// The new MAC address.
	Mac string
}

//
// This event records a change in a virtual machine's MAC address.
//
//
type VmMacChangedEvent struct {
	*VmEvent

	// The name of the virtual network adapter.
	Adapter string

	// The new MAC address.
	NewMac string

	// The old MAC address.
	OldMac string
}

//
// This event records a MAC address conflict for a virtual machine.
//
//
type VmMacConflictEvent struct {
	*VmEvent

	// The virtual machine whose MAC address conflicts with
	// the current virtual machine's address.
	ConflictedVm *VmEventArgument

	// The MAC address that is in conflict.
	Mac string
}

//
// This event is fired when FT VM reached the max restart count
//
//
type VmMaxFTRestartCountReached struct {
	*VmEvent
}

//
// This event is fired when the VM reached the max restart count
//
//
type VmMaxRestartCountReached struct {
	*VmEvent
}

//
// This event records when an error message (consisting of a collection of "observations")
// is thrown by the virtual machine. This is a generic event for such messages.
//
//
type VmMessageErrorEvent struct {
	*VmEvent

	// A raw message returned by the virtualization platform.
	Message string

	MessageInfo []*VirtualMachineMessage
}

//
// This event records when an informational message (consisting of a collection of "observations")
// is thrown by the virtual machine. This is a generic event for such messages.
//
//
type VmMessageEvent struct {
	*VmEvent

	// A raw message returned by the virtualization platform.
	Message string

	// Since VI API 2.5
	MessageInfo []*VirtualMachineMessage
}

//
// This event records when a warning message (consisting of a collection of "observations")
// is thrown by the virtual machine. This is a generic event for such messages.
//
//
type VmMessageWarningEvent struct {
	*VmEvent

	// A raw message returned by the virtualization platform.
	Message string

	MessageInfo []*VirtualMachineMessage
}

//
// This fault indicates that some error has occurred during the processing of
// of a MetadataManager operation. This may be subclassed by a more specific
// fault.
//
//
type VmMetadataManagerFault struct {
	*VimFault
}

//
// This event records a virtual machine migration.
//
//
type VmMigratedEvent struct {
	*VmEvent

	// The source datacenter
	//
	// Since vSphere API 5.0
	SourceDatacenter *DatacenterEventArgument

	// The source primary datastore
	//
	// Since vSphere API 5.0
	SourceDatastore *DatastoreEventArgument

	// The source host.  (Because this is after a successful migration,
	// the destination host is recorded in the inherited "host" property.)
	SourceHost *HostEventArgument
}

//
// Thrown when turning on Fault Tolerance protection on a running virtual machine
// if the virtual machine is running in a monitor mode that is incompatible.
//
//
type VmMonitorIncompatibleForFaultTolerance struct {
	*VimFault
}

//
// This event records that no compatible host was found to place a
// secondary VM.
// A default alarm will be triggered upon this event, which by default
// would trigger a SNMP trap.
//
//
type VmNoCompatibleHostForSecondaryEvent struct {
	*VmEvent
}

//
// This event records a migration failure when the destination host
// is not on the same network as the source host.
//
//
type VmNoNetworkAccessEvent struct {
	*VmEvent

	// The destination host.
	DestHost *HostEventArgument
}

//
// This data object type describes a file that is a virtual machine non-volatile
// memory file.
//
//
type VmNvramFileInfo struct {
	*FileInfo
}

//
// This data object type describes the query specification for a non-volatile memory
// file.
//
//
type VmNvramFileQuery struct {
	*FileQuery
}

//
// This event records a virtual machine for which no host is responsible.
//
//
type VmOrphanedEvent struct {
	*VmEvent
}

//
// Initial VM configuration for the specified pod.
// This configuration will be saved to the pod config
// StorageDrsConfigInfo
// when the placement recommendations are applied.
//
//
//
//
type VmPodConfigForPlacement struct {
	*DynamicData

	// Array of PodDiskLocator objects.
	Disk []*PodDiskLocator

	// The initial interVmRules that should during placement of this
	// virtual machine. It may not always be possible to specify that the
	// virtual machine being placed is part of the rule because the
	// virtual machine may not have been created yet. So for simplicity,
	// we assume the virtual machine being placed is always implicitly
	// part of any rule specified. It will be explicitly added to the
	// rule before it is saved to the pod config.
	InterVmRule []*ClusterRuleInfo

	// The pod that this initial configuration applies to.
	// Since there could be multiple pods in a single placement request,
	// we may need to specify multiple initial VM configurations, one per
	// pod.
	StoragePod *StoragePod

	// The VM configuration for the VM that is being placed.
	VmConfig *StorageDrsVmConfigInfo
}

//
// The VmPortGroupProfile data object represents the subprofile
// for a port group that will be used by virtual machines.
// Use the policy list for
// access to configuration data for the virtual machine port group profile. Use the
// property list for access to subprofiles, if any.
//
// vSphere Servers use Network managed objects to represent virtual machine port
// groups in the vSphere inventory.
//
//
//
type VmPortGroupProfile struct {
	*PortGroupProfile
}

//
// This event records when a virtual machine has been powered off on an isolated host
// in a HA cluster.
//
//
type VmPowerOffOnIsolationEvent struct {
	*VmPoweredOffEvent

	// The isolated host on which a virtual machine is powered off.
	IsolatedHost *HostEventArgument
}

//
// This exception is thrown if the power-on of a virtual machine is attempted
// when the operation is disabled on the host
//
//
type VmPowerOnDisabled struct {
	*InvalidState
}

//
// This event records when a virtual machine finished powering off.
//
//
type VmPoweredOffEvent struct {
	*VmEvent
}

//
// This event records when a virtual machine finished powering on.
//
//
type VmPoweredOnEvent struct {
	*VmEvent
}

//
// This event records when a virtual machine was powering on using
// DVPorts with port level configuration, which might be different
// from the DVportgroup.
//
//
type VmPoweringOnWithCustomizedDVPortEvent struct {
	*VmEvent

	// The list of Virtual NIC that were using the DVports.
	Vnic []*VnicPortArgument
}

//
// This event records a fault tolerance failover.
// The reason could be : lost connection to primary, partial hardware failure
// of primary or by user.
//
//
type VmPrimaryFailoverEvent struct {
	*VmEvent

	// The reason for the failure.
	// see VirtualMachineNeedSecondaryReason
	Reason string
}

//
// This event records a reconfiguration of the virtual machine.
//
//
type VmReconfiguredEvent struct {
	*VmEvent

	// The configuration specification that was used for the reconfiguration.
	ConfigSpec *VirtualMachineConfigSpec
}

//
// This event records that a virtual machine was successfully registered.
//
//
type VmRegisteredEvent struct {
	*VmEvent
}

//
// This event records that a virtual machine was successfully
// converted to the new virtual machine format on a VMFS3 volume.
//
//
type VmRelayoutSuccessfulEvent struct {
	*VmEvent
}

//
// This event records that a virtual machine is already in the
// correct format. No relay out is necessary.
//
//
type VmRelayoutUpToDateEvent struct {
	*VmEvent
}

//
// This event records that a virtual machine was sucessfully reloaded from a
// new configuration path.
//
//
type VmReloadFromPathEvent struct {
	*VmEvent

	ConfigPath string
}

//
// This event records that a virtual machine reload from a new configuration
// path failed.
//
//
type VmReloadFromPathFailedEvent struct {
	*VmEvent

	ConfigPath string
}

//
// This event records a failure to relocate a virtual machine.
//
//
type VmRelocateFailedEvent struct {
	*VmRelocateSpecEvent

	// The destination datacenter to which the virtual machine was being relocated
	//
	// Since vSphere API 5.0
	DestDatacenter *DatacenterEventArgument

	// The destination primary datastore to which the virtual machine was being relocated
	//
	// Since vSphere API 5.0
	DestDatastore *DatastoreEventArgument

	// The destination host to which the virtual machine is being relocated.
	DestHost *HostEventArgument

	// The reason why this relocate operation failed.
	Reason *LocalizedMethodFault
}

//
// This event is the base event for relocate and clone base events.
//
//
type VmRelocateSpecEvent struct {
	*VmEvent
}

//
// This event records the completion of a virtual machine relocation.
//
//
type VmRelocatedEvent struct {
	*VmRelocateSpecEvent

	// The source datacenter from which the virtual machine relocated
	//
	// Since vSphere API 5.0
	SourceDatacenter *DatacenterEventArgument

	// The source primary datastore from which the virtual machine relocated
	//
	// Since vSphere API 5.0
	SourceDatastore *DatastoreEventArgument

	// The source host from which the virtual machine was relocated.
	SourceHost *HostEventArgument
}

//
// This event records that a remote console was connected to the VM
//
//
type VmRemoteConsoleConnectedEvent struct {
	*VmEvent
}

//
// This event records that a remote console was disconnected from the VM
//
//
type VmRemoteConsoleDisconnectedEvent struct {
	*VmEvent
}

//
// This event records a virtual machine removed from VirtualCenter management.
//
//
type VmRemovedEvent struct {
	*VmEvent
}

//
// This event records the renaming of a virtual machine.
//
//
type VmRenamedEvent struct {
	*VmEvent

	// The new name of the virtual machine.
	NewName string

	// The old name of the virtual machine.
	OldName string
}

//
// The virtual machine is using features that exceed what the
// host is capable of providing. This may occur when joining an EVC cluster
// while the virtual machine is powered on.
// The most common resolution is to power cycle the virtual machine.
//
//
type VmRequirementsExceedCurrentEVCModeEvent struct {
	*VmEvent
}

//
// This event records a virtual machine resetting.
//
//
type VmResettingEvent struct {
	*VmEvent
}

//
// This event records when a virtual machine is moved from one resource pool to another.
//
//
type VmResourcePoolMovedEvent struct {
	*VmEvent

	// The new parent resourcePool of the moved virtual machine.
	NewParent *ResourcePoolEventArgument

	// The old parent resourcePool of the moved virtual machine.
	OldParent *ResourcePoolEventArgument
}

//
// This event records a change in resource allocation of a virtual machine.
//
//
type VmResourceReallocatedEvent struct {
	*VmEvent
}

// Deprecated.
// As of vSphere API 5.0, the Server will generate the EventEx event
// with the eventTypeId property set to "com.vmware.vc.ha.VmRestartedByHAEvent".
//
//
// This event records that the virtual machine was restarted on a host, since
// its original host had failed.
//
//
type VmRestartedOnAlternateHostEvent struct {
	*VmPoweredOnEvent

	// The host that failed.
	SourceHost *HostEventArgument
}

//
// This event records a virtual machine resuming.
//
//
type VmResumingEvent struct {
	*VmEvent
}

//
// This event records a secondary VM is added.
//
//
type VmSecondaryAddedEvent struct {
	*VmEvent
}

//
// This event records that a fault tolerance secondary VM has been
// disabled by vCenter because the VM could not be powered on.
//
//
type VmSecondaryDisabledBySystemEvent struct {
	*VmEvent

	Reason *LocalizedMethodFault
}

//
// This event records a secondary VM is disabled.
//
//
type VmSecondaryDisabledEvent struct {
	*VmEvent
}

//
// This event records a secondary VM is enabled.
//
//
type VmSecondaryEnabledEvent struct {
	*VmEvent
}

//
// This event records a secondary VM is started successfully.
//
//
type VmSecondaryStartedEvent struct {
	*VmEvent
}

//
// This event records when a virtual machine has been shut down on an isolated host
// in a HA cluster.
//
//
type VmShutdownOnIsolationEvent struct {
	*VmPoweredOffEvent

	// The isolated host on which a virtual machine was shutdown.
	IsolatedHost *HostEventArgument

	// Indicates if the shutdown was successful. If the shutdown failed, the virtual
	// machine was powered off. see Operation
	ShutdownResult string
}

type VmShutdownOnIsolationEventOperation struct {
}

//
// This data object type describes a file that is a virtual disk snapshot file.
//
//
type VmSnapshotFileInfo struct {
	*FileInfo
}

//
// This data object type describes the query specification for a virtual machine
// snapshot file.
//
//
type VmSnapshotFileQuery struct {
	*FileQuery
}

//
// This event indicates the start of a recording session on a virtual machine.
//
//
type VmStartRecordingEvent struct {
	*VmEvent
}

//
// This event indicates the start of a replay session on a virtual machine.
//
//
type VmStartReplayingEvent struct {
	*VmEvent
}

//
// This event records a virtual machine powering on.
//
//
type VmStartingEvent struct {
	*VmEvent
}

//
// This event records a vmotion to start a secondary VM.
//
//
type VmStartingSecondaryEvent struct {
	*VmEvent
}

//
// This event records a static MAC address conflict for a virtual machine.
//
//
type VmStaticMacConflictEvent struct {
	*VmEvent

	// The virtual machine whose static MAC address conflicts with
	// the current virtual machine's address.
	ConflictedVm *VmEventArgument

	// The static MAC address that is in conflict.
	Mac string
}

//
// This event records a virtual machine stopping.
//
//
type VmStoppingEvent struct {
	*VmEvent
}

//
// This event records when a virtual machine finished suspending.
//
//
type VmSuspendedEvent struct {
	*VmEvent
}

//
// This event records a virtual machine suspending.
//
//
type VmSuspendingEvent struct {
	*VmEvent
}

//
// This event records timeout when starting a secondary VM.
// A default alarm will be triggered upon this event, which by default
// would trigger a SNMP trap.
//
//
type VmTimedoutStartingSecondaryEvent struct {
	*VmEvent

	// The duration of the timeout in milliseconds.
	Timeout int64
}

//
// A base fault to indicate that something went wrong when upgrading tools.
//
//
type VmToolsUpgradeFault struct {
	*VimFault
}

//
// This event records when an unsupported guest is powering on.
//
//
type VmUnsupportedStartingEvent struct {
	*VmStartingEvent

	GuestId string
}

//
// This event records the successful completion of an upgrade operation.
//
//
type VmUpgradeCompleteEvent struct {
	*VmEvent

	// The version of the agent.
	Version string
}

//
// This event records a failure to upgrade virtual hardware.
//
//
type VmUpgradeFailedEvent struct {
	*VmEvent
}

//
// This event records the process of upgrading the virtual hardware on a
// virtual machine.
//
//
type VmUpgradingEvent struct {
	*VmEvent

	// The version of the agent.
	Version string
}

//
// This event records the assignment of a new BIOS UUID
// to a virtual machine.
//
//
type VmUuidAssignedEvent struct {
	*VmEvent

	// The new BIOS UUID.
	Uuid string
}

//
// This event records a change in a virtual machine's BIOS UUID.
//
//
type VmUuidChangedEvent struct {
	*VmEvent

	// The new BIOS UUID.
	NewUuid string

	// The old BIOS UUID.
	OldUuid string
}

//
// This event records a conflict of virtual machine BIOS UUIDs.
//
//
type VmUuidConflictEvent struct {
	*VmEvent

	// The virtual machine whose UUID conflicts with the
	// current virtual machine's UUID.
	ConflictedVm *VmEventArgument

	// The BIOS UUID in conflict.
	Uuid string
}

type VmValidateMaxDevice struct {
	*VimFault

	// number of devices found in vim.vm.ConfigSpec
	Count int32

	// The device
	Device string

	// max count for the device
	Max int32
}

//
// This event records the assignment of a new WWN (World Wide Name)
// to a virtual machine.
//
//
type VmWwnAssignedEvent struct {
	*VmEvent

	// The new node WWN.
	NodeWwns []int64

	// The new port WWN.
	PortWwns []int64
}

//
// This event records a change in a virtual machine's WWN (World Wide Name).
//
//
type VmWwnChangedEvent struct {
	*VmEvent

	// The new node WWN.
	NewNodeWwns []int64

	// The new port WWN.
	NewPortWwns []int64

	// The old node WWN.
	OldNodeWwns []int64

	// The old port WWN.
	OldPortWwns []int64
}

//
// Thrown if a user attempts to assign a
// WWN that is currently being used by other virtual machine or host.
//
//
type VmWwnConflict struct {
	*InvalidVmConfig

	// The host that is using the same WWN.
	Host *HostSystem

	// The name of the virtual machine/host that is using the same WWN.
	Name string

	// The virtual machine that is using the same WWN.
	Vm *VirtualMachine

	// The WWN that is in conflict.
	Wwn int64
}

//
// This event records a conflict of virtual machine WWNs (World Wide Name).
//
//
type VmWwnConflictEvent struct {
	*VmEvent

	// The host whose physical WWN conflicts with the
	// current virtual machine's WWN.
	ConflictedHosts []*HostEventArgument

	// The virtual machine whose WWN conflicts with the
	// current virtual machine's WWN.
	ConflictedVms []*VmEventArgument

	// The WWN in conflict.
	Wwn int64
}

//
// A VmfsAlreadyMounted fault indicates that VMFS volume with same UUID
// is already mounted on the host.
//
//
type VmfsAlreadyMounted struct {
	*VmfsMountFault
}

//
// An 'VmfsAmbiguousMount' fault occurs when ESX is unable to resolve the
// extents of a VMFS volume unambiguously. This is thrown only when a VMFS
// volume has multiple extents and multiple copies of VMFS volumes are available.
// VMFS layer will not be able to determine how to re-construct the VMFS
// volume as multiple choices are available.
//
//
type VmfsAmbiguousMount struct {
	*VmfsMountFault
}

//
// Datastore addition policy to use the entire disk as a single extent for
// a VMFS datastore.  If there is any data on the disk, it will be
// overwritten.
//
//
type VmfsDatastoreAllExtentOption struct {
	*VmfsDatastoreSingleExtentOption
}

//
// Base class that describes a VMFS datastore provisioning option.
//
//
type VmfsDatastoreBaseOption struct {
	*DynamicData

	// The partition table layout that the disk will have if this
	// provisioning option is selected.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	//
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	Layout *HostDiskPartitionLayout

	// Indicates whether selecting this option will change the partition
	// format type on the disk.See HostDiskPartitionInfoPartitionFormat
	//
	// Since vSphere API 5.0
	PartitionFormatChange bool
}

//
// This data object type is used when creating a new VMFS datastore,
// to create a specification for the VMFS datastore.
//
//
type VmfsDatastoreCreateSpec struct {
	*VmfsDatastoreSpec

	// Extents to append to VMFS.
	Extent []*HostScsiDiskPartition

	// Partitioning specification.
	Partition *HostDiskPartitionSpec

	// The VMFS creation specification.
	Vmfs *HostVmfsSpec
}

//
// Specification to increase the  capacity of a VMFS datastore by expanding
// (increasing the size of) an existing extent of the datastore.
//
//
type VmfsDatastoreExpandSpec struct {
	*VmfsDatastoreSpec

	// VMFS extent to expand.
	Extent *HostScsiDiskPartition

	// Partitioning specification.
	Partition *HostDiskPartitionSpec
}

//
// Specification to increase the capacity of a VMFS datastore by adding
// one or more new extents to the datastore.  All the extents to be added
// must be on the same disk.  Extension is different
// from creation in that the VMFS creation specification need not be
// specified.
//
//
type VmfsDatastoreExtendSpec struct {
	*VmfsDatastoreSpec

	// Extents to append to VMFS.
	Extent []*HostScsiDiskPartition

	// Partitioning specification.
	Partition *HostDiskPartitionSpec
}

//
// Information details about a VMFS datastore.
//
//
type VmfsDatastoreInfo struct {
	*DatastoreInfo

	// Maximum raw device mapping size (physical compatibility)
	//
	// Since vSphere API 5.1
	MaxPhysicalRDMFileSize int64

	// Maximum raw device mapping size (virtual compatibility)
	//
	// Since vSphere API 5.1
	MaxVirtualRDMFileSize int64

	// The VMFS volume information for the datastore.  May not be
	// available when the datastore is not accessible.
	Vmfs *HostVmfsVolume
}

//
// Datastore addition policy to use multiple extents on the disk for a VMFS
// datastore.  Multiple extents implies that more than one disk partition
// will be created on the disk for creating or increasing the capacity of a
// VMFS datastore.
// Multiple extents are needed when unpartitioned space is fragmented in the
// existing partition layout of the disk.
//
//
type VmfsDatastoreMultipleExtentOption struct {
	*VmfsDatastoreBaseOption

	// The block ranges to be used as extents in a VMFS datastore.  The first
	// block range will be the head partition.
	VmfsExtent []*HostDiskPartitionBlockRange
}

//
// VMFS datastore provisioning option that can be applied on a disk.  VMFS
// datastores can be created or have their capacity increased using storage
// from a disk.
// There are often multiple ways in which extents can be allocated on a disk.
// Each instance of this structure represents one of the possible options
// that can be applied to provisiong VMFS datastore storage.  Only options
// that follow ESX Server best practice guidelines will be presented.
//
//
type VmfsDatastoreOption struct {
	*DynamicData

	// Information about this VMFS datastore provisioniing option.  This
	// structure describes the extent allocation policy represented by
	// this option.
	Info *VmfsDatastoreBaseOption

	// Specification to create or increase the capacity of a VMFS datastore.
	// This property contains a configuration specification that can be
	// applied to effect the creation or capacity increase.
	Spec *VmfsDatastoreSpec
}

//
// Datastore addition policy to use a single extent on the disk for a VMFS
// datastore.  A single extent implies that one disk partition will be
// created on the disk for creating or increasing the capacity of a VMFS datastore.
//
//
type VmfsDatastoreSingleExtentOption struct {
	*VmfsDatastoreBaseOption

	// The block range to be used as an extent in a VMFS datastore.
	VmfsExtent *HostDiskPartitionBlockRange
}

//
// Base class for VMFS datastore addition specification.  Used as a generic
// way to point to one of the creation specifications that can be used to
// apply a specification to effect the creation or extension of a VMFS
// datastore.
//
//
type VmfsDatastoreSpec struct {
	*DynamicData

	// The UUID of the SCSI disk on which the VMFS datastore is located.See HostScsiDiskSee uuid
	DiskUuid string
}

//
// This is a base class for all VMFS volume mount related faults.
//
//
type VmfsMountFault struct {
	*HostConfigFault

	// Vmfs volume uuid
	Uuid string
}

//
// This fault is thrown when the Vmotion Interface on this host is not enabled.
// The Vmotion Interface is needed for waking up the host from standby mode.
//
//
type VmotionInterfaceNotEnabled struct {
	*HostPowerOpFailed
}

//
// The VmwareDistributedVirtualSwitch managed object
// is the VMware implementation of a distributed virtual switch.
// The functionality listed here is for a VMware distributed virtual switch only.
//
// When you use a VMware distributed virtual switch, you can perform
// backup and restore operations on the VMware switch. You can also
// perform rollback operations on the switch and on portgroups
// associated with the VMware switch. See the description for the
// following methods:
//
//
//
// • DVSManagerExportEntity_Task
//
// • DVSManagerImportEntity_Task
//
// • DVSRollback_Task
//
// • DVPortgroupRollback_Task
//
//
//
//
type VmwareDistributedVirtualSwitch struct {
	*ManagedObject
	*DistributedVirtualSwitch
}

//
// Update Link Aggregation Control Protocol groups.
// It can be called if the value of
// lacpApiVersion is
// LacpApiVersion#multipleLag
// else an exception ConflictingConfiguration will be thrown.
//
// Required Privileges
// DVSwitch.Modify
// Since
// vSphere API 5.5
//
func (mo *VmwareDistributedVirtualSwitch) UpdateDVSLacpGroupConfig_Task(
	_this *ManagedObjectReference, lacpGroupSpec []*VMwareDvsLacpGroupSpec,
) (*Task, error) {

	return nil, nil

}

//
// The PVLAN port types.
//
//
type VmwareDistributedVirtualSwitchPvlanPortType struct {
}

//
// This data type defines the configuration when PVLAN id is to be
// used for the ports.
//
//
type VmwareDistributedVirtualSwitchPvlanSpec struct {
	*VmwareDistributedVirtualSwitchVlanSpec

	// The secondaryVlanId.
	PvlanId int32
}

//
// This data type specifies that the port uses trunk mode,
// which allows the guest operating system to manage its own VLAN tags.
//
//
type VmwareDistributedVirtualSwitchTrunkVlanSpec struct {
	*VmwareDistributedVirtualSwitchVlanSpec

	// The VlanId range for the trunk port. The valid VlanId range is
	// from 0 to 4094. Overlapping ranges are allowed.
	VlanId []*NumericRange
}

//
// This data type defines the configuration when single vlanId is used for
// the port.
//
//
type VmwareDistributedVirtualSwitchVlanIdSpec struct {
	*VmwareDistributedVirtualSwitchVlanSpec

	// The VLAN ID for ports. Possible values:
	//
	// A value of 0 specifies that you do not want the port associated
	// with a VLAN.
	// A value from 1 to 4094 specifies a VLAN ID for the port.
	VlanId int32
}

//
// Base class for Vlan Specifiation for ports.
//
//
type VmwareDistributedVirtualSwitchVlanSpec struct {
	*InheritablePolicy
}

//
// Policy for a uplink port team.
//
//
type VmwareUplinkPortTeamingPolicy struct {
	*InheritablePolicy

	// Failover detection policy for the uplink port team.
	FailureCriteria *DVSFailureCriteria

	// Flag to specify whether or not to notify the physical switch
	// if a link fails. Also see notifySwitches
	NotifySwitches *BoolPolicy

	// Network adapter teaming policy. The policy defines the way traffic
	// from the clients of the team is routed through the different uplinks
	// in the team. The policies supported on the VDS platform is one of
	// nicTeamingPolicy.
	Policy *StringPolicy

	// The flag to indicate whether or not the teaming policy is applied
	// to inbound frames as well. Also see reversePolicy
	ReversePolicy *BoolPolicy

	// The flag to indicate whether or not to use a rolling policy when
	// restoring links. Also see rollingOrder
	RollingOrder *BoolPolicy

	// Failover order policy for uplink ports on the hosts.
	UplinkPortOrder *VMwareUplinkPortOrderPolicy
}

//
// This argument records a Virtual NIC device that connects to a DVPort.
//
//
type VnicPortArgument struct {
	*DynamicData

	// The DVPorts that were being used.
	Port *DistributedVirtualSwitchPortConnection

	// The Virtual NIC devices that were using the DVports.
	Vnic string
}

//
// An error occurred in the Open Source Components applications during
// volume editing. Possibly caused by an incompatible cygwin version
// installed in the VirtualCenter server.
//
//
type VolumeEditorError struct {
	*CustomizationFault
}

//
// A VramLimitLicense fault is thrown if executing an operation
// would result in exceeding maximum allowed vRAM amount.
//
// For example, this could happen when powering on a VM,
// hot-plugging memory into a running VMm, etc.
//
//
type VramLimitLicense struct {
	*NotEnoughLicenses

	// The maximum allowed vRAM amount.
	Limit int32
}

//
// The VsanClusterConfigInfo data object contains configuration
// data for the VSAN service in a cluster.  This data object is used both for
// specifying cluster-wide settings when updating the VSAN service, and as an
// output datatype when retrieving current cluster-wide VSAN service settings.See ReconfigureComputeResource_Task
//
//
type VsanClusterConfigInfo struct {
	*DynamicData

	// Default VSAN settings to use for hosts admitted to the cluster when the
	// VSAN service is enabled.  If omitted, values will default as though the
	// fields in the HostDefaultInfo have been omitted.See enabledSee HostDefaultInfo
	DefaultConfig *VsanClusterConfigInfoHostDefaultInfo

	// Whether the VSAN service is enabled for the cluster.
	Enabled bool
}

//
// Default VSAN service configuration to be used for hosts admitted
// to the cluster.See defaultConfig
//
//
type VsanClusterConfigInfoHostDefaultInfo struct {
	*DynamicData

	// Whether the VSAN service is configured to automatically claim local
	// storage on VSAN-enabled hosts in the cluster.
	//
	// If omitted while enabling the VSAN service, this value will default
	// to true.
	//
	// Changing this value to false shall not affect any
	// existing disk mappings in use by hosts currently participating in
	// the VSAN service.
	//
	// Changing this value to true will result in local disks
	// being automatically claimed for use by the VSAN service, for hosts
	// currently participating in the VSAN service.See diskMappingSee autoClaimStorage
	AutoClaimStorage bool

	// VSAN service cluster UUID, in the string form
	// "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn", where n are hexadecimal
	// digits.
	//
	// When enabling the VSAN service on the cluster, this value shall
	// not be specified by the user; a suitable UUID will be generated
	// by the platform.
	//
	// While the VSAN service is enabled, this is a read-only value.
	Uuid string
}

//
// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into a ClusterComputeResource whose
// VSAN cluster UUID does not match.See CannotMoveVsanEnabledHost
//
//
type VsanClusterUuidMismatch struct {
	*CannotMoveVsanEnabledHost

	// The VSAN cluster UUID in use by the destination
	// ClusterComputeResource.
	DestinationClusterUuid string

	// The VSAN cluster UUID in use by the host at hand.
	HostClusterUuid string
}

//
// Base exception class for VSAN disk-related faults.
//
//
type VsanDiskFault struct {
	*VsanFault

	// The canonical name for the disk at hand, if applicable.See canonicalName
	Device string
}

//
// The list of disk issues.
//
//
type VsanDiskIssueType struct {
}

//
// Base exception class for VSAN-specific faults raised for host
// or cluster operations.See HostVsanSystemSee ReconfigureComputeResource_Task
//
//
type VsanFault struct {
	*VimFault
}

//
// The VsanHostClusterStatus data object contains a host's cluster status
// information for the VSAN service.  This data object is used to represent
// read-only state whose values may change during operation.See QueryHostStatus
//
//
type VsanHostClusterStatus struct {
	*DynamicData

	// VSAN health state for this host.See VsanHostHealthState
	Health string

	// List of UUIDs for VSAN nodes known to this host.
	MemberUuid []string

	// VSAN node state for this host.
	NodeState *VsanHostClusterStatusState

	// VSAN node UUID for this host.
	NodeUuid string

	// VSAN service cluster UUID.
	Uuid string
}

//
// Data object representing the VSAN node state for a host.
//
//
type VsanHostClusterStatusState struct {
	*DynamicData

	// An estimation of the completion of a node state transition; this
	// value may be populated for transitory node states.See VsanHostNodeState
	Completion *VsanHostClusterStatusStateCompletionEstimate

	// VSAN node state for this host.See VsanHostNodeState
	State string
}

//
// Estimated completion status for transitory node states.See VsanHostNodeState
//
//
type VsanHostClusterStatusStateCompletionEstimate struct {
	*DynamicData

	// Estimated time of completion.
	CompleteTime time.Time

	// Estimated percent of completion as a value in the range [0, 100].
	PercentComplete int32
}

//
// The VsanHostConfigInfo data object contains host-specific settings
// for the VSAN service.  This data object is used both for specifying
// settings for updating the VSAN service, and as an output datatype
// when retrieving current VSAN service settings.
//
//
type VsanHostConfigInfo struct {
	*DynamicData

	// The VSAN service cluster configuration for this host.
	ClusterInfo *VsanHostConfigInfoClusterInfo

	// Whether the VSAN service is currently enabled on this host.
	Enabled bool

	// The HostSystem for this host.
	//
	// This argument is required when this configuration is specified as
	// an input to VC-level APIs.  When this configuration is specified
	// to a host-level direct API, this argument may be omitted.See ReconfigureComputeResource_TaskSee UpdateVsan_Task
	HostSystem *HostSystem

	// The VSAN network configuration for this host.
	//
	// VSAN network configuration settings are independent of the
	// current value of enabled.
	NetworkInfo *VsanHostConfigInfoNetworkInfo

	// The VSAN storage configuration for this host.
	//
	// VSAN storage configuration settings are independent of the
	// current value of enabled.
	StorageInfo *VsanHostConfigInfoStorageInfo
}

//
// Host-local VSAN cluster configuration.  This data object is used
// both for specifying and retrieving cluster configuration for a
// host participating in the VSAN service.
//
//
type VsanHostConfigInfoClusterInfo struct {
	*DynamicData

	// VSAN node UUID for this host.
	//
	// This is a read-only value which is populated upon enabling of the
	// VSAN service.
	NodeUuid string

	// VSAN service cluster UUID, in the string form
	// "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn", where n are hexadecimal
	// digits.
	//
	// If provided while enabling the VSAN service, this value will be
	// used for the service cluster UUID.  If omitted when enabling the
	// VSAN service, a suitable UUID will be generated by the platform.
	//
	// This is a read-only value while the VSAN service is enabled.
	Uuid string
}

//
// Host-local VSAN network configuration.  This data object is used
// both for specifying and retrieving network configuration for a
// host participating in the VSAN service.
//
//
type VsanHostConfigInfoNetworkInfo struct {
	*DynamicData

	// Set of PortConfig entries for use by the VSAN service, one per
	// "virtual network" as used by VSAN.
	Port []*VsanHostConfigInfoNetworkInfoPortConfig
}

//
// A PortConfig represents a virtual network adapter and its
// configuration for use by the VSAN service.See HostVirtualNic
//
//
type VsanHostConfigInfoNetworkInfoPortConfig struct {
	*DynamicData

	// Device name which identifies the network adapter for this
	// PortConfig.See device
	Device string

	// VsanHostIpConfig for this PortConfig.
	IpConfig *VsanHostIpConfig
}

//
// Host-local VSAN storage configuration.  This data object is used
// both for specifying and retrieving storage configuration for a
// host participating in the VSAN service.
//
//
type VsanHostConfigInfoStorageInfo struct {
	*DynamicData

	// Whether the VSAN service is configured to automatically claim local
	// unused storage on this host.
	//
	// When set, the VSAN service will automatically format and use local
	// disks.  Side effects from any disk consumption will be reflected in
	// diskMapping.
	//
	// If this argument is specified as a host-level configuration input
	// at the VC-level (see vsanHostConfig),
	// it will override that of any cluster-level default value.See diskMappingSee vsanHostConfigSee defaultConfig
	AutoClaimStorage bool

	// List of VsanHostDiskMapping entries in use by the VSAN service.
	//
	// DiskMappings to be used by the VSAN service may be manually
	// specified using
	// vim.host.VsanSystem#initializeDisks(DiskMapping[]).See vim.host.VsanSystem#initializeDisks(DiskMapping[])
	DiskMapping []*VsanHostDiskMapping
}

//
// A VsanHostDecommissionMode defines an action to take upon decommissioning
// a host from use with the VSAN service.
//
// If the VSAN service DecommissionMode is omitted in a call to
// EnterMaintenanceMode_Task, the default action chosen
// will be ensureObjectAccessibility.See EnterMaintenanceMode_TaskSee vsanMode
//
//
type VsanHostDecommissionMode struct {
	*DynamicData

	// Specifies an action to take with regard to the VSAN service upon
	// putting a host into maintenance mode.See VsanHostDecommissionModeObjectAction
	ObjectAction string
}

//
// The action to take with regard to storage objects upon decommissioning
// a host from use with the VSAN service.
//
//
type VsanHostDecommissionModeObjectAction struct {
}

//
// A DiskMapResult represents the result of an operation performed
// on the set of disks in a VsanHostDiskMapping.See InitializeDisks_TaskSee UpdateVsan_Task
//
//
type VsanHostDiskMapResult struct {
	*DynamicData

	// List of results for each disk in the mapping.
	DiskResult []*VsanHostDiskResult

	// Error information for this result.See VsanDiskFault
	Error *LocalizedMethodFault

	// DiskMapping for this result.
	Mapping *VsanHostDiskMapping
}

//
// A VsanHostDiskMapping is a set of one SSD HostScsiDisk backed
// by a set of one or more non-SSD HostScsiDisk. The maximum
// allowed VsanHostDiskMapping for a host is 5. A maximum set
// of 6 non-SSDs HostScsiDisk can be added to the one
// SSD HostScsiDisk.See VsanHostConfigInfoStorageInfoSee vim.host.VsanSystem#initializeDisks(DiskMapping[])
//
//
type VsanHostDiskMapping struct {
	*DynamicData

	// Set of non-SSD backing ScsiDisk.
	NonSsd []*HostScsiDisk

	// SSD ScsiDisk.
	Ssd *HostScsiDisk
}

//
// A DiskResult represents the result of VSAN configuration operation
// on a ScsiDisk, and its current eligibility state for use by
// the VSAN service.See QueryDisksForVsanSee UpdateVsan_TaskSee VsanHostDiskResultState
//
//
type VsanHostDiskResult struct {
	*DynamicData

	// Disk for this result.
	Disk *HostScsiDisk

	// Error information for this result: may be populated with additional
	// information about the disk at hand, regardless of the disk's state.See VsanDiskFaultSee state
	Error *LocalizedMethodFault

	// State of the disk for this result.See VsanHostDiskResultState
	State string

	// VSAN disk UUID in case this disk is a VSAN disk.
	VsanUuid string
}

//
// Values used for indicating a disk's status for use by the VSAN service.See state
//
//
type VsanHostDiskResultState struct {
}

//
// A VsanHostHealthState represents the state of a participating
// host in the VSAN service.See VsanHostClusterStatus
//
//
type VsanHostHealthState struct {
}

//
// An VsanHostIpConfig is a pair of multicast IP addresses for use by the VSAN
// service.  For VSAN there is one such IpConfig pair per "virtual network" as
// represented by VsanHostConfigInfoNetworkInfoPortConfig.See VsanHostConfigInfoNetworkInfoSee portSee VsanHostConfigInfoNetworkInfoPortConfigSee UpdateVsan_Task
//
//
type VsanHostIpConfig struct {
	*DynamicData

	// Master-to-agent multicast IP address.
	DownstreamIpAddress string

	// Agent-to-master multicast IP address.
	UpstreamIpAddress string
}

//
// The VsanHostMembershipInfo data object contains VSAN cluster
// membership information for a single host, as observed from a
// given host.  This data object is used to represent read-only
// state whose values may change during operation.See vsanRuntimeInfo
//
//
type VsanHostMembershipInfo struct {
	*DynamicData

	// Hostname for the host of this MembershipInfo.
	//
	// May be the empty string "" if the hostname is unavailable.
	Hostname string

	// VSAN node UUID for the host of this MembershipInfo.See nodeUuid
	NodeUuid string
}

//
// A VsanHostNodeState represents the state of participation of a host
// in the VSAN service.See VsanHostClusterStatusSee VsanHostClusterStatusState
//
//
type VsanHostNodeState struct {
}

//
// This data object contains VSAN cluster runtime information from
// the perspective of the host in question.
// This data object is used to represent read-only state whose values
// may change during operation.
//
//
type VsanHostRuntimeInfo struct {
	*DynamicData

	// Generation number tracking object accessibility.
	AccessGenNo int32

	// List of disk issues detected on this host.
	//
	// To retrieve more information on the issues, use
	// QueryDisksForVsan.
	DiskIssues []*VsanHostRuntimeInfoDiskIssue

	// This property reports host membership information.
	MembershipList []*VsanHostMembershipInfo
}

//
// Data structure of reporting a disk issue.
//
//
type VsanHostRuntimeInfoDiskIssue struct {
	*DynamicData

	// Disk uuid,See uuid
	DiskId string

	// Type of issueSee DiskIssueType
	Issue string
}

//
// Thrown if a dvPort is used as destination in multiple Distributed Port Mirroring sessions.
//
//
type VspanDestPortConflict struct {
	*DvsFault

	// The key of the the port that is used as destination in multiple Distributed Port Mirroring sessions
	PortKey string

	// The key of the Distributed Port Mirroring session whose destination ports include a port
	// that is also used as destination ports of other Distributed Port Mirroring sessions
	VspanSessionKey1 string

	// The key of the Distributed Port Mirroring session whose destination ports include a port
	// that is also used as destination ports of other Distributed Port Mirroring sessions
	VspanSessionKey2 string
}

//
// Thrown if a DistributedVirtualPort appears in both the transmitted source and destination
// ports of any Distributed Port Mirroring session.
//
//
type VspanPortConflict struct {
	*DvsFault

	// The key of the port that is both the transmitted source and destination.
	PortKey string

	// The key of the Distributed Port Mirroring session that is in conflict
	VspanSessionKey1 string

	// The key of the Distributed Port Mirroring session that is in conflict
	VspanSessionKey2 string
}

//
// Thrown when moving a port used as tranmistted source or destination ports in vspan
// session to a promiscuous portgroup if this operation may change
// the non-promiscuous port to promiscuous mode.
//
//
type VspanPortMoveFault struct {
	*DvsFault

	// The key of the dest portgroup.
	DestPortgroupName string

	// The key of the port.
	PortKey string

	// The key of the source portgroup.
	SrcPortgroupName string
}

//
// Thrown when changing a non-promiscuous port used as tranmistted source or dest
// ports in Distributed Port Mirroring session to promiscuous mode.
//
//
type VspanPortPromiscChangeFault struct {
	*DvsFault

	// The key of the port.
	PortKey string
}

//
// Thrown when changing a non-promiscous portgroup to promiscuous mode if any port
// in this portgroup is used as tranmistted source or dest ports in vspan
// session.
//
//
type VspanPortgroupPromiscChangeFault struct {
	*DvsFault

	// The key of the port.
	PortgroupName string
}

//
// Thrown when changing a portgroup from static/dynamic binding to
// ephemeral(no binding) if any ports in this portgroup participate in
// Distributed Port Mirroring session.
//
//
type VspanPortgroupTypeChangeFault struct {
	*DvsFault

	// The name of the portgroup.
	PortgroupName string
}

//
// Thrown if a promiscuous port appears in transmitted source or destination
// ports of any Distributed Port Mirroring session.
//
//
type VspanPromiscuousPortNotSupported struct {
	*DvsFault

	// The key of the promiscuous port that appears in transmitted
	// source or destination ports.
	PortKey string

	// The key of the Distributed Port Mirroring session in which a promiscuous port is used as
	// transmitted source or destination ports.
	VspanSessionKey string
}

//
// Thrown if a dvPort appears in both the source and destination
// ports of the same Distributed Port Mirroring session.
//
//
type VspanSameSessionPortConflict struct {
	*DvsFault

	// The key of the port that appears in both the source and
	// destination ports of the same Distributed Port Mirroring session.
	PortKey string

	// The key of the Distributed Port Mirroring session in which a dvPort appears in both the source and destination ports
	VspanSessionKey string
}

//
// Options for WaitForUpdatesEx.
//
//
type WaitOptions struct {
	*DynamicData

	// The maximum number of ObjectUpdate
	// entries that should be returned in a single result from WaitForUpdatesEx. See truncated
	//
	// An unset value indicates that there is no maximum. In this case
	// PropertyCollector policy may still limit the number of objects
	// that appear in an UpdateSet.
	//
	// A positive value causes WaitForUpdatesEx to suspend
	// the update calculation when the total count of ObjectUpdate entries ready to return reaches
	// the specified maximum. PropertyCollector policy may still
	// limit the total count to something less than maxObjectUpdates.
	//
	// A value less than or equal to 0 is illegal.
	MaxObjectUpdates int32

	// The number of seconds the PropertyCollector should wait
	// before returning null. Returning updates may take longer if the
	// actual calculation time exceeds maxWaitSeconds. Additionally PropertyCollector policy may
	// cause it to return null sooner than maxWaitSeconds.
	//
	// An unset value causes WaitForUpdatesEx to wait as
	// long as possible for updates. Policy may still cause the
	// PropertyCollector to return null at some point.
	//
	// A value of 0 causes WaitForUpdatesEx to do one update
	// calculation and return any results. This behavior is similar to CheckForUpdates.
	//
	// A positive value causes WaitForUpdatesEx to return
	// null if no updates are available within the specified number of
	// seconds. The choice of a positive value often depends on the
	// client communication stack. For example it may be helpful to
	// choose a duration shorter than a local HTTP request timeout.
	// Typically it should be no shorter than a few minutes.
	//
	// A negative value is illegal.
	MaxWaitSeconds int32
}

//
// The virtual machine and at least one of its virtual NICs are configured to
// use Wake-on-LAN, but the host does not support Wake-on-LAN for the
// virtual machine's selected guest OS.
//
//
type WakeOnLanNotSupported struct {
	*VirtualHardwareCompatibilityIssue
}

//
// This fault is thrown when Wake-on-LAN isn't supported by the Vmotion NIC on the host.
//
//
type WakeOnLanNotSupportedByVmotionNIC struct {
	*HostPowerOpFailed
}

//
// This event is a general warning event from upgrade.
//
//
type WarningUpgradeEvent struct {
	*UpgradeEvent
}

type WeekOfMonth struct {
}

//
// The WeeklyTaskScheduler data object sets the time for weekly
// task execution. You can set the schedule for task execution
// on one or more days during the week, and you complete the schedule
// by setting the inherited properties for the hour and minute.
//
// By default the scheduler executes the task according to the
// specified day(s) every week.
// If you set the interval to a value greater than 1, the task will
// execute at the specified weekly interval. (For example, an interval
// of 2 will cause the task to execute on the specified days every 2 weeks.)
//
//
//
type WeeklyTaskScheduler struct {
	*DailyTaskScheduler

	Friday bool

	Monday bool

	Saturday bool

	// The day or days of the week when the scheduled task will run.
	// At least one of the days must be true.
	Sunday bool

	Thursday bool

	Tuesday bool

	Wednesday bool
}

//
// This fault is reported when the execution of a storage vmotion or
// relocate operation would impact vSphere HA's ability to
// restart a VM. For storage vmotion, this fault
// is reported when HA protection will be lost after the vmotion
// completes. Consequently, HA would not restart the VM if it
// subsequently failed. For relocate, relocate is not supported on
// VMs that failed before the operation is attempted and are in the
// process of being restarted at the time the operation is performed.
//
//
type WillLoseHAProtection struct {
	*MigrationFault

	// The steps the user can take to restore protection if the
	// the operation is performed. Values come from
	// Resolution.
	Resolution string
}

type WillLoseHAProtectionResolution struct {
}

//
// A virtual machine's total CPU feature requirements are determined by
// overlaying the requirements specified in its configuration (if any) on top
// of the requirements specified in the descriptor for its guest OS.  It is
// therefore possible for a host change to implicitly change a virtual
// machine's CPU feature requirements.  The guest OS descriptor may have
// different requirements on the new host.  Or, if the virtual machine
// currently specifies requirements in its configuration, those requirements
// will be lost if the new host does not support this.
//
// This fault indicates that the virtual machine's CPU feature requirements
// would change because of a migration, and also that the destination host
// does support storing CPU feature requirements in the virtual machine's
// configuration.  (If the destination host does not support such an action,
// CannotModifyConfigCpuRequirements is used instead of this fault.)
//
//
// This is a warning to notify the user that the migration process will
// adjust the virtual machine's configuration so that it will be operating
// under an unchanged set of CPU feature requirements on its new host.  If the
// user wishes to expose the different guest OS requirements of the new host,
// the user will need to edit the virtual machine's configuration after the
// migration.
//
//
//
type WillModifyConfigCpuRequirements struct {
	*MigrationFault
}

//
// This fault is reported when the execution of a storage vmotion or
// relocate operation would reset the snapshotDirectory settings
// to its default value (VM's home/config directory).
//
//
type WillResetSnapshotDirectory struct {
	*MigrationFault
}

//
// This data object type describes the Windows-specific
// NetBIOS configuration.
//
//
type WinNetBIOSConfigInfo struct {
	*NetBIOSConfigInfo

	// The IP address of the primary WINS server.
	PrimaryWINS string

	// The IP address of the secondary WINS server.
	SecondaryWINS string
}

//
// This exception is thrown when VirtualMachine.wipeDisk
// encounters an error
//
//
type WipeDiskFault struct {
	*VimFault
}
